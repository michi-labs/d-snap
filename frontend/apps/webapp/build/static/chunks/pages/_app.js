/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "../../../node_modules/@dfinity/agent/lib/esm/actor.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/actor.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACTOR_METHOD_WITH_HTTP_DETAILS: function() { return /* binding */ ACTOR_METHOD_WITH_HTTP_DETAILS; },\n/* harmony export */   Actor: function() { return /* binding */ Actor; },\n/* harmony export */   ActorCallError: function() { return /* binding */ ActorCallError; },\n/* harmony export */   CanisterInstallMode: function() { return /* binding */ CanisterInstallMode; },\n/* harmony export */   QueryCallRejectedError: function() { return /* binding */ QueryCallRejectedError; },\n/* harmony export */   UpdateCallRejectedError: function() { return /* binding */ UpdateCallRejectedError; },\n/* harmony export */   getManagementCanister: function() { return /* binding */ getManagementCanister; }\n/* harmony export */ });\n/* harmony import */ var buffer___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer/ */ \"../../../node_modules/@dfinity/agent/node_modules/buffer/index.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"../../../node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dfinity/candid */ \"../../../node_modules/@dfinity/candid/lib/esm/index.js\");\n/* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polling */ \"../../../node_modules/@dfinity/agent/lib/esm/polling/index.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @dfinity/principal */ \"../../../node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/buffer */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _canisters_management_idl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./canisters/management_idl */ \"../../../node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js\");\n\n\n\n\n\n\n\n\nclass ActorCallError extends _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError {\n    constructor(canisterId, methodName, type, props) {\n        super([\n            `Call failed:`,\n            `  Canister: ${canisterId.toText()}`,\n            `  Method: ${methodName} (${type})`,\n            ...Object.getOwnPropertyNames(props).map(n => `  \"${n}\": ${JSON.stringify(props[n])}`),\n        ].join('\\n'));\n        this.canisterId = canisterId;\n        this.methodName = methodName;\n        this.type = type;\n        this.props = props;\n    }\n}\nclass QueryCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, result) {\n        var _a;\n        super(canisterId, methodName, 'query', {\n            Status: result.status,\n            Code: (_a = _agent__WEBPACK_IMPORTED_MODULE_1__.ReplicaRejectCode[result.reject_code]) !== null && _a !== void 0 ? _a : `Unknown Code \"${result.reject_code}\"`,\n            Message: result.reject_message,\n        });\n        this.result = result;\n    }\n}\nclass UpdateCallRejectedError extends ActorCallError {\n    constructor(canisterId, methodName, requestId, response) {\n        super(canisterId, methodName, 'update', Object.assign({ 'Request ID': (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_6__.toHex)(requestId) }, (response.body\n            ? Object.assign(Object.assign({}, (response.body.error_code\n                ? {\n                    'Error code': response.body.error_code,\n                }\n                : {})), { 'Reject code': String(response.body.reject_code), 'Reject message': response.body.reject_message }) : {\n            'HTTP status code': response.status.toString(),\n            'HTTP status text': response.statusText,\n        })));\n        this.requestId = requestId;\n        this.response = response;\n    }\n}\n/**\n * The mode used when installing a canister.\n */\nvar CanisterInstallMode;\n(function (CanisterInstallMode) {\n    CanisterInstallMode[\"Install\"] = \"install\";\n    CanisterInstallMode[\"Reinstall\"] = \"reinstall\";\n    CanisterInstallMode[\"Upgrade\"] = \"upgrade\";\n})(CanisterInstallMode || (CanisterInstallMode = {}));\nconst metadataSymbol = Symbol.for('ic-agent-metadata');\n/**\n * An actor base class. An actor is an object containing only functions that will\n * return a promise. These functions are derived from the IDL definition.\n */\nclass Actor {\n    constructor(metadata) {\n        this[metadataSymbol] = Object.freeze(metadata);\n    }\n    /**\n     * Get the Agent class this Actor would call, or undefined if the Actor would use\n     * the default agent (global.ic.agent).\n     * @param actor The actor to get the agent of.\n     */\n    static agentOf(actor) {\n        return actor[metadataSymbol].config.agent;\n    }\n    /**\n     * Get the interface of an actor, in the form of an instance of a Service.\n     * @param actor The actor to get the interface of.\n     */\n    static interfaceOf(actor) {\n        return actor[metadataSymbol].service;\n    }\n    static canisterIdOf(actor) {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(actor[metadataSymbol].config.canisterId);\n    }\n    static async install(fields, config) {\n        const mode = fields.mode === undefined ? CanisterInstallMode.Install : fields.mode;\n        // Need to transform the arg into a number array.\n        const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];\n        // Same for module.\n        const wasmModule = [...new Uint8Array(fields.module)];\n        const canisterId = typeof config.canisterId === 'string'\n            ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromText(config.canisterId)\n            : config.canisterId;\n        await getManagementCanister(config).install_code({\n            mode: { [mode]: null },\n            arg,\n            wasm_module: wasmModule,\n            canister_id: canisterId,\n        });\n    }\n    static async createCanister(config) {\n        const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({ amount: [], settings: [] });\n        return canisterId;\n    }\n    static async createAndInstallCanister(interfaceFactory, fields, config) {\n        const canisterId = await this.createCanister(config);\n        await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));\n        return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));\n    }\n    static createActorClass(interfaceFactory, options) {\n        const service = interfaceFactory({ IDL: _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL });\n        class CanisterActor extends Actor {\n            constructor(config) {\n                if (!config.canisterId)\n                    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError(`Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n                const canisterId = typeof config.canisterId === 'string'\n                    ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromText(config.canisterId)\n                    : config.canisterId;\n                super({\n                    config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),\n                    service,\n                });\n                for (const [methodName, func] of service._fields) {\n                    if (options === null || options === void 0 ? void 0 : options.httpDetails) {\n                        func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);\n                    }\n                    this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);\n                }\n            }\n        }\n        return CanisterActor;\n    }\n    static createActor(interfaceFactory, configuration) {\n        if (!configuration.canisterId) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AgentError(`Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);\n        }\n        return new (this.createActorClass(interfaceFactory))(configuration);\n    }\n    static createActorWithHttpDetails(interfaceFactory, configuration) {\n        return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(configuration);\n    }\n}\n// IDL functions can have multiple return values, so decoding always\n// produces an array. Ensure that functions with single or zero return\n// values behave as expected.\nfunction decodeReturnValue(types, msg) {\n    const returnValues = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.decode(types, buffer___WEBPACK_IMPORTED_MODULE_0__.Buffer.from(msg));\n    switch (returnValues.length) {\n        case 0:\n            return undefined;\n        case 1:\n            return returnValues[0];\n        default:\n            return returnValues;\n    }\n}\nconst DEFAULT_ACTOR_CONFIG = {\n    pollingStrategyFactory: _polling__WEBPACK_IMPORTED_MODULE_4__.strategy.defaultStrategy,\n};\nconst ACTOR_METHOD_WITH_HTTP_DETAILS = 'http-details';\nfunction _createActorMethod(actor, methodName, func, blsVerify) {\n    let caller;\n    if (func.annotations.includes('query') || func.annotations.includes('composite_query')) {\n        caller = async (options, ...args) => {\n            var _a, _b;\n            // First, if there's a config transformation, call it.\n            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).queryTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n            const agent = options.agent || actor[metadataSymbol].config.agent || (0,_agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent)();\n            const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);\n            const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.encode(func.argTypes, args);\n            const result = await agent.query(cid, { methodName, arg });\n            switch (result.status) {\n                case \"rejected\" /* QueryResponseStatus.Rejected */:\n                    throw new QueryCallRejectedError(cid, methodName, result);\n                case \"replied\" /* QueryResponseStatus.Replied */:\n                    return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS)\n                        ? {\n                            httpDetails: result.httpDetails,\n                            result: decodeReturnValue(func.retTypes, result.reply.arg),\n                        }\n                        : decodeReturnValue(func.retTypes, result.reply.arg);\n            }\n        };\n    }\n    else {\n        caller = async (options, ...args) => {\n            var _a, _b;\n            // First, if there's a config transformation, call it.\n            options = Object.assign(Object.assign({}, options), (_b = (_a = actor[metadataSymbol].config).callTransform) === null || _b === void 0 ? void 0 : _b.call(_a, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));\n            const agent = options.agent || actor[metadataSymbol].config.agent || (0,_agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent)();\n            const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);\n            const cid = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(canisterId);\n            const ecid = effectiveCanisterId !== undefined ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(effectiveCanisterId) : cid;\n            const arg = _dfinity_candid__WEBPACK_IMPORTED_MODULE_3__.IDL.encode(func.argTypes, args);\n            const { requestId, response } = await agent.call(cid, {\n                methodName,\n                arg,\n                effectiveCanisterId: ecid,\n            });\n            if (!response.ok || response.body /* IC-1462 */) {\n                throw new UpdateCallRejectedError(cid, methodName, requestId, response);\n            }\n            const pollStrategy = pollingStrategyFactory();\n            const responseBytes = await (0,_polling__WEBPACK_IMPORTED_MODULE_4__.pollForResponse)(agent, ecid, requestId, pollStrategy, blsVerify);\n            const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);\n            if (responseBytes !== undefined) {\n                return shouldIncludeHttpDetails\n                    ? {\n                        httpDetails: response,\n                        result: decodeReturnValue(func.retTypes, responseBytes),\n                    }\n                    : decodeReturnValue(func.retTypes, responseBytes);\n            }\n            else if (func.retTypes.length === 0) {\n                return shouldIncludeHttpDetails\n                    ? {\n                        httpDetails: response,\n                        result: undefined,\n                    }\n                    : undefined;\n            }\n            else {\n                throw new Error(`Call was returned undefined, but type [${func.retTypes.join(',')}].`);\n            }\n        };\n    }\n    const handler = (...args) => caller({}, ...args);\n    handler.withOptions =\n        (options) => (...args) => caller(options, ...args);\n    return handler;\n}\n/**\n * Create a management canister actor\n * @param config\n */\nfunction getManagementCanister(config) {\n    function transform(_methodName, args, _callConfig) {\n        const first = args[0];\n        let effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromHex('');\n        if (first && typeof first === 'object' && first.canister_id) {\n            effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.from(first.canister_id);\n        }\n        return { effectiveCanisterId };\n    }\n    return Actor.createActor(_canisters_management_idl__WEBPACK_IMPORTED_MODULE_7__[\"default\"], Object.assign(Object.assign(Object.assign({}, config), { canisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_5__.Principal.fromHex('') }), {\n        callTransform: transform,\n        queryTransform: transform,\n    }));\n}\n//# sourceMappingURL=actor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlDO0FBQzZCO0FBQ3hCO0FBQ0E7QUFDZ0I7QUFDUDtBQUNSO0FBQ3dCO0FBQ3hELDZCQUE2QiwrQ0FBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DLHlCQUF5QixZQUFZLEdBQUcsS0FBSztBQUM3QyxnRUFBZ0UsRUFBRSxLQUFLLHlCQUF5QjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQWlCLHdFQUF3RSxtQkFBbUI7QUFDcEk7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdFQUFnRSxjQUFjLG9EQUFLLGFBQWE7QUFDaEcsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNLGtHQUFrRztBQUM1SDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBUztBQUN2QjtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCLDBDQUEwQyw0Q0FBNEMsMEJBQTBCO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlDQUF5QyxhQUFhLFlBQVk7QUFDN0csZ0ZBQWdGLGFBQWEsWUFBWTtBQUN6RztBQUNBO0FBQ0EsMkNBQTJDLEdBQUcsb0RBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFVLDBDQUEwQywwQkFBMEI7QUFDNUc7QUFDQSxzQkFBc0IseURBQVM7QUFDL0I7QUFDQTtBQUNBLHdFQUF3RSxvQ0FBb0MsWUFBWTtBQUN4SDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQVUsMENBQTBDLGlDQUFpQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxtQkFBbUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFVLFFBQVEsMkNBQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOERBQXdCO0FBQ3BEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsdUtBQXVLO0FBQzNOLGlGQUFpRix1REFBZTtBQUNoRyx3QkFBd0IseURBQVM7QUFDakMsd0JBQXdCLHVEQUFVO0FBQ2xDLG9EQUFvRCxpQkFBaUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzS0FBc0s7QUFDMU4saUZBQWlGLHVEQUFlO0FBQ2hHLG9CQUFvQiwwREFBMEQsOENBQThDO0FBQzVILHdCQUF3Qix5REFBUztBQUNqQyw2REFBNkQseURBQVM7QUFDdEUsd0JBQXdCLHVEQUFVO0FBQ2xDLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlEQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSx3QkFBd0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQ0FBa0MseURBQVM7QUFDM0M7QUFDQSxrQ0FBa0MseURBQVM7QUFDM0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw2QkFBNkIsaUVBQXFCLDhDQUE4QyxhQUFhLFlBQVkseURBQVMsY0FBYztBQUNoSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FjdG9yLmpzPzAwZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyLyc7XG5pbXBvcnQgeyBnZXREZWZhdWx0QWdlbnQsIFJlcGxpY2FSZWplY3RDb2RlLCB9IGZyb20gJy4vYWdlbnQnO1xuaW1wb3J0IHsgQWdlbnRFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IElETCB9IGZyb20gJ0BkZmluaXR5L2NhbmRpZCc7XG5pbXBvcnQgeyBwb2xsRm9yUmVzcG9uc2UsIHN0cmF0ZWd5IH0gZnJvbSAnLi9wb2xsaW5nJztcbmltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgeyB0b0hleCB9IGZyb20gJy4vdXRpbHMvYnVmZmVyJztcbmltcG9ydCBtYW5hZ2VtZW50Q2FuaXN0ZXJJZGwgZnJvbSAnLi9jYW5pc3RlcnMvbWFuYWdlbWVudF9pZGwnO1xuZXhwb3J0IGNsYXNzIEFjdG9yQ2FsbEVycm9yIGV4dGVuZHMgQWdlbnRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgICAgc3VwZXIoW1xuICAgICAgICAgICAgYENhbGwgZmFpbGVkOmAsXG4gICAgICAgICAgICBgICBDYW5pc3RlcjogJHtjYW5pc3RlcklkLnRvVGV4dCgpfWAsXG4gICAgICAgICAgICBgICBNZXRob2Q6ICR7bWV0aG9kTmFtZX0gKCR7dHlwZX0pYCxcbiAgICAgICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BzKS5tYXAobiA9PiBgICBcIiR7bn1cIjogJHtKU09OLnN0cmluZ2lmeShwcm9wc1tuXSl9YCksXG4gICAgICAgIF0uam9pbignXFxuJykpO1xuICAgICAgICB0aGlzLmNhbmlzdGVySWQgPSBjYW5pc3RlcklkO1xuICAgICAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFF1ZXJ5Q2FsbFJlamVjdGVkRXJyb3IgZXh0ZW5kcyBBY3RvckNhbGxFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoY2FuaXN0ZXJJZCwgbWV0aG9kTmFtZSwgJ3F1ZXJ5Jywge1xuICAgICAgICAgICAgU3RhdHVzOiByZXN1bHQuc3RhdHVzLFxuICAgICAgICAgICAgQ29kZTogKF9hID0gUmVwbGljYVJlamVjdENvZGVbcmVzdWx0LnJlamVjdF9jb2RlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYFVua25vd24gQ29kZSBcIiR7cmVzdWx0LnJlamVjdF9jb2RlfVwiYCxcbiAgICAgICAgICAgIE1lc3NhZ2U6IHJlc3VsdC5yZWplY3RfbWVzc2FnZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBVcGRhdGVDYWxsUmVqZWN0ZWRFcnJvciBleHRlbmRzIEFjdG9yQ2FsbEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYW5pc3RlcklkLCBtZXRob2ROYW1lLCByZXF1ZXN0SWQsIHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKGNhbmlzdGVySWQsIG1ldGhvZE5hbWUsICd1cGRhdGUnLCBPYmplY3QuYXNzaWduKHsgJ1JlcXVlc3QgSUQnOiB0b0hleChyZXF1ZXN0SWQpIH0sIChyZXNwb25zZS5ib2R5XG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlc3BvbnNlLmJvZHkuZXJyb3JfY29kZVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAnRXJyb3IgY29kZSc6IHJlc3BvbnNlLmJvZHkuZXJyb3JfY29kZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSkpLCB7ICdSZWplY3QgY29kZSc6IFN0cmluZyhyZXNwb25zZS5ib2R5LnJlamVjdF9jb2RlKSwgJ1JlamVjdCBtZXNzYWdlJzogcmVzcG9uc2UuYm9keS5yZWplY3RfbWVzc2FnZSB9KSA6IHtcbiAgICAgICAgICAgICdIVFRQIHN0YXR1cyBjb2RlJzogcmVzcG9uc2Uuc3RhdHVzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAnSFRUUCBzdGF0dXMgdGV4dCc6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHRoaXMucmVxdWVzdElkID0gcmVxdWVzdElkO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgbW9kZSB1c2VkIHdoZW4gaW5zdGFsbGluZyBhIGNhbmlzdGVyLlxuICovXG5leHBvcnQgdmFyIENhbmlzdGVySW5zdGFsbE1vZGU7XG4oZnVuY3Rpb24gKENhbmlzdGVySW5zdGFsbE1vZGUpIHtcbiAgICBDYW5pc3Rlckluc3RhbGxNb2RlW1wiSW5zdGFsbFwiXSA9IFwiaW5zdGFsbFwiO1xuICAgIENhbmlzdGVySW5zdGFsbE1vZGVbXCJSZWluc3RhbGxcIl0gPSBcInJlaW5zdGFsbFwiO1xuICAgIENhbmlzdGVySW5zdGFsbE1vZGVbXCJVcGdyYWRlXCJdID0gXCJ1cGdyYWRlXCI7XG59KShDYW5pc3Rlckluc3RhbGxNb2RlIHx8IChDYW5pc3Rlckluc3RhbGxNb2RlID0ge30pKTtcbmNvbnN0IG1ldGFkYXRhU3ltYm9sID0gU3ltYm9sLmZvcignaWMtYWdlbnQtbWV0YWRhdGEnKTtcbi8qKlxuICogQW4gYWN0b3IgYmFzZSBjbGFzcy4gQW4gYWN0b3IgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSBmdW5jdGlvbnMgdGhhdCB3aWxsXG4gKiByZXR1cm4gYSBwcm9taXNlLiBUaGVzZSBmdW5jdGlvbnMgYXJlIGRlcml2ZWQgZnJvbSB0aGUgSURMIGRlZmluaXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3RvciB7XG4gICAgY29uc3RydWN0b3IobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpc1ttZXRhZGF0YVN5bWJvbF0gPSBPYmplY3QuZnJlZXplKG1ldGFkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBBZ2VudCBjbGFzcyB0aGlzIEFjdG9yIHdvdWxkIGNhbGwsIG9yIHVuZGVmaW5lZCBpZiB0aGUgQWN0b3Igd291bGQgdXNlXG4gICAgICogdGhlIGRlZmF1bHQgYWdlbnQgKGdsb2JhbC5pYy5hZ2VudCkuXG4gICAgICogQHBhcmFtIGFjdG9yIFRoZSBhY3RvciB0byBnZXQgdGhlIGFnZW50IG9mLlxuICAgICAqL1xuICAgIHN0YXRpYyBhZ2VudE9mKGFjdG9yKSB7XG4gICAgICAgIHJldHVybiBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLmFnZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGludGVyZmFjZSBvZiBhbiBhY3RvciwgaW4gdGhlIGZvcm0gb2YgYW4gaW5zdGFuY2Ugb2YgYSBTZXJ2aWNlLlxuICAgICAqIEBwYXJhbSBhY3RvciBUaGUgYWN0b3IgdG8gZ2V0IHRoZSBpbnRlcmZhY2Ugb2YuXG4gICAgICovXG4gICAgc3RhdGljIGludGVyZmFjZU9mKGFjdG9yKSB7XG4gICAgICAgIHJldHVybiBhY3RvclttZXRhZGF0YVN5bWJvbF0uc2VydmljZTtcbiAgICB9XG4gICAgc3RhdGljIGNhbmlzdGVySWRPZihhY3Rvcikge1xuICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmZyb20oYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZy5jYW5pc3RlcklkKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGluc3RhbGwoZmllbGRzLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgbW9kZSA9IGZpZWxkcy5tb2RlID09PSB1bmRlZmluZWQgPyBDYW5pc3Rlckluc3RhbGxNb2RlLkluc3RhbGwgOiBmaWVsZHMubW9kZTtcbiAgICAgICAgLy8gTmVlZCB0byB0cmFuc2Zvcm0gdGhlIGFyZyBpbnRvIGEgbnVtYmVyIGFycmF5LlxuICAgICAgICBjb25zdCBhcmcgPSBmaWVsZHMuYXJnID8gWy4uLm5ldyBVaW50OEFycmF5KGZpZWxkcy5hcmcpXSA6IFtdO1xuICAgICAgICAvLyBTYW1lIGZvciBtb2R1bGUuXG4gICAgICAgIGNvbnN0IHdhc21Nb2R1bGUgPSBbLi4ubmV3IFVpbnQ4QXJyYXkoZmllbGRzLm1vZHVsZSldO1xuICAgICAgICBjb25zdCBjYW5pc3RlcklkID0gdHlwZW9mIGNvbmZpZy5jYW5pc3RlcklkID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBQcmluY2lwYWwuZnJvbVRleHQoY29uZmlnLmNhbmlzdGVySWQpXG4gICAgICAgICAgICA6IGNvbmZpZy5jYW5pc3RlcklkO1xuICAgICAgICBhd2FpdCBnZXRNYW5hZ2VtZW50Q2FuaXN0ZXIoY29uZmlnKS5pbnN0YWxsX2NvZGUoe1xuICAgICAgICAgICAgbW9kZTogeyBbbW9kZV06IG51bGwgfSxcbiAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgIHdhc21fbW9kdWxlOiB3YXNtTW9kdWxlLFxuICAgICAgICAgICAgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVySWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlQ2FuaXN0ZXIoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHsgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVySWQgfSA9IGF3YWl0IGdldE1hbmFnZW1lbnRDYW5pc3Rlcihjb25maWcgfHwge30pLnByb3Zpc2lvbmFsX2NyZWF0ZV9jYW5pc3Rlcl93aXRoX2N5Y2xlcyh7IGFtb3VudDogW10sIHNldHRpbmdzOiBbXSB9KTtcbiAgICAgICAgcmV0dXJuIGNhbmlzdGVySWQ7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGVBbmRJbnN0YWxsQ2FuaXN0ZXIoaW50ZXJmYWNlRmFjdG9yeSwgZmllbGRzLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgY2FuaXN0ZXJJZCA9IGF3YWl0IHRoaXMuY3JlYXRlQ2FuaXN0ZXIoY29uZmlnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbnN0YWxsKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkcyksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgeyBjYW5pc3RlcklkIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQWN0b3IoaW50ZXJmYWNlRmFjdG9yeSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWcpLCB7IGNhbmlzdGVySWQgfSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlQWN0b3JDbGFzcyhpbnRlcmZhY2VGYWN0b3J5LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2UgPSBpbnRlcmZhY2VGYWN0b3J5KHsgSURMIH0pO1xuICAgICAgICBjbGFzcyBDYW5pc3RlckFjdG9yIGV4dGVuZHMgQWN0b3Ige1xuICAgICAgICAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb25maWcuY2FuaXN0ZXJJZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFnZW50RXJyb3IoYENhbmlzdGVyIElEIGlzIHJlcXVpcmVkLCBidXQgcmVjZWl2ZWQgJHt0eXBlb2YgY29uZmlnLmNhbmlzdGVySWR9IGluc3RlYWQuIElmIHlvdSBhcmUgdXNpbmcgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZGVjbGFyYXRpb25zLCB0aGlzIG1heSBiZSBiZWNhdXNlIHlvdXIgYXBwbGljYXRpb24gaXMgbm90IHNldHRpbmcgdGhlIGNhbmlzdGVyIElEIGluIHByb2Nlc3MuZW52IGNvcnJlY3RseS5gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5pc3RlcklkID0gdHlwZW9mIGNvbmZpZy5jYW5pc3RlcklkID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IFByaW5jaXBhbC5mcm9tVGV4dChjb25maWcuY2FuaXN0ZXJJZClcbiAgICAgICAgICAgICAgICAgICAgOiBjb25maWcuY2FuaXN0ZXJJZDtcbiAgICAgICAgICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQUNUT1JfQ09ORklHKSwgY29uZmlnKSwgeyBjYW5pc3RlcklkIH0pLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW21ldGhvZE5hbWUsIGZ1bmNdIG9mIHNlcnZpY2UuX2ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmh0dHBEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jLmFubm90YXRpb25zLnB1c2goQUNUT1JfTUVUSE9EX1dJVEhfSFRUUF9ERVRBSUxTKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gX2NyZWF0ZUFjdG9yTWV0aG9kKHRoaXMsIG1ldGhvZE5hbWUsIGZ1bmMsIGNvbmZpZy5ibHNWZXJpZnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2FuaXN0ZXJBY3RvcjtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUFjdG9yKGludGVyZmFjZUZhY3RvcnksIGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLmNhbmlzdGVySWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZ2VudEVycm9yKGBDYW5pc3RlciBJRCBpcyByZXF1aXJlZCwgYnV0IHJlY2VpdmVkICR7dHlwZW9mIGNvbmZpZ3VyYXRpb24uY2FuaXN0ZXJJZH0gaW5zdGVhZC4gSWYgeW91IGFyZSB1c2luZyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBkZWNsYXJhdGlvbnMsIHRoaXMgbWF5IGJlIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBpcyBub3Qgc2V0dGluZyB0aGUgY2FuaXN0ZXIgSUQgaW4gcHJvY2Vzcy5lbnYgY29ycmVjdGx5LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY3JlYXRlQWN0b3JDbGFzcyhpbnRlcmZhY2VGYWN0b3J5KSkoY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVBY3RvcldpdGhIdHRwRGV0YWlscyhpbnRlcmZhY2VGYWN0b3J5LCBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY3JlYXRlQWN0b3JDbGFzcyhpbnRlcmZhY2VGYWN0b3J5LCB7IGh0dHBEZXRhaWxzOiB0cnVlIH0pKShjb25maWd1cmF0aW9uKTtcbiAgICB9XG59XG4vLyBJREwgZnVuY3Rpb25zIGNhbiBoYXZlIG11bHRpcGxlIHJldHVybiB2YWx1ZXMsIHNvIGRlY29kaW5nIGFsd2F5c1xuLy8gcHJvZHVjZXMgYW4gYXJyYXkuIEVuc3VyZSB0aGF0IGZ1bmN0aW9ucyB3aXRoIHNpbmdsZSBvciB6ZXJvIHJldHVyblxuLy8gdmFsdWVzIGJlaGF2ZSBhcyBleHBlY3RlZC5cbmZ1bmN0aW9uIGRlY29kZVJldHVyblZhbHVlKHR5cGVzLCBtc2cpIHtcbiAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSBJREwuZGVjb2RlKHR5cGVzLCBCdWZmZXIuZnJvbShtc2cpKTtcbiAgICBzd2l0Y2ggKHJldHVyblZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlc1swXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gICAgfVxufVxuY29uc3QgREVGQVVMVF9BQ1RPUl9DT05GSUcgPSB7XG4gICAgcG9sbGluZ1N0cmF0ZWd5RmFjdG9yeTogc3RyYXRlZ3kuZGVmYXVsdFN0cmF0ZWd5LFxufTtcbmV4cG9ydCBjb25zdCBBQ1RPUl9NRVRIT0RfV0lUSF9IVFRQX0RFVEFJTFMgPSAnaHR0cC1kZXRhaWxzJztcbmZ1bmN0aW9uIF9jcmVhdGVBY3Rvck1ldGhvZChhY3RvciwgbWV0aG9kTmFtZSwgZnVuYywgYmxzVmVyaWZ5KSB7XG4gICAgbGV0IGNhbGxlcjtcbiAgICBpZiAoZnVuYy5hbm5vdGF0aW9ucy5pbmNsdWRlcygncXVlcnknKSB8fCBmdW5jLmFubm90YXRpb25zLmluY2x1ZGVzKCdjb21wb3NpdGVfcXVlcnknKSkge1xuICAgICAgICBjYWxsZXIgPSBhc3luYyAob3B0aW9ucywgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBpZiB0aGVyZSdzIGEgY29uZmlnIHRyYW5zZm9ybWF0aW9uLCBjYWxsIGl0LlxuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIChfYiA9IChfYSA9IGFjdG9yW21ldGFkYXRhU3ltYm9sXS5jb25maWcpLnF1ZXJ5VHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbWV0aG9kTmFtZSwgYXJncywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnKSwgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50ID0gb3B0aW9ucy5hZ2VudCB8fCBhY3RvclttZXRhZGF0YVN5bWJvbF0uY29uZmlnLmFnZW50IHx8IGdldERlZmF1bHRBZ2VudCgpO1xuICAgICAgICAgICAgY29uc3QgY2lkID0gUHJpbmNpcGFsLmZyb20ob3B0aW9ucy5jYW5pc3RlcklkIHx8IGFjdG9yW21ldGFkYXRhU3ltYm9sXS5jb25maWcuY2FuaXN0ZXJJZCk7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBJREwuZW5jb2RlKGZ1bmMuYXJnVHlwZXMsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWdlbnQucXVlcnkoY2lkLCB7IG1ldGhvZE5hbWUsIGFyZyB9KTtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0LnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWplY3RlZFwiIC8qIFF1ZXJ5UmVzcG9uc2VTdGF0dXMuUmVqZWN0ZWQgKi86XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBRdWVyeUNhbGxSZWplY3RlZEVycm9yKGNpZCwgbWV0aG9kTmFtZSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwbGllZFwiIC8qIFF1ZXJ5UmVzcG9uc2VTdGF0dXMuUmVwbGllZCAqLzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYW5ub3RhdGlvbnMuaW5jbHVkZXMoQUNUT1JfTUVUSE9EX1dJVEhfSFRUUF9ERVRBSUxTKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cERldGFpbHM6IHJlc3VsdC5odHRwRGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGRlY29kZVJldHVyblZhbHVlKGZ1bmMucmV0VHlwZXMsIHJlc3VsdC5yZXBseS5hcmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWNvZGVSZXR1cm5WYWx1ZShmdW5jLnJldFR5cGVzLCByZXN1bHQucmVwbHkuYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhbGxlciA9IGFzeW5jIChvcHRpb25zLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgLy8gRmlyc3QsIGlmIHRoZXJlJ3MgYSBjb25maWcgdHJhbnNmb3JtYXRpb24sIGNhbGwgaXQuXG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgKF9iID0gKF9hID0gYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZykuY2FsbFRyYW5zZm9ybSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG1ldGhvZE5hbWUsIGFyZ3MsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZyksIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICBjb25zdCBhZ2VudCA9IG9wdGlvbnMuYWdlbnQgfHwgYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZy5hZ2VudCB8fCBnZXREZWZhdWx0QWdlbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FuaXN0ZXJJZCwgZWZmZWN0aXZlQ2FuaXN0ZXJJZCwgcG9sbGluZ1N0cmF0ZWd5RmFjdG9yeSB9ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQUNUT1JfQ09ORklHKSwgYWN0b3JbbWV0YWRhdGFTeW1ib2xdLmNvbmZpZyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgY2lkID0gUHJpbmNpcGFsLmZyb20oY2FuaXN0ZXJJZCk7XG4gICAgICAgICAgICBjb25zdCBlY2lkID0gZWZmZWN0aXZlQ2FuaXN0ZXJJZCAhPT0gdW5kZWZpbmVkID8gUHJpbmNpcGFsLmZyb20oZWZmZWN0aXZlQ2FuaXN0ZXJJZCkgOiBjaWQ7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBJREwuZW5jb2RlKGZ1bmMuYXJnVHlwZXMsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgeyByZXF1ZXN0SWQsIHJlc3BvbnNlIH0gPSBhd2FpdCBhZ2VudC5jYWxsKGNpZCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgIGVmZmVjdGl2ZUNhbmlzdGVySWQ6IGVjaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2sgfHwgcmVzcG9uc2UuYm9keSAvKiBJQy0xNDYyICovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVwZGF0ZUNhbGxSZWplY3RlZEVycm9yKGNpZCwgbWV0aG9kTmFtZSwgcmVxdWVzdElkLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb2xsU3RyYXRlZ3kgPSBwb2xsaW5nU3RyYXRlZ3lGYWN0b3J5KCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJ5dGVzID0gYXdhaXQgcG9sbEZvclJlc3BvbnNlKGFnZW50LCBlY2lkLCByZXF1ZXN0SWQsIHBvbGxTdHJhdGVneSwgYmxzVmVyaWZ5KTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEluY2x1ZGVIdHRwRGV0YWlscyA9IGZ1bmMuYW5ub3RhdGlvbnMuaW5jbHVkZXMoQUNUT1JfTUVUSE9EX1dJVEhfSFRUUF9ERVRBSUxTKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZUJ5dGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkSW5jbHVkZUh0dHBEZXRhaWxzXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cERldGFpbHM6IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBkZWNvZGVSZXR1cm5WYWx1ZShmdW5jLnJldFR5cGVzLCByZXNwb25zZUJ5dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IGRlY29kZVJldHVyblZhbHVlKGZ1bmMucmV0VHlwZXMsIHJlc3BvbnNlQnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnVuYy5yZXRUeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hvdWxkSW5jbHVkZUh0dHBEZXRhaWxzXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cERldGFpbHM6IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGwgd2FzIHJldHVybmVkIHVuZGVmaW5lZCwgYnV0IHR5cGUgWyR7ZnVuYy5yZXRUeXBlcy5qb2luKCcsJyl9XS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlciA9ICguLi5hcmdzKSA9PiBjYWxsZXIoe30sIC4uLmFyZ3MpO1xuICAgIGhhbmRsZXIud2l0aE9wdGlvbnMgPVxuICAgICAgICAob3B0aW9ucykgPT4gKC4uLmFyZ3MpID0+IGNhbGxlcihvcHRpb25zLCAuLi5hcmdzKTtcbiAgICByZXR1cm4gaGFuZGxlcjtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbWFuYWdlbWVudCBjYW5pc3RlciBhY3RvclxuICogQHBhcmFtIGNvbmZpZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFuYWdlbWVudENhbmlzdGVyKGNvbmZpZykge1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShfbWV0aG9kTmFtZSwgYXJncywgX2NhbGxDb25maWcpIHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSBhcmdzWzBdO1xuICAgICAgICBsZXQgZWZmZWN0aXZlQ2FuaXN0ZXJJZCA9IFByaW5jaXBhbC5mcm9tSGV4KCcnKTtcbiAgICAgICAgaWYgKGZpcnN0ICYmIHR5cGVvZiBmaXJzdCA9PT0gJ29iamVjdCcgJiYgZmlyc3QuY2FuaXN0ZXJfaWQpIHtcbiAgICAgICAgICAgIGVmZmVjdGl2ZUNhbmlzdGVySWQgPSBQcmluY2lwYWwuZnJvbShmaXJzdC5jYW5pc3Rlcl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZWZmZWN0aXZlQ2FuaXN0ZXJJZCB9O1xuICAgIH1cbiAgICByZXR1cm4gQWN0b3IuY3JlYXRlQWN0b3IobWFuYWdlbWVudENhbmlzdGVySWRsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgeyBjYW5pc3RlcklkOiBQcmluY2lwYWwuZnJvbUhleCgnJykgfSksIHtcbiAgICAgICAgY2FsbFRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICBxdWVyeVRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/actor.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/agent/api.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/agent/api.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReplicaRejectCode: function() { return /* binding */ ReplicaRejectCode; }\n/* harmony export */ });\n/**\n * Codes used by the replica for rejecting a message.\n * See {@link https://sdk.dfinity.org/docs/interface-spec/#reject-codes | the interface spec}.\n */\nvar ReplicaRejectCode;\n(function (ReplicaRejectCode) {\n    ReplicaRejectCode[ReplicaRejectCode[\"SysFatal\"] = 1] = \"SysFatal\";\n    ReplicaRejectCode[ReplicaRejectCode[\"SysTransient\"] = 2] = \"SysTransient\";\n    ReplicaRejectCode[ReplicaRejectCode[\"DestinationInvalid\"] = 3] = \"DestinationInvalid\";\n    ReplicaRejectCode[ReplicaRejectCode[\"CanisterReject\"] = 4] = \"CanisterReject\";\n    ReplicaRejectCode[ReplicaRejectCode[\"CanisterError\"] = 5] = \"CanisterError\";\n})(ReplicaRejectCode || (ReplicaRejectCode = {}));\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvYXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsUUFBUSxxRkFBcUY7QUFDN0Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9hZ2VudC9hcGkuanM/YWJlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvZGVzIHVzZWQgYnkgdGhlIHJlcGxpY2EgZm9yIHJlamVjdGluZyBhIG1lc3NhZ2UuXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vc2RrLmRmaW5pdHkub3JnL2RvY3MvaW50ZXJmYWNlLXNwZWMvI3JlamVjdC1jb2RlcyB8IHRoZSBpbnRlcmZhY2Ugc3BlY30uXG4gKi9cbmV4cG9ydCB2YXIgUmVwbGljYVJlamVjdENvZGU7XG4oZnVuY3Rpb24gKFJlcGxpY2FSZWplY3RDb2RlKSB7XG4gICAgUmVwbGljYVJlamVjdENvZGVbUmVwbGljYVJlamVjdENvZGVbXCJTeXNGYXRhbFwiXSA9IDFdID0gXCJTeXNGYXRhbFwiO1xuICAgIFJlcGxpY2FSZWplY3RDb2RlW1JlcGxpY2FSZWplY3RDb2RlW1wiU3lzVHJhbnNpZW50XCJdID0gMl0gPSBcIlN5c1RyYW5zaWVudFwiO1xuICAgIFJlcGxpY2FSZWplY3RDb2RlW1JlcGxpY2FSZWplY3RDb2RlW1wiRGVzdGluYXRpb25JbnZhbGlkXCJdID0gM10gPSBcIkRlc3RpbmF0aW9uSW52YWxpZFwiO1xuICAgIFJlcGxpY2FSZWplY3RDb2RlW1JlcGxpY2FSZWplY3RDb2RlW1wiQ2FuaXN0ZXJSZWplY3RcIl0gPSA0XSA9IFwiQ2FuaXN0ZXJSZWplY3RcIjtcbiAgICBSZXBsaWNhUmVqZWN0Q29kZVtSZXBsaWNhUmVqZWN0Q29kZVtcIkNhbmlzdGVyRXJyb3JcIl0gPSA1XSA9IFwiQ2FuaXN0ZXJFcnJvclwiO1xufSkoUmVwbGljYVJlamVjdENvZGUgfHwgKFJlcGxpY2FSZWplY3RDb2RlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/agent/api.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/agent/http/errors.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/agent/http/errors.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentHTTPResponseError: function() { return /* binding */ AgentHTTPResponseError; }\n/* harmony export */ });\nclass AgentHTTPResponseError extends Error {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n        this.name = this.constructor.name;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC9lcnJvcnMuanM/MGQxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgQWdlbnRIVFRQUmVzcG9uc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCByZXNwb25zZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/agent/http/errors.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/agent/http/index.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/agent/http/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Expiry: function() { return /* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry; },\n/* harmony export */   HttpAgent: function() { return /* binding */ HttpAgent; },\n/* harmony export */   IdentityInvalidError: function() { return /* binding */ IdentityInvalidError; },\n/* harmony export */   RequestStatusResponseStatus: function() { return /* binding */ RequestStatusResponseStatus; },\n/* harmony export */   httpHeadersTransform: function() { return /* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform; },\n/* harmony export */   makeExpiryTransform: function() { return /* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.makeExpiryTransform; },\n/* harmony export */   makeNonce: function() { return /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_7__.makeNonce; },\n/* harmony export */   makeNonceTransform: function() { return /* reexport safe */ _transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"../../../node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors */ \"../../../node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../auth */ \"../../../node_modules/@dfinity/agent/lib/esm/auth.js\");\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../cbor */ \"../../../node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../request_id */ \"../../../node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/buffer */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _transforms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transforms */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./errors */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/http/errors.js\");\n/* harmony import */ var _canisterStatus__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../canisterStatus */ \"../../../node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../certificate */ \"../../../node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"../../../node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var _utils_expirableMap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../utils/expirableMap */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js\");\n/* harmony import */ var _public_key__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../public_key */ \"../../../node_modules/@dfinity/agent/lib/esm/public_key.js\");\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HttpAgent_queryPipeline, _HttpAgent_updatePipeline, _HttpAgent_subnetKeys, _HttpAgent_verifyQuerySignatures, _HttpAgent_verifyQueryResponse;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar RequestStatusResponseStatus;\n(function (RequestStatusResponseStatus) {\n    RequestStatusResponseStatus[\"Received\"] = \"received\";\n    RequestStatusResponseStatus[\"Processing\"] = \"processing\";\n    RequestStatusResponseStatus[\"Replied\"] = \"replied\";\n    RequestStatusResponseStatus[\"Rejected\"] = \"rejected\";\n    RequestStatusResponseStatus[\"Unknown\"] = \"unknown\";\n    RequestStatusResponseStatus[\"Done\"] = \"done\";\n})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));\n// Default delta for ingress expiry is 5 minutes.\nconst DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;\n// Root public key for the IC, encoded as hex\nconst IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +\n    'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +\n    '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +\n    'b01291091c5f87b98883463f98091a0baaae';\n// IC0 domain info\nconst IC0_DOMAIN = 'ic0.app';\nconst IC0_SUB_DOMAIN = '.ic0.app';\nconst ICP0_DOMAIN = 'icp0.io';\nconst ICP0_SUB_DOMAIN = '.icp0.io';\nconst ICP_API_DOMAIN = 'icp-api.io';\nconst ICP_API_SUB_DOMAIN = '.icp-api.io';\nclass HttpDefaultFetchError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {\n    constructor(message) {\n        super(message);\n        this.message = message;\n    }\n}\nclass IdentityInvalidError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {\n    constructor(message) {\n        super(message);\n        this.message = message;\n    }\n}\nfunction getDefaultFetch() {\n    let defaultFetch;\n    if (typeof window !== 'undefined') {\n        // Browser context\n        if (window.fetch) {\n            defaultFetch = window.fetch.bind(window);\n        }\n        else {\n            throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.');\n        }\n    }\n    else if (typeof __webpack_require__.g !== 'undefined') {\n        // Node context\n        if (__webpack_require__.g.fetch) {\n            defaultFetch = __webpack_require__.g.fetch.bind(__webpack_require__.g);\n        }\n        else {\n            throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.');\n        }\n    }\n    else if (typeof self !== 'undefined') {\n        if (self.fetch) {\n            defaultFetch = self.fetch.bind(self);\n        }\n    }\n    if (defaultFetch) {\n        return defaultFetch;\n    }\n    throw new HttpDefaultFetchError('Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.');\n}\n// A HTTP agent allows users to interact with a client of the internet computer\n// using the available methods. It exposes an API that closely follows the\n// public view of the internet computer, and is not intended to be exposed\n// directly to the majority of users due to its low-level interface.\n//\n// There is a pipeline to apply transformations to the request before sending\n// it to the client. This is to decouple signature, nonce generation and\n// other computations so that this class can stay as simple as possible while\n// allowing extensions.\nclass HttpAgent {\n    constructor(options = {}) {\n        this.rootKey = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_5__.fromHex)(IC_ROOT_KEY);\n        this._timeDiffMsecs = 0;\n        this._rootKeyFetched = false;\n        this._isAgent = true;\n        _HttpAgent_queryPipeline.set(this, []);\n        _HttpAgent_updatePipeline.set(this, []);\n        _HttpAgent_subnetKeys.set(this, new _utils_expirableMap__WEBPACK_IMPORTED_MODULE_11__.ExpirableMap({\n            expirationTime: 5 * 60 * 1000, // 5 minutes\n        }));\n        _HttpAgent_verifyQuerySignatures.set(this, true);\n        /**\n         * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation\n         * @param queryResponse - The response from the query\n         * @param subnetStatus - The subnet status, including all node keys\n         * @returns ApiQueryResponse\n         */\n        _HttpAgent_verifyQueryResponse.set(this, (queryResponse, subnetStatus) => {\n            if (__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\") === false) {\n                // This should not be called if the user has disabled verification\n                return queryResponse;\n            }\n            if (!subnetStatus) {\n                throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n            }\n            const { status, signatures = [], requestId } = queryResponse;\n            const domainSeparator = new TextEncoder().encode('\\x0Bic-response');\n            for (const sig of signatures) {\n                const { timestamp, identity } = sig;\n                const nodeId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(identity).toText();\n                let hash;\n                // Hash is constructed differently depending on the status\n                if (status === 'replied') {\n                    const { reply } = queryResponse;\n                    hash = (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hashOfMap)({\n                        status: status,\n                        reply: reply,\n                        timestamp: BigInt(timestamp),\n                        request_id: requestId,\n                    });\n                }\n                else if (status === 'rejected') {\n                    const { reject_code, reject_message, error_code } = queryResponse;\n                    hash = (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.hashOfMap)({\n                        status: status,\n                        reject_code: reject_code,\n                        reject_message: reject_message,\n                        error_code: error_code,\n                        timestamp: BigInt(timestamp),\n                        request_id: requestId,\n                    });\n                }\n                else {\n                    throw new Error(`Unknown status: ${status}`);\n                }\n                const separatorWithHash = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_5__.concat)(domainSeparator, new Uint8Array(hash));\n                // FIX: check for match without verifying N times\n                const pubKey = subnetStatus === null || subnetStatus === void 0 ? void 0 : subnetStatus.nodeKeys.get(nodeId);\n                if (!pubKey) {\n                    throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n                }\n                const rawKey = _public_key__WEBPACK_IMPORTED_MODULE_12__.Ed25519PublicKey.fromDer(pubKey).rawKey;\n                const valid = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_13__.ed25519.verify(sig.signature, new Uint8Array(separatorWithHash), new Uint8Array(rawKey));\n                if (valid)\n                    return queryResponse;\n                throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError(`Invalid signature from replica ${nodeId} signed query.`);\n            }\n            return queryResponse;\n        });\n        if (options.source) {\n            if (!(options.source instanceof HttpAgent)) {\n                throw new Error(\"An Agent's source can only be another HttpAgent\");\n            }\n            this._identity = options.source._identity;\n            this._fetch = options.source._fetch;\n            this._host = options.source._host;\n            this._credentials = options.source._credentials;\n        }\n        else {\n            this._fetch = options.fetch || getDefaultFetch() || fetch.bind(__webpack_require__.g);\n            this._fetchOptions = options.fetchOptions;\n            this._callOptions = options.callOptions;\n        }\n        if (options.host !== undefined) {\n            if (!options.host.match(/^[a-z]+:/) && typeof window !== 'undefined') {\n                this._host = new URL(window.location.protocol + '//' + options.host);\n            }\n            else {\n                this._host = new URL(options.host);\n            }\n        }\n        else if (options.source !== undefined) {\n            // Safe to ignore here.\n            this._host = options.source._host;\n        }\n        else {\n            const location = typeof window !== 'undefined' ? window.location : undefined;\n            if (!location) {\n                this._host = new URL('https://icp-api.io');\n                console.warn('Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.');\n            }\n            // Mainnet and local will have the api route available\n            const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];\n            const hostname = location === null || location === void 0 ? void 0 : location.hostname;\n            let knownHost;\n            if (hostname && typeof hostname === 'string') {\n                knownHost = knownHosts.find(host => hostname.endsWith(host));\n            }\n            if (location && knownHost) {\n                // If the user is on a boundary-node provided host, we can use the same host for the agent\n                this._host = new URL(`${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`);\n            }\n            else {\n                this._host = new URL('https://icp-api.io');\n                console.warn('Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.');\n            }\n        }\n        if (options.verifyQuerySignatures !== undefined) {\n            __classPrivateFieldSet(this, _HttpAgent_verifyQuerySignatures, options.verifyQuerySignatures, \"f\");\n        }\n        // Default is 3, only set from option if greater or equal to 0\n        this._retryTimes =\n            options.retryTimes !== undefined && options.retryTimes >= 0 ? options.retryTimes : 3;\n        // Rewrite to avoid redirects\n        if (this._host.hostname.endsWith(IC0_SUB_DOMAIN)) {\n            this._host.hostname = IC0_DOMAIN;\n        }\n        else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN)) {\n            this._host.hostname = ICP0_DOMAIN;\n        }\n        else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {\n            this._host.hostname = ICP_API_DOMAIN;\n        }\n        if (options.credentials) {\n            const { name, password } = options.credentials;\n            this._credentials = `${name}${password ? ':' + password : ''}`;\n        }\n        this._identity = Promise.resolve(options.identity || new _auth__WEBPACK_IMPORTED_MODULE_2__.AnonymousIdentity());\n        // Add a nonce transform to ensure calls are unique\n        this.addTransform('update', (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform)(_types__WEBPACK_IMPORTED_MODULE_7__.makeNonce));\n        if (options.useQueryNonces) {\n            this.addTransform('query', (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.makeNonceTransform)(_types__WEBPACK_IMPORTED_MODULE_7__.makeNonce));\n        }\n    }\n    isLocal() {\n        const hostname = this._host.hostname;\n        return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');\n    }\n    addTransform(type, fn, priority = fn.priority || 0) {\n        if (type === 'update') {\n            // Keep the pipeline sorted at all time, by priority.\n            const i = __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n            __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\").length, 0, Object.assign(fn, { priority }));\n        }\n        else if (type === 'query') {\n            // Keep the pipeline sorted at all time, by priority.\n            const i = __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").findIndex(x => (x.priority || 0) < priority);\n            __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\").length, 0, Object.assign(fn, { priority }));\n        }\n    }\n    async getPrincipal() {\n        if (!this._identity) {\n            throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n        }\n        return (await this._identity).getPrincipal();\n    }\n    async call(canisterId, options, identity) {\n        const id = await (identity !== undefined ? await identity : await this._identity);\n        if (!id) {\n            throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n        }\n        const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n        const ecid = options.effectiveCanisterId\n            ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(options.effectiveCanisterId)\n            : canister;\n        const sender = id.getPrincipal() || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n        let ingress_expiry = new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);\n        // If the value is off by more than 30 seconds, reconcile system time with the network\n        if (Math.abs(this._timeDiffMsecs) > 1000 * 30) {\n            ingress_expiry = new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this._timeDiffMsecs);\n        }\n        const submit = {\n            request_type: _types__WEBPACK_IMPORTED_MODULE_7__.SubmitRequestType.Call,\n            canister_id: canister,\n            method_name: options.methodName,\n            arg: options.arg,\n            sender,\n            ingress_expiry,\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let transformedRequest = (await this._transform({\n            request: {\n                body: null,\n                method: 'POST',\n                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),\n            },\n            endpoint: \"call\" /* Endpoint.Call */,\n            body: submit,\n        }));\n        // Apply transform for identity.\n        transformedRequest = await id.transformRequest(transformedRequest);\n        const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(transformedRequest.body);\n        // Run both in parallel. The fetch is quite expensive, so we have plenty of time to\n        // calculate the requestId locally.\n        const request = this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign(Object.assign({}, this._callOptions), transformedRequest.request), { body })));\n        const [response, requestId] = await Promise.all([request, (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.requestIdOf)(submit)]);\n        const responseBuffer = await response.arrayBuffer();\n        const responseBody = (response.status === 200 && responseBuffer.byteLength > 0 ? _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(responseBuffer) : null);\n        return {\n            requestId,\n            response: {\n                ok: response.ok,\n                status: response.status,\n                statusText: response.statusText,\n                body: responseBody,\n                headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),\n            },\n        };\n    }\n    async _requestAndRetry(request, tries = 0) {\n        let response;\n        try {\n            response = await request();\n        }\n        catch (error) {\n            if (this._retryTimes > tries) {\n                console.warn(`Caught exception while attempting to make request:\\n` +\n                    `  ${error}\\n` +\n                    `  Retrying request.`);\n                return await this._requestAndRetry(request, tries + 1);\n            }\n            throw error;\n        }\n        if (response.ok) {\n            return response;\n        }\n        const responseText = await response.clone().text();\n        const errorMessage = `Server returned an error:\\n` +\n            `  Code: ${response.status} (${response.statusText})\\n` +\n            `  Body: ${responseText}\\n`;\n        if (this._retryTimes > tries) {\n            console.warn(errorMessage + `  Retrying request.`);\n            return await this._requestAndRetry(request, tries + 1);\n        }\n        throw new _errors__WEBPACK_IMPORTED_MODULE_8__.AgentHTTPResponseError(errorMessage, {\n            ok: response.ok,\n            status: response.status,\n            statusText: response.statusText,\n            headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),\n        });\n    }\n    async query(canisterId, fields, identity) {\n        const makeQuery = async () => {\n            const id = await (identity !== undefined ? await identity : await this._identity);\n            if (!id) {\n                throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n            }\n            const canister = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n            const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n            const request = {\n                request_type: \"query\" /* ReadRequestType.Query */,\n                canister_id: canister,\n                method_name: fields.methodName,\n                arg: fields.arg,\n                sender,\n                ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n            };\n            const requestId = await (0,_request_id__WEBPACK_IMPORTED_MODULE_4__.requestIdOf)(request);\n            // TODO: remove this any. This can be a Signed or UnSigned request.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let transformedRequest = await this._transform({\n                request: {\n                    method: 'POST',\n                    headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),\n                },\n                endpoint: \"read\" /* Endpoint.Query */,\n                body: request,\n            });\n            // Apply transform for identity.\n            transformedRequest = await (id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest));\n            const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(transformedRequest.body);\n            const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));\n            const queryResponse = _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await response.arrayBuffer());\n            return Object.assign(Object.assign({}, queryResponse), { httpDetails: {\n                    ok: response.ok,\n                    status: response.status,\n                    statusText: response.statusText,\n                    headers: (0,_transforms__WEBPACK_IMPORTED_MODULE_6__.httpHeadersTransform)(response.headers),\n                }, requestId });\n        };\n        const getSubnetStatus = async () => {\n            if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n                return undefined;\n            }\n            const subnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(canisterId.toString());\n            if (subnetStatus) {\n                return subnetStatus;\n            }\n            await this.fetchSubnetKeys(canisterId.toString());\n            return __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(canisterId.toString());\n        };\n        // Make query and fetch subnet keys in parallel\n        const [query, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);\n        // Skip verification if the user has disabled it\n        if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, \"f\")) {\n            return query;\n        }\n        try {\n            return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, query, subnetStatus);\n        }\n        catch (_) {\n            // In case the node signatures have changed, refresh the subnet keys and try again\n            console.warn('Query response verification failed. Retrying with fresh subnet keys.');\n            __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").delete(canisterId.toString());\n            await this.fetchSubnetKeys(canisterId.toString());\n            const updatedSubnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").get(canisterId.toString());\n            if (!updatedSubnetStatus) {\n                throw new _certificate__WEBPACK_IMPORTED_MODULE_10__.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');\n            }\n            return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, \"f\").call(this, query, updatedSubnetStatus);\n        }\n    }\n    async createReadStateRequest(fields, identity) {\n        const id = await (identity !== undefined ? await identity : await this._identity);\n        if (!id) {\n            throw new IdentityInvalidError(\"This identity has expired due this application's security policy. Please refresh your authentication.\");\n        }\n        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n        // TODO: remove this any. This can be a Signed or UnSigned request.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const transformedRequest = await this._transform({\n            request: {\n                method: 'POST',\n                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),\n            },\n            endpoint: \"read_state\" /* Endpoint.ReadState */,\n            body: {\n                request_type: \"read_state\" /* ReadRequestType.ReadState */,\n                paths: fields.paths,\n                sender,\n                ingress_expiry: new _transforms__WEBPACK_IMPORTED_MODULE_6__.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),\n            },\n        });\n        // Apply transform for identity.\n        return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);\n    }\n    async readState(canisterId, fields, identity, \n    // eslint-disable-next-line\n    request) {\n        const canister = typeof canisterId === 'string' ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(canisterId) : canisterId;\n        const transformedRequest = request !== null && request !== void 0 ? request : (await this.createReadStateRequest(fields, identity));\n        const body = _cbor__WEBPACK_IMPORTED_MODULE_3__.encode(transformedRequest.body);\n        // TODO - https://dfinity.atlassian.net/browse/SDK-1092\n        const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));\n        if (!response.ok) {\n            throw new Error(`Server returned an error:\\n` +\n                `  Code: ${response.status} (${response.statusText})\\n` +\n                `  Body: ${await response.text()}\\n`);\n        }\n        return _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await response.arrayBuffer());\n    }\n    /**\n     * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request\n     * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default\n     */\n    async syncTime(canisterId) {\n        const CanisterStatus = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../canisterStatus */ \"../../../node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\"));\n        const callTime = Date.now();\n        try {\n            if (!canisterId) {\n                console.log('Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai');\n            }\n            const status = await CanisterStatus.request({\n                // Fall back with canisterId of the ICP Ledger\n                canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),\n                agent: this,\n                paths: ['time'],\n            });\n            const replicaTime = status.get('time');\n            if (replicaTime) {\n                this._timeDiffMsecs = Number(replicaTime) - Number(callTime);\n            }\n        }\n        catch (error) {\n            console.error('Caught exception while attempting to sync time:', error);\n        }\n    }\n    async status() {\n        const headers = this._credentials\n            ? {\n                Authorization: 'Basic ' + btoa(this._credentials),\n            }\n            : {};\n        const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/status`, this._host), Object.assign({ headers }, this._fetchOptions)));\n        return _cbor__WEBPACK_IMPORTED_MODULE_3__.decode(await response.arrayBuffer());\n    }\n    async fetchRootKey() {\n        if (!this._rootKeyFetched) {\n            // Hex-encoded version of the replica root key\n            this.rootKey = (await this.status()).root_key;\n            this._rootKeyFetched = true;\n        }\n        return this.rootKey;\n    }\n    invalidateIdentity() {\n        this._identity = null;\n    }\n    replaceIdentity(identity) {\n        this._identity = Promise.resolve(identity);\n    }\n    async fetchSubnetKeys(canisterId) {\n        const effectiveCanisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(canisterId);\n        const response = await (0,_canisterStatus__WEBPACK_IMPORTED_MODULE_9__.request)({\n            canisterId: effectiveCanisterId,\n            paths: ['subnet'],\n            agent: this,\n        });\n        const subnetResponse = response.get('subnet');\n        if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {\n            __classPrivateFieldGet(this, _HttpAgent_subnetKeys, \"f\").set(effectiveCanisterId.toText(), subnetResponse);\n            return subnetResponse;\n        }\n        // If the subnet status is not returned, return undefined\n        return undefined;\n    }\n    _transform(request) {\n        let p = Promise.resolve(request);\n        if (request.endpoint === \"call\" /* Endpoint.Call */) {\n            for (const fn of __classPrivateFieldGet(this, _HttpAgent_updatePipeline, \"f\")) {\n                p = p.then(r => fn(r).then(r2 => r2 || r));\n            }\n        }\n        else {\n            for (const fn of __classPrivateFieldGet(this, _HttpAgent_queryPipeline, \"f\")) {\n                p = p.then(r => fn(r).then(r2 => r2 || r));\n            }\n        }\n        return p;\n    }\n}\n_HttpAgent_queryPipeline = new WeakMap(), _HttpAgent_updatePipeline = new WeakMap(), _HttpAgent_subnetKeys = new WeakMap(), _HttpAgent_verifyQuerySignatures = new WeakMap(), _HttpAgent_verifyQueryResponse = new WeakMap();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQztBQUNMO0FBQ0s7QUFDWjtBQUN1QjtBQUNMO0FBQzJCO0FBQ3hCO0FBQ047QUFDSDtBQUNrQjtBQUNqQjtBQUNRO0FBQ0o7QUFDdkI7QUFDTztBQUM3QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrRUFBa0U7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQ0FBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DLCtDQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFNO0FBQzFCO0FBQ0EsWUFBWSxxQkFBTTtBQUNsQiwyQkFBMkIscUJBQU0sWUFBWSxxQkFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDRCQUE0QjtBQUM1Qix1QkFBdUIsc0RBQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw4REFBWTtBQUN4RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0EsMERBQTBELHlEQUFTO0FBQ25FO0FBQ0EscUJBQXFCLHlDQUFXO0FBQ2hDO0FBQ0Esd0dBQXdHLFNBQVMsdUVBQXVFLHNEQUFzRCxNQUFNO0FBQ3BQO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCLEdBQUcsb0JBQW9CO0FBQ25FLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQSxlQUFlLHlDQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EscUNBQXFDLHdMQUE4QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3Rix5REFBUztBQUNqRztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSSxTQUFTO0FBQzVJLGVBQWUseUNBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseURBQVM7QUFDN0MsK0JBQStCLHdEQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC9pbmRleC5qcz9mOGVjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfSHR0cEFnZW50X3F1ZXJ5UGlwZWxpbmUsIF9IdHRwQWdlbnRfdXBkYXRlUGlwZWxpbmUsIF9IdHRwQWdlbnRfc3VibmV0S2V5cywgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVNpZ25hdHVyZXMsIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlSZXNwb25zZTtcbmltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgeyBBZ2VudEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IEFub255bW91c0lkZW50aXR5IH0gZnJvbSAnLi4vLi4vYXV0aCc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJy4uLy4uL2Nib3InO1xuaW1wb3J0IHsgaGFzaE9mTWFwLCByZXF1ZXN0SWRPZiB9IGZyb20gJy4uLy4uL3JlcXVlc3RfaWQnO1xuaW1wb3J0IHsgY29uY2F0LCBmcm9tSGV4IH0gZnJvbSAnLi4vLi4vdXRpbHMvYnVmZmVyJztcbmltcG9ydCB7IEV4cGlyeSwgaHR0cEhlYWRlcnNUcmFuc2Zvcm0sIG1ha2VOb25jZVRyYW5zZm9ybSB9IGZyb20gJy4vdHJhbnNmb3Jtcyc7XG5pbXBvcnQgeyBtYWtlTm9uY2UsIFN1Ym1pdFJlcXVlc3RUeXBlLCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgQWdlbnRIVFRQUmVzcG9uc2VFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IHJlcXVlc3QgfSBmcm9tICcuLi8uLi9jYW5pc3RlclN0YXR1cyc7XG5pbXBvcnQgeyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yIH0gZnJvbSAnLi4vLi4vY2VydGlmaWNhdGUnO1xuaW1wb3J0IHsgZWQyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG5pbXBvcnQgeyBFeHBpcmFibGVNYXAgfSBmcm9tICcuLi8uLi91dGlscy9leHBpcmFibGVNYXAnO1xuaW1wb3J0IHsgRWQyNTUxOVB1YmxpY0tleSB9IGZyb20gJy4uLy4uL3B1YmxpY19rZXknO1xuZXhwb3J0ICogZnJvbSAnLi90cmFuc2Zvcm1zJztcbmV4cG9ydCB7IG1ha2VOb25jZSB9IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHZhciBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXM7XG4oZnVuY3Rpb24gKFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cykge1xuICAgIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1c1tcIlJlY2VpdmVkXCJdID0gXCJyZWNlaXZlZFwiO1xuICAgIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1c1tcIlByb2Nlc3NpbmdcIl0gPSBcInByb2Nlc3NpbmdcIjtcbiAgICBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXNbXCJSZXBsaWVkXCJdID0gXCJyZXBsaWVkXCI7XG4gICAgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzW1wiUmVqZWN0ZWRcIl0gPSBcInJlamVjdGVkXCI7XG4gICAgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICAgIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1c1tcIkRvbmVcIl0gPSBcImRvbmVcIjtcbn0pKFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cyB8fCAoUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzID0ge30pKTtcbi8vIERlZmF1bHQgZGVsdGEgZm9yIGluZ3Jlc3MgZXhwaXJ5IGlzIDUgbWludXRlcy5cbmNvbnN0IERFRkFVTFRfSU5HUkVTU19FWFBJUllfREVMVEFfSU5fTVNFQ1MgPSA1ICogNjAgKiAxMDAwO1xuLy8gUm9vdCBwdWJsaWMga2V5IGZvciB0aGUgSUMsIGVuY29kZWQgYXMgaGV4XG5jb25zdCBJQ19ST09UX0tFWSA9ICczMDgxODIzMDFkMDYwZDJiMDYwMTA0MDE4MmRjN2MwNTAzMDEwMjAxMDYwYzJiMDYwMTA0MDE4MmRjN2MwNTAzMDIwMTAzNjEwMDgxNCcgK1xuICAgICdjMGU2ZWM3MWZhYjU4M2IwOGJkODEzNzNjMjU1YzNjMzcxYjJlODQ4NjNjOThhNGYxZTA4Yjc0MjM1ZDE0ZmI1ZDljMGNkNTQ2ZDk2OCcgK1xuICAgICc1ZjkxM2EwYzBiMmNjNTM0MTU4M2JmNGI0MzkyZTQ2N2RiOTZkNjViOWJiNGNiNzE3MTEyZjg0NzJlMGQ1YTRkMTQ1MDVmZmQ3NDg0JyArXG4gICAgJ2IwMTI5MTA5MWM1Zjg3Yjk4ODgzNDYzZjk4MDkxYTBiYWFhZSc7XG4vLyBJQzAgZG9tYWluIGluZm9cbmNvbnN0IElDMF9ET01BSU4gPSAnaWMwLmFwcCc7XG5jb25zdCBJQzBfU1VCX0RPTUFJTiA9ICcuaWMwLmFwcCc7XG5jb25zdCBJQ1AwX0RPTUFJTiA9ICdpY3AwLmlvJztcbmNvbnN0IElDUDBfU1VCX0RPTUFJTiA9ICcuaWNwMC5pbyc7XG5jb25zdCBJQ1BfQVBJX0RPTUFJTiA9ICdpY3AtYXBpLmlvJztcbmNvbnN0IElDUF9BUElfU1VCX0RPTUFJTiA9ICcuaWNwLWFwaS5pbyc7XG5jbGFzcyBIdHRwRGVmYXVsdEZldGNoRXJyb3IgZXh0ZW5kcyBBZ2VudEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJZGVudGl0eUludmFsaWRFcnJvciBleHRlbmRzIEFnZW50RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEZldGNoKCkge1xuICAgIGxldCBkZWZhdWx0RmV0Y2g7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEJyb3dzZXIgY29udGV4dFxuICAgICAgICBpZiAod2luZG93LmZldGNoKSB7XG4gICAgICAgICAgICBkZWZhdWx0RmV0Y2ggPSB3aW5kb3cuZmV0Y2guYmluZCh3aW5kb3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEh0dHBEZWZhdWx0RmV0Y2hFcnJvcignRmV0Y2ggaW1wbGVtZW50YXRpb24gd2FzIG5vdCBhdmFpbGFibGUuIFlvdSBhcHBlYXIgdG8gYmUgaW4gYSBicm93c2VyIGNvbnRleHQsIGJ1dCB3aW5kb3cuZmV0Y2ggd2FzIG5vdCBwcmVzZW50LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE5vZGUgY29udGV4dFxuICAgICAgICBpZiAoZ2xvYmFsLmZldGNoKSB7XG4gICAgICAgICAgICBkZWZhdWx0RmV0Y2ggPSBnbG9iYWwuZmV0Y2guYmluZChnbG9iYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEh0dHBEZWZhdWx0RmV0Y2hFcnJvcignRmV0Y2ggaW1wbGVtZW50YXRpb24gd2FzIG5vdCBhdmFpbGFibGUuIFlvdSBhcHBlYXIgdG8gYmUgaW4gYSBOb2RlLmpzIGNvbnRleHQsIGJ1dCBnbG9iYWwuZmV0Y2ggd2FzIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChzZWxmLmZldGNoKSB7XG4gICAgICAgICAgICBkZWZhdWx0RmV0Y2ggPSBzZWxmLmZldGNoLmJpbmQoc2VsZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRGZXRjaCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEZldGNoO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSHR0cERlZmF1bHRGZXRjaEVycm9yKCdGZXRjaCBpbXBsZW1lbnRhdGlvbiB3YXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIHByb3ZpZGUgZmV0Y2ggdG8gdGhlIEh0dHBBZ2VudCBjb25zdHJ1Y3Rvciwgb3IgZW5zdXJlIGl0IGlzIGF2YWlsYWJsZSBpbiB0aGUgd2luZG93IG9yIGdsb2JhbCBjb250ZXh0LicpO1xufVxuLy8gQSBIVFRQIGFnZW50IGFsbG93cyB1c2VycyB0byBpbnRlcmFjdCB3aXRoIGEgY2xpZW50IG9mIHRoZSBpbnRlcm5ldCBjb21wdXRlclxuLy8gdXNpbmcgdGhlIGF2YWlsYWJsZSBtZXRob2RzLiBJdCBleHBvc2VzIGFuIEFQSSB0aGF0IGNsb3NlbHkgZm9sbG93cyB0aGVcbi8vIHB1YmxpYyB2aWV3IG9mIHRoZSBpbnRlcm5ldCBjb21wdXRlciwgYW5kIGlzIG5vdCBpbnRlbmRlZCB0byBiZSBleHBvc2VkXG4vLyBkaXJlY3RseSB0byB0aGUgbWFqb3JpdHkgb2YgdXNlcnMgZHVlIHRvIGl0cyBsb3ctbGV2ZWwgaW50ZXJmYWNlLlxuLy9cbi8vIFRoZXJlIGlzIGEgcGlwZWxpbmUgdG8gYXBwbHkgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSByZXF1ZXN0IGJlZm9yZSBzZW5kaW5nXG4vLyBpdCB0byB0aGUgY2xpZW50LiBUaGlzIGlzIHRvIGRlY291cGxlIHNpZ25hdHVyZSwgbm9uY2UgZ2VuZXJhdGlvbiBhbmRcbi8vIG90aGVyIGNvbXB1dGF0aW9ucyBzbyB0aGF0IHRoaXMgY2xhc3MgY2FuIHN0YXkgYXMgc2ltcGxlIGFzIHBvc3NpYmxlIHdoaWxlXG4vLyBhbGxvd2luZyBleHRlbnNpb25zLlxuZXhwb3J0IGNsYXNzIEh0dHBBZ2VudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMucm9vdEtleSA9IGZyb21IZXgoSUNfUk9PVF9LRVkpO1xuICAgICAgICB0aGlzLl90aW1lRGlmZk1zZWNzID0gMDtcbiAgICAgICAgdGhpcy5fcm9vdEtleUZldGNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNBZ2VudCA9IHRydWU7XG4gICAgICAgIF9IdHRwQWdlbnRfcXVlcnlQaXBlbGluZS5zZXQodGhpcywgW10pO1xuICAgICAgICBfSHR0cEFnZW50X3VwZGF0ZVBpcGVsaW5lLnNldCh0aGlzLCBbXSk7XG4gICAgICAgIF9IdHRwQWdlbnRfc3VibmV0S2V5cy5zZXQodGhpcywgbmV3IEV4cGlyYWJsZU1hcCh7XG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZTogNSAqIDYwICogMTAwMCwgLy8gNSBtaW51dGVzXG4gICAgICAgIH0pKTtcbiAgICAgICAgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVNpZ25hdHVyZXMuc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VlIGh0dHBzOi8vaW50ZXJuZXRjb21wdXRlci5vcmcvZG9jcy9jdXJyZW50L3JlZmVyZW5jZXMvaWMtaW50ZXJmYWNlLXNwZWMvI2h0dHAtcXVlcnkgZm9yIGRldGFpbHMgb24gdmFsaWRhdGlvblxuICAgICAgICAgKiBAcGFyYW0gcXVlcnlSZXNwb25zZSAtIFRoZSByZXNwb25zZSBmcm9tIHRoZSBxdWVyeVxuICAgICAgICAgKiBAcGFyYW0gc3VibmV0U3RhdHVzIC0gVGhlIHN1Ym5ldCBzdGF0dXMsIGluY2x1ZGluZyBhbGwgbm9kZSBrZXlzXG4gICAgICAgICAqIEByZXR1cm5zIEFwaVF1ZXJ5UmVzcG9uc2VcbiAgICAgICAgICovXG4gICAgICAgIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlSZXNwb25zZS5zZXQodGhpcywgKHF1ZXJ5UmVzcG9uc2UsIHN1Ym5ldFN0YXR1cykgPT4ge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVNpZ25hdHVyZXMsIFwiZlwiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIGlmIHRoZSB1c2VyIGhhcyBkaXNhYmxlZCB2ZXJpZmljYXRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlSZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3VibmV0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGZyb20gcmVwbGljYSBzaWduZWQgcXVlcnk6IG5vIG1hdGNoaW5nIG5vZGUga2V5IGZvdW5kLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBzdGF0dXMsIHNpZ25hdHVyZXMgPSBbXSwgcmVxdWVzdElkIH0gPSBxdWVyeVJlc3BvbnNlO1xuICAgICAgICAgICAgY29uc3QgZG9tYWluU2VwYXJhdG9yID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdcXHgwQmljLXJlc3BvbnNlJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNpZyBvZiBzaWduYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0aW1lc3RhbXAsIGlkZW50aXR5IH0gPSBzaWc7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gUHJpbmNpcGFsLmZyb21VaW50OEFycmF5KGlkZW50aXR5KS50b1RleHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgaGFzaDtcbiAgICAgICAgICAgICAgICAvLyBIYXNoIGlzIGNvbnN0cnVjdGVkIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB0aGUgc3RhdHVzXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3JlcGxpZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVwbHkgfSA9IHF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBoYXNoT2ZNYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseTogcmVwbHksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IEJpZ0ludCh0aW1lc3RhbXApLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdF9pZDogcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHVzID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVqZWN0X2NvZGUsIHJlamVjdF9tZXNzYWdlLCBlcnJvcl9jb2RlIH0gPSBxdWVyeVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNoID0gaGFzaE9mTWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0X2NvZGU6IHJlamVjdF9jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0X21lc3NhZ2U6IHJlamVjdF9tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfY29kZTogZXJyb3JfY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogQmlnSW50KHRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0X2lkOiByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0YXR1czogJHtzdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvcldpdGhIYXNoID0gY29uY2F0KGRvbWFpblNlcGFyYXRvciwgbmV3IFVpbnQ4QXJyYXkoaGFzaCkpO1xuICAgICAgICAgICAgICAgIC8vIEZJWDogY2hlY2sgZm9yIG1hdGNoIHdpdGhvdXQgdmVyaWZ5aW5nIE4gdGltZXNcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJLZXkgPSBzdWJuZXRTdGF0dXMgPT09IG51bGwgfHwgc3VibmV0U3RhdHVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdWJuZXRTdGF0dXMubm9kZUtleXMuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwdWJLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGZyb20gcmVwbGljYSBzaWduZWQgcXVlcnk6IG5vIG1hdGNoaW5nIG5vZGUga2V5IGZvdW5kLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByYXdLZXkgPSBFZDI1NTE5UHVibGljS2V5LmZyb21EZXIocHViS2V5KS5yYXdLZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBlZDI1NTE5LnZlcmlmeShzaWcuc2lnbmF0dXJlLCBuZXcgVWludDhBcnJheShzZXBhcmF0b3JXaXRoSGFzaCksIG5ldyBVaW50OEFycmF5KHJhd0tleSkpO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIGZyb20gcmVwbGljYSAke25vZGVJZH0gc2lnbmVkIHF1ZXJ5LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5UmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghKG9wdGlvbnMuc291cmNlIGluc3RhbmNlb2YgSHR0cEFnZW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIEFnZW50J3Mgc291cmNlIGNhbiBvbmx5IGJlIGFub3RoZXIgSHR0cEFnZW50XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faWRlbnRpdHkgPSBvcHRpb25zLnNvdXJjZS5faWRlbnRpdHk7XG4gICAgICAgICAgICB0aGlzLl9mZXRjaCA9IG9wdGlvbnMuc291cmNlLl9mZXRjaDtcbiAgICAgICAgICAgIHRoaXMuX2hvc3QgPSBvcHRpb25zLnNvdXJjZS5faG9zdDtcbiAgICAgICAgICAgIHRoaXMuX2NyZWRlbnRpYWxzID0gb3B0aW9ucy5zb3VyY2UuX2NyZWRlbnRpYWxzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmV0Y2ggPSBvcHRpb25zLmZldGNoIHx8IGdldERlZmF1bHRGZXRjaCgpIHx8IGZldGNoLmJpbmQoZ2xvYmFsKTtcbiAgICAgICAgICAgIHRoaXMuX2ZldGNoT3B0aW9ucyA9IG9wdGlvbnMuZmV0Y2hPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5fY2FsbE9wdGlvbnMgPSBvcHRpb25zLmNhbGxPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmhvc3QubWF0Y2goL15bYS16XSs6LykgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ob3N0ID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgb3B0aW9ucy5ob3N0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvc3QgPSBuZXcgVVJMKG9wdGlvbnMuaG9zdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2FmZSB0byBpZ25vcmUgaGVyZS5cbiAgICAgICAgICAgIHRoaXMuX2hvc3QgPSBvcHRpb25zLnNvdXJjZS5faG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faG9zdCA9IG5ldyBVUkwoJ2h0dHBzOi8vaWNwLWFwaS5pbycpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGluZmVyIGhvc3QgZnJvbSB3aW5kb3cubG9jYXRpb24sIGRlZmF1bHRpbmcgdG8gbWFpbm5ldCBnYXRld2F5IG9mIGh0dHBzOi8vaWNwLWFwaS5pby4gUGxlYXNlIHByb3ZpZGUgYSBob3N0IHRvIHRoZSBIdHRwQWdlbnQgY29uc3RydWN0b3IgdG8gYXZvaWQgdGhpcyB3YXJuaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFpbm5ldCBhbmQgbG9jYWwgd2lsbCBoYXZlIHRoZSBhcGkgcm91dGUgYXZhaWxhYmxlXG4gICAgICAgICAgICBjb25zdCBrbm93bkhvc3RzID0gWydpYzAuYXBwJywgJ2ljcDAuaW8nLCAnMTI3LjAuMC4xJywgJ2xvY2FsaG9zdCddO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBsb2NhdGlvbiA9PT0gbnVsbCB8fCBsb2NhdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgICAgICBsZXQga25vd25Ib3N0O1xuICAgICAgICAgICAgaWYgKGhvc3RuYW1lICYmIHR5cGVvZiBob3N0bmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBrbm93bkhvc3QgPSBrbm93bkhvc3RzLmZpbmQoaG9zdCA9PiBob3N0bmFtZS5lbmRzV2l0aChob3N0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYXRpb24gJiYga25vd25Ib3N0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgaXMgb24gYSBib3VuZGFyeS1ub2RlIHByb3ZpZGVkIGhvc3QsIHdlIGNhbiB1c2UgdGhlIHNhbWUgaG9zdCBmb3IgdGhlIGFnZW50XG4gICAgICAgICAgICAgICAgdGhpcy5faG9zdCA9IG5ldyBVUkwoYCR7bG9jYXRpb24ucHJvdG9jb2x9Ly8ke2tub3duSG9zdH0ke2xvY2F0aW9uLnBvcnQgPyAnOicgKyBsb2NhdGlvbi5wb3J0IDogJyd9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ob3N0ID0gbmV3IFVSTCgnaHR0cHM6Ly9pY3AtYXBpLmlvJyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgaW5mZXIgaG9zdCBmcm9tIHdpbmRvdy5sb2NhdGlvbiwgZGVmYXVsdGluZyB0byBtYWlubmV0IGdhdGV3YXkgb2YgaHR0cHM6Ly9pY3AtYXBpLmlvLiBQbGVhc2UgcHJvdmlkZSBhIGhvc3QgdG8gdGhlIEh0dHBBZ2VudCBjb25zdHJ1Y3RvciB0byBhdm9pZCB0aGlzIHdhcm5pbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMudmVyaWZ5UXVlcnlTaWduYXR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVNpZ25hdHVyZXMsIG9wdGlvbnMudmVyaWZ5UXVlcnlTaWduYXR1cmVzLCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCBpcyAzLCBvbmx5IHNldCBmcm9tIG9wdGlvbiBpZiBncmVhdGVyIG9yIGVxdWFsIHRvIDBcbiAgICAgICAgdGhpcy5fcmV0cnlUaW1lcyA9XG4gICAgICAgICAgICBvcHRpb25zLnJldHJ5VGltZXMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJldHJ5VGltZXMgPj0gMCA/IG9wdGlvbnMucmV0cnlUaW1lcyA6IDM7XG4gICAgICAgIC8vIFJld3JpdGUgdG8gYXZvaWQgcmVkaXJlY3RzXG4gICAgICAgIGlmICh0aGlzLl9ob3N0Lmhvc3RuYW1lLmVuZHNXaXRoKElDMF9TVUJfRE9NQUlOKSkge1xuICAgICAgICAgICAgdGhpcy5faG9zdC5ob3N0bmFtZSA9IElDMF9ET01BSU47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faG9zdC5ob3N0bmFtZS5lbmRzV2l0aChJQ1AwX1NVQl9ET01BSU4pKSB7XG4gICAgICAgICAgICB0aGlzLl9ob3N0Lmhvc3RuYW1lID0gSUNQMF9ET01BSU47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5faG9zdC5ob3N0bmFtZS5lbmRzV2l0aChJQ1BfQVBJX1NVQl9ET01BSU4pKSB7XG4gICAgICAgICAgICB0aGlzLl9ob3N0Lmhvc3RuYW1lID0gSUNQX0FQSV9ET01BSU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgcGFzc3dvcmQgfSA9IG9wdGlvbnMuY3JlZGVudGlhbHM7XG4gICAgICAgICAgICB0aGlzLl9jcmVkZW50aWFscyA9IGAke25hbWV9JHtwYXNzd29yZCA/ICc6JyArIHBhc3N3b3JkIDogJyd9YDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pZGVudGl0eSA9IFByb21pc2UucmVzb2x2ZShvcHRpb25zLmlkZW50aXR5IHx8IG5ldyBBbm9ueW1vdXNJZGVudGl0eSgpKTtcbiAgICAgICAgLy8gQWRkIGEgbm9uY2UgdHJhbnNmb3JtIHRvIGVuc3VyZSBjYWxscyBhcmUgdW5pcXVlXG4gICAgICAgIHRoaXMuYWRkVHJhbnNmb3JtKCd1cGRhdGUnLCBtYWtlTm9uY2VUcmFuc2Zvcm0obWFrZU5vbmNlKSk7XG4gICAgICAgIGlmIChvcHRpb25zLnVzZVF1ZXJ5Tm9uY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRyYW5zZm9ybSgncXVlcnknLCBtYWtlTm9uY2VUcmFuc2Zvcm0obWFrZU5vbmNlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNMb2NhbCgpIHtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSB0aGlzLl9ob3N0Lmhvc3RuYW1lO1xuICAgICAgICByZXR1cm4gaG9zdG5hbWUgPT09ICcxMjcuMC4wLjEnIHx8IGhvc3RuYW1lLmVuZHNXaXRoKCcxMjcuMC4wLjEnKTtcbiAgICB9XG4gICAgYWRkVHJhbnNmb3JtKHR5cGUsIGZuLCBwcmlvcml0eSA9IGZuLnByaW9yaXR5IHx8IDApIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgICAgICAvLyBLZWVwIHRoZSBwaXBlbGluZSBzb3J0ZWQgYXQgYWxsIHRpbWUsIGJ5IHByaW9yaXR5LlxuICAgICAgICAgICAgY29uc3QgaSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF91cGRhdGVQaXBlbGluZSwgXCJmXCIpLmZpbmRJbmRleCh4ID0+ICh4LnByaW9yaXR5IHx8IDApIDwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3VwZGF0ZVBpcGVsaW5lLCBcImZcIikuc3BsaWNlKGkgPj0gMCA/IGkgOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdXBkYXRlUGlwZWxpbmUsIFwiZlwiKS5sZW5ndGgsIDAsIE9iamVjdC5hc3NpZ24oZm4sIHsgcHJpb3JpdHkgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdxdWVyeScpIHtcbiAgICAgICAgICAgIC8vIEtlZXAgdGhlIHBpcGVsaW5lIHNvcnRlZCBhdCBhbGwgdGltZSwgYnkgcHJpb3JpdHkuXG4gICAgICAgICAgICBjb25zdCBpID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3F1ZXJ5UGlwZWxpbmUsIFwiZlwiKS5maW5kSW5kZXgoeCA9PiAoeC5wcmlvcml0eSB8fCAwKSA8IHByaW9yaXR5KTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9xdWVyeVBpcGVsaW5lLCBcImZcIikuc3BsaWNlKGkgPj0gMCA/IGkgOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfcXVlcnlQaXBlbGluZSwgXCJmXCIpLmxlbmd0aCwgMCwgT2JqZWN0LmFzc2lnbihmbiwgeyBwcmlvcml0eSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJpbmNpcGFsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lkZW50aXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWRlbnRpdHlJbnZhbGlkRXJyb3IoXCJUaGlzIGlkZW50aXR5IGhhcyBleHBpcmVkIGR1ZSB0aGlzIGFwcGxpY2F0aW9uJ3Mgc2VjdXJpdHkgcG9saWN5LiBQbGVhc2UgcmVmcmVzaCB5b3VyIGF1dGhlbnRpY2F0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuX2lkZW50aXR5KS5nZXRQcmluY2lwYWwoKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbChjYW5pc3RlcklkLCBvcHRpb25zLCBpZGVudGl0eSkge1xuICAgICAgICBjb25zdCBpZCA9IGF3YWl0IChpZGVudGl0eSAhPT0gdW5kZWZpbmVkID8gYXdhaXQgaWRlbnRpdHkgOiBhd2FpdCB0aGlzLl9pZGVudGl0eSk7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJZGVudGl0eUludmFsaWRFcnJvcihcIlRoaXMgaWRlbnRpdHkgaGFzIGV4cGlyZWQgZHVlIHRoaXMgYXBwbGljYXRpb24ncyBzZWN1cml0eSBwb2xpY3kuIFBsZWFzZSByZWZyZXNoIHlvdXIgYXV0aGVudGljYXRpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbmlzdGVyID0gUHJpbmNpcGFsLmZyb20oY2FuaXN0ZXJJZCk7XG4gICAgICAgIGNvbnN0IGVjaWQgPSBvcHRpb25zLmVmZmVjdGl2ZUNhbmlzdGVySWRcbiAgICAgICAgICAgID8gUHJpbmNpcGFsLmZyb20ob3B0aW9ucy5lZmZlY3RpdmVDYW5pc3RlcklkKVxuICAgICAgICAgICAgOiBjYW5pc3RlcjtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gaWQuZ2V0UHJpbmNpcGFsKCkgfHwgUHJpbmNpcGFsLmFub255bW91cygpO1xuICAgICAgICBsZXQgaW5ncmVzc19leHBpcnkgPSBuZXcgRXhwaXJ5KERFRkFVTFRfSU5HUkVTU19FWFBJUllfREVMVEFfSU5fTVNFQ1MpO1xuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgb2ZmIGJ5IG1vcmUgdGhhbiAzMCBzZWNvbmRzLCByZWNvbmNpbGUgc3lzdGVtIHRpbWUgd2l0aCB0aGUgbmV0d29ya1xuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fdGltZURpZmZNc2VjcykgPiAxMDAwICogMzApIHtcbiAgICAgICAgICAgIGluZ3Jlc3NfZXhwaXJ5ID0gbmV3IEV4cGlyeShERUZBVUxUX0lOR1JFU1NfRVhQSVJZX0RFTFRBX0lOX01TRUNTICsgdGhpcy5fdGltZURpZmZNc2Vjcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VibWl0ID0ge1xuICAgICAgICAgICAgcmVxdWVzdF90eXBlOiBTdWJtaXRSZXF1ZXN0VHlwZS5DYWxsLFxuICAgICAgICAgICAgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyLFxuICAgICAgICAgICAgbWV0aG9kX25hbWU6IG9wdGlvbnMubWV0aG9kTmFtZSxcbiAgICAgICAgICAgIGFyZzogb3B0aW9ucy5hcmcsXG4gICAgICAgICAgICBzZW5kZXIsXG4gICAgICAgICAgICBpbmdyZXNzX2V4cGlyeSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkUmVxdWVzdCA9IChhd2FpdCB0aGlzLl90cmFuc2Zvcm0oe1xuICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgIGJvZHk6IG51bGwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vY2JvcicgfSwgKHRoaXMuX2NyZWRlbnRpYWxzID8geyBBdXRob3JpemF0aW9uOiAnQmFzaWMgJyArIGJ0b2EodGhpcy5fY3JlZGVudGlhbHMpIH0gOiB7fSkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuZHBvaW50OiBcImNhbGxcIiAvKiBFbmRwb2ludC5DYWxsICovLFxuICAgICAgICAgICAgYm9keTogc3VibWl0LFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIEFwcGx5IHRyYW5zZm9ybSBmb3IgaWRlbnRpdHkuXG4gICAgICAgIHRyYW5zZm9ybWVkUmVxdWVzdCA9IGF3YWl0IGlkLnRyYW5zZm9ybVJlcXVlc3QodHJhbnNmb3JtZWRSZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgYm9keSA9IGNib3IuZW5jb2RlKHRyYW5zZm9ybWVkUmVxdWVzdC5ib2R5KTtcbiAgICAgICAgLy8gUnVuIGJvdGggaW4gcGFyYWxsZWwuIFRoZSBmZXRjaCBpcyBxdWl0ZSBleHBlbnNpdmUsIHNvIHdlIGhhdmUgcGxlbnR5IG9mIHRpbWUgdG9cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSByZXF1ZXN0SWQgbG9jYWxseS5cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3JlcXVlc3RBbmRSZXRyeSgoKSA9PiB0aGlzLl9mZXRjaCgnJyArIG5ldyBVUkwoYC9hcGkvdjIvY2FuaXN0ZXIvJHtlY2lkLnRvVGV4dCgpfS9jYWxsYCwgdGhpcy5faG9zdCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9jYWxsT3B0aW9ucyksIHRyYW5zZm9ybWVkUmVxdWVzdC5yZXF1ZXN0KSwgeyBib2R5IH0pKSk7XG4gICAgICAgIGNvbnN0IFtyZXNwb25zZSwgcmVxdWVzdElkXSA9IGF3YWl0IFByb21pc2UuYWxsKFtyZXF1ZXN0LCByZXF1ZXN0SWRPZihzdWJtaXQpXSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHJlc3BvbnNlQnVmZmVyLmJ5dGVMZW5ndGggPiAwID8gY2Jvci5kZWNvZGUocmVzcG9uc2VCdWZmZXIpIDogbnVsbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIG9rOiByZXNwb25zZS5vayxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlc3BvbnNlQm9keSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwSGVhZGVyc1RyYW5zZm9ybShyZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIF9yZXF1ZXN0QW5kUmV0cnkocmVxdWVzdCwgdHJpZXMgPSAwKSB7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JldHJ5VGltZXMgPiB0cmllcykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2F1Z2h0IGV4Y2VwdGlvbiB3aGlsZSBhdHRlbXB0aW5nIHRvIG1ha2UgcmVxdWVzdDpcXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYCAgJHtlcnJvcn1cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYCAgUmV0cnlpbmcgcmVxdWVzdC5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVxdWVzdEFuZFJldHJ5KHJlcXVlc3QsIHRyaWVzICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS5jbG9uZSgpLnRleHQoKTtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFNlcnZlciByZXR1cm5lZCBhbiBlcnJvcjpcXG5gICtcbiAgICAgICAgICAgIGAgIENvZGU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAoJHtyZXNwb25zZS5zdGF0dXNUZXh0fSlcXG5gICtcbiAgICAgICAgICAgIGAgIEJvZHk6ICR7cmVzcG9uc2VUZXh0fVxcbmA7XG4gICAgICAgIGlmICh0aGlzLl9yZXRyeVRpbWVzID4gdHJpZXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvck1lc3NhZ2UgKyBgICBSZXRyeWluZyByZXF1ZXN0LmApO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlcXVlc3RBbmRSZXRyeShyZXF1ZXN0LCB0cmllcyArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBZ2VudEhUVFBSZXNwb25zZUVycm9yKGVycm9yTWVzc2FnZSwge1xuICAgICAgICAgICAgb2s6IHJlc3BvbnNlLm9rLFxuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVyczogaHR0cEhlYWRlcnNUcmFuc2Zvcm0ocmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBxdWVyeShjYW5pc3RlcklkLCBmaWVsZHMsIGlkZW50aXR5KSB7XG4gICAgICAgIGNvbnN0IG1ha2VRdWVyeSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gYXdhaXQgKGlkZW50aXR5ICE9PSB1bmRlZmluZWQgPyBhd2FpdCBpZGVudGl0eSA6IGF3YWl0IHRoaXMuX2lkZW50aXR5KTtcbiAgICAgICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWRlbnRpdHlJbnZhbGlkRXJyb3IoXCJUaGlzIGlkZW50aXR5IGhhcyBleHBpcmVkIGR1ZSB0aGlzIGFwcGxpY2F0aW9uJ3Mgc2VjdXJpdHkgcG9saWN5LiBQbGVhc2UgcmVmcmVzaCB5b3VyIGF1dGhlbnRpY2F0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbmlzdGVyID0gUHJpbmNpcGFsLmZyb20oY2FuaXN0ZXJJZCk7XG4gICAgICAgICAgICBjb25zdCBzZW5kZXIgPSAoaWQgPT09IG51bGwgfHwgaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkLmdldFByaW5jaXBhbCgpKSB8fCBQcmluY2lwYWwuYW5vbnltb3VzKCk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RfdHlwZTogXCJxdWVyeVwiIC8qIFJlYWRSZXF1ZXN0VHlwZS5RdWVyeSAqLyxcbiAgICAgICAgICAgICAgICBjYW5pc3Rlcl9pZDogY2FuaXN0ZXIsXG4gICAgICAgICAgICAgICAgbWV0aG9kX25hbWU6IGZpZWxkcy5tZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgIGFyZzogZmllbGRzLmFyZyxcbiAgICAgICAgICAgICAgICBzZW5kZXIsXG4gICAgICAgICAgICAgICAgaW5ncmVzc19leHBpcnk6IG5ldyBFeHBpcnkoREVGQVVMVF9JTkdSRVNTX0VYUElSWV9ERUxUQV9JTl9NU0VDUyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gYXdhaXQgcmVxdWVzdElkT2YocmVxdWVzdCk7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBhbnkuIFRoaXMgY2FuIGJlIGEgU2lnbmVkIG9yIFVuU2lnbmVkIHJlcXVlc3QuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkUmVxdWVzdCA9IGF3YWl0IHRoaXMuX3RyYW5zZm9ybSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vY2JvcicgfSwgKHRoaXMuX2NyZWRlbnRpYWxzID8geyBBdXRob3JpemF0aW9uOiAnQmFzaWMgJyArIGJ0b2EodGhpcy5fY3JlZGVudGlhbHMpIH0gOiB7fSkpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kcG9pbnQ6IFwicmVhZFwiIC8qIEVuZHBvaW50LlF1ZXJ5ICovLFxuICAgICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFwcGx5IHRyYW5zZm9ybSBmb3IgaWRlbnRpdHkuXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZFJlcXVlc3QgPSBhd2FpdCAoaWQgPT09IG51bGwgfHwgaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkLnRyYW5zZm9ybVJlcXVlc3QodHJhbnNmb3JtZWRSZXF1ZXN0KSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2Jvci5lbmNvZGUodHJhbnNmb3JtZWRSZXF1ZXN0LmJvZHkpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0QW5kUmV0cnkoKCkgPT4gdGhpcy5fZmV0Y2goJycgKyBuZXcgVVJMKGAvYXBpL3YyL2NhbmlzdGVyLyR7Y2FuaXN0ZXIudG9UZXh0KCl9L3F1ZXJ5YCwgdGhpcy5faG9zdCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9mZXRjaE9wdGlvbnMpLCB0cmFuc2Zvcm1lZFJlcXVlc3QucmVxdWVzdCksIHsgYm9keSB9KSkpO1xuICAgICAgICAgICAgY29uc3QgcXVlcnlSZXNwb25zZSA9IGNib3IuZGVjb2RlKGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcXVlcnlSZXNwb25zZSksIHsgaHR0cERldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgb2s6IHJlc3BvbnNlLm9rLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cEhlYWRlcnNUcmFuc2Zvcm0ocmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgICAgICAgICAgfSwgcmVxdWVzdElkIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZXRTdWJuZXRTdGF0dXMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVNpZ25hdHVyZXMsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdWJuZXRTdGF0dXMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfc3VibmV0S2V5cywgXCJmXCIpLmdldChjYW5pc3RlcklkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHN1Ym5ldFN0YXR1cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJuZXRTdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZldGNoU3VibmV0S2V5cyhjYW5pc3RlcklkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9zdWJuZXRLZXlzLCBcImZcIikuZ2V0KGNhbmlzdGVySWQudG9TdHJpbmcoKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE1ha2UgcXVlcnkgYW5kIGZldGNoIHN1Ym5ldCBrZXlzIGluIHBhcmFsbGVsXG4gICAgICAgIGNvbnN0IFtxdWVyeSwgc3VibmV0U3RhdHVzXSA9IGF3YWl0IFByb21pc2UuYWxsKFttYWtlUXVlcnkoKSwgZ2V0U3VibmV0U3RhdHVzKCldKTtcbiAgICAgICAgLy8gU2tpcCB2ZXJpZmljYXRpb24gaWYgdGhlIHVzZXIgaGFzIGRpc2FibGVkIGl0XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3ZlcmlmeVF1ZXJ5U2lnbmF0dXJlcywgXCJmXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlSZXNwb25zZSwgXCJmXCIpLmNhbGwodGhpcywgcXVlcnksIHN1Ym5ldFN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgdGhlIG5vZGUgc2lnbmF0dXJlcyBoYXZlIGNoYW5nZWQsIHJlZnJlc2ggdGhlIHN1Ym5ldCBrZXlzIGFuZCB0cnkgYWdhaW5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUXVlcnkgcmVzcG9uc2UgdmVyaWZpY2F0aW9uIGZhaWxlZC4gUmV0cnlpbmcgd2l0aCBmcmVzaCBzdWJuZXQga2V5cy4nKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9zdWJuZXRLZXlzLCBcImZcIikuZGVsZXRlKGNhbmlzdGVySWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZldGNoU3VibmV0S2V5cyhjYW5pc3RlcklkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFN1Ym5ldFN0YXR1cyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9zdWJuZXRLZXlzLCBcImZcIikuZ2V0KGNhbmlzdGVySWQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZWRTdWJuZXRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2VydGlmaWNhdGVWZXJpZmljYXRpb25FcnJvcignSW52YWxpZCBzaWduYXR1cmUgZnJvbSByZXBsaWNhIHNpZ25lZCBxdWVyeTogbm8gbWF0Y2hpbmcgbm9kZSBrZXkgZm91bmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3ZlcmlmeVF1ZXJ5UmVzcG9uc2UsIFwiZlwiKS5jYWxsKHRoaXMsIHF1ZXJ5LCB1cGRhdGVkU3VibmV0U3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVSZWFkU3RhdGVSZXF1ZXN0KGZpZWxkcywgaWRlbnRpdHkpIHtcbiAgICAgICAgY29uc3QgaWQgPSBhd2FpdCAoaWRlbnRpdHkgIT09IHVuZGVmaW5lZCA/IGF3YWl0IGlkZW50aXR5IDogYXdhaXQgdGhpcy5faWRlbnRpdHkpO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSWRlbnRpdHlJbnZhbGlkRXJyb3IoXCJUaGlzIGlkZW50aXR5IGhhcyBleHBpcmVkIGR1ZSB0aGlzIGFwcGxpY2F0aW9uJ3Mgc2VjdXJpdHkgcG9saWN5LiBQbGVhc2UgcmVmcmVzaCB5b3VyIGF1dGhlbnRpY2F0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kZXIgPSAoaWQgPT09IG51bGwgfHwgaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkLmdldFByaW5jaXBhbCgpKSB8fCBQcmluY2lwYWwuYW5vbnltb3VzKCk7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGFueS4gVGhpcyBjYW4gYmUgYSBTaWduZWQgb3IgVW5TaWduZWQgcmVxdWVzdC5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRSZXF1ZXN0ID0gYXdhaXQgdGhpcy5fdHJhbnNmb3JtKHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9jYm9yJyB9LCAodGhpcy5fY3JlZGVudGlhbHMgPyB7IEF1dGhvcml6YXRpb246ICdCYXNpYyAnICsgYnRvYSh0aGlzLl9jcmVkZW50aWFscykgfSA6IHt9KSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kcG9pbnQ6IFwicmVhZF9zdGF0ZVwiIC8qIEVuZHBvaW50LlJlYWRTdGF0ZSAqLyxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X3R5cGU6IFwicmVhZF9zdGF0ZVwiIC8qIFJlYWRSZXF1ZXN0VHlwZS5SZWFkU3RhdGUgKi8sXG4gICAgICAgICAgICAgICAgcGF0aHM6IGZpZWxkcy5wYXRocyxcbiAgICAgICAgICAgICAgICBzZW5kZXIsXG4gICAgICAgICAgICAgICAgaW5ncmVzc19leHBpcnk6IG5ldyBFeHBpcnkoREVGQVVMVF9JTkdSRVNTX0VYUElSWV9ERUxUQV9JTl9NU0VDUyksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXBwbHkgdHJhbnNmb3JtIGZvciBpZGVudGl0eS5cbiAgICAgICAgcmV0dXJuIGlkID09PSBudWxsIHx8IGlkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZC50cmFuc2Zvcm1SZXF1ZXN0KHRyYW5zZm9ybWVkUmVxdWVzdCk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRTdGF0ZShjYW5pc3RlcklkLCBmaWVsZHMsIGlkZW50aXR5LCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICByZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGNhbmlzdGVyID0gdHlwZW9mIGNhbmlzdGVySWQgPT09ICdzdHJpbmcnID8gUHJpbmNpcGFsLmZyb21UZXh0KGNhbmlzdGVySWQpIDogY2FuaXN0ZXJJZDtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRSZXF1ZXN0ID0gcmVxdWVzdCAhPT0gbnVsbCAmJiByZXF1ZXN0ICE9PSB2b2lkIDAgPyByZXF1ZXN0IDogKGF3YWl0IHRoaXMuY3JlYXRlUmVhZFN0YXRlUmVxdWVzdChmaWVsZHMsIGlkZW50aXR5KSk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBjYm9yLmVuY29kZSh0cmFuc2Zvcm1lZFJlcXVlc3QuYm9keSk7XG4gICAgICAgIC8vIFRPRE8gLSBodHRwczovL2RmaW5pdHkuYXRsYXNzaWFuLm5ldC9icm93c2UvU0RLLTEwOTJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0QW5kUmV0cnkoKCkgPT4gdGhpcy5fZmV0Y2goJycgKyBuZXcgVVJMKGAvYXBpL3YyL2NhbmlzdGVyLyR7Y2FuaXN0ZXJ9L3JlYWRfc3RhdGVgLCB0aGlzLl9ob3N0KSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2ZldGNoT3B0aW9ucyksIHRyYW5zZm9ybWVkUmVxdWVzdC5yZXF1ZXN0KSwgeyBib2R5IH0pKSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJldHVybmVkIGFuIGVycm9yOlxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIENvZGU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAoJHtyZXNwb25zZS5zdGF0dXNUZXh0fSlcXG5gICtcbiAgICAgICAgICAgICAgICBgICBCb2R5OiAke2F3YWl0IHJlc3BvbnNlLnRleHQoKX1cXG5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2Jvci5kZWNvZGUoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyBhZ2VudCB0byBzeW5jIGl0cyB0aW1lIHdpdGggdGhlIG5ldHdvcmsuIENhbiBiZSBjYWxsZWQgZHVyaW5nIGludGlhbGl6YXRpb24gb3IgbWlkLWxpZmVjeWNsZSBpZiB0aGUgZGV2aWNlJ3MgY2xvY2sgaGFzIGRyaWZ0ZWQgYXdheSBmcm9tIHRoZSBuZXR3b3JrIHRpbWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHNldCB0aGUgRXhwaXJ5IGZvciBhIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge1ByaW5jaXBhbH0gY2FuaXN0ZXJJZCAtIFBhc3MgYSBjYW5pc3RlciBJRCBpZiB5b3UgbmVlZCB0byBzeW5jIHRoZSB0aW1lIHdpdGggYSBwYXJ0aWN1bGFyIHJlcGxpY2EuIFVzZXMgdGhlIG1hbmFnZW1lbnQgY2FuaXN0ZXIgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGFzeW5jIHN5bmNUaW1lKGNhbmlzdGVySWQpIHtcbiAgICAgICAgY29uc3QgQ2FuaXN0ZXJTdGF0dXMgPSBhd2FpdCBpbXBvcnQoJy4uLy4uL2NhbmlzdGVyU3RhdHVzJyk7XG4gICAgICAgIGNvbnN0IGNhbGxUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghY2FuaXN0ZXJJZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTeW5jaW5nIHRpbWUgd2l0aCB0aGUgSUMuIE5vIGNhbmlzdGVySWQgcHJvdmlkZWQsIHNvIGZhbGxpbmcgYmFjayB0byByeWpsMy10eWFhYS1hYWFhYS1hYWFiYS1jYWknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IENhbmlzdGVyU3RhdHVzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB3aXRoIGNhbmlzdGVySWQgb2YgdGhlIElDUCBMZWRnZXJcbiAgICAgICAgICAgICAgICBjYW5pc3RlcklkOiBjYW5pc3RlcklkICE9PSBudWxsICYmIGNhbmlzdGVySWQgIT09IHZvaWQgMCA/IGNhbmlzdGVySWQgOiBQcmluY2lwYWwuZnJvbSgncnlqbDMtdHlhYWEtYWFhYWEtYWFhYmEtY2FpJyksXG4gICAgICAgICAgICAgICAgYWdlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcGF0aHM6IFsndGltZSddLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXBsaWNhVGltZSA9IHN0YXR1cy5nZXQoJ3RpbWUnKTtcbiAgICAgICAgICAgIGlmIChyZXBsaWNhVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVEaWZmTXNlY3MgPSBOdW1iZXIocmVwbGljYVRpbWUpIC0gTnVtYmVyKGNhbGxUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhdWdodCBleGNlcHRpb24gd2hpbGUgYXR0ZW1wdGluZyB0byBzeW5jIHRpbWU6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuX2NyZWRlbnRpYWxzXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiAnQmFzaWMgJyArIGJ0b2EodGhpcy5fY3JlZGVudGlhbHMpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0QW5kUmV0cnkoKCkgPT4gdGhpcy5fZmV0Y2goJycgKyBuZXcgVVJMKGAvYXBpL3YyL3N0YXR1c2AsIHRoaXMuX2hvc3QpLCBPYmplY3QuYXNzaWduKHsgaGVhZGVycyB9LCB0aGlzLl9mZXRjaE9wdGlvbnMpKSk7XG4gICAgICAgIHJldHVybiBjYm9yLmRlY29kZShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hSb290S2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RLZXlGZXRjaGVkKSB7XG4gICAgICAgICAgICAvLyBIZXgtZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSByZXBsaWNhIHJvb3Qga2V5XG4gICAgICAgICAgICB0aGlzLnJvb3RLZXkgPSAoYXdhaXQgdGhpcy5zdGF0dXMoKSkucm9vdF9rZXk7XG4gICAgICAgICAgICB0aGlzLl9yb290S2V5RmV0Y2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdEtleTtcbiAgICB9XG4gICAgaW52YWxpZGF0ZUlkZW50aXR5KCkge1xuICAgICAgICB0aGlzLl9pZGVudGl0eSA9IG51bGw7XG4gICAgfVxuICAgIHJlcGxhY2VJZGVudGl0eShpZGVudGl0eSkge1xuICAgICAgICB0aGlzLl9pZGVudGl0eSA9IFByb21pc2UucmVzb2x2ZShpZGVudGl0eSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoU3VibmV0S2V5cyhjYW5pc3RlcklkKSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZUNhbmlzdGVySWQgPSBQcmluY2lwYWwuZnJvbShjYW5pc3RlcklkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0KHtcbiAgICAgICAgICAgIGNhbmlzdGVySWQ6IGVmZmVjdGl2ZUNhbmlzdGVySWQsXG4gICAgICAgICAgICBwYXRoczogWydzdWJuZXQnXSxcbiAgICAgICAgICAgIGFnZW50OiB0aGlzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3VibmV0UmVzcG9uc2UgPSByZXNwb25zZS5nZXQoJ3N1Ym5ldCcpO1xuICAgICAgICBpZiAoc3VibmV0UmVzcG9uc2UgJiYgdHlwZW9mIHN1Ym5ldFJlc3BvbnNlID09PSAnb2JqZWN0JyAmJiAnbm9kZUtleXMnIGluIHN1Ym5ldFJlc3BvbnNlKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9IdHRwQWdlbnRfc3VibmV0S2V5cywgXCJmXCIpLnNldChlZmZlY3RpdmVDYW5pc3RlcklkLnRvVGV4dCgpLCBzdWJuZXRSZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gc3VibmV0UmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHN1Ym5ldCBzdGF0dXMgaXMgbm90IHJldHVybmVkLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF90cmFuc2Zvcm0ocmVxdWVzdCkge1xuICAgICAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZShyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHJlcXVlc3QuZW5kcG9pbnQgPT09IFwiY2FsbFwiIC8qIEVuZHBvaW50LkNhbGwgKi8pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm4gb2YgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSHR0cEFnZW50X3VwZGF0ZVBpcGVsaW5lLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICBwID0gcC50aGVuKHIgPT4gZm4ocikudGhlbihyMiA9PiByMiB8fCByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0h0dHBBZ2VudF9xdWVyeVBpcGVsaW5lLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICBwID0gcC50aGVuKHIgPT4gZm4ocikudGhlbihyMiA9PiByMiB8fCByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxufVxuX0h0dHBBZ2VudF9xdWVyeVBpcGVsaW5lID0gbmV3IFdlYWtNYXAoKSwgX0h0dHBBZ2VudF91cGRhdGVQaXBlbGluZSA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfc3VibmV0S2V5cyA9IG5ldyBXZWFrTWFwKCksIF9IdHRwQWdlbnRfdmVyaWZ5UXVlcnlTaWduYXR1cmVzID0gbmV3IFdlYWtNYXAoKSwgX0h0dHBBZ2VudF92ZXJpZnlRdWVyeVJlc3BvbnNlID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/agent/http/index.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js":
/*!*****************************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Expiry: function() { return /* binding */ Expiry; },\n/* harmony export */   httpHeadersTransform: function() { return /* binding */ httpHeadersTransform; },\n/* harmony export */   makeExpiryTransform: function() { return /* binding */ makeExpiryTransform; },\n/* harmony export */   makeNonceTransform: function() { return /* binding */ makeNonceTransform; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ \"../../../node_modules/@dfinity/candid/lib/esm/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! simple-cbor */ \"../../../node_modules/simple-cbor/src/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(simple_cbor__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n\n\n\nconst NANOSECONDS_PER_MILLISECONDS = BigInt(1000000);\nconst REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1000;\nclass Expiry {\n    constructor(deltaInMSec) {\n        // Use bigint because it can overflow the maximum number allowed in a double float.\n        const raw_value = BigInt(Math.floor(Date.now() + deltaInMSec - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) *\n            NANOSECONDS_PER_MILLISECONDS;\n        // round down to the nearest second\n        const ingress_as_seconds = raw_value / BigInt(1000000000);\n        // round down to nearest minute\n        const ingress_as_minutes = ingress_as_seconds / BigInt(60);\n        const rounded_down_nanos = ingress_as_minutes * BigInt(60) * BigInt(1000000000);\n        this._value = rounded_down_nanos;\n    }\n    toCBOR() {\n        // TODO: change this to take the minimum amount of space (it always takes 8 bytes now).\n        return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.u64(this._value.toString(16), 16);\n    }\n    toHash() {\n        return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(this._value);\n    }\n}\n/**\n * Create a Nonce transform, which takes a function that returns a Buffer, and adds it\n * as the nonce to every call requests.\n * @param nonceFn A function that returns a buffer. By default uses a semi-random method.\n */\nfunction makeNonceTransform(nonceFn = _types__WEBPACK_IMPORTED_MODULE_2__.makeNonce) {\n    return async (request) => {\n        // Nonce needs to be inserted into the header for all requests, to enable logs to be correlated with requests.\n        const headers = request.request.headers;\n        // TODO: uncomment this when the http proxy supports it.\n        // headers.set('X-IC-Request-ID', toHex(new Uint8Array(nonce)));\n        request.request.headers = headers;\n        // Nonce only needs to be inserted into the body for async calls, to prevent replay attacks.\n        if (request.endpoint === \"call\" /* Endpoint.Call */) {\n            request.body.nonce = nonceFn();\n        }\n    };\n}\n/**\n * Create a transform that adds a delay (by default 5 minutes) to the expiry.\n *\n * @param delayInMilliseconds The delay to add to the call time, in milliseconds.\n */\nfunction makeExpiryTransform(delayInMilliseconds) {\n    return async (request) => {\n        request.body.ingress_expiry = new Expiry(delayInMilliseconds);\n    };\n}\n/**\n * Maps the default fetch headers field to the serializable HttpHeaderField.\n *\n * @param headers Fetch definition of the headers type\n * @returns array of header fields\n */\nfunction httpHeadersTransform(headers) {\n    const headerFields = [];\n    headers.forEach((value, key) => {\n        headerFields.push([key, value]);\n    });\n    return headerFields;\n}\n//# sourceMappingURL=transforms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC90cmFuc2Zvcm1zLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ1I7QUFDQztBQUNyQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQVU7QUFDekI7QUFDQTtBQUNBLGVBQWUsMERBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0MsNkNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2FnZW50L2h0dHAvdHJhbnNmb3Jtcy5qcz81MWEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxlYkVuY29kZSB9IGZyb20gJ0BkZmluaXR5L2NhbmRpZCc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJ3NpbXBsZS1jYm9yJztcbmltcG9ydCB7IG1ha2VOb25jZSwgfSBmcm9tICcuL3R5cGVzJztcbmNvbnN0IE5BTk9TRUNPTkRTX1BFUl9NSUxMSVNFQ09ORFMgPSBCaWdJbnQoMTAwMDAwMCk7XG5jb25zdCBSRVBMSUNBX1BFUk1JVFRFRF9EUklGVF9NSUxMSVNFQ09ORFMgPSA2MCAqIDEwMDA7XG5leHBvcnQgY2xhc3MgRXhwaXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihkZWx0YUluTVNlYykge1xuICAgICAgICAvLyBVc2UgYmlnaW50IGJlY2F1c2UgaXQgY2FuIG92ZXJmbG93IHRoZSBtYXhpbXVtIG51bWJlciBhbGxvd2VkIGluIGEgZG91YmxlIGZsb2F0LlxuICAgICAgICBjb25zdCByYXdfdmFsdWUgPSBCaWdJbnQoTWF0aC5mbG9vcihEYXRlLm5vdygpICsgZGVsdGFJbk1TZWMgLSBSRVBMSUNBX1BFUk1JVFRFRF9EUklGVF9NSUxMSVNFQ09ORFMpKSAqXG4gICAgICAgICAgICBOQU5PU0VDT05EU19QRVJfTUlMTElTRUNPTkRTO1xuICAgICAgICAvLyByb3VuZCBkb3duIHRvIHRoZSBuZWFyZXN0IHNlY29uZFxuICAgICAgICBjb25zdCBpbmdyZXNzX2FzX3NlY29uZHMgPSByYXdfdmFsdWUgLyBCaWdJbnQoMTAwMDAwMDAwMCk7XG4gICAgICAgIC8vIHJvdW5kIGRvd24gdG8gbmVhcmVzdCBtaW51dGVcbiAgICAgICAgY29uc3QgaW5ncmVzc19hc19taW51dGVzID0gaW5ncmVzc19hc19zZWNvbmRzIC8gQmlnSW50KDYwKTtcbiAgICAgICAgY29uc3Qgcm91bmRlZF9kb3duX25hbm9zID0gaW5ncmVzc19hc19taW51dGVzICogQmlnSW50KDYwKSAqIEJpZ0ludCgxMDAwMDAwMDAwKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSByb3VuZGVkX2Rvd25fbmFub3M7XG4gICAgfVxuICAgIHRvQ0JPUigpIHtcbiAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRoaXMgdG8gdGFrZSB0aGUgbWluaW11bSBhbW91bnQgb2Ygc3BhY2UgKGl0IGFsd2F5cyB0YWtlcyA4IGJ5dGVzIG5vdykuXG4gICAgICAgIHJldHVybiBjYm9yLnZhbHVlLnU2NCh0aGlzLl92YWx1ZS50b1N0cmluZygxNiksIDE2KTtcbiAgICB9XG4gICAgdG9IYXNoKCkge1xuICAgICAgICByZXR1cm4gbGViRW5jb2RlKHRoaXMuX3ZhbHVlKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIE5vbmNlIHRyYW5zZm9ybSwgd2hpY2ggdGFrZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBCdWZmZXIsIGFuZCBhZGRzIGl0XG4gKiBhcyB0aGUgbm9uY2UgdG8gZXZlcnkgY2FsbCByZXF1ZXN0cy5cbiAqIEBwYXJhbSBub25jZUZuIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYnVmZmVyLiBCeSBkZWZhdWx0IHVzZXMgYSBzZW1pLXJhbmRvbSBtZXRob2QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTm9uY2VUcmFuc2Zvcm0obm9uY2VGbiA9IG1ha2VOb25jZSkge1xuICAgIHJldHVybiBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgICAvLyBOb25jZSBuZWVkcyB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBoZWFkZXIgZm9yIGFsbCByZXF1ZXN0cywgdG8gZW5hYmxlIGxvZ3MgdG8gYmUgY29ycmVsYXRlZCB3aXRoIHJlcXVlc3RzLlxuICAgICAgICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdC5yZXF1ZXN0LmhlYWRlcnM7XG4gICAgICAgIC8vIFRPRE86IHVuY29tbWVudCB0aGlzIHdoZW4gdGhlIGh0dHAgcHJveHkgc3VwcG9ydHMgaXQuXG4gICAgICAgIC8vIGhlYWRlcnMuc2V0KCdYLUlDLVJlcXVlc3QtSUQnLCB0b0hleChuZXcgVWludDhBcnJheShub25jZSkpKTtcbiAgICAgICAgcmVxdWVzdC5yZXF1ZXN0LmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAvLyBOb25jZSBvbmx5IG5lZWRzIHRvIGJlIGluc2VydGVkIGludG8gdGhlIGJvZHkgZm9yIGFzeW5jIGNhbGxzLCB0byBwcmV2ZW50IHJlcGxheSBhdHRhY2tzLlxuICAgICAgICBpZiAocmVxdWVzdC5lbmRwb2ludCA9PT0gXCJjYWxsXCIgLyogRW5kcG9pbnQuQ2FsbCAqLykge1xuICAgICAgICAgICAgcmVxdWVzdC5ib2R5Lm5vbmNlID0gbm9uY2VGbigpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgdHJhbnNmb3JtIHRoYXQgYWRkcyBhIGRlbGF5IChieSBkZWZhdWx0IDUgbWludXRlcykgdG8gdGhlIGV4cGlyeS5cbiAqXG4gKiBAcGFyYW0gZGVsYXlJbk1pbGxpc2Vjb25kcyBUaGUgZGVsYXkgdG8gYWRkIHRvIHRoZSBjYWxsIHRpbWUsIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFeHBpcnlUcmFuc2Zvcm0oZGVsYXlJbk1pbGxpc2Vjb25kcykge1xuICAgIHJldHVybiBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgICByZXF1ZXN0LmJvZHkuaW5ncmVzc19leHBpcnkgPSBuZXcgRXhwaXJ5KGRlbGF5SW5NaWxsaXNlY29uZHMpO1xuICAgIH07XG59XG4vKipcbiAqIE1hcHMgdGhlIGRlZmF1bHQgZmV0Y2ggaGVhZGVycyBmaWVsZCB0byB0aGUgc2VyaWFsaXphYmxlIEh0dHBIZWFkZXJGaWVsZC5cbiAqXG4gKiBAcGFyYW0gaGVhZGVycyBGZXRjaCBkZWZpbml0aW9uIG9mIHRoZSBoZWFkZXJzIHR5cGVcbiAqIEByZXR1cm5zIGFycmF5IG9mIGhlYWRlciBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh0dHBIZWFkZXJzVHJhbnNmb3JtKGhlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJGaWVsZHMgPSBbXTtcbiAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaGVhZGVyRmllbGRzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyRmllbGRzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3Jtcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/agent/http/types.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/agent/http/types.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SubmitRequestType: function() { return /* binding */ SubmitRequestType; },\n/* harmony export */   makeNonce: function() { return /* binding */ makeNonce; }\n/* harmony export */ });\n/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/random */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/random.js\");\n\n// The types of values allowed in the `request_type` field for submit requests.\nvar SubmitRequestType;\n(function (SubmitRequestType) {\n    SubmitRequestType[\"Call\"] = \"call\";\n})(SubmitRequestType || (SubmitRequestType = {}));\n/**\n * Create a random Nonce, based on random values\n */\nfunction makeNonce() {\n    // Encode 128 bits.\n    const buffer = new ArrayBuffer(16);\n    const view = new DataView(buffer);\n    const rand1 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand2 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand3 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    const rand4 = (0,_utils_random__WEBPACK_IMPORTED_MODULE_0__.randomNumber)();\n    view.setUint32(0, rand1);\n    view.setUint32(4, rand2);\n    view.setUint32(8, rand3);\n    view.setUint32(12, rand4);\n    return buffer;\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0Q7QUFDbEQ7QUFDTztBQUNQO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyREFBWTtBQUM5QixrQkFBa0IsMkRBQVk7QUFDOUIsa0JBQWtCLDJEQUFZO0FBQzlCLGtCQUFrQiwyREFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaHR0cC90eXBlcy5qcz9lNTAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJhbmRvbU51bWJlciB9IGZyb20gJy4uLy4uL3V0aWxzL3JhbmRvbSc7XG4vLyBUaGUgdHlwZXMgb2YgdmFsdWVzIGFsbG93ZWQgaW4gdGhlIGByZXF1ZXN0X3R5cGVgIGZpZWxkIGZvciBzdWJtaXQgcmVxdWVzdHMuXG5leHBvcnQgdmFyIFN1Ym1pdFJlcXVlc3RUeXBlO1xuKGZ1bmN0aW9uIChTdWJtaXRSZXF1ZXN0VHlwZSkge1xuICAgIFN1Ym1pdFJlcXVlc3RUeXBlW1wiQ2FsbFwiXSA9IFwiY2FsbFwiO1xufSkoU3VibWl0UmVxdWVzdFR5cGUgfHwgKFN1Ym1pdFJlcXVlc3RUeXBlID0ge30pKTtcbi8qKlxuICogQ3JlYXRlIGEgcmFuZG9tIE5vbmNlLCBiYXNlZCBvbiByYW5kb20gdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTm9uY2UoKSB7XG4gICAgLy8gRW5jb2RlIDEyOCBiaXRzLlxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigxNik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGNvbnN0IHJhbmQxID0gcmFuZG9tTnVtYmVyKCk7XG4gICAgY29uc3QgcmFuZDIgPSByYW5kb21OdW1iZXIoKTtcbiAgICBjb25zdCByYW5kMyA9IHJhbmRvbU51bWJlcigpO1xuICAgIGNvbnN0IHJhbmQ0ID0gcmFuZG9tTnVtYmVyKCk7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgcmFuZDEpO1xuICAgIHZpZXcuc2V0VWludDMyKDQsIHJhbmQyKTtcbiAgICB2aWV3LnNldFVpbnQzMig4LCByYW5kMyk7XG4gICAgdmlldy5zZXRVaW50MzIoMTIsIHJhbmQ0KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/agent/http/types.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/agent/index.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/agent/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Expiry: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.Expiry; },\n/* harmony export */   HttpAgent: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.HttpAgent; },\n/* harmony export */   IdentityInvalidError: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.IdentityInvalidError; },\n/* harmony export */   ProxyAgent: function() { return /* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_2__.ProxyAgent; },\n/* harmony export */   ProxyMessageKind: function() { return /* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_2__.ProxyMessageKind; },\n/* harmony export */   ProxyStubAgent: function() { return /* reexport safe */ _proxy__WEBPACK_IMPORTED_MODULE_2__.ProxyStubAgent; },\n/* harmony export */   ReplicaRejectCode: function() { return /* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.ReplicaRejectCode; },\n/* harmony export */   RequestStatusResponseStatus: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.RequestStatusResponseStatus; },\n/* harmony export */   getDefaultAgent: function() { return /* binding */ getDefaultAgent; },\n/* harmony export */   httpHeadersTransform: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.httpHeadersTransform; },\n/* harmony export */   makeExpiryTransform: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.makeExpiryTransform; },\n/* harmony export */   makeNonce: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.makeNonce; },\n/* harmony export */   makeNonceTransform: function() { return /* reexport safe */ _http__WEBPACK_IMPORTED_MODULE_1__.makeNonceTransform; }\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/api.js\");\n/* harmony import */ var _http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./http */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/http/index.js\");\n/* harmony import */ var _proxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proxy */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/proxy.js\");\n\n\n\nfunction getDefaultAgent() {\n    const agent = typeof window === 'undefined'\n        ? typeof __webpack_require__.g === 'undefined'\n            ? typeof self === 'undefined'\n                ? undefined\n                : self.ic.agent\n            : __webpack_require__.g.ic.agent\n        : window.ic.agent;\n    if (!agent) {\n        throw new Error('No Agent could be found.');\n    }\n    return agent;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzQjtBQUNDO0FBQ0M7QUFDakI7QUFDUDtBQUNBLGlCQUFpQixxQkFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFCQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9hZ2VudC9pbmRleC5qcz8xOTc2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vYXBpJztcbmV4cG9ydCAqIGZyb20gJy4vaHR0cCc7XG5leHBvcnQgKiBmcm9tICcuL3Byb3h5JztcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0QWdlbnQoKSB7XG4gICAgY29uc3QgYWdlbnQgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHR5cGVvZiBnbG9iYWwgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBzZWxmLmljLmFnZW50XG4gICAgICAgICAgICA6IGdsb2JhbC5pYy5hZ2VudFxuICAgICAgICA6IHdpbmRvdy5pYy5hZ2VudDtcbiAgICBpZiAoIWFnZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gQWdlbnQgY291bGQgYmUgZm91bmQuJyk7XG4gICAgfVxuICAgIHJldHVybiBhZ2VudDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/agent/index.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/agent/proxy.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/agent/proxy.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProxyAgent: function() { return /* binding */ ProxyAgent; },\n/* harmony export */   ProxyMessageKind: function() { return /* binding */ ProxyMessageKind; },\n/* harmony export */   ProxyStubAgent: function() { return /* binding */ ProxyStubAgent; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"../../../node_modules/@dfinity/principal/lib/esm/index.js\");\n\nvar ProxyMessageKind;\n(function (ProxyMessageKind) {\n    ProxyMessageKind[\"Error\"] = \"err\";\n    ProxyMessageKind[\"GetPrincipal\"] = \"gp\";\n    ProxyMessageKind[\"GetPrincipalResponse\"] = \"gpr\";\n    ProxyMessageKind[\"Query\"] = \"q\";\n    ProxyMessageKind[\"QueryResponse\"] = \"qr\";\n    ProxyMessageKind[\"Call\"] = \"c\";\n    ProxyMessageKind[\"CallResponse\"] = \"cr\";\n    ProxyMessageKind[\"ReadState\"] = \"rs\";\n    ProxyMessageKind[\"ReadStateResponse\"] = \"rsr\";\n    ProxyMessageKind[\"Status\"] = \"s\";\n    ProxyMessageKind[\"StatusResponse\"] = \"sr\";\n})(ProxyMessageKind || (ProxyMessageKind = {}));\n// A Stub Agent that forwards calls to another Agent implementation.\nclass ProxyStubAgent {\n    constructor(_frontend, _agent) {\n        this._frontend = _frontend;\n        this._agent = _agent;\n    }\n    onmessage(msg) {\n        switch (msg.type) {\n            case ProxyMessageKind.GetPrincipal:\n                this._agent.getPrincipal().then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.GetPrincipalResponse,\n                        response: response.toText(),\n                    });\n                });\n                break;\n            case ProxyMessageKind.Query:\n                this._agent.query(...msg.args).then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.QueryResponse,\n                        response,\n                    });\n                });\n                break;\n            case ProxyMessageKind.Call:\n                this._agent.call(...msg.args).then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.CallResponse,\n                        response,\n                    });\n                });\n                break;\n            case ProxyMessageKind.ReadState:\n                this._agent.readState(...msg.args).then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.ReadStateResponse,\n                        response,\n                    });\n                });\n                break;\n            case ProxyMessageKind.Status:\n                this._agent.status().then(response => {\n                    this._frontend({\n                        id: msg.id,\n                        type: ProxyMessageKind.StatusResponse,\n                        response,\n                    });\n                });\n                break;\n            default:\n                throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);\n        }\n    }\n}\n// An Agent that forwards calls to a backend. The calls are serialized\nclass ProxyAgent {\n    constructor(_backend) {\n        this._backend = _backend;\n        this._nextId = 0;\n        this._pendingCalls = new Map();\n        this.rootKey = null;\n    }\n    onmessage(msg) {\n        const id = msg.id;\n        const maybePromise = this._pendingCalls.get(id);\n        if (!maybePromise) {\n            throw new Error('A proxy get the same message twice...');\n        }\n        this._pendingCalls.delete(id);\n        const [resolve, reject] = maybePromise;\n        switch (msg.type) {\n            case ProxyMessageKind.Error:\n                return reject(msg.error);\n            case ProxyMessageKind.GetPrincipalResponse:\n            case ProxyMessageKind.CallResponse:\n            case ProxyMessageKind.QueryResponse:\n            case ProxyMessageKind.ReadStateResponse:\n            case ProxyMessageKind.StatusResponse:\n                return resolve(msg.response);\n            default:\n                throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);\n        }\n    }\n    async getPrincipal() {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.GetPrincipal,\n        }).then(principal => {\n            if (typeof principal !== 'string') {\n                throw new Error('Invalid principal received.');\n            }\n            return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(principal);\n        });\n    }\n    readState(canisterId, fields) {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.ReadState,\n            args: [canisterId.toString(), fields],\n        });\n    }\n    call(canisterId, fields) {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.Call,\n            args: [canisterId.toString(), fields],\n        });\n    }\n    status() {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.Status,\n        });\n    }\n    query(canisterId, fields) {\n        return this._sendAndWait({\n            id: this._nextId++,\n            type: ProxyMessageKind.Query,\n            args: [canisterId.toString(), fields],\n        });\n    }\n    async _sendAndWait(msg) {\n        return new Promise((resolve, reject) => {\n            this._pendingCalls.set(msg.id, [resolve, reject]);\n            this._backend(msg);\n        });\n    }\n    async fetchRootKey() {\n        // Hex-encoded version of the replica root key\n        const rootKey = (await this.status()).root_key;\n        this.rootKey = rootKey;\n        return rootKey;\n    }\n}\n//# sourceMappingURL=proxy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYWdlbnQvcHJveHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErQztBQUN4QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQzdDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkRBQTZELG9CQUFvQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLG9CQUFvQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFTO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9hZ2VudC9wcm94eS5qcz9iMDExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5leHBvcnQgdmFyIFByb3h5TWVzc2FnZUtpbmQ7XG4oZnVuY3Rpb24gKFByb3h5TWVzc2FnZUtpbmQpIHtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiRXJyb3JcIl0gPSBcImVyclwiO1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJHZXRQcmluY2lwYWxcIl0gPSBcImdwXCI7XG4gICAgUHJveHlNZXNzYWdlS2luZFtcIkdldFByaW5jaXBhbFJlc3BvbnNlXCJdID0gXCJncHJcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiUXVlcnlcIl0gPSBcInFcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiUXVlcnlSZXNwb25zZVwiXSA9IFwicXJcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiQ2FsbFwiXSA9IFwiY1wiO1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJDYWxsUmVzcG9uc2VcIl0gPSBcImNyXCI7XG4gICAgUHJveHlNZXNzYWdlS2luZFtcIlJlYWRTdGF0ZVwiXSA9IFwicnNcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiUmVhZFN0YXRlUmVzcG9uc2VcIl0gPSBcInJzclwiO1xuICAgIFByb3h5TWVzc2FnZUtpbmRbXCJTdGF0dXNcIl0gPSBcInNcIjtcbiAgICBQcm94eU1lc3NhZ2VLaW5kW1wiU3RhdHVzUmVzcG9uc2VcIl0gPSBcInNyXCI7XG59KShQcm94eU1lc3NhZ2VLaW5kIHx8IChQcm94eU1lc3NhZ2VLaW5kID0ge30pKTtcbi8vIEEgU3R1YiBBZ2VudCB0aGF0IGZvcndhcmRzIGNhbGxzIHRvIGFub3RoZXIgQWdlbnQgaW1wbGVtZW50YXRpb24uXG5leHBvcnQgY2xhc3MgUHJveHlTdHViQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKF9mcm9udGVuZCwgX2FnZW50KSB7XG4gICAgICAgIHRoaXMuX2Zyb250ZW5kID0gX2Zyb250ZW5kO1xuICAgICAgICB0aGlzLl9hZ2VudCA9IF9hZ2VudDtcbiAgICB9XG4gICAgb25tZXNzYWdlKG1zZykge1xuICAgICAgICBzd2l0Y2ggKG1zZy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuR2V0UHJpbmNpcGFsOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FnZW50LmdldFByaW5jaXBhbCgpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcm9udGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbXNnLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5HZXRQcmluY2lwYWxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZS50b1RleHQoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuUXVlcnk6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWdlbnQucXVlcnkoLi4ubXNnLmFyZ3MpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcm9udGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbXNnLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5RdWVyeVJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcm94eU1lc3NhZ2VLaW5kLkNhbGw6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWdlbnQuY2FsbCguLi5tc2cuYXJncykudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zyb250ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtc2cuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBQcm94eU1lc3NhZ2VLaW5kLkNhbGxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUHJveHlNZXNzYWdlS2luZC5SZWFkU3RhdGU6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWdlbnQucmVhZFN0YXRlKC4uLm1zZy5hcmdzKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZnJvbnRlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1zZy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFByb3h5TWVzc2FnZUtpbmQuUmVhZFN0YXRlUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuU3RhdHVzOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FnZW50LnN0YXR1cygpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mcm9udGVuZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbXNnLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5TdGF0dXNSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgcmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkobXNnKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEFuIEFnZW50IHRoYXQgZm9yd2FyZHMgY2FsbHMgdG8gYSBiYWNrZW5kLiBUaGUgY2FsbHMgYXJlIHNlcmlhbGl6ZWRcbmV4cG9ydCBjbGFzcyBQcm94eUFnZW50IHtcbiAgICBjb25zdHJ1Y3RvcihfYmFja2VuZCkge1xuICAgICAgICB0aGlzLl9iYWNrZW5kID0gX2JhY2tlbmQ7XG4gICAgICAgIHRoaXMuX25leHRJZCA9IDA7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDYWxscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yb290S2V5ID0gbnVsbDtcbiAgICB9XG4gICAgb25tZXNzYWdlKG1zZykge1xuICAgICAgICBjb25zdCBpZCA9IG1zZy5pZDtcbiAgICAgICAgY29uc3QgbWF5YmVQcm9taXNlID0gdGhpcy5fcGVuZGluZ0NhbGxzLmdldChpZCk7XG4gICAgICAgIGlmICghbWF5YmVQcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgcHJveHkgZ2V0IHRoZSBzYW1lIG1lc3NhZ2UgdHdpY2UuLi4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZW5kaW5nQ2FsbHMuZGVsZXRlKGlkKTtcbiAgICAgICAgY29uc3QgW3Jlc29sdmUsIHJlamVjdF0gPSBtYXliZVByb21pc2U7XG4gICAgICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUHJveHlNZXNzYWdlS2luZC5FcnJvcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG1zZy5lcnJvcik7XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuR2V0UHJpbmNpcGFsUmVzcG9uc2U6XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuQ2FsbFJlc3BvbnNlOlxuICAgICAgICAgICAgY2FzZSBQcm94eU1lc3NhZ2VLaW5kLlF1ZXJ5UmVzcG9uc2U6XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuUmVhZFN0YXRlUmVzcG9uc2U6XG4gICAgICAgICAgICBjYXNlIFByb3h5TWVzc2FnZUtpbmQuU3RhdHVzUmVzcG9uc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobXNnLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgYmVpbmcgc2VudCB0byBQcm94eUFnZW50OiAke0pTT04uc3RyaW5naWZ5KG1zZyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0UHJpbmNpcGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEFuZFdhaXQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRJZCsrLFxuICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5HZXRQcmluY2lwYWwsXG4gICAgICAgIH0pLnRoZW4ocHJpbmNpcGFsID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJpbmNpcGFsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcmluY2lwYWwgcmVjZWl2ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmZyb21UZXh0KHByaW5jaXBhbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWFkU3RhdGUoY2FuaXN0ZXJJZCwgZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kQW5kV2FpdCh7XG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dElkKyssXG4gICAgICAgICAgICB0eXBlOiBQcm94eU1lc3NhZ2VLaW5kLlJlYWRTdGF0ZSxcbiAgICAgICAgICAgIGFyZ3M6IFtjYW5pc3RlcklkLnRvU3RyaW5nKCksIGZpZWxkc10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsKGNhbmlzdGVySWQsIGZpZWxkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEFuZFdhaXQoe1xuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRJZCsrLFxuICAgICAgICAgICAgdHlwZTogUHJveHlNZXNzYWdlS2luZC5DYWxsLFxuICAgICAgICAgICAgYXJnczogW2NhbmlzdGVySWQudG9TdHJpbmcoKSwgZmllbGRzXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRBbmRXYWl0KHtcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0SWQrKyxcbiAgICAgICAgICAgIHR5cGU6IFByb3h5TWVzc2FnZUtpbmQuU3RhdHVzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVlcnkoY2FuaXN0ZXJJZCwgZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kQW5kV2FpdCh7XG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dElkKyssXG4gICAgICAgICAgICB0eXBlOiBQcm94eU1lc3NhZ2VLaW5kLlF1ZXJ5LFxuICAgICAgICAgICAgYXJnczogW2NhbmlzdGVySWQudG9TdHJpbmcoKSwgZmllbGRzXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kQW5kV2FpdChtc2cpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdDYWxscy5zZXQobXNnLmlkLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZW5kKG1zZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFJvb3RLZXkoKSB7XG4gICAgICAgIC8vIEhleC1lbmNvZGVkIHZlcnNpb24gb2YgdGhlIHJlcGxpY2Egcm9vdCBrZXlcbiAgICAgICAgY29uc3Qgcm9vdEtleSA9IChhd2FpdCB0aGlzLnN0YXR1cygpKS5yb290X2tleTtcbiAgICAgICAgdGhpcy5yb290S2V5ID0gcm9vdEtleTtcbiAgICAgICAgcmV0dXJuIHJvb3RLZXk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJveHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/agent/proxy.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/auth.js":
/*!************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/auth.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnonymousIdentity: function() { return /* binding */ AnonymousIdentity; },\n/* harmony export */   SignIdentity: function() { return /* binding */ SignIdentity; },\n/* harmony export */   createIdentityDescriptor: function() { return /* binding */ createIdentityDescriptor; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"../../../node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./request_id */ \"../../../node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\nconst domainSeparator = new TextEncoder().encode('\\x0Aic-request');\n/**\n * An Identity that can sign blobs.\n */\nclass SignIdentity {\n    /**\n     * Get the principal represented by this identity. Normally should be a\n     * `Principal.selfAuthenticating()`.\n     */\n    getPrincipal() {\n        if (!this._principal) {\n            this._principal = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));\n        }\n        return this._principal;\n    }\n    /**\n     * Transform a request into a signed version of the request. This is done last\n     * after the transforms on the body of a request. The returned object can be\n     * anything, but must be serializable to CBOR.\n     * @param request - internet computer request to transform\n     */\n    async transformRequest(request) {\n        const { body } = request, fields = __rest(request, [\"body\"]);\n        const requestId = await (0,_request_id__WEBPACK_IMPORTED_MODULE_1__.requestIdOf)(body);\n        return Object.assign(Object.assign({}, fields), { body: {\n                content: body,\n                sender_pubkey: this.getPublicKey().toDer(),\n                sender_sig: await this.sign((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(domainSeparator, requestId)),\n            } });\n    }\n}\nclass AnonymousIdentity {\n    getPrincipal() {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.anonymous();\n    }\n    async transformRequest(request) {\n        return Object.assign(Object.assign({}, request), { body: { content: request.body } });\n    }\n}\n/**\n * Create an IdentityDescriptor from a @dfinity/identity Identity\n * @param identity - identity describe in returned descriptor\n */\nfunction createIdentityDescriptor(identity) {\n    const identityIndicator = 'getPublicKey' in identity\n        ? { type: 'PublicKeyIdentity', publicKey: (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(identity.getPublicKey().toDer()) }\n        : { type: 'AnonymousIdentity' };\n    return identityIndicator;\n}\n//# sourceMappingURL=auth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vYXV0aC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxjQUFjLFNBQUksSUFBSSxTQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQztBQUNKO0FBQ0k7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5REFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdDQUFnQyx3REFBVztBQUMzQyw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0EsNENBQTRDLHFEQUFNO0FBQ2xELGVBQWU7QUFDZjtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUseURBQVM7QUFDeEI7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLFFBQVEseUJBQXlCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLHNDQUFzQyxvREFBSztBQUN2RCxZQUFZO0FBQ1o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9hdXRoLmpzPzM5YmYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmltcG9ydCB7IHJlcXVlc3RJZE9mIH0gZnJvbSAnLi9yZXF1ZXN0X2lkJztcbmltcG9ydCB7IGNvbmNhdCwgdG9IZXggfSBmcm9tICcuL3V0aWxzL2J1ZmZlcic7XG5jb25zdCBkb21haW5TZXBhcmF0b3IgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ1xceDBBaWMtcmVxdWVzdCcpO1xuLyoqXG4gKiBBbiBJZGVudGl0eSB0aGF0IGNhbiBzaWduIGJsb2JzLlxuICovXG5leHBvcnQgY2xhc3MgU2lnbklkZW50aXR5IHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHByaW5jaXBhbCByZXByZXNlbnRlZCBieSB0aGlzIGlkZW50aXR5LiBOb3JtYWxseSBzaG91bGQgYmUgYVxuICAgICAqIGBQcmluY2lwYWwuc2VsZkF1dGhlbnRpY2F0aW5nKClgLlxuICAgICAqL1xuICAgIGdldFByaW5jaXBhbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wcmluY2lwYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaW5jaXBhbCA9IFByaW5jaXBhbC5zZWxmQXV0aGVudGljYXRpbmcobmV3IFVpbnQ4QXJyYXkodGhpcy5nZXRQdWJsaWNLZXkoKS50b0RlcigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW5jaXBhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIGEgcmVxdWVzdCBpbnRvIGEgc2lnbmVkIHZlcnNpb24gb2YgdGhlIHJlcXVlc3QuIFRoaXMgaXMgZG9uZSBsYXN0XG4gICAgICogYWZ0ZXIgdGhlIHRyYW5zZm9ybXMgb24gdGhlIGJvZHkgb2YgYSByZXF1ZXN0LiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNhbiBiZVxuICAgICAqIGFueXRoaW5nLCBidXQgbXVzdCBiZSBzZXJpYWxpemFibGUgdG8gQ0JPUi5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIGludGVybmV0IGNvbXB1dGVyIHJlcXVlc3QgdG8gdHJhbnNmb3JtXG4gICAgICovXG4gICAgYXN5bmMgdHJhbnNmb3JtUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHsgYm9keSB9ID0gcmVxdWVzdCwgZmllbGRzID0gX19yZXN0KHJlcXVlc3QsIFtcImJvZHlcIl0pO1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSBhd2FpdCByZXF1ZXN0SWRPZihib2R5KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGRzKSwgeyBib2R5OiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogYm9keSxcbiAgICAgICAgICAgICAgICBzZW5kZXJfcHVia2V5OiB0aGlzLmdldFB1YmxpY0tleSgpLnRvRGVyKCksXG4gICAgICAgICAgICAgICAgc2VuZGVyX3NpZzogYXdhaXQgdGhpcy5zaWduKGNvbmNhdChkb21haW5TZXBhcmF0b3IsIHJlcXVlc3RJZCkpLFxuICAgICAgICAgICAgfSB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQW5vbnltb3VzSWRlbnRpdHkge1xuICAgIGdldFByaW5jaXBhbCgpIHtcbiAgICAgICAgcmV0dXJuIFByaW5jaXBhbC5hbm9ueW1vdXMoKTtcbiAgICB9XG4gICAgYXN5bmMgdHJhbnNmb3JtUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IGJvZHk6IHsgY29udGVudDogcmVxdWVzdC5ib2R5IH0gfSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW4gSWRlbnRpdHlEZXNjcmlwdG9yIGZyb20gYSBAZGZpbml0eS9pZGVudGl0eSBJZGVudGl0eVxuICogQHBhcmFtIGlkZW50aXR5IC0gaWRlbnRpdHkgZGVzY3JpYmUgaW4gcmV0dXJuZWQgZGVzY3JpcHRvclxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSWRlbnRpdHlEZXNjcmlwdG9yKGlkZW50aXR5KSB7XG4gICAgY29uc3QgaWRlbnRpdHlJbmRpY2F0b3IgPSAnZ2V0UHVibGljS2V5JyBpbiBpZGVudGl0eVxuICAgICAgICA/IHsgdHlwZTogJ1B1YmxpY0tleUlkZW50aXR5JywgcHVibGljS2V5OiB0b0hleChpZGVudGl0eS5nZXRQdWJsaWNLZXkoKS50b0RlcigpKSB9XG4gICAgICAgIDogeyB0eXBlOiAnQW5vbnltb3VzSWRlbnRpdHknIH07XG4gICAgcmV0dXJuIGlkZW50aXR5SW5kaWNhdG9yO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/auth.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodePath: function() { return /* binding */ encodePath; },\n/* harmony export */   fetchNodeKeys: function() { return /* binding */ fetchNodeKeys; },\n/* harmony export */   request: function() { return /* binding */ request; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"../../../node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors */ \"../../../node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../certificate */ \"../../../node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/buffer */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cbor */ \"../../../node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _utils_leb__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/leb */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/leb.js\");\n/** @module CanisterStatus */\n\n\n\n\n\n\n/**\n *\n * @param {CanisterStatusOptions} options {@link CanisterStatusOptions}\n * @param {CanisterStatusOptions['canisterId']} options.canisterId {@link Principal}\n * @param {CanisterStatusOptions['agent']} options.agent {@link HttpAgent} optional authenticated agent to use to make the canister request. Useful for accessing private metadata under icp:private\n * @param {CanisterStatusOptions['paths']} options.paths {@link Path[]}\n * @returns {Status} object populated with data from the requested paths\n * @example\n * const status = await canisterStatus({\n *   paths: ['controllers', 'candid'],\n *   ...options\n * });\n *\n * const controllers = status.get('controllers');\n */\nconst request = async (options) => {\n    const { agent, paths } = options;\n    const canisterId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(options.canisterId);\n    const uniquePaths = [...new Set(paths)];\n    // Map path options to their correct formats\n    const encodedPaths = uniquePaths.map(path => {\n        return encodePath(path, canisterId);\n    });\n    const status = new Map();\n    const promises = uniquePaths.map((path, index) => {\n        return (async () => {\n            var _a;\n            try {\n                const response = await agent.readState(canisterId, {\n                    paths: [encodedPaths[index]],\n                });\n                const cert = await _certificate__WEBPACK_IMPORTED_MODULE_2__.Certificate.create({\n                    certificate: response.certificate,\n                    rootKey: agent.rootKey,\n                    canisterId: canisterId,\n                });\n                const lookup = (cert, path) => {\n                    if (path === 'subnet') {\n                        const data = fetchNodeKeys(response.certificate, canisterId, agent.rootKey);\n                        return {\n                            path: path,\n                            data,\n                        };\n                    }\n                    else {\n                        return {\n                            path: path,\n                            data: (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookupResultToBuffer)(cert.lookup(encodePath(path, canisterId))),\n                        };\n                    }\n                };\n                // must pass in the rootKey if we have no delegation\n                const { path, data } = lookup(cert, uniquePaths[index]);\n                if (!data) {\n                    // Typically, the cert lookup will throw\n                    console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n                    if (typeof path === 'string') {\n                        status.set(path, null);\n                    }\n                    else {\n                        status.set(path.key, null);\n                    }\n                }\n                else {\n                    switch (path) {\n                        case 'time': {\n                            status.set(path, (0,_utils_leb__WEBPACK_IMPORTED_MODULE_5__.decodeTime)(data));\n                            break;\n                        }\n                        case 'controllers': {\n                            status.set(path, decodeControllers(data));\n                            break;\n                        }\n                        case 'module_hash': {\n                            status.set(path, decodeHex(data));\n                            break;\n                        }\n                        case 'subnet': {\n                            status.set(path, data);\n                            break;\n                        }\n                        case 'candid': {\n                            status.set(path, new TextDecoder().decode(data));\n                            break;\n                        }\n                        default: {\n                            // Check for CustomPath signature\n                            if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                                switch (path.decodeStrategy) {\n                                    case 'raw':\n                                        status.set(path.key, data);\n                                        break;\n                                    case 'leb128': {\n                                        status.set(path.key, (0,_utils_leb__WEBPACK_IMPORTED_MODULE_5__.decodeLeb128)(data));\n                                        break;\n                                    }\n                                    case 'cbor': {\n                                        status.set(path.key, decodeCbor(data));\n                                        break;\n                                    }\n                                    case 'hex': {\n                                        status.set(path.key, decodeHex(data));\n                                        break;\n                                    }\n                                    case 'utf-8': {\n                                        status.set(path.key, decodeUtf8(data));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                // Break on signature verification errors\n                if ((_a = error === null || error === void 0 ? void 0 : error.message) === null || _a === void 0 ? void 0 : _a.includes('Invalid certificate')) {\n                    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError(error.message);\n                }\n                if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                    status.set(path.key, null);\n                }\n                else {\n                    status.set(path, null);\n                }\n                console.group();\n                console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n                console.warn(error);\n                console.groupEnd();\n            }\n        })();\n    });\n    // Fetch all values separately, as each option can fail\n    await Promise.all(promises);\n    return status;\n};\nconst fetchNodeKeys = (certificate, canisterId, root_key) => {\n    if (!canisterId._isPrincipal) {\n        throw new Error('Invalid canisterId');\n    }\n    const cert = _cbor__WEBPACK_IMPORTED_MODULE_4__.decode(new Uint8Array(certificate));\n    const tree = cert.tree;\n    let delegation = cert.delegation;\n    let subnetId;\n    if (delegation && delegation.subnet_id) {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id));\n    }\n    // On local replica, with System type subnet, there is no delegation\n    else if (!delegation && typeof root_key !== 'undefined') {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(new Uint8Array(root_key));\n        delegation = {\n            subnet_id: subnetId.toUint8Array(),\n            certificate: new ArrayBuffer(0),\n        };\n    }\n    // otherwise use default NNS subnet id\n    else {\n        subnetId = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.selfAuthenticating(_dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText('tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe').toUint8Array());\n        delegation = {\n            subnet_id: subnetId.toUint8Array(),\n            certificate: new ArrayBuffer(0),\n        };\n    }\n    const canisterInRange = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.check_canister_ranges)({ canisterId, subnetId, tree });\n    if (!canisterInRange) {\n        throw new Error('Canister not in range');\n    }\n    const nodeTree = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookup_path)(['subnet', delegation === null || delegation === void 0 ? void 0 : delegation.subnet_id, 'node'], tree);\n    const nodeForks = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.flatten_forks)(nodeTree);\n    nodeForks.length;\n    const nodeKeys = new Map();\n    nodeForks.forEach(fork => {\n        Object.getPrototypeOf(new Uint8Array(fork[1]));\n        const node_id = _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.from(new Uint8Array(fork[1])).toText();\n        const derEncodedPublicKey = (0,_certificate__WEBPACK_IMPORTED_MODULE_2__.lookup_path)(['public_key'], fork[2]);\n        if (derEncodedPublicKey.byteLength !== 44) {\n            throw new Error('Invalid public key length');\n        }\n        else {\n            nodeKeys.set(node_id, derEncodedPublicKey);\n        }\n    });\n    return {\n        subnetId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(delegation.subnet_id)).toText(),\n        nodeKeys,\n    };\n};\nconst encodePath = (path, canisterId) => {\n    const encoder = new TextEncoder();\n    const encode = (arg) => {\n        return new DataView(encoder.encode(arg).buffer).buffer;\n    };\n    const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;\n    switch (path) {\n        case 'time':\n            return [encode('time')];\n        case 'controllers':\n            return [encode('canister'), canisterBuffer, encode('controllers')];\n        case 'module_hash':\n            return [encode('canister'), canisterBuffer, encode('module_hash')];\n        case 'subnet':\n            return [encode('subnet')];\n        case 'candid':\n            return [encode('canister'), canisterBuffer, encode('metadata'), encode('candid:service')];\n        default: {\n            // Check for CustomPath signature\n            if ('key' in path && 'path' in path) {\n                // For simplified metadata queries\n                if (typeof path['path'] === 'string' || path['path'] instanceof ArrayBuffer) {\n                    const metaPath = path.path;\n                    const encoded = typeof metaPath === 'string' ? encode(metaPath) : metaPath;\n                    return [encode('canister'), canisterBuffer, encode('metadata'), encoded];\n                    // For non-metadata, return the provided custompath\n                }\n                else {\n                    return path['path'];\n                }\n            }\n        }\n    }\n    throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`);\n};\nconst decodeHex = (buf) => {\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(buf);\n};\nconst decodeCbor = (buf) => {\n    return _cbor__WEBPACK_IMPORTED_MODULE_4__.decode(buf);\n};\nconst decodeUtf8 = (buf) => {\n    return new TextDecoder().decode(buf);\n};\n// Controllers are CBOR-encoded buffers\nconst decodeControllers = (buf) => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const controllersRaw = decodeCbor(buf);\n    return controllersRaw.map((buf) => {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array(buf));\n    });\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2FuaXN0ZXJTdGF0dXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDK0M7QUFDUjtBQUNnRjtBQUMvRTtBQUNSO0FBQ3dCO0FBQ3hEO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QixTQUFTO0FBQzNDLFdBQVcscUNBQXFDLG9CQUFvQjtBQUNwRSxXQUFXLGdDQUFnQyxlQUFlLGlCQUFpQjtBQUMzRSxXQUFXLGdDQUFnQyxlQUFlO0FBQzFELGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksZUFBZTtBQUMzQix1QkFBdUIseURBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsbUNBQW1DLHFEQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtFQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQSxxRUFBcUUsS0FBSztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzREFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHdEQUFZO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUNBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseURBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlEQUFTLG9CQUFvQix5REFBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1FQUFxQixHQUFHLDRCQUE0QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseURBQVc7QUFDaEMsc0JBQXNCLDJEQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFTO0FBQ2pDLG9DQUFvQyx5REFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBa0IseURBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0lBQXdJLE1BQU07QUFDOUk7QUFDQTtBQUNBLFdBQVcsb0RBQUs7QUFDaEI7QUFDQTtBQUNBLFdBQVcseUNBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBUztBQUN4QixLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2FuaXN0ZXJTdGF0dXMvaW5kZXguanM/YWViMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQG1vZHVsZSBDYW5pc3RlclN0YXR1cyAqL1xuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmltcG9ydCB7IEFnZW50RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgQ2VydGlmaWNhdGUsIGZsYXR0ZW5fZm9ya3MsIGNoZWNrX2NhbmlzdGVyX3JhbmdlcywgbG9va3VwUmVzdWx0VG9CdWZmZXIsIGxvb2t1cF9wYXRoLCB9IGZyb20gJy4uL2NlcnRpZmljYXRlJztcbmltcG9ydCB7IHRvSGV4IH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyJztcbmltcG9ydCAqIGFzIENib3IgZnJvbSAnLi4vY2Jvcic7XG5pbXBvcnQgeyBkZWNvZGVMZWIxMjgsIGRlY29kZVRpbWUgfSBmcm9tICcuLi91dGlscy9sZWInO1xuLyoqXG4gKlxuICogQHBhcmFtIHtDYW5pc3RlclN0YXR1c09wdGlvbnN9IG9wdGlvbnMge0BsaW5rIENhbmlzdGVyU3RhdHVzT3B0aW9uc31cbiAqIEBwYXJhbSB7Q2FuaXN0ZXJTdGF0dXNPcHRpb25zWydjYW5pc3RlcklkJ119IG9wdGlvbnMuY2FuaXN0ZXJJZCB7QGxpbmsgUHJpbmNpcGFsfVxuICogQHBhcmFtIHtDYW5pc3RlclN0YXR1c09wdGlvbnNbJ2FnZW50J119IG9wdGlvbnMuYWdlbnQge0BsaW5rIEh0dHBBZ2VudH0gb3B0aW9uYWwgYXV0aGVudGljYXRlZCBhZ2VudCB0byB1c2UgdG8gbWFrZSB0aGUgY2FuaXN0ZXIgcmVxdWVzdC4gVXNlZnVsIGZvciBhY2Nlc3NpbmcgcHJpdmF0ZSBtZXRhZGF0YSB1bmRlciBpY3A6cHJpdmF0ZVxuICogQHBhcmFtIHtDYW5pc3RlclN0YXR1c09wdGlvbnNbJ3BhdGhzJ119IG9wdGlvbnMucGF0aHMge0BsaW5rIFBhdGhbXX1cbiAqIEByZXR1cm5zIHtTdGF0dXN9IG9iamVjdCBwb3B1bGF0ZWQgd2l0aCBkYXRhIGZyb20gdGhlIHJlcXVlc3RlZCBwYXRoc1xuICogQGV4YW1wbGVcbiAqIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGNhbmlzdGVyU3RhdHVzKHtcbiAqICAgcGF0aHM6IFsnY29udHJvbGxlcnMnLCAnY2FuZGlkJ10sXG4gKiAgIC4uLm9wdGlvbnNcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGNvbnRyb2xsZXJzID0gc3RhdHVzLmdldCgnY29udHJvbGxlcnMnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IHJlcXVlc3QgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgYWdlbnQsIHBhdGhzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNhbmlzdGVySWQgPSBQcmluY2lwYWwuZnJvbShvcHRpb25zLmNhbmlzdGVySWQpO1xuICAgIGNvbnN0IHVuaXF1ZVBhdGhzID0gWy4uLm5ldyBTZXQocGF0aHMpXTtcbiAgICAvLyBNYXAgcGF0aCBvcHRpb25zIHRvIHRoZWlyIGNvcnJlY3QgZm9ybWF0c1xuICAgIGNvbnN0IGVuY29kZWRQYXRocyA9IHVuaXF1ZVBhdGhzLm1hcChwYXRoID0+IHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVBhdGgocGF0aCwgY2FuaXN0ZXJJZCk7XG4gICAgfSk7XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHByb21pc2VzID0gdW5pcXVlUGF0aHMubWFwKChwYXRoLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZ2VudC5yZWFkU3RhdGUoY2FuaXN0ZXJJZCwge1xuICAgICAgICAgICAgICAgICAgICBwYXRoczogW2VuY29kZWRQYXRoc1tpbmRleF1dLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlcnQgPSBhd2FpdCBDZXJ0aWZpY2F0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZTogcmVzcG9uc2UuY2VydGlmaWNhdGUsXG4gICAgICAgICAgICAgICAgICAgIHJvb3RLZXk6IGFnZW50LnJvb3RLZXksXG4gICAgICAgICAgICAgICAgICAgIGNhbmlzdGVySWQ6IGNhbmlzdGVySWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9va3VwID0gKGNlcnQsIHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggPT09ICdzdWJuZXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZmV0Y2hOb2RlS2V5cyhyZXNwb25zZS5jZXJ0aWZpY2F0ZSwgY2FuaXN0ZXJJZCwgYWdlbnQucm9vdEtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbG9va3VwUmVzdWx0VG9CdWZmZXIoY2VydC5sb29rdXAoZW5jb2RlUGF0aChwYXRoLCBjYW5pc3RlcklkKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gbXVzdCBwYXNzIGluIHRoZSByb290S2V5IGlmIHdlIGhhdmUgbm8gZGVsZWdhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aCwgZGF0YSB9ID0gbG9va3VwKGNlcnQsIHVuaXF1ZVBhdGhzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFR5cGljYWxseSwgdGhlIGNlcnQgbG9va3VwIHdpbGwgdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBFeHBlY3RlZCB0byBmaW5kIHJlc3VsdCBmb3IgcGF0aCAke3BhdGh9LCBidXQgaW5zdGVhZCBmb3VuZCBub3RoaW5nLmApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLmtleSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndGltZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgsIGRlY29kZVRpbWUoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29udHJvbGxlcnMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLCBkZWNvZGVDb250cm9sbGVycyhkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtb2R1bGVfaGFzaCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgsIGRlY29kZUhleChkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdWJuZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NhbmRpZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgsIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEN1c3RvbVBhdGggc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJyAmJiAna2V5JyBpbiBwYXRoICYmICdwYXRoJyBpbiBwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocGF0aC5kZWNvZGVTdHJhdGVneSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmF3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlYjEyOCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBkZWNvZGVMZWIxMjgoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2Jvcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBkZWNvZGVDYm9yKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hleCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBkZWNvZGVIZXgoZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmLTgnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldChwYXRoLmtleSwgZGVjb2RlVXRmOChkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBCcmVhayBvbiBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGVycm9yc1xuICAgICAgICAgICAgICAgIGlmICgoX2EgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdJbnZhbGlkIGNlcnRpZmljYXRlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFnZW50RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycgJiYgJ2tleScgaW4gcGF0aCAmJiAncGF0aCcgaW4gcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuc2V0KHBhdGgua2V5LCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQocGF0aCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZ3JvdXAoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEV4cGVjdGVkIHRvIGZpbmQgcmVzdWx0IGZvciBwYXRoICR7cGF0aH0sIGJ1dCBpbnN0ZWFkIGZvdW5kIG5vdGhpbmcuYCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfSk7XG4gICAgLy8gRmV0Y2ggYWxsIHZhbHVlcyBzZXBhcmF0ZWx5LCBhcyBlYWNoIG9wdGlvbiBjYW4gZmFpbFxuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICByZXR1cm4gc3RhdHVzO1xufTtcbmV4cG9ydCBjb25zdCBmZXRjaE5vZGVLZXlzID0gKGNlcnRpZmljYXRlLCBjYW5pc3RlcklkLCByb290X2tleSkgPT4ge1xuICAgIGlmICghY2FuaXN0ZXJJZC5faXNQcmluY2lwYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNhbmlzdGVySWQnKTtcbiAgICB9XG4gICAgY29uc3QgY2VydCA9IENib3IuZGVjb2RlKG5ldyBVaW50OEFycmF5KGNlcnRpZmljYXRlKSk7XG4gICAgY29uc3QgdHJlZSA9IGNlcnQudHJlZTtcbiAgICBsZXQgZGVsZWdhdGlvbiA9IGNlcnQuZGVsZWdhdGlvbjtcbiAgICBsZXQgc3VibmV0SWQ7XG4gICAgaWYgKGRlbGVnYXRpb24gJiYgZGVsZWdhdGlvbi5zdWJuZXRfaWQpIHtcbiAgICAgICAgc3VibmV0SWQgPSBQcmluY2lwYWwuZnJvbVVpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkoZGVsZWdhdGlvbi5zdWJuZXRfaWQpKTtcbiAgICB9XG4gICAgLy8gT24gbG9jYWwgcmVwbGljYSwgd2l0aCBTeXN0ZW0gdHlwZSBzdWJuZXQsIHRoZXJlIGlzIG5vIGRlbGVnYXRpb25cbiAgICBlbHNlIGlmICghZGVsZWdhdGlvbiAmJiB0eXBlb2Ygcm9vdF9rZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN1Ym5ldElkID0gUHJpbmNpcGFsLnNlbGZBdXRoZW50aWNhdGluZyhuZXcgVWludDhBcnJheShyb290X2tleSkpO1xuICAgICAgICBkZWxlZ2F0aW9uID0ge1xuICAgICAgICAgICAgc3VibmV0X2lkOiBzdWJuZXRJZC50b1VpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGNlcnRpZmljYXRlOiBuZXcgQXJyYXlCdWZmZXIoMCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSB1c2UgZGVmYXVsdCBOTlMgc3VibmV0IGlkXG4gICAgZWxzZSB7XG4gICAgICAgIHN1Ym5ldElkID0gUHJpbmNpcGFsLnNlbGZBdXRoZW50aWNhdGluZyhQcmluY2lwYWwuZnJvbVRleHQoJ3RkYjI2LWpvcDZrLWFvZ2xsLTdsdGdzLWVydWlmLTZrazdtLXFwa3RmLWdkaXF4LW14dHJmLXZiNWU2LWVxZScpLnRvVWludDhBcnJheSgpKTtcbiAgICAgICAgZGVsZWdhdGlvbiA9IHtcbiAgICAgICAgICAgIHN1Ym5ldF9pZDogc3VibmV0SWQudG9VaW50OEFycmF5KCksXG4gICAgICAgICAgICBjZXJ0aWZpY2F0ZTogbmV3IEFycmF5QnVmZmVyKDApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBjYW5pc3RlckluUmFuZ2UgPSBjaGVja19jYW5pc3Rlcl9yYW5nZXMoeyBjYW5pc3RlcklkLCBzdWJuZXRJZCwgdHJlZSB9KTtcbiAgICBpZiAoIWNhbmlzdGVySW5SYW5nZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbmlzdGVyIG5vdCBpbiByYW5nZScpO1xuICAgIH1cbiAgICBjb25zdCBub2RlVHJlZSA9IGxvb2t1cF9wYXRoKFsnc3VibmV0JywgZGVsZWdhdGlvbiA9PT0gbnVsbCB8fCBkZWxlZ2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWxlZ2F0aW9uLnN1Ym5ldF9pZCwgJ25vZGUnXSwgdHJlZSk7XG4gICAgY29uc3Qgbm9kZUZvcmtzID0gZmxhdHRlbl9mb3Jrcyhub2RlVHJlZSk7XG4gICAgbm9kZUZvcmtzLmxlbmd0aDtcbiAgICBjb25zdCBub2RlS2V5cyA9IG5ldyBNYXAoKTtcbiAgICBub2RlRm9ya3MuZm9yRWFjaChmb3JrID0+IHtcbiAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBVaW50OEFycmF5KGZvcmtbMV0pKTtcbiAgICAgICAgY29uc3Qgbm9kZV9pZCA9IFByaW5jaXBhbC5mcm9tKG5ldyBVaW50OEFycmF5KGZvcmtbMV0pKS50b1RleHQoKTtcbiAgICAgICAgY29uc3QgZGVyRW5jb2RlZFB1YmxpY0tleSA9IGxvb2t1cF9wYXRoKFsncHVibGljX2tleSddLCBmb3JrWzJdKTtcbiAgICAgICAgaWYgKGRlckVuY29kZWRQdWJsaWNLZXkuYnl0ZUxlbmd0aCAhPT0gNDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwdWJsaWMga2V5IGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZUtleXMuc2V0KG5vZGVfaWQsIGRlckVuY29kZWRQdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VibmV0SWQ6IFByaW5jaXBhbC5mcm9tVWludDhBcnJheShuZXcgVWludDhBcnJheShkZWxlZ2F0aW9uLnN1Ym5ldF9pZCkpLnRvVGV4dCgpLFxuICAgICAgICBub2RlS2V5cyxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVQYXRoID0gKHBhdGgsIGNhbmlzdGVySWQpID0+IHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlID0gKGFyZykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGVuY29kZXIuZW5jb2RlKGFyZykuYnVmZmVyKS5idWZmZXI7XG4gICAgfTtcbiAgICBjb25zdCBjYW5pc3RlckJ1ZmZlciA9IG5ldyBEYXRhVmlldyhjYW5pc3RlcklkLnRvVWludDhBcnJheSgpLmJ1ZmZlcikuYnVmZmVyO1xuICAgIHN3aXRjaCAocGF0aCkge1xuICAgICAgICBjYXNlICd0aW1lJzpcbiAgICAgICAgICAgIHJldHVybiBbZW5jb2RlKCd0aW1lJyldO1xuICAgICAgICBjYXNlICdjb250cm9sbGVycyc6XG4gICAgICAgICAgICByZXR1cm4gW2VuY29kZSgnY2FuaXN0ZXInKSwgY2FuaXN0ZXJCdWZmZXIsIGVuY29kZSgnY29udHJvbGxlcnMnKV07XG4gICAgICAgIGNhc2UgJ21vZHVsZV9oYXNoJzpcbiAgICAgICAgICAgIHJldHVybiBbZW5jb2RlKCdjYW5pc3RlcicpLCBjYW5pc3RlckJ1ZmZlciwgZW5jb2RlKCdtb2R1bGVfaGFzaCcpXTtcbiAgICAgICAgY2FzZSAnc3VibmV0JzpcbiAgICAgICAgICAgIHJldHVybiBbZW5jb2RlKCdzdWJuZXQnKV07XG4gICAgICAgIGNhc2UgJ2NhbmRpZCc6XG4gICAgICAgICAgICByZXR1cm4gW2VuY29kZSgnY2FuaXN0ZXInKSwgY2FuaXN0ZXJCdWZmZXIsIGVuY29kZSgnbWV0YWRhdGEnKSwgZW5jb2RlKCdjYW5kaWQ6c2VydmljZScpXTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEN1c3RvbVBhdGggc2lnbmF0dXJlXG4gICAgICAgICAgICBpZiAoJ2tleScgaW4gcGF0aCAmJiAncGF0aCcgaW4gcGF0aCkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBzaW1wbGlmaWVkIG1ldGFkYXRhIHF1ZXJpZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGhbJ3BhdGgnXSA9PT0gJ3N0cmluZycgfHwgcGF0aFsncGF0aCddIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YVBhdGggPSBwYXRoLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSB0eXBlb2YgbWV0YVBhdGggPT09ICdzdHJpbmcnID8gZW5jb2RlKG1ldGFQYXRoKSA6IG1ldGFQYXRoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2VuY29kZSgnY2FuaXN0ZXInKSwgY2FuaXN0ZXJCdWZmZXIsIGVuY29kZSgnbWV0YWRhdGEnKSwgZW5jb2RlZF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBub24tbWV0YWRhdGEsIHJldHVybiB0aGUgcHJvdmlkZWQgY3VzdG9tcGF0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhbJ3BhdGgnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBbiB1bmV4cGVlY3RlZCBlcnJvciB3YXMgZW5jb3VudGVyZWQgd2hpbGUgZW5jb2RpbmcgeW91ciBwYXRoIGZvciBjYW5pc3RlciBzdGF0dXMuIFBsZWFzZSBlbnN1cmUgdGhhdCB5b3VyIHBhdGgsICR7cGF0aH0gd2FzIGZvcm1hdHRlZCBjb3JyZWN0bHkuYCk7XG59O1xuY29uc3QgZGVjb2RlSGV4ID0gKGJ1ZikgPT4ge1xuICAgIHJldHVybiB0b0hleChidWYpO1xufTtcbmNvbnN0IGRlY29kZUNib3IgPSAoYnVmKSA9PiB7XG4gICAgcmV0dXJuIENib3IuZGVjb2RlKGJ1Zik7XG59O1xuY29uc3QgZGVjb2RlVXRmOCA9IChidWYpID0+IHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1Zik7XG59O1xuLy8gQ29udHJvbGxlcnMgYXJlIENCT1ItZW5jb2RlZCBidWZmZXJzXG5jb25zdCBkZWNvZGVDb250cm9sbGVycyA9IChidWYpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgY29uc3QgY29udHJvbGxlcnNSYXcgPSBkZWNvZGVDYm9yKGJ1Zik7XG4gICAgcmV0dXJuIGNvbnRyb2xsZXJzUmF3Lm1hcCgoYnVmKSA9PiB7XG4gICAgICAgIHJldHVybiBQcmluY2lwYWwuZnJvbVVpbnQ4QXJyYXkobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/canisters/asset.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/canisters/asset.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createAssetCanisterActor: function() { return /* binding */ createAssetCanisterActor; }\n/* harmony export */ });\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actor */ \"../../../node_modules/@dfinity/agent/lib/esm/actor.js\");\n/* harmony import */ var _asset_idl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asset_idl */ \"../../../node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js\");\n\n\n/**\n * Create a management canister actor.\n * @param config\n */\nfunction createAssetCanisterActor(config) {\n    return _actor__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(_asset_idl__WEBPACK_IMPORTED_MODULE_1__[\"default\"], config);\n}\n//# sourceMappingURL=asset.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2FuaXN0ZXJzL2Fzc2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNPO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHlDQUFLLGFBQWEsa0RBQWE7QUFDMUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2FuaXN0ZXJzL2Fzc2V0LmpzP2MzNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0b3IgfSBmcm9tICcuLi9hY3Rvcic7XG5pbXBvcnQgYXNzZXRDYW5pc3RlciBmcm9tICcuL2Fzc2V0X2lkbCc7XG4vKipcbiAqIENyZWF0ZSBhIG1hbmFnZW1lbnQgY2FuaXN0ZXIgYWN0b3IuXG4gKiBAcGFyYW0gY29uZmlnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBc3NldENhbmlzdGVyQWN0b3IoY29uZmlnKSB7XG4gICAgcmV0dXJuIEFjdG9yLmNyZWF0ZUFjdG9yKGFzc2V0Q2FuaXN0ZXIsIGNvbmZpZyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NldC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/canisters/asset.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js":
/*!***************************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/**\n * This file is generated from the candid for asset management.\n */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n/* harmony default export */ __webpack_exports__[\"default\"] = (({ IDL }) => {\n    return IDL.Service({\n        retrieve: IDL.Func([IDL.Text], [IDL.Vec(IDL.Nat8)], ['query']),\n        store: IDL.Func([IDL.Text, IDL.Vec(IDL.Nat8)], [], []),\n    });\n});\n//# sourceMappingURL=asset_idl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2FuaXN0ZXJzL2Fzc2V0X2lkbC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUFlLEdBQUcsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyxFQUFDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2NhbmlzdGVycy9hc3NldF9pZGwuanM/ZjU0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgY2FuZGlkIGZvciBhc3NldCBtYW5hZ2VtZW50LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlXG5leHBvcnQgZGVmYXVsdCAoeyBJREwgfSkgPT4ge1xuICAgIHJldHVybiBJREwuU2VydmljZSh7XG4gICAgICAgIHJldHJpZXZlOiBJREwuRnVuYyhbSURMLlRleHRdLCBbSURMLlZlYyhJREwuTmF0OCldLCBbJ3F1ZXJ5J10pLFxuICAgICAgICBzdG9yZTogSURMLkZ1bmMoW0lETC5UZXh0LCBJREwuVmVjKElETC5OYXQ4KV0sIFtdLCBbXSksXG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXRfaWRsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js":
/*!********************************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/**\n * This file is generated from the candid for asset management.\n */\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n/* harmony default export */ __webpack_exports__[\"default\"] = (({ IDL }) => {\n    const canister_id = IDL.Principal;\n    const definite_canister_settings = IDL.Record({\n        controllers: IDL.Vec(IDL.Principal),\n        freezing_threshold: IDL.Nat,\n        memory_allocation: IDL.Nat,\n        compute_allocation: IDL.Nat,\n    });\n    const canister_settings = IDL.Record({\n        controllers: IDL.Opt(IDL.Vec(IDL.Principal)),\n        freezing_threshold: IDL.Opt(IDL.Nat),\n        memory_allocation: IDL.Opt(IDL.Nat),\n        compute_allocation: IDL.Opt(IDL.Nat),\n    });\n    const wasm_module = IDL.Vec(IDL.Nat8);\n    return IDL.Service({\n        canister_status: IDL.Func([IDL.Record({ canister_id: canister_id })], [\n            IDL.Record({\n                status: IDL.Variant({\n                    stopped: IDL.Null,\n                    stopping: IDL.Null,\n                    running: IDL.Null,\n                }),\n                memory_size: IDL.Nat,\n                cycles: IDL.Nat,\n                settings: definite_canister_settings,\n                module_hash: IDL.Opt(IDL.Vec(IDL.Nat8)),\n            }),\n        ], []),\n        create_canister: IDL.Func([IDL.Record({ settings: IDL.Opt(canister_settings) })], [IDL.Record({ canister_id: canister_id })], []),\n        delete_canister: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),\n        deposit_cycles: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),\n        install_code: IDL.Func([\n            IDL.Record({\n                arg: IDL.Vec(IDL.Nat8),\n                wasm_module: wasm_module,\n                mode: IDL.Variant({\n                    reinstall: IDL.Null,\n                    upgrade: IDL.Null,\n                    install: IDL.Null,\n                }),\n                canister_id: canister_id,\n            }),\n        ], [], []),\n        provisional_create_canister_with_cycles: IDL.Func([\n            IDL.Record({\n                settings: IDL.Opt(canister_settings),\n                amount: IDL.Opt(IDL.Nat),\n            }),\n        ], [IDL.Record({ canister_id: canister_id })], []),\n        provisional_top_up_canister: IDL.Func([IDL.Record({ canister_id: canister_id, amount: IDL.Nat })], [], []),\n        raw_rand: IDL.Func([], [IDL.Vec(IDL.Nat8)], []),\n        start_canister: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),\n        stop_canister: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),\n        uninstall_code: IDL.Func([IDL.Record({ canister_id: canister_id })], [], []),\n        update_settings: IDL.Func([\n            IDL.Record({\n                canister_id: IDL.Principal,\n                settings: canister_settings,\n            }),\n        ], [], []),\n    });\n});\n//# sourceMappingURL=management_idl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2FuaXN0ZXJzL21hbmFnZW1lbnRfaWRsLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQWUsR0FBRyxLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnREFBZ0QsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnREFBZ0Qsc0NBQXNDLGtCQUFrQiwwQkFBMEI7QUFDbEksZ0RBQWdELDBCQUEwQjtBQUMxRSwrQ0FBK0MsMEJBQTBCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5QkFBeUIsMEJBQTBCO0FBQ25ELDREQUE0RCwyQ0FBMkM7QUFDdkc7QUFDQSwrQ0FBK0MsMEJBQTBCO0FBQ3pFLDhDQUE4QywwQkFBMEI7QUFDeEUsK0NBQStDLDBCQUEwQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDLEVBQUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2FuaXN0ZXJzL21hbmFnZW1lbnRfaWRsLmpzPzJlZmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIGNhbmRpZCBmb3IgYXNzZXQgbWFuYWdlbWVudC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGRlZmF1bHQgKHsgSURMIH0pID0+IHtcbiAgICBjb25zdCBjYW5pc3Rlcl9pZCA9IElETC5QcmluY2lwYWw7XG4gICAgY29uc3QgZGVmaW5pdGVfY2FuaXN0ZXJfc2V0dGluZ3MgPSBJREwuUmVjb3JkKHtcbiAgICAgICAgY29udHJvbGxlcnM6IElETC5WZWMoSURMLlByaW5jaXBhbCksXG4gICAgICAgIGZyZWV6aW5nX3RocmVzaG9sZDogSURMLk5hdCxcbiAgICAgICAgbWVtb3J5X2FsbG9jYXRpb246IElETC5OYXQsXG4gICAgICAgIGNvbXB1dGVfYWxsb2NhdGlvbjogSURMLk5hdCxcbiAgICB9KTtcbiAgICBjb25zdCBjYW5pc3Rlcl9zZXR0aW5ncyA9IElETC5SZWNvcmQoe1xuICAgICAgICBjb250cm9sbGVyczogSURMLk9wdChJREwuVmVjKElETC5QcmluY2lwYWwpKSxcbiAgICAgICAgZnJlZXppbmdfdGhyZXNob2xkOiBJREwuT3B0KElETC5OYXQpLFxuICAgICAgICBtZW1vcnlfYWxsb2NhdGlvbjogSURMLk9wdChJREwuTmF0KSxcbiAgICAgICAgY29tcHV0ZV9hbGxvY2F0aW9uOiBJREwuT3B0KElETC5OYXQpLFxuICAgIH0pO1xuICAgIGNvbnN0IHdhc21fbW9kdWxlID0gSURMLlZlYyhJREwuTmF0OCk7XG4gICAgcmV0dXJuIElETC5TZXJ2aWNlKHtcbiAgICAgICAgY2FuaXN0ZXJfc3RhdHVzOiBJREwuRnVuYyhbSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KV0sIFtcbiAgICAgICAgICAgIElETC5SZWNvcmQoe1xuICAgICAgICAgICAgICAgIHN0YXR1czogSURMLlZhcmlhbnQoe1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGVkOiBJREwuTnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBpbmc6IElETC5OdWxsLFxuICAgICAgICAgICAgICAgICAgICBydW5uaW5nOiBJREwuTnVsbCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBtZW1vcnlfc2l6ZTogSURMLk5hdCxcbiAgICAgICAgICAgICAgICBjeWNsZXM6IElETC5OYXQsXG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IGRlZmluaXRlX2NhbmlzdGVyX3NldHRpbmdzLFxuICAgICAgICAgICAgICAgIG1vZHVsZV9oYXNoOiBJREwuT3B0KElETC5WZWMoSURMLk5hdDgpKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdLCBbXSksXG4gICAgICAgIGNyZWF0ZV9jYW5pc3RlcjogSURMLkZ1bmMoW0lETC5SZWNvcmQoeyBzZXR0aW5nczogSURMLk9wdChjYW5pc3Rlcl9zZXR0aW5ncykgfSldLCBbSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KV0sIFtdKSxcbiAgICAgICAgZGVsZXRlX2NhbmlzdGVyOiBJREwuRnVuYyhbSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KV0sIFtdLCBbXSksXG4gICAgICAgIGRlcG9zaXRfY3ljbGVzOiBJREwuRnVuYyhbSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KV0sIFtdLCBbXSksXG4gICAgICAgIGluc3RhbGxfY29kZTogSURMLkZ1bmMoW1xuICAgICAgICAgICAgSURMLlJlY29yZCh7XG4gICAgICAgICAgICAgICAgYXJnOiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICAgICAgICAgICAgICB3YXNtX21vZHVsZTogd2FzbV9tb2R1bGUsXG4gICAgICAgICAgICAgICAgbW9kZTogSURMLlZhcmlhbnQoe1xuICAgICAgICAgICAgICAgICAgICByZWluc3RhbGw6IElETC5OdWxsLFxuICAgICAgICAgICAgICAgICAgICB1cGdyYWRlOiBJREwuTnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbDogSURMLk51bGwsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF0sIFtdLCBbXSksXG4gICAgICAgIHByb3Zpc2lvbmFsX2NyZWF0ZV9jYW5pc3Rlcl93aXRoX2N5Y2xlczogSURMLkZ1bmMoW1xuICAgICAgICAgICAgSURMLlJlY29yZCh7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3M6IElETC5PcHQoY2FuaXN0ZXJfc2V0dGluZ3MpLFxuICAgICAgICAgICAgICAgIGFtb3VudDogSURMLk9wdChJREwuTmF0KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdLCBbSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KV0sIFtdKSxcbiAgICAgICAgcHJvdmlzaW9uYWxfdG9wX3VwX2NhbmlzdGVyOiBJREwuRnVuYyhbSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCwgYW1vdW50OiBJREwuTmF0IH0pXSwgW10sIFtdKSxcbiAgICAgICAgcmF3X3JhbmQ6IElETC5GdW5jKFtdLCBbSURMLlZlYyhJREwuTmF0OCldLCBbXSksXG4gICAgICAgIHN0YXJ0X2NhbmlzdGVyOiBJREwuRnVuYyhbSURMLlJlY29yZCh7IGNhbmlzdGVyX2lkOiBjYW5pc3Rlcl9pZCB9KV0sIFtdLCBbXSksXG4gICAgICAgIHN0b3BfY2FuaXN0ZXI6IElETC5GdW5jKFtJREwuUmVjb3JkKHsgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkIH0pXSwgW10sIFtdKSxcbiAgICAgICAgdW5pbnN0YWxsX2NvZGU6IElETC5GdW5jKFtJREwuUmVjb3JkKHsgY2FuaXN0ZXJfaWQ6IGNhbmlzdGVyX2lkIH0pXSwgW10sIFtdKSxcbiAgICAgICAgdXBkYXRlX3NldHRpbmdzOiBJREwuRnVuYyhbXG4gICAgICAgICAgICBJREwuUmVjb3JkKHtcbiAgICAgICAgICAgICAgICBjYW5pc3Rlcl9pZDogSURMLlByaW5jaXBhbCxcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogY2FuaXN0ZXJfc2V0dGluZ3MsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXSwgW10sIFtdKSxcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYW5hZ2VtZW50X2lkbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/cbor.js":
/*!************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/cbor.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CborTag: function() { return /* binding */ CborTag; },\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; }\n/* harmony export */ });\n/* harmony import */ var borc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! borc */ \"../../../node_modules/borc/src/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! simple-cbor */ \"../../../node_modules/simple-cbor/src/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(simple_cbor__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n// This file is based on:\n// https://github.com/dfinity-lab/dfinity/blob/9bca65f8edd65701ea6bdb00e0752f9186bbc893/docs/spec/public/index.adoc#cbor-encoding-of-requests-and-responses\n\n\n\n\n// We are using hansl/simple-cbor for CBOR serialization, to avoid issues with\n// encoding the uint64 values that the HTTP handler of the client expects for\n// canister IDs. However, simple-cbor does not yet provide deserialization so\n// we are using `Uint8Array` so that we can use the dignifiedquire/borc CBOR\n// decoder.\nclass PrincipalEncoder {\n    get name() {\n        return 'Principal';\n    }\n    get priority() {\n        return 0;\n    }\n    match(value) {\n        return value && value._isPrincipal === true;\n    }\n    encode(v) {\n        return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes(v.toUint8Array());\n    }\n}\nclass BufferEncoder {\n    get name() {\n        return 'Buffer';\n    }\n    get priority() {\n        return 1;\n    }\n    match(value) {\n        return value instanceof ArrayBuffer || ArrayBuffer.isView(value);\n    }\n    encode(v) {\n        return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes(new Uint8Array(v));\n    }\n}\nclass BigIntEncoder {\n    get name() {\n        return 'BigInt';\n    }\n    get priority() {\n        return 1;\n    }\n    match(value) {\n        return typeof value === `bigint`;\n    }\n    encode(v) {\n        // Always use a bigint encoding.\n        if (v > BigInt(0)) {\n            return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.tagged(2, simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.fromHex)(v.toString(16))));\n        }\n        else {\n            return simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.tagged(3, simple_cbor__WEBPACK_IMPORTED_MODULE_1__.value.bytes((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.fromHex)((BigInt('-1') * v).toString(16))));\n        }\n    }\n}\nconst serializer = simple_cbor__WEBPACK_IMPORTED_MODULE_1__.SelfDescribeCborSerializer.withDefaultEncoders(true);\nserializer.addEncoder(new PrincipalEncoder());\nserializer.addEncoder(new BufferEncoder());\nserializer.addEncoder(new BigIntEncoder());\nvar CborTag;\n(function (CborTag) {\n    CborTag[CborTag[\"Uint64LittleEndian\"] = 71] = \"Uint64LittleEndian\";\n    CborTag[CborTag[\"Semantic\"] = 55799] = \"Semantic\";\n})(CborTag || (CborTag = {}));\n/**\n * Encode a JavaScript value into CBOR.\n */\nfunction encode(value) {\n    return serializer.serialize(value);\n}\nfunction decodePositiveBigInt(buf) {\n    const len = buf.byteLength;\n    let res = BigInt(0);\n    for (let i = 0; i < len; i++) {\n        res = res * BigInt(0x100) + BigInt(buf[i]);\n    }\n    return res;\n}\n// A BORC subclass that decodes byte strings to ArrayBuffer instead of the Buffer class.\nclass Uint8ArrayDecoder extends borc__WEBPACK_IMPORTED_MODULE_0__.Decoder {\n    createByteString(raw) {\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...raw);\n    }\n    createByteStringFromHeap(start, end) {\n        if (start === end) {\n            return new ArrayBuffer(0);\n        }\n        return new Uint8Array(this._heap.slice(start, end));\n    }\n}\nfunction decode(input) {\n    const buffer = new Uint8Array(input);\n    const decoder = new Uint8ArrayDecoder({\n        size: buffer.byteLength,\n        tags: {\n            // Override tags 2 and 3 for BigInt support (borc supports only BigNumber).\n            2: val => decodePositiveBigInt(val),\n            3: val => -decodePositiveBigInt(val),\n            [CborTag.Semantic]: (value) => value,\n        },\n    });\n    return decoder.decodeFirst(buffer);\n}\n//# sourceMappingURL=cbor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2Jvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUN3QjtBQUNZO0FBQ3FCO0FBQ1I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhDQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOENBQVUsV0FBVyw4Q0FBVSxPQUFPLHNEQUFPO0FBQ2hFO0FBQ0E7QUFDQSxtQkFBbUIsOENBQVUsV0FBVyw4Q0FBVSxPQUFPLHNEQUFPO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBCQUEwQjtBQUMzQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlDQUFZO0FBQzVDO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Nib3IuanM/MjliMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgaXMgYmFzZWQgb246XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGZpbml0eS1sYWIvZGZpbml0eS9ibG9iLzliY2E2NWY4ZWRkNjU3MDFlYTZiZGIwMGUwNzUyZjkxODZiYmM4OTMvZG9jcy9zcGVjL3B1YmxpYy9pbmRleC5hZG9jI2Nib3ItZW5jb2Rpbmctb2YtcmVxdWVzdHMtYW5kLXJlc3BvbnNlc1xuaW1wb3J0IGJvcmMgZnJvbSAnYm9yYyc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJ3NpbXBsZS1jYm9yJztcbmltcG9ydCB7IFNlbGZEZXNjcmliZUNib3JTZXJpYWxpemVyIH0gZnJvbSAnc2ltcGxlLWNib3InO1xuaW1wb3J0IHsgY29uY2F0LCBmcm9tSGV4IH0gZnJvbSAnLi91dGlscy9idWZmZXInO1xuLy8gV2UgYXJlIHVzaW5nIGhhbnNsL3NpbXBsZS1jYm9yIGZvciBDQk9SIHNlcmlhbGl6YXRpb24sIHRvIGF2b2lkIGlzc3VlcyB3aXRoXG4vLyBlbmNvZGluZyB0aGUgdWludDY0IHZhbHVlcyB0aGF0IHRoZSBIVFRQIGhhbmRsZXIgb2YgdGhlIGNsaWVudCBleHBlY3RzIGZvclxuLy8gY2FuaXN0ZXIgSURzLiBIb3dldmVyLCBzaW1wbGUtY2JvciBkb2VzIG5vdCB5ZXQgcHJvdmlkZSBkZXNlcmlhbGl6YXRpb24gc29cbi8vIHdlIGFyZSB1c2luZyBgVWludDhBcnJheWAgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZSBkaWduaWZpZWRxdWlyZS9ib3JjIENCT1Jcbi8vIGRlY29kZXIuXG5jbGFzcyBQcmluY2lwYWxFbmNvZGVyIHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdQcmluY2lwYWwnO1xuICAgIH1cbiAgICBnZXQgcHJpb3JpdHkoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBtYXRjaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX2lzUHJpbmNpcGFsID09PSB0cnVlO1xuICAgIH1cbiAgICBlbmNvZGUodikge1xuICAgICAgICByZXR1cm4gY2Jvci52YWx1ZS5ieXRlcyh2LnRvVWludDhBcnJheSgpKTtcbiAgICB9XG59XG5jbGFzcyBCdWZmZXJFbmNvZGVyIHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdCdWZmZXInO1xuICAgIH1cbiAgICBnZXQgcHJpb3JpdHkoKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBtYXRjaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpO1xuICAgIH1cbiAgICBlbmNvZGUodikge1xuICAgICAgICByZXR1cm4gY2Jvci52YWx1ZS5ieXRlcyhuZXcgVWludDhBcnJheSh2KSk7XG4gICAgfVxufVxuY2xhc3MgQmlnSW50RW5jb2RlciB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQmlnSW50JztcbiAgICB9XG4gICAgZ2V0IHByaW9yaXR5KCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gYGJpZ2ludGA7XG4gICAgfVxuICAgIGVuY29kZSh2KSB7XG4gICAgICAgIC8vIEFsd2F5cyB1c2UgYSBiaWdpbnQgZW5jb2RpbmcuXG4gICAgICAgIGlmICh2ID4gQmlnSW50KDApKSB7XG4gICAgICAgICAgICByZXR1cm4gY2Jvci52YWx1ZS50YWdnZWQoMiwgY2Jvci52YWx1ZS5ieXRlcyhmcm9tSGV4KHYudG9TdHJpbmcoMTYpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNib3IudmFsdWUudGFnZ2VkKDMsIGNib3IudmFsdWUuYnl0ZXMoZnJvbUhleCgoQmlnSW50KCctMScpICogdikudG9TdHJpbmcoMTYpKSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3Qgc2VyaWFsaXplciA9IFNlbGZEZXNjcmliZUNib3JTZXJpYWxpemVyLndpdGhEZWZhdWx0RW5jb2RlcnModHJ1ZSk7XG5zZXJpYWxpemVyLmFkZEVuY29kZXIobmV3IFByaW5jaXBhbEVuY29kZXIoKSk7XG5zZXJpYWxpemVyLmFkZEVuY29kZXIobmV3IEJ1ZmZlckVuY29kZXIoKSk7XG5zZXJpYWxpemVyLmFkZEVuY29kZXIobmV3IEJpZ0ludEVuY29kZXIoKSk7XG5leHBvcnQgdmFyIENib3JUYWc7XG4oZnVuY3Rpb24gKENib3JUYWcpIHtcbiAgICBDYm9yVGFnW0Nib3JUYWdbXCJVaW50NjRMaXR0bGVFbmRpYW5cIl0gPSA3MV0gPSBcIlVpbnQ2NExpdHRsZUVuZGlhblwiO1xuICAgIENib3JUYWdbQ2JvclRhZ1tcIlNlbWFudGljXCJdID0gNTU3OTldID0gXCJTZW1hbnRpY1wiO1xufSkoQ2JvclRhZyB8fCAoQ2JvclRhZyA9IHt9KSk7XG4vKipcbiAqIEVuY29kZSBhIEphdmFTY3JpcHQgdmFsdWUgaW50byBDQk9SLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZXIuc2VyaWFsaXplKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVBvc2l0aXZlQmlnSW50KGJ1Zikge1xuICAgIGNvbnN0IGxlbiA9IGJ1Zi5ieXRlTGVuZ3RoO1xuICAgIGxldCByZXMgPSBCaWdJbnQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXMgPSByZXMgKiBCaWdJbnQoMHgxMDApICsgQmlnSW50KGJ1ZltpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBBIEJPUkMgc3ViY2xhc3MgdGhhdCBkZWNvZGVzIGJ5dGUgc3RyaW5ncyB0byBBcnJheUJ1ZmZlciBpbnN0ZWFkIG9mIHRoZSBCdWZmZXIgY2xhc3MuXG5jbGFzcyBVaW50OEFycmF5RGVjb2RlciBleHRlbmRzIGJvcmMuRGVjb2RlciB7XG4gICAgY3JlYXRlQnl0ZVN0cmluZyhyYXcpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCguLi5yYXcpO1xuICAgIH1cbiAgICBjcmVhdGVCeXRlU3RyaW5nRnJvbUhlYXAoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5faGVhcC5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFVpbnQ4QXJyYXlEZWNvZGVyKHtcbiAgICAgICAgc2l6ZTogYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgIHRhZ3M6IHtcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHRhZ3MgMiBhbmQgMyBmb3IgQmlnSW50IHN1cHBvcnQgKGJvcmMgc3VwcG9ydHMgb25seSBCaWdOdW1iZXIpLlxuICAgICAgICAgICAgMjogdmFsID0+IGRlY29kZVBvc2l0aXZlQmlnSW50KHZhbCksXG4gICAgICAgICAgICAzOiB2YWwgPT4gLWRlY29kZVBvc2l0aXZlQmlnSW50KHZhbCksXG4gICAgICAgICAgICBbQ2JvclRhZy5TZW1hbnRpY106ICh2YWx1ZSkgPT4gdmFsdWUsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlRmlyc3QoYnVmZmVyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNib3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/cbor.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/certificate.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/certificate.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Certificate: function() { return /* binding */ Certificate; },\n/* harmony export */   CertificateVerificationError: function() { return /* binding */ CertificateVerificationError; },\n/* harmony export */   NodeId: function() { return /* binding */ NodeId; },\n/* harmony export */   check_canister_ranges: function() { return /* binding */ check_canister_ranges; },\n/* harmony export */   flatten_forks: function() { return /* binding */ flatten_forks; },\n/* harmony export */   hashTreeToString: function() { return /* binding */ hashTreeToString; },\n/* harmony export */   lookupResultToBuffer: function() { return /* binding */ lookupResultToBuffer; },\n/* harmony export */   lookup_path: function() { return /* binding */ lookup_path; },\n/* harmony export */   reconstruct: function() { return /* binding */ reconstruct; }\n/* harmony export */ });\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor */ \"../../../node_modules/@dfinity/agent/lib/esm/cbor.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"../../../node_modules/@dfinity/agent/lib/esm/errors.js\");\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./request_id */ \"../../../node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/buffer */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @dfinity/principal */ \"../../../node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _utils_bls__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/bls */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/bls.js\");\n/* harmony import */ var _utils_leb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/leb */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/leb.js\");\n\n\n\n\n\n\n\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nclass CertificateVerificationError extends _errors__WEBPACK_IMPORTED_MODULE_1__.AgentError {\n    constructor(reason) {\n        super(`Invalid certificate: ${reason}`);\n    }\n}\nconst NodeId = {\n    Empty: 0,\n    Fork: 1,\n    Labeled: 2,\n    Leaf: 3,\n    Pruned: 4,\n};\n\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nfunction hashTreeToString(tree) {\n    const indent = (s) => s\n        .split('\\n')\n        .map(x => '  ' + x)\n        .join('\\n');\n    function labelToString(label) {\n        const decoder = new TextDecoder(undefined, { fatal: true });\n        try {\n            return JSON.stringify(decoder.decode(label));\n        }\n        catch (e) {\n            return `data(...${label.byteLength} bytes)`;\n        }\n    }\n    switch (tree[0]) {\n        case NodeId.Empty:\n            return '()';\n        case NodeId.Fork: {\n            if (tree[1] instanceof Array && tree[2] instanceof ArrayBuffer) {\n                const left = hashTreeToString(tree[1]);\n                const right = hashTreeToString(tree[2]);\n                return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n            }\n            else {\n                throw new Error('Invalid tree structure for fork');\n            }\n        }\n        case NodeId.Labeled: {\n            if (tree[1] instanceof ArrayBuffer && tree[2] instanceof ArrayBuffer) {\n                const label = labelToString(tree[1]);\n                const sub = hashTreeToString(tree[2]);\n                return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n            }\n            else {\n                throw new Error('Invalid tree structure for labeled');\n            }\n        }\n        case NodeId.Leaf: {\n            if (!tree[1]) {\n                throw new Error('Invalid tree structure for leaf');\n            }\n            else if (Array.isArray(tree[1])) {\n                return JSON.stringify(tree[1]);\n            }\n            return `leaf(...${tree[1].byteLength} bytes)`;\n        }\n        case NodeId.Pruned: {\n            if (!tree[1]) {\n                throw new Error('Invalid tree structure for pruned');\n            }\n            else if (Array.isArray(tree[1])) {\n                return JSON.stringify(tree[1]);\n            }\n            return `pruned(${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(new Uint8Array(tree[1]))}`;\n        }\n        default: {\n            return `unknown(${JSON.stringify(tree[0])})`;\n        }\n    }\n}\nfunction isBufferEqual(a, b) {\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    const a8 = new Uint8Array(a);\n    const b8 = new Uint8Array(b);\n    for (let i = 0; i < a8.length; i++) {\n        if (a8[i] !== b8[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nclass Certificate {\n    constructor(certificate, _rootKey, _canisterId, _blsVerify, \n    // Default to 5 minutes\n    _maxAgeInMinutes = 5) {\n        this._rootKey = _rootKey;\n        this._canisterId = _canisterId;\n        this._blsVerify = _blsVerify;\n        this._maxAgeInMinutes = _maxAgeInMinutes;\n        this.cert = _cbor__WEBPACK_IMPORTED_MODULE_0__.decode(new Uint8Array(certificate));\n    }\n    /**\n     * Create a new instance of a certificate, automatically verifying it. Throws a\n     * CertificateVerificationError if the certificate cannot be verified.\n     * @constructs  Certificate\n     * @param {CreateCertificateOptions} options {@link CreateCertificateOptions}\n     * @param {ArrayBuffer} options.certificate The bytes of the certificate\n     * @param {ArrayBuffer} options.rootKey The root key to verify against\n     * @param {Principal} options.canisterId The effective or signing canister ID\n     * @param {number} options.maxAgeInMinutes The maximum age of the certificate in minutes. Default is 5 minutes.\n     * @throws {CertificateVerificationError}\n     */\n    static async create(options) {\n        let blsVerify = options.blsVerify;\n        if (!blsVerify) {\n            blsVerify = _utils_bls__WEBPACK_IMPORTED_MODULE_5__.blsVerify;\n        }\n        const cert = new Certificate(options.certificate, options.rootKey, options.canisterId, blsVerify, options.maxAgeInMinutes);\n        await cert.verify();\n        return cert;\n    }\n    lookup(path) {\n        // constrain the type of the result, so that empty HashTree is undefined\n        return lookupResultToBuffer(lookup_path(path, this.cert.tree));\n    }\n    lookup_label(label) {\n        return this.lookup([label]);\n    }\n    async verify() {\n        const rootHash = await reconstruct(this.cert.tree);\n        const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n        const sig = this.cert.signature;\n        const key = extractDER(derKey);\n        const msg = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-state-root'), rootHash);\n        let sigVer = false;\n        const lookupTime = this.lookup(['time']);\n        if (!lookupTime) {\n            // Should never happen - time is always present in IC certificates\n            throw new CertificateVerificationError('Certificate does not contain a time');\n        }\n        const FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n        const MAX_AGE_IN_MSEC = this._maxAgeInMinutes * 60 * 1000;\n        const now = Date.now();\n        const earliestCertificateTime = now - MAX_AGE_IN_MSEC;\n        const fiveMinutesFromNow = now + FIVE_MINUTES_IN_MSEC;\n        const certTime = (0,_utils_leb__WEBPACK_IMPORTED_MODULE_6__.decodeTime)(lookupTime);\n        if (certTime.getTime() < earliestCertificateTime) {\n            throw new CertificateVerificationError(`Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` +\n                certTime.toISOString() +\n                ' Current time: ' +\n                new Date(now).toISOString());\n        }\n        else if (certTime.getTime() > fiveMinutesFromNow) {\n            throw new CertificateVerificationError('Certificate is signed more than 5 minutes in the future. Certificate time: ' +\n                certTime.toISOString() +\n                ' Current time: ' +\n                new Date(now).toISOString());\n        }\n        try {\n            sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n        }\n        catch (err) {\n            sigVer = false;\n        }\n        if (!sigVer) {\n            throw new CertificateVerificationError('Signature verification failed');\n        }\n    }\n    async _checkDelegationAndGetKey(d) {\n        if (!d) {\n            return this._rootKey;\n        }\n        const cert = await Certificate.create({\n            certificate: d.certificate,\n            rootKey: this._rootKey,\n            canisterId: this._canisterId,\n            blsVerify: this._blsVerify,\n            // Do not check max age for delegation certificates\n            maxAgeInMinutes: Infinity,\n        });\n        const canisterInRange = check_canister_ranges({\n            canisterId: this._canisterId,\n            subnetId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(new Uint8Array(d.subnet_id)),\n            tree: cert.cert.tree,\n        });\n        if (!canisterInRange) {\n            throw new CertificateVerificationError(`Canister ${this._canisterId} not in range of delegations for subnet 0x${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(d.subnet_id)}`);\n        }\n        const publicKeyLookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);\n        if (!publicKeyLookup) {\n            throw new Error(`Could not find subnet key for subnet 0x${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.toHex)(d.subnet_id)}`);\n        }\n        return publicKeyLookup;\n    }\n}\nconst DER_PREFIX = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.fromHex)('308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100');\nconst KEY_LENGTH = 96;\nfunction extractDER(buf) {\n    const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n    if (buf.byteLength !== expectedLength) {\n        throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n    }\n    const prefix = buf.slice(0, DER_PREFIX.byteLength);\n    if (!isBufferEqual(prefix, DER_PREFIX)) {\n        throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`);\n    }\n    return buf.slice(DER_PREFIX.byteLength);\n}\n/**\n * utility function to constrain the type of a path\n * @param {ArrayBuffer | HashTree | undefined} result - the result of a lookup\n * @returns ArrayBuffer or Undefined\n */\nfunction lookupResultToBuffer(result) {\n    if (result instanceof ArrayBuffer) {\n        return result;\n    }\n    else if (result instanceof Uint8Array) {\n        return result.buffer;\n    }\n    return undefined;\n}\n/**\n * @param t\n */\nasync function reconstruct(t) {\n    switch (t[0]) {\n        case NodeId.Empty:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)(domain_sep('ic-hashtree-empty'));\n        case NodeId.Pruned:\n            return t[1];\n        case NodeId.Leaf:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-leaf'), t[1]));\n        case NodeId.Labeled:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-labeled'), t[1], await reconstruct(t[2])));\n        case NodeId.Fork:\n            return (0,_request_id__WEBPACK_IMPORTED_MODULE_2__.hash)((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(domain_sep('ic-hashtree-fork'), await reconstruct(t[1]), await reconstruct(t[2])));\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction domain_sep(s) {\n    const len = new Uint8Array([s.length]);\n    const str = new TextEncoder().encode(s);\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_3__.concat)(len, str);\n}\n/**\n * @param path\n * @param tree\n */\nfunction lookup_path(path, tree) {\n    if (path.length === 0) {\n        switch (tree[0]) {\n            case NodeId.Leaf: {\n                // should not be undefined\n                if (!tree[1])\n                    throw new Error('Invalid tree structure for leaf');\n                if (tree[1] instanceof ArrayBuffer) {\n                    return tree[1];\n                }\n                else if (tree[1] instanceof Uint8Array) {\n                    return tree[1].buffer;\n                }\n                else\n                    return tree[1];\n            }\n            case NodeId.Fork: {\n                return tree;\n            }\n            default: {\n                return tree;\n            }\n        }\n    }\n    const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n    const t = find_label(label, flatten_forks(tree));\n    if (t) {\n        return lookup_path(path.slice(1), t);\n    }\n}\n/**\n * If the tree is a fork, flatten it into an array of trees\n * @param t - the tree to flatten\n * @returns HashTree[] - the flattened tree\n */\nfunction flatten_forks(t) {\n    switch (t[0]) {\n        case NodeId.Empty:\n            return [];\n        case NodeId.Fork:\n            return flatten_forks(t[1]).concat(flatten_forks(t[2]));\n        default:\n            return [t];\n    }\n}\nfunction find_label(l, trees) {\n    if (trees.length === 0) {\n        return undefined;\n    }\n    for (const t of trees) {\n        if (t[0] === NodeId.Labeled) {\n            const p = t[1];\n            if (isBufferEqual(l, p)) {\n                return t[2];\n            }\n        }\n    }\n}\n/**\n * Check if a canister falls within a range of canisters\n * @param canisterId Principal\n * @param ranges [Principal, Principal][]\n * @returns\n */\nfunction check_canister_ranges(params) {\n    const { canisterId, subnetId, tree } = params;\n    const rangeLookup = lookup_path(['subnet', subnetId.toUint8Array(), 'canister_ranges'], tree);\n    if (!rangeLookup || !(rangeLookup instanceof ArrayBuffer)) {\n        throw new Error(`Could not find canister ranges for subnet ${subnetId}`);\n    }\n    const ranges_arr = _cbor__WEBPACK_IMPORTED_MODULE_0__.decode(rangeLookup);\n    const ranges = ranges_arr.map(v => [\n        _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(v[0]),\n        _dfinity_principal__WEBPACK_IMPORTED_MODULE_4__.Principal.fromUint8Array(v[1]),\n    ]);\n    const canisterInRange = ranges.some(r => r[0].ltEq(canisterId) && r[1].gtEq(canisterId));\n    return canisterInRange;\n}\n//# sourceMappingURL=certificate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vY2VydGlmaWNhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNPO0FBQ0Y7QUFDb0I7QUFDVDtBQUNaO0FBQ007QUFDekM7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLCtDQUFVO0FBQzVEO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGFBQWE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhLGtCQUFrQixjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjLFdBQVcsWUFBWTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQUssMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCLFNBQVM7QUFDbEQsZUFBZSxhQUFhO0FBQzVCLGVBQWUsYUFBYTtBQUM1QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpREFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQVU7QUFDbkM7QUFDQSxzRkFBc0YsdUJBQXVCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0IseURBQVM7QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrREFBK0Qsa0JBQWtCLDJDQUEyQyxvREFBSyxjQUFjO0FBQy9JO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxvREFBSyxjQUFjO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGdCQUFnQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsV0FBVyxZQUFZLE9BQU87QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsaURBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFJLENBQUMscURBQU07QUFDOUI7QUFDQSxtQkFBbUIsaURBQUksQ0FBQyxxREFBTTtBQUM5QjtBQUNBLG1CQUFtQixpREFBSSxDQUFDLHFEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxREFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQSxxRUFBcUUsU0FBUztBQUM5RTtBQUNBLHVCQUF1Qix5Q0FBVztBQUNsQztBQUNBLFFBQVEseURBQVM7QUFDakIsUUFBUSx5REFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9jZXJ0aWZpY2F0ZS5qcz9iMTMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNib3IgZnJvbSAnLi9jYm9yJztcbmltcG9ydCB7IEFnZW50RXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBoYXNoIH0gZnJvbSAnLi9yZXF1ZXN0X2lkJztcbmltcG9ydCB7IGNvbmNhdCwgZnJvbUhleCwgdG9IZXggfSBmcm9tICcuL3V0aWxzL2J1ZmZlcic7XG5pbXBvcnQgeyBQcmluY2lwYWwgfSBmcm9tICdAZGZpbml0eS9wcmluY2lwYWwnO1xuaW1wb3J0ICogYXMgYmxzIGZyb20gJy4vdXRpbHMvYmxzJztcbmltcG9ydCB7IGRlY29kZVRpbWUgfSBmcm9tICcuL3V0aWxzL2xlYic7XG4vKipcbiAqIEEgY2VydGlmaWNhdGUgbWF5IGZhaWwgdmVyaWZpY2F0aW9uIHdpdGggcmVzcGVjdCB0byB0aGUgcHJvdmlkZWQgcHVibGljIGtleVxuICovXG5leHBvcnQgY2xhc3MgQ2VydGlmaWNhdGVWZXJpZmljYXRpb25FcnJvciBleHRlbmRzIEFnZW50RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgICAgICBzdXBlcihgSW52YWxpZCBjZXJ0aWZpY2F0ZTogJHtyZWFzb259YCk7XG4gICAgfVxufVxuY29uc3QgTm9kZUlkID0ge1xuICAgIEVtcHR5OiAwLFxuICAgIEZvcms6IDEsXG4gICAgTGFiZWxlZDogMixcbiAgICBMZWFmOiAzLFxuICAgIFBydW5lZDogNCxcbn07XG5leHBvcnQgeyBOb2RlSWQgfTtcbi8qKlxuICogTWFrZSBhIGh1bWFuIHJlYWRhYmxlIHN0cmluZyBvdXQgb2YgYSBoYXNoIHRyZWUuXG4gKiBAcGFyYW0gdHJlZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRyZWVUb1N0cmluZyh0cmVlKSB7XG4gICAgY29uc3QgaW5kZW50ID0gKHMpID0+IHNcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKHggPT4gJyAgJyArIHgpXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICBmdW5jdGlvbiBsYWJlbFRvU3RyaW5nKGxhYmVsKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIodW5kZWZpbmVkLCB7IGZhdGFsOiB0cnVlIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRlY29kZXIuZGVjb2RlKGxhYmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBgZGF0YSguLi4ke2xhYmVsLmJ5dGVMZW5ndGh9IGJ5dGVzKWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0cmVlWzBdKSB7XG4gICAgICAgIGNhc2UgTm9kZUlkLkVtcHR5OlxuICAgICAgICAgICAgcmV0dXJuICcoKSc7XG4gICAgICAgIGNhc2UgTm9kZUlkLkZvcms6IHtcbiAgICAgICAgICAgIGlmICh0cmVlWzFdIGluc3RhbmNlb2YgQXJyYXkgJiYgdHJlZVsyXSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGhhc2hUcmVlVG9TdHJpbmcodHJlZVsxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBoYXNoVHJlZVRvU3RyaW5nKHRyZWVbMl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBgc3ViKFxcbiBsZWZ0OlxcbiR7aW5kZW50KGxlZnQpfVxcbi0tLVxcbiByaWdodDpcXG4ke2luZGVudChyaWdodCl9XFxuKWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJlZSBzdHJ1Y3R1cmUgZm9yIGZvcmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlIE5vZGVJZC5MYWJlbGVkOiB7XG4gICAgICAgICAgICBpZiAodHJlZVsxXSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICYmIHRyZWVbMl0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gbGFiZWxUb1N0cmluZyh0cmVlWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWIgPSBoYXNoVHJlZVRvU3RyaW5nKHRyZWVbMl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBgbGFiZWwoXFxuIGxhYmVsOlxcbiR7aW5kZW50KGxhYmVsKX1cXG4gc3ViOlxcbiR7aW5kZW50KHN1Yil9XFxuKWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJlZSBzdHJ1Y3R1cmUgZm9yIGxhYmVsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlIE5vZGVJZC5MZWFmOiB7XG4gICAgICAgICAgICBpZiAoIXRyZWVbMV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJlZSBzdHJ1Y3R1cmUgZm9yIGxlYWYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHJlZVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodHJlZVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYGxlYWYoLi4uJHt0cmVlWzFdLmJ5dGVMZW5ndGh9IGJ5dGVzKWA7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBOb2RlSWQuUHJ1bmVkOiB7XG4gICAgICAgICAgICBpZiAoIXRyZWVbMV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJlZSBzdHJ1Y3R1cmUgZm9yIHBydW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0cmVlWzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0cmVlWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBgcHJ1bmVkKCR7dG9IZXgobmV3IFVpbnQ4QXJyYXkodHJlZVsxXSkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcmV0dXJuIGB1bmtub3duKCR7SlNPTi5zdHJpbmdpZnkodHJlZVswXSl9KWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc0J1ZmZlckVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhOCA9IG5ldyBVaW50OEFycmF5KGEpO1xuICAgIGNvbnN0IGI4ID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhOC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYThbaV0gIT09IGI4W2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgY2xhc3MgQ2VydGlmaWNhdGUge1xuICAgIGNvbnN0cnVjdG9yKGNlcnRpZmljYXRlLCBfcm9vdEtleSwgX2NhbmlzdGVySWQsIF9ibHNWZXJpZnksIFxuICAgIC8vIERlZmF1bHQgdG8gNSBtaW51dGVzXG4gICAgX21heEFnZUluTWludXRlcyA9IDUpIHtcbiAgICAgICAgdGhpcy5fcm9vdEtleSA9IF9yb290S2V5O1xuICAgICAgICB0aGlzLl9jYW5pc3RlcklkID0gX2NhbmlzdGVySWQ7XG4gICAgICAgIHRoaXMuX2Jsc1ZlcmlmeSA9IF9ibHNWZXJpZnk7XG4gICAgICAgIHRoaXMuX21heEFnZUluTWludXRlcyA9IF9tYXhBZ2VJbk1pbnV0ZXM7XG4gICAgICAgIHRoaXMuY2VydCA9IGNib3IuZGVjb2RlKG5ldyBVaW50OEFycmF5KGNlcnRpZmljYXRlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBhIGNlcnRpZmljYXRlLCBhdXRvbWF0aWNhbGx5IHZlcmlmeWluZyBpdC4gVGhyb3dzIGFcbiAgICAgKiBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yIGlmIHRoZSBjZXJ0aWZpY2F0ZSBjYW5ub3QgYmUgdmVyaWZpZWQuXG4gICAgICogQGNvbnN0cnVjdHMgIENlcnRpZmljYXRlXG4gICAgICogQHBhcmFtIHtDcmVhdGVDZXJ0aWZpY2F0ZU9wdGlvbnN9IG9wdGlvbnMge0BsaW5rIENyZWF0ZUNlcnRpZmljYXRlT3B0aW9uc31cbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBvcHRpb25zLmNlcnRpZmljYXRlIFRoZSBieXRlcyBvZiB0aGUgY2VydGlmaWNhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBvcHRpb25zLnJvb3RLZXkgVGhlIHJvb3Qga2V5IHRvIHZlcmlmeSBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtQcmluY2lwYWx9IG9wdGlvbnMuY2FuaXN0ZXJJZCBUaGUgZWZmZWN0aXZlIG9yIHNpZ25pbmcgY2FuaXN0ZXIgSURcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tYXhBZ2VJbk1pbnV0ZXMgVGhlIG1heGltdW0gYWdlIG9mIHRoZSBjZXJ0aWZpY2F0ZSBpbiBtaW51dGVzLiBEZWZhdWx0IGlzIDUgbWludXRlcy5cbiAgICAgKiBAdGhyb3dzIHtDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUob3B0aW9ucykge1xuICAgICAgICBsZXQgYmxzVmVyaWZ5ID0gb3B0aW9ucy5ibHNWZXJpZnk7XG4gICAgICAgIGlmICghYmxzVmVyaWZ5KSB7XG4gICAgICAgICAgICBibHNWZXJpZnkgPSBibHMuYmxzVmVyaWZ5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlcnQgPSBuZXcgQ2VydGlmaWNhdGUob3B0aW9ucy5jZXJ0aWZpY2F0ZSwgb3B0aW9ucy5yb290S2V5LCBvcHRpb25zLmNhbmlzdGVySWQsIGJsc1ZlcmlmeSwgb3B0aW9ucy5tYXhBZ2VJbk1pbnV0ZXMpO1xuICAgICAgICBhd2FpdCBjZXJ0LnZlcmlmeSgpO1xuICAgICAgICByZXR1cm4gY2VydDtcbiAgICB9XG4gICAgbG9va3VwKHBhdGgpIHtcbiAgICAgICAgLy8gY29uc3RyYWluIHRoZSB0eXBlIG9mIHRoZSByZXN1bHQsIHNvIHRoYXQgZW1wdHkgSGFzaFRyZWUgaXMgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBsb29rdXBSZXN1bHRUb0J1ZmZlcihsb29rdXBfcGF0aChwYXRoLCB0aGlzLmNlcnQudHJlZSkpO1xuICAgIH1cbiAgICBsb29rdXBfbGFiZWwobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwKFtsYWJlbF0pO1xuICAgIH1cbiAgICBhc3luYyB2ZXJpZnkoKSB7XG4gICAgICAgIGNvbnN0IHJvb3RIYXNoID0gYXdhaXQgcmVjb25zdHJ1Y3QodGhpcy5jZXJ0LnRyZWUpO1xuICAgICAgICBjb25zdCBkZXJLZXkgPSBhd2FpdCB0aGlzLl9jaGVja0RlbGVnYXRpb25BbmRHZXRLZXkodGhpcy5jZXJ0LmRlbGVnYXRpb24pO1xuICAgICAgICBjb25zdCBzaWcgPSB0aGlzLmNlcnQuc2lnbmF0dXJlO1xuICAgICAgICBjb25zdCBrZXkgPSBleHRyYWN0REVSKGRlcktleSk7XG4gICAgICAgIGNvbnN0IG1zZyA9IGNvbmNhdChkb21haW5fc2VwKCdpYy1zdGF0ZS1yb290JyksIHJvb3RIYXNoKTtcbiAgICAgICAgbGV0IHNpZ1ZlciA9IGZhbHNlO1xuICAgICAgICBjb25zdCBsb29rdXBUaW1lID0gdGhpcy5sb29rdXAoWyd0aW1lJ10pO1xuICAgICAgICBpZiAoIWxvb2t1cFRpbWUpIHtcbiAgICAgICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW4gLSB0aW1lIGlzIGFsd2F5cyBwcmVzZW50IGluIElDIGNlcnRpZmljYXRlc1xuICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoJ0NlcnRpZmljYXRlIGRvZXMgbm90IGNvbnRhaW4gYSB0aW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgRklWRV9NSU5VVEVTX0lOX01TRUMgPSA1ICogNjAgKiAxMDAwO1xuICAgICAgICBjb25zdCBNQVhfQUdFX0lOX01TRUMgPSB0aGlzLl9tYXhBZ2VJbk1pbnV0ZXMgKiA2MCAqIDEwMDA7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGVhcmxpZXN0Q2VydGlmaWNhdGVUaW1lID0gbm93IC0gTUFYX0FHRV9JTl9NU0VDO1xuICAgICAgICBjb25zdCBmaXZlTWludXRlc0Zyb21Ob3cgPSBub3cgKyBGSVZFX01JTlVURVNfSU5fTVNFQztcbiAgICAgICAgY29uc3QgY2VydFRpbWUgPSBkZWNvZGVUaW1lKGxvb2t1cFRpbWUpO1xuICAgICAgICBpZiAoY2VydFRpbWUuZ2V0VGltZSgpIDwgZWFybGllc3RDZXJ0aWZpY2F0ZVRpbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yKGBDZXJ0aWZpY2F0ZSBpcyBzaWduZWQgbW9yZSB0aGFuICR7dGhpcy5fbWF4QWdlSW5NaW51dGVzfSBtaW51dGVzIGluIHRoZSBwYXN0LiBDZXJ0aWZpY2F0ZSB0aW1lOiBgICtcbiAgICAgICAgICAgICAgICBjZXJ0VGltZS50b0lTT1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAnIEN1cnJlbnQgdGltZTogJyArXG4gICAgICAgICAgICAgICAgbmV3IERhdGUobm93KS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjZXJ0VGltZS5nZXRUaW1lKCkgPiBmaXZlTWludXRlc0Zyb21Ob3cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDZXJ0aWZpY2F0ZVZlcmlmaWNhdGlvbkVycm9yKCdDZXJ0aWZpY2F0ZSBpcyBzaWduZWQgbW9yZSB0aGFuIDUgbWludXRlcyBpbiB0aGUgZnV0dXJlLiBDZXJ0aWZpY2F0ZSB0aW1lOiAnICtcbiAgICAgICAgICAgICAgICBjZXJ0VGltZS50b0lTT1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAnIEN1cnJlbnQgdGltZTogJyArXG4gICAgICAgICAgICAgICAgbmV3IERhdGUobm93KS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2lnVmVyID0gYXdhaXQgdGhpcy5fYmxzVmVyaWZ5KG5ldyBVaW50OEFycmF5KGtleSksIG5ldyBVaW50OEFycmF5KHNpZyksIG5ldyBVaW50OEFycmF5KG1zZykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHNpZ1ZlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2lnVmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ2VydGlmaWNhdGVWZXJpZmljYXRpb25FcnJvcignU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY2hlY2tEZWxlZ2F0aW9uQW5kR2V0S2V5KGQpIHtcbiAgICAgICAgaWYgKCFkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdEtleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZXJ0ID0gYXdhaXQgQ2VydGlmaWNhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgIGNlcnRpZmljYXRlOiBkLmNlcnRpZmljYXRlLFxuICAgICAgICAgICAgcm9vdEtleTogdGhpcy5fcm9vdEtleSxcbiAgICAgICAgICAgIGNhbmlzdGVySWQ6IHRoaXMuX2NhbmlzdGVySWQsXG4gICAgICAgICAgICBibHNWZXJpZnk6IHRoaXMuX2Jsc1ZlcmlmeSxcbiAgICAgICAgICAgIC8vIERvIG5vdCBjaGVjayBtYXggYWdlIGZvciBkZWxlZ2F0aW9uIGNlcnRpZmljYXRlc1xuICAgICAgICAgICAgbWF4QWdlSW5NaW51dGVzOiBJbmZpbml0eSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbmlzdGVySW5SYW5nZSA9IGNoZWNrX2NhbmlzdGVyX3Jhbmdlcyh7XG4gICAgICAgICAgICBjYW5pc3RlcklkOiB0aGlzLl9jYW5pc3RlcklkLFxuICAgICAgICAgICAgc3VibmV0SWQ6IFByaW5jaXBhbC5mcm9tVWludDhBcnJheShuZXcgVWludDhBcnJheShkLnN1Ym5ldF9pZCkpLFxuICAgICAgICAgICAgdHJlZTogY2VydC5jZXJ0LnRyZWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNhbmlzdGVySW5SYW5nZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENlcnRpZmljYXRlVmVyaWZpY2F0aW9uRXJyb3IoYENhbmlzdGVyICR7dGhpcy5fY2FuaXN0ZXJJZH0gbm90IGluIHJhbmdlIG9mIGRlbGVnYXRpb25zIGZvciBzdWJuZXQgMHgke3RvSGV4KGQuc3VibmV0X2lkKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWJsaWNLZXlMb29rdXAgPSBjZXJ0Lmxvb2t1cChbJ3N1Ym5ldCcsIGQuc3VibmV0X2lkLCAncHVibGljX2tleSddKTtcbiAgICAgICAgaWYgKCFwdWJsaWNLZXlMb29rdXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgc3VibmV0IGtleSBmb3Igc3VibmV0IDB4JHt0b0hleChkLnN1Ym5ldF9pZCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleUxvb2t1cDtcbiAgICB9XG59XG5jb25zdCBERVJfUFJFRklYID0gZnJvbUhleCgnMzA4MTgyMzAxZDA2MGQyYjA2MDEwNDAxODJkYzdjMDUwMzAxMDIwMTA2MGMyYjA2MDEwNDAxODJkYzdjMDUwMzAyMDEwMzYxMDAnKTtcbmNvbnN0IEtFWV9MRU5HVEggPSA5NjtcbmZ1bmN0aW9uIGV4dHJhY3RERVIoYnVmKSB7XG4gICAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSBERVJfUFJFRklYLmJ5dGVMZW5ndGggKyBLRVlfTEVOR1RIO1xuICAgIGlmIChidWYuYnl0ZUxlbmd0aCAhPT0gZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQkxTIERFUi1lbmNvZGVkIHB1YmxpYyBrZXkgbXVzdCBiZSAke2V4cGVjdGVkTGVuZ3RofSBieXRlcyBsb25nYCk7XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IGJ1Zi5zbGljZSgwLCBERVJfUFJFRklYLmJ5dGVMZW5ndGgpO1xuICAgIGlmICghaXNCdWZmZXJFcXVhbChwcmVmaXgsIERFUl9QUkVGSVgpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEJMUyBERVItZW5jb2RlZCBwdWJsaWMga2V5IGlzIGludmFsaWQuIEV4cGVjdCB0aGUgZm9sbG93aW5nIHByZWZpeDogJHtERVJfUFJFRklYfSwgYnV0IGdldCAke3ByZWZpeH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi5zbGljZShERVJfUFJFRklYLmJ5dGVMZW5ndGgpO1xufVxuLyoqXG4gKiB1dGlsaXR5IGZ1bmN0aW9uIHRvIGNvbnN0cmFpbiB0aGUgdHlwZSBvZiBhIHBhdGhcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXIgfCBIYXNoVHJlZSB8IHVuZGVmaW5lZH0gcmVzdWx0IC0gdGhlIHJlc3VsdCBvZiBhIGxvb2t1cFxuICogQHJldHVybnMgQXJyYXlCdWZmZXIgb3IgVW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb29rdXBSZXN1bHRUb0J1ZmZlcihyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQHBhcmFtIHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlY29uc3RydWN0KHQpIHtcbiAgICBzd2l0Y2ggKHRbMF0pIHtcbiAgICAgICAgY2FzZSBOb2RlSWQuRW1wdHk6XG4gICAgICAgICAgICByZXR1cm4gaGFzaChkb21haW5fc2VwKCdpYy1oYXNodHJlZS1lbXB0eScpKTtcbiAgICAgICAgY2FzZSBOb2RlSWQuUHJ1bmVkOlxuICAgICAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICAgIGNhc2UgTm9kZUlkLkxlYWY6XG4gICAgICAgICAgICByZXR1cm4gaGFzaChjb25jYXQoZG9tYWluX3NlcCgnaWMtaGFzaHRyZWUtbGVhZicpLCB0WzFdKSk7XG4gICAgICAgIGNhc2UgTm9kZUlkLkxhYmVsZWQ6XG4gICAgICAgICAgICByZXR1cm4gaGFzaChjb25jYXQoZG9tYWluX3NlcCgnaWMtaGFzaHRyZWUtbGFiZWxlZCcpLCB0WzFdLCBhd2FpdCByZWNvbnN0cnVjdCh0WzJdKSkpO1xuICAgICAgICBjYXNlIE5vZGVJZC5Gb3JrOlxuICAgICAgICAgICAgcmV0dXJuIGhhc2goY29uY2F0KGRvbWFpbl9zZXAoJ2ljLWhhc2h0cmVlLWZvcmsnKSwgYXdhaXQgcmVjb25zdHJ1Y3QodFsxXSksIGF3YWl0IHJlY29uc3RydWN0KHRbMl0pKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZG9tYWluX3NlcChzKSB7XG4gICAgY29uc3QgbGVuID0gbmV3IFVpbnQ4QXJyYXkoW3MubGVuZ3RoXSk7XG4gICAgY29uc3Qgc3RyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHMpO1xuICAgIHJldHVybiBjb25jYXQobGVuLCBzdHIpO1xufVxuLyoqXG4gKiBAcGFyYW0gcGF0aFxuICogQHBhcmFtIHRyZWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvb2t1cF9wYXRoKHBhdGgsIHRyZWUpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3dpdGNoICh0cmVlWzBdKSB7XG4gICAgICAgICAgICBjYXNlIE5vZGVJZC5MZWFmOiB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBpZiAoIXRyZWVbMV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmVlIHN0cnVjdHVyZSBmb3IgbGVhZicpO1xuICAgICAgICAgICAgICAgIGlmICh0cmVlWzFdIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyZWVbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyZWVbMV0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmVlWzFdLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJlZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTm9kZUlkLkZvcms6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYWJlbCA9IHR5cGVvZiBwYXRoWzBdID09PSAnc3RyaW5nJyA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShwYXRoWzBdKSA6IHBhdGhbMF07XG4gICAgY29uc3QgdCA9IGZpbmRfbGFiZWwobGFiZWwsIGZsYXR0ZW5fZm9ya3ModHJlZSkpO1xuICAgIGlmICh0KSB7XG4gICAgICAgIHJldHVybiBsb29rdXBfcGF0aChwYXRoLnNsaWNlKDEpLCB0KTtcbiAgICB9XG59XG4vKipcbiAqIElmIHRoZSB0cmVlIGlzIGEgZm9yaywgZmxhdHRlbiBpdCBpbnRvIGFuIGFycmF5IG9mIHRyZWVzXG4gKiBAcGFyYW0gdCAtIHRoZSB0cmVlIHRvIGZsYXR0ZW5cbiAqIEByZXR1cm5zIEhhc2hUcmVlW10gLSB0aGUgZmxhdHRlbmVkIHRyZWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5fZm9ya3ModCkge1xuICAgIHN3aXRjaCAodFswXSkge1xuICAgICAgICBjYXNlIE5vZGVJZC5FbXB0eTpcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgY2FzZSBOb2RlSWQuRm9yazpcbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuX2ZvcmtzKHRbMV0pLmNvbmNhdChmbGF0dGVuX2ZvcmtzKHRbMl0pKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbdF07XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZF9sYWJlbChsLCB0cmVlcykge1xuICAgIGlmICh0cmVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0IG9mIHRyZWVzKSB7XG4gICAgICAgIGlmICh0WzBdID09PSBOb2RlSWQuTGFiZWxlZCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IHRbMV07XG4gICAgICAgICAgICBpZiAoaXNCdWZmZXJFcXVhbChsLCBwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0WzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiBhIGNhbmlzdGVyIGZhbGxzIHdpdGhpbiBhIHJhbmdlIG9mIGNhbmlzdGVyc1xuICogQHBhcmFtIGNhbmlzdGVySWQgUHJpbmNpcGFsXG4gKiBAcGFyYW0gcmFuZ2VzIFtQcmluY2lwYWwsIFByaW5jaXBhbF1bXVxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrX2NhbmlzdGVyX3JhbmdlcyhwYXJhbXMpIHtcbiAgICBjb25zdCB7IGNhbmlzdGVySWQsIHN1Ym5ldElkLCB0cmVlIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmFuZ2VMb29rdXAgPSBsb29rdXBfcGF0aChbJ3N1Ym5ldCcsIHN1Ym5ldElkLnRvVWludDhBcnJheSgpLCAnY2FuaXN0ZXJfcmFuZ2VzJ10sIHRyZWUpO1xuICAgIGlmICghcmFuZ2VMb29rdXAgfHwgIShyYW5nZUxvb2t1cCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGNhbmlzdGVyIHJhbmdlcyBmb3Igc3VibmV0ICR7c3VibmV0SWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlc19hcnIgPSBjYm9yLmRlY29kZShyYW5nZUxvb2t1cCk7XG4gICAgY29uc3QgcmFuZ2VzID0gcmFuZ2VzX2Fyci5tYXAodiA9PiBbXG4gICAgICAgIFByaW5jaXBhbC5mcm9tVWludDhBcnJheSh2WzBdKSxcbiAgICAgICAgUHJpbmNpcGFsLmZyb21VaW50OEFycmF5KHZbMV0pLFxuICAgIF0pO1xuICAgIGNvbnN0IGNhbmlzdGVySW5SYW5nZSA9IHJhbmdlcy5zb21lKHIgPT4gclswXS5sdEVxKGNhbmlzdGVySWQpICYmIHJbMV0uZ3RFcShjYW5pc3RlcklkKSk7XG4gICAgcmV0dXJuIGNhbmlzdGVySW5SYW5nZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNlcnRpZmljYXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/certificate.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/der.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/der.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER_COSE_OID: function() { return /* binding */ DER_COSE_OID; },\n/* harmony export */   ED25519_OID: function() { return /* binding */ ED25519_OID; },\n/* harmony export */   SECP256K1_OID: function() { return /* binding */ SECP256K1_OID; },\n/* harmony export */   decodeLen: function() { return /* binding */ decodeLen; },\n/* harmony export */   decodeLenBytes: function() { return /* binding */ decodeLenBytes; },\n/* harmony export */   encodeLen: function() { return /* binding */ encodeLen; },\n/* harmony export */   encodeLenBytes: function() { return /* binding */ encodeLenBytes; },\n/* harmony export */   unwrapDER: function() { return /* binding */ unwrapDER; },\n/* harmony export */   wrapDER: function() { return /* binding */ wrapDER; }\n/* harmony export */ });\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/buffer */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\nconst encodeLenBytes = (len) => {\n    if (len <= 0x7f) {\n        return 1;\n    }\n    else if (len <= 0xff) {\n        return 2;\n    }\n    else if (len <= 0xffff) {\n        return 3;\n    }\n    else if (len <= 0xffffff) {\n        return 4;\n    }\n    else {\n        throw new Error('Length too long (> 4 bytes)');\n    }\n};\nconst encodeLen = (buf, offset, len) => {\n    if (len <= 0x7f) {\n        buf[offset] = len;\n        return 1;\n    }\n    else if (len <= 0xff) {\n        buf[offset] = 0x81;\n        buf[offset + 1] = len;\n        return 2;\n    }\n    else if (len <= 0xffff) {\n        buf[offset] = 0x82;\n        buf[offset + 1] = len >> 8;\n        buf[offset + 2] = len;\n        return 3;\n    }\n    else if (len <= 0xffffff) {\n        buf[offset] = 0x83;\n        buf[offset + 1] = len >> 16;\n        buf[offset + 2] = len >> 8;\n        buf[offset + 3] = len;\n        return 4;\n    }\n    else {\n        throw new Error('Length too long (> 4 bytes)');\n    }\n};\nconst decodeLenBytes = (buf, offset) => {\n    if (buf[offset] < 0x80)\n        return 1;\n    if (buf[offset] === 0x80)\n        throw new Error('Invalid length 0');\n    if (buf[offset] === 0x81)\n        return 2;\n    if (buf[offset] === 0x82)\n        return 3;\n    if (buf[offset] === 0x83)\n        return 4;\n    throw new Error('Length too long (> 4 bytes)');\n};\nconst decodeLen = (buf, offset) => {\n    const lenBytes = decodeLenBytes(buf, offset);\n    if (lenBytes === 1)\n        return buf[offset];\n    else if (lenBytes === 2)\n        return buf[offset + 1];\n    else if (lenBytes === 3)\n        return (buf[offset + 1] << 8) + buf[offset + 2];\n    else if (lenBytes === 4)\n        return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];\n    throw new Error('Length too long (> 4 bytes)');\n};\n/**\n * A DER encoded `SEQUENCE(OID)` for DER-encoded-COSE\n */\nconst DER_COSE_OID = Uint8Array.from([\n    ...[0x30, 0x0c],\n    ...[0x06, 0x0a],\n    ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0xb8, 0x43, 0x01, 0x01], // DER encoded COSE\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for the Ed25519 algorithm\n */\nconst ED25519_OID = Uint8Array.from([\n    ...[0x30, 0x05],\n    ...[0x06, 0x03],\n    ...[0x2b, 0x65, 0x70], // id-Ed25519 OID\n]);\n/**\n * A DER encoded `SEQUENCE(OID)` for secp256k1 with the ECDSA algorithm\n */\nconst SECP256K1_OID = Uint8Array.from([\n    ...[0x30, 0x10],\n    ...[0x06, 0x07],\n    ...[0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01],\n    ...[0x06, 0x05],\n    ...[0x2b, 0x81, 0x04, 0x00, 0x0a], // OID secp256k1\n]);\n/**\n * Wraps the given `payload` in a DER encoding tagged with the given encoded `oid` like so:\n * `SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param payload The payload to encode as the bit string\n * @param oid The DER encoded (and SEQUENCE wrapped!) OID to tag the payload with\n */\nfunction wrapDER(payload, oid) {\n    // The Bit String header needs to include the unused bit count byte in its length\n    const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);\n    const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;\n    let offset = 0;\n    const buf = new Uint8Array(1 + encodeLenBytes(len) + len);\n    // Sequence\n    buf[offset++] = 0x30;\n    // Sequence Length\n    offset += encodeLen(buf, offset, len);\n    // OID\n    buf.set(oid, offset);\n    offset += oid.byteLength;\n    // Bit String Header\n    buf[offset++] = 0x03;\n    offset += encodeLen(buf, offset, payload.byteLength + 1);\n    // 0 padding\n    buf[offset++] = 0x00;\n    buf.set(new Uint8Array(payload), offset);\n    return buf;\n}\n/**\n * Extracts a payload from the given `derEncoded` data, and checks that it was tagged with the given `oid`.\n *\n * `derEncoded = SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param derEncoded The DER encoded and tagged data\n * @param oid The DER encoded (and SEQUENCE wrapped!) expected OID\n * @returns The unwrapped payload\n */\nconst unwrapDER = (derEncoded, oid) => {\n    let offset = 0;\n    const expect = (n, msg) => {\n        if (buf[offset++] !== n) {\n            throw new Error('Expected: ' + msg);\n        }\n    };\n    const buf = new Uint8Array(derEncoded);\n    expect(0x30, 'sequence');\n    offset += decodeLenBytes(buf, offset);\n    if (!(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.bufEquals)(buf.slice(offset, offset + oid.byteLength), oid)) {\n        throw new Error('Not the expected OID.');\n    }\n    offset += oid.byteLength;\n    expect(0x03, 'bit string');\n    const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding\n    offset += decodeLenBytes(buf, offset);\n    expect(0x00, '0 padding');\n    const result = buf.slice(offset);\n    if (payloadLen !== result.length) {\n        throw new Error(`DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`);\n    }\n    return result;\n};\n//# sourceMappingURL=der.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDcEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFlBQVksZ0JBQWdCLGNBQWM7QUFDM0c7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL2Rlci5qcz8zODgxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJ1ZkVxdWFscyB9IGZyb20gJy4vdXRpbHMvYnVmZmVyJztcbmV4cG9ydCBjb25zdCBlbmNvZGVMZW5CeXRlcyA9IChsZW4pID0+IHtcbiAgICBpZiAobGVuIDw9IDB4N2YpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA8PSAweGZmKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPD0gMHhmZmZmKSB7XG4gICAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPD0gMHhmZmZmZmYpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCB0b28gbG9uZyAoPiA0IGJ5dGVzKScpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZW5jb2RlTGVuID0gKGJ1Ziwgb2Zmc2V0LCBsZW4pID0+IHtcbiAgICBpZiAobGVuIDw9IDB4N2YpIHtcbiAgICAgICAgYnVmW29mZnNldF0gPSBsZW47XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPD0gMHhmZikge1xuICAgICAgICBidWZbb2Zmc2V0XSA9IDB4ODE7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyAxXSA9IGxlbjtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA8PSAweGZmZmYpIHtcbiAgICAgICAgYnVmW29mZnNldF0gPSAweDgyO1xuICAgICAgICBidWZbb2Zmc2V0ICsgMV0gPSBsZW4gPj4gODtcbiAgICAgICAgYnVmW29mZnNldCArIDJdID0gbGVuO1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuIDw9IDB4ZmZmZmZmKSB7XG4gICAgICAgIGJ1ZltvZmZzZXRdID0gMHg4MztcbiAgICAgICAgYnVmW29mZnNldCArIDFdID0gbGVuID4+IDE2O1xuICAgICAgICBidWZbb2Zmc2V0ICsgMl0gPSBsZW4gPj4gODtcbiAgICAgICAgYnVmW29mZnNldCArIDNdID0gbGVuO1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIHRvbyBsb25nICg+IDQgYnl0ZXMpJyk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBkZWNvZGVMZW5CeXRlcyA9IChidWYsIG9mZnNldCkgPT4ge1xuICAgIGlmIChidWZbb2Zmc2V0XSA8IDB4ODApXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChidWZbb2Zmc2V0XSA9PT0gMHg4MClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxlbmd0aCAwJyk7XG4gICAgaWYgKGJ1ZltvZmZzZXRdID09PSAweDgxKVxuICAgICAgICByZXR1cm4gMjtcbiAgICBpZiAoYnVmW29mZnNldF0gPT09IDB4ODIpXG4gICAgICAgIHJldHVybiAzO1xuICAgIGlmIChidWZbb2Zmc2V0XSA9PT0gMHg4MylcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggdG9vIGxvbmcgKD4gNCBieXRlcyknKTtcbn07XG5leHBvcnQgY29uc3QgZGVjb2RlTGVuID0gKGJ1Ziwgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgbGVuQnl0ZXMgPSBkZWNvZGVMZW5CeXRlcyhidWYsIG9mZnNldCk7XG4gICAgaWYgKGxlbkJ5dGVzID09PSAxKVxuICAgICAgICByZXR1cm4gYnVmW29mZnNldF07XG4gICAgZWxzZSBpZiAobGVuQnl0ZXMgPT09IDIpXG4gICAgICAgIHJldHVybiBidWZbb2Zmc2V0ICsgMV07XG4gICAgZWxzZSBpZiAobGVuQnl0ZXMgPT09IDMpXG4gICAgICAgIHJldHVybiAoYnVmW29mZnNldCArIDFdIDw8IDgpICsgYnVmW29mZnNldCArIDJdO1xuICAgIGVsc2UgaWYgKGxlbkJ5dGVzID09PSA0KVxuICAgICAgICByZXR1cm4gKGJ1ZltvZmZzZXQgKyAxXSA8PCAxNikgKyAoYnVmW29mZnNldCArIDJdIDw8IDgpICsgYnVmW29mZnNldCArIDNdO1xuICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIHRvbyBsb25nICg+IDQgYnl0ZXMpJyk7XG59O1xuLyoqXG4gKiBBIERFUiBlbmNvZGVkIGBTRVFVRU5DRShPSUQpYCBmb3IgREVSLWVuY29kZWQtQ09TRVxuICovXG5leHBvcnQgY29uc3QgREVSX0NPU0VfT0lEID0gVWludDhBcnJheS5mcm9tKFtcbiAgICAuLi5bMHgzMCwgMHgwY10sXG4gICAgLi4uWzB4MDYsIDB4MGFdLFxuICAgIC4uLlsweDJiLCAweDA2LCAweDAxLCAweDA0LCAweDAxLCAweDgzLCAweGI4LCAweDQzLCAweDAxLCAweDAxXSwgLy8gREVSIGVuY29kZWQgQ09TRVxuXSk7XG4vKipcbiAqIEEgREVSIGVuY29kZWQgYFNFUVVFTkNFKE9JRClgIGZvciB0aGUgRWQyNTUxOSBhbGdvcml0aG1cbiAqL1xuZXhwb3J0IGNvbnN0IEVEMjU1MTlfT0lEID0gVWludDhBcnJheS5mcm9tKFtcbiAgICAuLi5bMHgzMCwgMHgwNV0sXG4gICAgLi4uWzB4MDYsIDB4MDNdLFxuICAgIC4uLlsweDJiLCAweDY1LCAweDcwXSwgLy8gaWQtRWQyNTUxOSBPSURcbl0pO1xuLyoqXG4gKiBBIERFUiBlbmNvZGVkIGBTRVFVRU5DRShPSUQpYCBmb3Igc2VjcDI1NmsxIHdpdGggdGhlIEVDRFNBIGFsZ29yaXRobVxuICovXG5leHBvcnQgY29uc3QgU0VDUDI1NksxX09JRCA9IFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgLi4uWzB4MzAsIDB4MTBdLFxuICAgIC4uLlsweDA2LCAweDA3XSxcbiAgICAuLi5bMHgyYSwgMHg4NiwgMHg0OCwgMHhjZSwgMHgzZCwgMHgwMiwgMHgwMV0sXG4gICAgLi4uWzB4MDYsIDB4MDVdLFxuICAgIC4uLlsweDJiLCAweDgxLCAweDA0LCAweDAwLCAweDBhXSwgLy8gT0lEIHNlY3AyNTZrMVxuXSk7XG4vKipcbiAqIFdyYXBzIHRoZSBnaXZlbiBgcGF5bG9hZGAgaW4gYSBERVIgZW5jb2RpbmcgdGFnZ2VkIHdpdGggdGhlIGdpdmVuIGVuY29kZWQgYG9pZGAgbGlrZSBzbzpcbiAqIGBTRVFVRU5DRShvaWQsIEJJVFNUUklORyhwYXlsb2FkKSlgXG4gKlxuICogQHBhcmFtIHBheWxvYWQgVGhlIHBheWxvYWQgdG8gZW5jb2RlIGFzIHRoZSBiaXQgc3RyaW5nXG4gKiBAcGFyYW0gb2lkIFRoZSBERVIgZW5jb2RlZCAoYW5kIFNFUVVFTkNFIHdyYXBwZWQhKSBPSUQgdG8gdGFnIHRoZSBwYXlsb2FkIHdpdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBERVIocGF5bG9hZCwgb2lkKSB7XG4gICAgLy8gVGhlIEJpdCBTdHJpbmcgaGVhZGVyIG5lZWRzIHRvIGluY2x1ZGUgdGhlIHVudXNlZCBiaXQgY291bnQgYnl0ZSBpbiBpdHMgbGVuZ3RoXG4gICAgY29uc3QgYml0U3RyaW5nSGVhZGVyTGVuZ3RoID0gMiArIGVuY29kZUxlbkJ5dGVzKHBheWxvYWQuYnl0ZUxlbmd0aCArIDEpO1xuICAgIGNvbnN0IGxlbiA9IG9pZC5ieXRlTGVuZ3RoICsgYml0U3RyaW5nSGVhZGVyTGVuZ3RoICsgcGF5bG9hZC5ieXRlTGVuZ3RoO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KDEgKyBlbmNvZGVMZW5CeXRlcyhsZW4pICsgbGVuKTtcbiAgICAvLyBTZXF1ZW5jZVxuICAgIGJ1ZltvZmZzZXQrK10gPSAweDMwO1xuICAgIC8vIFNlcXVlbmNlIExlbmd0aFxuICAgIG9mZnNldCArPSBlbmNvZGVMZW4oYnVmLCBvZmZzZXQsIGxlbik7XG4gICAgLy8gT0lEXG4gICAgYnVmLnNldChvaWQsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IG9pZC5ieXRlTGVuZ3RoO1xuICAgIC8vIEJpdCBTdHJpbmcgSGVhZGVyXG4gICAgYnVmW29mZnNldCsrXSA9IDB4MDM7XG4gICAgb2Zmc2V0ICs9IGVuY29kZUxlbihidWYsIG9mZnNldCwgcGF5bG9hZC5ieXRlTGVuZ3RoICsgMSk7XG4gICAgLy8gMCBwYWRkaW5nXG4gICAgYnVmW29mZnNldCsrXSA9IDB4MDA7XG4gICAgYnVmLnNldChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgb2Zmc2V0KTtcbiAgICByZXR1cm4gYnVmO1xufVxuLyoqXG4gKiBFeHRyYWN0cyBhIHBheWxvYWQgZnJvbSB0aGUgZ2l2ZW4gYGRlckVuY29kZWRgIGRhdGEsIGFuZCBjaGVja3MgdGhhdCBpdCB3YXMgdGFnZ2VkIHdpdGggdGhlIGdpdmVuIGBvaWRgLlxuICpcbiAqIGBkZXJFbmNvZGVkID0gU0VRVUVOQ0Uob2lkLCBCSVRTVFJJTkcocGF5bG9hZCkpYFxuICpcbiAqIEBwYXJhbSBkZXJFbmNvZGVkIFRoZSBERVIgZW5jb2RlZCBhbmQgdGFnZ2VkIGRhdGFcbiAqIEBwYXJhbSBvaWQgVGhlIERFUiBlbmNvZGVkIChhbmQgU0VRVUVOQ0Ugd3JhcHBlZCEpIGV4cGVjdGVkIE9JRFxuICogQHJldHVybnMgVGhlIHVud3JhcHBlZCBwYXlsb2FkXG4gKi9cbmV4cG9ydCBjb25zdCB1bndyYXBERVIgPSAoZGVyRW5jb2RlZCwgb2lkKSA9PiB7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgZXhwZWN0ID0gKG4sIG1zZykgPT4ge1xuICAgICAgICBpZiAoYnVmW29mZnNldCsrXSAhPT0gbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZDogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGRlckVuY29kZWQpO1xuICAgIGV4cGVjdCgweDMwLCAnc2VxdWVuY2UnKTtcbiAgICBvZmZzZXQgKz0gZGVjb2RlTGVuQnl0ZXMoYnVmLCBvZmZzZXQpO1xuICAgIGlmICghYnVmRXF1YWxzKGJ1Zi5zbGljZShvZmZzZXQsIG9mZnNldCArIG9pZC5ieXRlTGVuZ3RoKSwgb2lkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCB0aGUgZXhwZWN0ZWQgT0lELicpO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gb2lkLmJ5dGVMZW5ndGg7XG4gICAgZXhwZWN0KDB4MDMsICdiaXQgc3RyaW5nJyk7XG4gICAgY29uc3QgcGF5bG9hZExlbiA9IGRlY29kZUxlbihidWYsIG9mZnNldCkgLSAxOyAvLyBTdWJ0cmFjdGluZyAxIHRvIGFjY291bnQgZm9yIHRoZSAwIHBhZGRpbmdcbiAgICBvZmZzZXQgKz0gZGVjb2RlTGVuQnl0ZXMoYnVmLCBvZmZzZXQpO1xuICAgIGV4cGVjdCgweDAwLCAnMCBwYWRkaW5nJyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYnVmLnNsaWNlKG9mZnNldCk7XG4gICAgaWYgKHBheWxvYWRMZW4gIT09IHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBERVIgcGF5bG9hZCBtaXNtYXRjaDogRXhwZWN0ZWQgbGVuZ3RoICR7cGF5bG9hZExlbn0gYWN0dWFsIGxlbmd0aCAke3Jlc3VsdC5sZW5ndGh9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/der.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/errors.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/errors.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgentError: function() { return /* binding */ AgentError; }\n/* harmony export */ });\n/**\n * An error that happens in the Agent. This is the root of all errors and should be used\n * everywhere in the Agent code (this package).\n *\n * @todo https://github.com/dfinity/agent-js/issues/420\n */\nclass AgentError extends Error {\n    constructor(message) {\n        super(message);\n        this.message = message;\n        Object.setPrototypeOf(this, AgentError.prototype);\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9lcnJvcnMuanM/ODQwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFuIGVycm9yIHRoYXQgaGFwcGVucyBpbiB0aGUgQWdlbnQuIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYWxsIGVycm9ycyBhbmQgc2hvdWxkIGJlIHVzZWRcbiAqIGV2ZXJ5d2hlcmUgaW4gdGhlIEFnZW50IGNvZGUgKHRoaXMgcGFja2FnZSkuXG4gKlxuICogQHRvZG8gaHR0cHM6Ly9naXRodWIuY29tL2RmaW5pdHkvYWdlbnQtanMvaXNzdWVzLzQyMFxuICovXG5leHBvcnQgY2xhc3MgQWdlbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQWdlbnRFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/errors.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/fetch_candid.js":
/*!********************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/fetch_candid.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchCandid: function() { return /* binding */ fetchCandid; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"../../../node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _canisterStatus_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./canisterStatus/index */ \"../../../node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\");\n/* harmony import */ var _agent_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./agent/http */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/http/index.js\");\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actor */ \"../../../node_modules/@dfinity/agent/lib/esm/actor.js\");\n\n\n\n\n/**\n * Retrieves the Candid interface for the specified canister.\n *\n * @param agent The agent to use for the request (usually an `HttpAgent`)\n * @param canisterId A string corresponding to the canister ID\n * @returns Candid source code\n */\nasync function fetchCandid(canisterId, agent) {\n    if (!agent) {\n        // Create an anonymous `HttpAgent` (adapted from Candid UI)\n        agent = new _agent_http__WEBPACK_IMPORTED_MODULE_2__.HttpAgent();\n        if (agent.isLocal()) {\n            agent.fetchRootKey();\n        }\n    }\n    // Attempt to use canister metadata\n    const status = await _canisterStatus_index__WEBPACK_IMPORTED_MODULE_1__.request({\n        agent,\n        canisterId: _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromText(canisterId),\n        paths: ['candid'],\n    });\n    const candid = status.get('candid');\n    if (candid) {\n        return candid;\n    }\n    // Use `__get_candid_interface_tmp_hack` for canisters without Candid metadata\n    const tmpHackInterface = ({ IDL }) => IDL.Service({\n        __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ['query']),\n    });\n    const actor = _actor__WEBPACK_IMPORTED_MODULE_3__.Actor.createActor(tmpHackInterface, { agent, canisterId });\n    return (await actor.__get_candid_interface_tmp_hack());\n}\n//# sourceMappingURL=fetch_candid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vZmV0Y2hfY2FuZGlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStDO0FBQ1U7QUFDaEI7QUFDVDtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixrREFBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBEQUFzQjtBQUMvQztBQUNBLG9CQUFvQix5REFBUztBQUM3QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEtBQUs7QUFDckM7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCLHlDQUFLLGlDQUFpQyxtQkFBbUI7QUFDM0U7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS9mZXRjaF9jYW5kaWQuanM/ZjFhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcmluY2lwYWwgfSBmcm9tICdAZGZpbml0eS9wcmluY2lwYWwnO1xuaW1wb3J0ICogYXMgQ2FuaXN0ZXJTdGF0dXMgZnJvbSAnLi9jYW5pc3RlclN0YXR1cy9pbmRleCc7XG5pbXBvcnQgeyBIdHRwQWdlbnQgfSBmcm9tICcuL2FnZW50L2h0dHAnO1xuaW1wb3J0IHsgQWN0b3IgfSBmcm9tICcuL2FjdG9yJztcbi8qKlxuICogUmV0cmlldmVzIHRoZSBDYW5kaWQgaW50ZXJmYWNlIGZvciB0aGUgc3BlY2lmaWVkIGNhbmlzdGVyLlxuICpcbiAqIEBwYXJhbSBhZ2VudCBUaGUgYWdlbnQgdG8gdXNlIGZvciB0aGUgcmVxdWVzdCAodXN1YWxseSBhbiBgSHR0cEFnZW50YClcbiAqIEBwYXJhbSBjYW5pc3RlcklkIEEgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNhbmlzdGVyIElEXG4gKiBAcmV0dXJucyBDYW5kaWQgc291cmNlIGNvZGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQ2FuZGlkKGNhbmlzdGVySWQsIGFnZW50KSB7XG4gICAgaWYgKCFhZ2VudCkge1xuICAgICAgICAvLyBDcmVhdGUgYW4gYW5vbnltb3VzIGBIdHRwQWdlbnRgIChhZGFwdGVkIGZyb20gQ2FuZGlkIFVJKVxuICAgICAgICBhZ2VudCA9IG5ldyBIdHRwQWdlbnQoKTtcbiAgICAgICAgaWYgKGFnZW50LmlzTG9jYWwoKSkge1xuICAgICAgICAgICAgYWdlbnQuZmV0Y2hSb290S2V5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXR0ZW1wdCB0byB1c2UgY2FuaXN0ZXIgbWV0YWRhdGFcbiAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBDYW5pc3RlclN0YXR1cy5yZXF1ZXN0KHtcbiAgICAgICAgYWdlbnQsXG4gICAgICAgIGNhbmlzdGVySWQ6IFByaW5jaXBhbC5mcm9tVGV4dChjYW5pc3RlcklkKSxcbiAgICAgICAgcGF0aHM6IFsnY2FuZGlkJ10sXG4gICAgfSk7XG4gICAgY29uc3QgY2FuZGlkID0gc3RhdHVzLmdldCgnY2FuZGlkJyk7XG4gICAgaWYgKGNhbmRpZCkge1xuICAgICAgICByZXR1cm4gY2FuZGlkO1xuICAgIH1cbiAgICAvLyBVc2UgYF9fZ2V0X2NhbmRpZF9pbnRlcmZhY2VfdG1wX2hhY2tgIGZvciBjYW5pc3RlcnMgd2l0aG91dCBDYW5kaWQgbWV0YWRhdGFcbiAgICBjb25zdCB0bXBIYWNrSW50ZXJmYWNlID0gKHsgSURMIH0pID0+IElETC5TZXJ2aWNlKHtcbiAgICAgICAgX19nZXRfY2FuZGlkX2ludGVyZmFjZV90bXBfaGFjazogSURMLkZ1bmMoW10sIFtJREwuVGV4dF0sIFsncXVlcnknXSksXG4gICAgfSk7XG4gICAgY29uc3QgYWN0b3IgPSBBY3Rvci5jcmVhdGVBY3Rvcih0bXBIYWNrSW50ZXJmYWNlLCB7IGFnZW50LCBjYW5pc3RlcklkIH0pO1xuICAgIHJldHVybiAoYXdhaXQgYWN0b3IuX19nZXRfY2FuZGlkX2ludGVyZmFjZV90bXBfaGFjaygpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoX2NhbmRpZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/fetch_candid.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/index.js":
/*!*************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACTOR_METHOD_WITH_HTTP_DETAILS: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.ACTOR_METHOD_WITH_HTTP_DETAILS; },\n/* harmony export */   Actor: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.Actor; },\n/* harmony export */   ActorCallError: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.ActorCallError; },\n/* harmony export */   AnonymousIdentity: function() { return /* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_4__.AnonymousIdentity; },\n/* harmony export */   CanisterInstallMode: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.CanisterInstallMode; },\n/* harmony export */   CanisterStatus: function() { return /* reexport module object */ _canisterStatus__WEBPACK_IMPORTED_MODULE_15__; },\n/* harmony export */   Cbor: function() { return /* reexport module object */ _cbor__WEBPACK_IMPORTED_MODULE_16__; },\n/* harmony export */   Certificate: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.Certificate; },\n/* harmony export */   CertificateVerificationError: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.CertificateVerificationError; },\n/* harmony export */   DER_COSE_OID: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.DER_COSE_OID; },\n/* harmony export */   ED25519_OID: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.ED25519_OID; },\n/* harmony export */   Ed25519PublicKey: function() { return /* reexport safe */ _public_key__WEBPACK_IMPORTED_MODULE_9__.Ed25519PublicKey; },\n/* harmony export */   Expiry: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.Expiry; },\n/* harmony export */   HttpAgent: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.HttpAgent; },\n/* harmony export */   IdentityInvalidError: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.IdentityInvalidError; },\n/* harmony export */   NodeId: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.NodeId; },\n/* harmony export */   ProxyAgent: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyAgent; },\n/* harmony export */   ProxyMessageKind: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyMessageKind; },\n/* harmony export */   ProxyStubAgent: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ProxyStubAgent; },\n/* harmony export */   QueryCallRejectedError: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.QueryCallRejectedError; },\n/* harmony export */   ReplicaRejectCode: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.ReplicaRejectCode; },\n/* harmony export */   RequestStatusResponseStatus: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.RequestStatusResponseStatus; },\n/* harmony export */   SECP256K1_OID: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.SECP256K1_OID; },\n/* harmony export */   SignIdentity: function() { return /* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_4__.SignIdentity; },\n/* harmony export */   SubmitRequestType: function() { return /* reexport safe */ _agent_http_types__WEBPACK_IMPORTED_MODULE_3__.SubmitRequestType; },\n/* harmony export */   UpdateCallRejectedError: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.UpdateCallRejectedError; },\n/* harmony export */   blsVerify: function() { return /* reexport safe */ _utils_bls__WEBPACK_IMPORTED_MODULE_11__.blsVerify; },\n/* harmony export */   bufEquals: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.bufEquals; },\n/* harmony export */   check_canister_ranges: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.check_canister_ranges; },\n/* harmony export */   compare: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.compare; },\n/* harmony export */   concat: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.concat; },\n/* harmony export */   createAssetCanisterActor: function() { return /* reexport safe */ _canisters_asset__WEBPACK_IMPORTED_MODULE_5__.createAssetCanisterActor; },\n/* harmony export */   createIdentityDescriptor: function() { return /* reexport safe */ _auth__WEBPACK_IMPORTED_MODULE_4__.createIdentityDescriptor; },\n/* harmony export */   decodeLen: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.decodeLen; },\n/* harmony export */   decodeLenBytes: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.decodeLenBytes; },\n/* harmony export */   encodeLen: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.encodeLen; },\n/* harmony export */   encodeLenBytes: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.encodeLenBytes; },\n/* harmony export */   fetchCandid: function() { return /* reexport safe */ _fetch_candid__WEBPACK_IMPORTED_MODULE_8__.fetchCandid; },\n/* harmony export */   flatten_forks: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.flatten_forks; },\n/* harmony export */   fromHex: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.fromHex; },\n/* harmony export */   getDefaultAgent: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.getDefaultAgent; },\n/* harmony export */   getManagementCanister: function() { return /* reexport safe */ _actor__WEBPACK_IMPORTED_MODULE_0__.getManagementCanister; },\n/* harmony export */   hash: function() { return /* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.hash; },\n/* harmony export */   hashOfMap: function() { return /* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.hashOfMap; },\n/* harmony export */   hashTreeToString: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.hashTreeToString; },\n/* harmony export */   hashValue: function() { return /* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.hashValue; },\n/* harmony export */   httpHeadersTransform: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.httpHeadersTransform; },\n/* harmony export */   lookupResultToBuffer: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.lookupResultToBuffer; },\n/* harmony export */   lookup_path: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.lookup_path; },\n/* harmony export */   makeExpiryTransform: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.makeExpiryTransform; },\n/* harmony export */   makeNonce: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.makeNonce; },\n/* harmony export */   makeNonceTransform: function() { return /* reexport safe */ _agent__WEBPACK_IMPORTED_MODULE_1__.makeNonceTransform; },\n/* harmony export */   polling: function() { return /* reexport module object */ _polling__WEBPACK_IMPORTED_MODULE_14__; },\n/* harmony export */   randomNumber: function() { return /* reexport safe */ _utils_random__WEBPACK_IMPORTED_MODULE_13__.randomNumber; },\n/* harmony export */   reconstruct: function() { return /* reexport safe */ _certificate__WEBPACK_IMPORTED_MODULE_6__.reconstruct; },\n/* harmony export */   requestIdOf: function() { return /* reexport safe */ _request_id__WEBPACK_IMPORTED_MODULE_10__.requestIdOf; },\n/* harmony export */   toHex: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.toHex; },\n/* harmony export */   uint8ToBuf: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_12__.uint8ToBuf; },\n/* harmony export */   unwrapDER: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.unwrapDER; },\n/* harmony export */   verify: function() { return /* reexport safe */ _utils_bls__WEBPACK_IMPORTED_MODULE_11__.verify; },\n/* harmony export */   wrapDER: function() { return /* reexport safe */ _der__WEBPACK_IMPORTED_MODULE_7__.wrapDER; }\n/* harmony export */ });\n/* harmony import */ var _actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actor */ \"../../../node_modules/@dfinity/agent/lib/esm/actor.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/index.js\");\n/* harmony import */ var _agent_http_transforms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./agent/http/transforms */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js\");\n/* harmony import */ var _agent_http_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./agent/http/types */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/http/types.js\");\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./auth */ \"../../../node_modules/@dfinity/agent/lib/esm/auth.js\");\n/* harmony import */ var _canisters_asset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./canisters/asset */ \"../../../node_modules/@dfinity/agent/lib/esm/canisters/asset.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./certificate */ \"../../../node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _der__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./der */ \"../../../node_modules/@dfinity/agent/lib/esm/der.js\");\n/* harmony import */ var _fetch_candid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fetch_candid */ \"../../../node_modules/@dfinity/agent/lib/esm/fetch_candid.js\");\n/* harmony import */ var _public_key__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./public_key */ \"../../../node_modules/@dfinity/agent/lib/esm/public_key.js\");\n/* harmony import */ var _request_id__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./request_id */ \"../../../node_modules/@dfinity/agent/lib/esm/request_id.js\");\n/* harmony import */ var _utils_bls__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/bls */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/bls.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/buffer */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _utils_random__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/random */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/random.js\");\n/* harmony import */ var _polling__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./polling */ \"../../../node_modules/@dfinity/agent/lib/esm/polling/index.js\");\n/* harmony import */ var _canisterStatus__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./canisterStatus */ \"../../../node_modules/@dfinity/agent/lib/esm/canisterStatus/index.js\");\n/* harmony import */ var _cbor__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./cbor */ \"../../../node_modules/@dfinity/agent/lib/esm/cbor.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The CanisterStatus utility is used to request structured data directly from the IC public API. This data can be accessed using agent.readState, but CanisterStatus provides a helpful abstraction with some known paths.\n *\n * You can request a canisters Controllers, ModuleHash, Candid interface, Subnet, or Time, or provide a custom path {@link CanisterStatus.CustomPath} and pass arbitrary buffers for valid paths identified in https://internetcomputer.org/docs/current/references/ic-interface-spec.\n *\n * The primary method for this namespace is {@link CanisterStatus.request}\n */\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdCO0FBQ0E7QUFDZ0I7QUFDTDtBQUNaO0FBQ1c7QUFDSjtBQUNSO0FBQ1M7QUFDRjtBQUNBO0FBQ0Q7QUFDRztBQUNBO0FBQ007QUFDckM7QUFDQTtBQUNBO0FBQ0EscUhBQXFILGlDQUFpQztBQUN0SjtBQUNBLDZDQUE2QztBQUM3QztBQUNtRDtBQUNwQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vaW5kZXguanM/OGVhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2FjdG9yJztcbmV4cG9ydCAqIGZyb20gJy4vYWdlbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9hZ2VudC9odHRwL3RyYW5zZm9ybXMnO1xuZXhwb3J0ICogZnJvbSAnLi9hZ2VudC9odHRwL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vYXV0aCc7XG5leHBvcnQgKiBmcm9tICcuL2NhbmlzdGVycy9hc3NldCc7XG5leHBvcnQgKiBmcm9tICcuL2NlcnRpZmljYXRlJztcbmV4cG9ydCAqIGZyb20gJy4vZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vZmV0Y2hfY2FuZGlkJztcbmV4cG9ydCAqIGZyb20gJy4vcHVibGljX2tleSc7XG5leHBvcnQgKiBmcm9tICcuL3JlcXVlc3RfaWQnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9ibHMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9idWZmZXInO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9yYW5kb20nO1xuZXhwb3J0ICogYXMgcG9sbGluZyBmcm9tICcuL3BvbGxpbmcnO1xuLyoqXG4gKiBUaGUgQ2FuaXN0ZXJTdGF0dXMgdXRpbGl0eSBpcyB1c2VkIHRvIHJlcXVlc3Qgc3RydWN0dXJlZCBkYXRhIGRpcmVjdGx5IGZyb20gdGhlIElDIHB1YmxpYyBBUEkuIFRoaXMgZGF0YSBjYW4gYmUgYWNjZXNzZWQgdXNpbmcgYWdlbnQucmVhZFN0YXRlLCBidXQgQ2FuaXN0ZXJTdGF0dXMgcHJvdmlkZXMgYSBoZWxwZnVsIGFic3RyYWN0aW9uIHdpdGggc29tZSBrbm93biBwYXRocy5cbiAqXG4gKiBZb3UgY2FuIHJlcXVlc3QgYSBjYW5pc3RlcnMgQ29udHJvbGxlcnMsIE1vZHVsZUhhc2gsIENhbmRpZCBpbnRlcmZhY2UsIFN1Ym5ldCwgb3IgVGltZSwgb3IgcHJvdmlkZSBhIGN1c3RvbSBwYXRoIHtAbGluayBDYW5pc3RlclN0YXR1cy5DdXN0b21QYXRofSBhbmQgcGFzcyBhcmJpdHJhcnkgYnVmZmVycyBmb3IgdmFsaWQgcGF0aHMgaWRlbnRpZmllZCBpbiBodHRwczovL2ludGVybmV0Y29tcHV0ZXIub3JnL2RvY3MvY3VycmVudC9yZWZlcmVuY2VzL2ljLWludGVyZmFjZS1zcGVjLlxuICpcbiAqIFRoZSBwcmltYXJ5IG1ldGhvZCBmb3IgdGhpcyBuYW1lc3BhY2UgaXMge0BsaW5rIENhbmlzdGVyU3RhdHVzLnJlcXVlc3R9XG4gKi9cbmV4cG9ydCAqIGFzIENhbmlzdGVyU3RhdHVzIGZyb20gJy4vY2FuaXN0ZXJTdGF0dXMnO1xuZXhwb3J0ICogYXMgQ2JvciBmcm9tICcuL2Nib3InO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/index.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/polling/index.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/polling/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultStrategy: function() { return /* reexport safe */ _strategy__WEBPACK_IMPORTED_MODULE_3__.defaultStrategy; },\n/* harmony export */   pollForResponse: function() { return /* binding */ pollForResponse; },\n/* harmony export */   strategy: function() { return /* reexport module object */ _strategy__WEBPACK_IMPORTED_MODULE_3__; }\n/* harmony export */ });\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../agent */ \"../../../node_modules/@dfinity/agent/lib/esm/agent/index.js\");\n/* harmony import */ var _certificate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../certificate */ \"../../../node_modules/@dfinity/agent/lib/esm/certificate.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/buffer */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n/* harmony import */ var _strategy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strategy */ \"../../../node_modules/@dfinity/agent/lib/esm/polling/strategy.js\");\n\n\n\n\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n */\nasync function pollForResponse(agent, canisterId, requestId, strategy, \n// eslint-disable-next-line\nrequest, blsVerify) {\n    var _a;\n    const path = [new TextEncoder().encode('request_status'), requestId];\n    const currentRequest = request !== null && request !== void 0 ? request : (await ((_a = agent.createReadStateRequest) === null || _a === void 0 ? void 0 : _a.call(agent, { paths: [path] })));\n    const state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n    if (agent.rootKey == null)\n        throw new Error('Agent root key not initialized before polling');\n    const cert = await _certificate__WEBPACK_IMPORTED_MODULE_1__.Certificate.create({\n        certificate: state.certificate,\n        rootKey: agent.rootKey,\n        canisterId: canisterId,\n        blsVerify,\n    });\n    const maybeBuf = cert.lookup([...path, new TextEncoder().encode('status')]);\n    let status;\n    if (typeof maybeBuf === 'undefined') {\n        // Missing requestId means we need to wait\n        status = _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Unknown;\n    }\n    else {\n        status = new TextDecoder().decode(maybeBuf);\n    }\n    switch (status) {\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Replied: {\n            return cert.lookup([...path, 'reply']);\n        }\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Received:\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Unknown:\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Processing:\n            // Execute the polling strategy, then retry.\n            await strategy(canisterId, requestId, status);\n            return pollForResponse(agent, canisterId, requestId, strategy, currentRequest);\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Rejected: {\n            const rejectCode = new Uint8Array(cert.lookup([...path, 'reject_code']))[0];\n            const rejectMessage = new TextDecoder().decode(cert.lookup([...path, 'reject_message']));\n            throw new Error(`Call was rejected:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(requestId)}\\n` +\n                `  Reject code: ${rejectCode}\\n` +\n                `  Reject text: ${rejectMessage}\\n`);\n        }\n        case _agent__WEBPACK_IMPORTED_MODULE_0__.RequestStatusResponseStatus.Done:\n            // This is _technically_ not an error, but we still didn't see the `Replied` status so\n            // we don't know the result and cannot decode it.\n            throw new Error(`Call was marked as done but we never saw the reply:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.toHex)(requestId)}\\n`);\n    }\n    throw new Error('unreachable');\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcG9sbGluZy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXVEO0FBQ1Y7QUFDTDtBQUNEO0FBQ007QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdMQUFnTCxlQUFlO0FBQy9MLHNEQUFzRCxlQUFlO0FBQ3JFO0FBQ0E7QUFDQSx1QkFBdUIscURBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0RBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtEQUEyQjtBQUN4QztBQUNBO0FBQ0EsYUFBYSwrREFBMkI7QUFDeEMsYUFBYSwrREFBMkI7QUFDeEMsYUFBYSwrREFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrREFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9EQUFLLFlBQVk7QUFDbEQsa0NBQWtDLFdBQVc7QUFDN0Msa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQSxhQUFhLCtEQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQUssWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcG9sbGluZy9pbmRleC5qcz8xZjBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cyB9IGZyb20gJy4uL2FnZW50JztcbmltcG9ydCB7IENlcnRpZmljYXRlIH0gZnJvbSAnLi4vY2VydGlmaWNhdGUnO1xuaW1wb3J0IHsgdG9IZXggfSBmcm9tICcuLi91dGlscy9idWZmZXInO1xuZXhwb3J0ICogYXMgc3RyYXRlZ3kgZnJvbSAnLi9zdHJhdGVneSc7XG5leHBvcnQgeyBkZWZhdWx0U3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWd5Jztcbi8qKlxuICogUG9sbHMgdGhlIElDIHRvIGNoZWNrIHRoZSBzdGF0dXMgb2YgdGhlIGdpdmVuIHJlcXVlc3QgdGhlblxuICogcmV0dXJucyB0aGUgcmVzcG9uc2UgYnl0ZXMgb25jZSB0aGUgcmVxdWVzdCBoYXMgYmVlbiBwcm9jZXNzZWQuXG4gKiBAcGFyYW0gYWdlbnQgVGhlIGFnZW50IHRvIHVzZSB0byBwb2xsIHJlYWRfc3RhdGUuXG4gKiBAcGFyYW0gY2FuaXN0ZXJJZCBUaGUgZWZmZWN0aXZlIGNhbmlzdGVyIElELlxuICogQHBhcmFtIHJlcXVlc3RJZCBUaGUgUmVxdWVzdCBJRCB0byBwb2xsIHN0YXR1cyBmb3IuXG4gKiBAcGFyYW0gc3RyYXRlZ3kgQSBwb2xsaW5nIHN0cmF0ZWd5LlxuICogQHBhcmFtIHJlcXVlc3QgUmVxdWVzdCBmb3IgdGhlIHJlYWRTdGF0ZSBjYWxsLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcG9sbEZvclJlc3BvbnNlKGFnZW50LCBjYW5pc3RlcklkLCByZXF1ZXN0SWQsIHN0cmF0ZWd5LCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxucmVxdWVzdCwgYmxzVmVyaWZ5KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBhdGggPSBbbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdyZXF1ZXN0X3N0YXR1cycpLCByZXF1ZXN0SWRdO1xuICAgIGNvbnN0IGN1cnJlbnRSZXF1ZXN0ID0gcmVxdWVzdCAhPT0gbnVsbCAmJiByZXF1ZXN0ICE9PSB2b2lkIDAgPyByZXF1ZXN0IDogKGF3YWl0ICgoX2EgPSBhZ2VudC5jcmVhdGVSZWFkU3RhdGVSZXF1ZXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChhZ2VudCwgeyBwYXRoczogW3BhdGhdIH0pKSk7XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCBhZ2VudC5yZWFkU3RhdGUoY2FuaXN0ZXJJZCwgeyBwYXRoczogW3BhdGhdIH0sIHVuZGVmaW5lZCwgY3VycmVudFJlcXVlc3QpO1xuICAgIGlmIChhZ2VudC5yb290S2V5ID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWdlbnQgcm9vdCBrZXkgbm90IGluaXRpYWxpemVkIGJlZm9yZSBwb2xsaW5nJyk7XG4gICAgY29uc3QgY2VydCA9IGF3YWl0IENlcnRpZmljYXRlLmNyZWF0ZSh7XG4gICAgICAgIGNlcnRpZmljYXRlOiBzdGF0ZS5jZXJ0aWZpY2F0ZSxcbiAgICAgICAgcm9vdEtleTogYWdlbnQucm9vdEtleSxcbiAgICAgICAgY2FuaXN0ZXJJZDogY2FuaXN0ZXJJZCxcbiAgICAgICAgYmxzVmVyaWZ5LFxuICAgIH0pO1xuICAgIGNvbnN0IG1heWJlQnVmID0gY2VydC5sb29rdXAoWy4uLnBhdGgsIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnc3RhdHVzJyldKTtcbiAgICBsZXQgc3RhdHVzO1xuICAgIGlmICh0eXBlb2YgbWF5YmVCdWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIE1pc3NpbmcgcmVxdWVzdElkIG1lYW5zIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgICBzdGF0dXMgPSBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMuVW5rbm93bjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXR1cyA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtYXliZUJ1Zik7XG4gICAgfVxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzLlJlcGxpZWQ6IHtcbiAgICAgICAgICAgIHJldHVybiBjZXJ0Lmxvb2t1cChbLi4ucGF0aCwgJ3JlcGx5J10pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgUmVxdWVzdFN0YXR1c1Jlc3BvbnNlU3RhdHVzLlJlY2VpdmVkOlxuICAgICAgICBjYXNlIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cy5Vbmtub3duOlxuICAgICAgICBjYXNlIFJlcXVlc3RTdGF0dXNSZXNwb25zZVN0YXR1cy5Qcm9jZXNzaW5nOlxuICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgcG9sbGluZyBzdHJhdGVneSwgdGhlbiByZXRyeS5cbiAgICAgICAgICAgIGF3YWl0IHN0cmF0ZWd5KGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKTtcbiAgICAgICAgICAgIHJldHVybiBwb2xsRm9yUmVzcG9uc2UoYWdlbnQsIGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RyYXRlZ3ksIGN1cnJlbnRSZXF1ZXN0KTtcbiAgICAgICAgY2FzZSBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMuUmVqZWN0ZWQ6IHtcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdENvZGUgPSBuZXcgVWludDhBcnJheShjZXJ0Lmxvb2t1cChbLi4ucGF0aCwgJ3JlamVjdF9jb2RlJ10pKVswXTtcbiAgICAgICAgICAgIGNvbnN0IHJlamVjdE1lc3NhZ2UgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoY2VydC5sb29rdXAoWy4uLnBhdGgsICdyZWplY3RfbWVzc2FnZSddKSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGwgd2FzIHJlamVjdGVkOlxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIFJlcXVlc3QgSUQ6ICR7dG9IZXgocmVxdWVzdElkKX1cXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZWplY3QgY29kZTogJHtyZWplY3RDb2RlfVxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIFJlamVjdCB0ZXh0OiAke3JlamVjdE1lc3NhZ2V9XFxuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBSZXF1ZXN0U3RhdHVzUmVzcG9uc2VTdGF0dXMuRG9uZTpcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgX3RlY2huaWNhbGx5XyBub3QgYW4gZXJyb3IsIGJ1dCB3ZSBzdGlsbCBkaWRuJ3Qgc2VlIHRoZSBgUmVwbGllZGAgc3RhdHVzIHNvXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBrbm93IHRoZSByZXN1bHQgYW5kIGNhbm5vdCBkZWNvZGUgaXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGwgd2FzIG1hcmtlZCBhcyBkb25lIGJ1dCB3ZSBuZXZlciBzYXcgdGhlIHJlcGx5OlxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIFJlcXVlc3QgSUQ6ICR7dG9IZXgocmVxdWVzdElkKX1cXG5gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZScpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/polling/index.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/polling/strategy.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/polling/strategy.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   backoff: function() { return /* binding */ backoff; },\n/* harmony export */   chain: function() { return /* binding */ chain; },\n/* harmony export */   conditionalDelay: function() { return /* binding */ conditionalDelay; },\n/* harmony export */   defaultStrategy: function() { return /* binding */ defaultStrategy; },\n/* harmony export */   maxAttempts: function() { return /* binding */ maxAttempts; },\n/* harmony export */   once: function() { return /* binding */ once; },\n/* harmony export */   throttle: function() { return /* binding */ throttle; },\n/* harmony export */   timeout: function() { return /* binding */ timeout; }\n/* harmony export */ });\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/buffer */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nfunction defaultStrategy() {\n    return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n/**\n * Predicate that returns true once.\n */\nfunction once() {\n    let first = true;\n    return async () => {\n        if (first) {\n            first = false;\n            return true;\n        }\n        return false;\n    };\n}\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nfunction conditionalDelay(condition, timeInMsec) {\n    return async (canisterId, requestId, status) => {\n        if (await condition(canisterId, requestId, status)) {\n            return new Promise(resolve => setTimeout(resolve, timeInMsec));\n        }\n    };\n}\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nfunction maxAttempts(count) {\n    let attempts = count;\n    return async (canisterId, requestId, status) => {\n        if (--attempts <= 0) {\n            throw new Error(`Failed to retrieve a reply for request after ${count} attempts:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(requestId)}\\n` +\n                `  Request status: ${status}\\n`);\n        }\n    };\n}\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nfunction throttle(throttleInMsec) {\n    return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nfunction timeout(timeInMsec) {\n    const end = Date.now() + timeInMsec;\n    return async (canisterId, requestId, status) => {\n        if (Date.now() > end) {\n            throw new Error(`Request timed out after ${timeInMsec} msec:\\n` +\n                `  Request ID: ${(0,_utils_buffer__WEBPACK_IMPORTED_MODULE_0__.toHex)(requestId)}\\n` +\n                `  Request status: ${status}\\n`);\n        }\n    };\n}\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nfunction backoff(startingThrottleInMsec, backoffFactor) {\n    let currentThrottling = startingThrottleInMsec;\n    return () => new Promise(resolve => setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n    }, currentThrottling));\n}\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nfunction chain(...strategies) {\n    return async (canisterId, requestId, status) => {\n        for (const a of strategies) {\n            await a(canisterId, requestId, status);\n        }\n    };\n}\n//# sourceMappingURL=strategy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcG9sbGluZy9zdHJhdGVneS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxPQUFPO0FBQ25GLGlDQUFpQyxvREFBSyxZQUFZO0FBQ2xELHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FLGlDQUFpQyxvREFBSyxZQUFZO0FBQ2xELHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcG9sbGluZy9zdHJhdGVneS5qcz82NDE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvSGV4IH0gZnJvbSAnLi4vdXRpbHMvYnVmZmVyJztcbmNvbnN0IEZJVkVfTUlOVVRFU19JTl9NU0VDID0gNSAqIDYwICogMTAwMDtcbi8qKlxuICogQSBiZXN0IHByYWN0aWNlcyBwb2xsaW5nIHN0cmF0ZWd5OiB3YWl0IDIgc2Vjb25kcyBiZWZvcmUgdGhlIGZpcnN0IHBvbGwsIHRoZW4gMSBzZWNvbmRcbiAqIHdpdGggYW4gZXhwb25lbnRpYWwgYmFja29mZiBmYWN0b3Igb2YgMS4yLiBUaW1lb3V0IGFmdGVyIDUgbWludXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRTdHJhdGVneSgpIHtcbiAgICByZXR1cm4gY2hhaW4oY29uZGl0aW9uYWxEZWxheShvbmNlKCksIDEwMDApLCBiYWNrb2ZmKDEwMDAsIDEuMiksIHRpbWVvdXQoRklWRV9NSU5VVEVTX0lOX01TRUMpKTtcbn1cbi8qKlxuICogUHJlZGljYXRlIHRoYXQgcmV0dXJucyB0cnVlIG9uY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmNlKCkge1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG4vKipcbiAqIERlbGF5IHRoZSBwb2xsaW5nIG9uY2UuXG4gKiBAcGFyYW0gY29uZGl0aW9uIEEgcHJlZGljYXRlIHRoYXQgaW5kaWNhdGVzIHdoZW4gdG8gZGVsYXkuXG4gKiBAcGFyYW0gdGltZUluTXNlYyBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25kaXRpb25hbERlbGF5KGNvbmRpdGlvbiwgdGltZUluTXNlYykge1xuICAgIHJldHVybiBhc3luYyAoY2FuaXN0ZXJJZCwgcmVxdWVzdElkLCBzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKGF3YWl0IGNvbmRpdGlvbihjYW5pc3RlcklkLCByZXF1ZXN0SWQsIHN0YXR1cykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZUluTXNlYykpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogRXJyb3Igb3V0IGFmdGVyIGEgbWF4aW11bSBudW1iZXIgb2YgcG9sbGluZyBoYXMgYmVlbiBkb25lLlxuICogQHBhcmFtIGNvdW50IFRoZSBtYXhpbXVtIGF0dGVtcHRzIHRvIHBvbGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXhBdHRlbXB0cyhjb3VudCkge1xuICAgIGxldCBhdHRlbXB0cyA9IGNvdW50O1xuICAgIHJldHVybiBhc3luYyAoY2FuaXN0ZXJJZCwgcmVxdWVzdElkLCBzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKC0tYXR0ZW1wdHMgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmV0cmlldmUgYSByZXBseSBmb3IgcmVxdWVzdCBhZnRlciAke2NvdW50fSBhdHRlbXB0czpcXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZXF1ZXN0IElEOiAke3RvSGV4KHJlcXVlc3RJZCl9XFxuYCArXG4gICAgICAgICAgICAgICAgYCAgUmVxdWVzdCBzdGF0dXM6ICR7c3RhdHVzfVxcbmApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogVGhyb3R0bGUgcG9sbGluZy5cbiAqIEBwYXJhbSB0aHJvdHRsZUluTXNlYyBBbW91bnQgaW4gbWlsbGlzZWNvbmQgdG8gd2FpdCBiZXR3ZWVuIGVhY2ggcG9sbGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKHRocm90dGxlSW5Nc2VjKSB7XG4gICAgcmV0dXJuICgpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aHJvdHRsZUluTXNlYykpO1xufVxuLyoqXG4gKiBSZWplY3QgYSBjYWxsIGFmdGVyIGEgY2VydGFpbiBhbW91bnQgb2YgdGltZS5cbiAqIEBwYXJhbSB0aW1lSW5Nc2VjIFRpbWUgaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgcG9sbGluZyBzaG91bGQgYmUgcmVqZWN0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lb3V0KHRpbWVJbk1zZWMpIHtcbiAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpICsgdGltZUluTXNlYztcbiAgICByZXR1cm4gYXN5bmMgKGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKSA9PiB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpID4gZW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3QgdGltZWQgb3V0IGFmdGVyICR7dGltZUluTXNlY30gbXNlYzpcXG5gICtcbiAgICAgICAgICAgICAgICBgICBSZXF1ZXN0IElEOiAke3RvSGV4KHJlcXVlc3RJZCl9XFxuYCArXG4gICAgICAgICAgICAgICAgYCAgUmVxdWVzdCBzdGF0dXM6ICR7c3RhdHVzfVxcbmApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQSBzdHJhdGVneSB0aGF0IHRocm90dGxlLCBidXQgdXNpbmcgYW4gZXhwb25lbnRpYWwgYmFja29mZiBzdHJhdGVneS5cbiAqIEBwYXJhbSBzdGFydGluZ1Rocm90dGxlSW5Nc2VjIFRoZSB0aHJvdHRsZSBpbiBtaWxsaXNlY29uZHMgdG8gc3RhcnQgd2l0aC5cbiAqIEBwYXJhbSBiYWNrb2ZmRmFjdG9yIFRoZSBmYWN0b3IgdG8gbXVsdGlwbGUgdGhlIHRocm90dGxlIHRpbWUgYmV0d2VlbiBldmVyeSBwb2xsLiBGb3JcbiAqICAgZXhhbXBsZSBpZiB1c2luZyAyLCB0aGUgdGhyb3R0bGUgd2lsbCBkb3VibGUgYmV0d2VlbiBldmVyeSBydW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYWNrb2ZmKHN0YXJ0aW5nVGhyb3R0bGVJbk1zZWMsIGJhY2tvZmZGYWN0b3IpIHtcbiAgICBsZXQgY3VycmVudFRocm90dGxpbmcgPSBzdGFydGluZ1Rocm90dGxlSW5Nc2VjO1xuICAgIHJldHVybiAoKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjdXJyZW50VGhyb3R0bGluZyAqPSBiYWNrb2ZmRmFjdG9yO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSwgY3VycmVudFRocm90dGxpbmcpKTtcbn1cbi8qKlxuICogQ2hhaW4gbXVsdGlwbGUgcG9sbGluZyBzdHJhdGVneS4gVGhpcyBfY2hhaW5zXyB0aGUgc3RyYXRlZ2llcywgc28gaWYgeW91IHBhc3MgaW4sXG4gKiBzYXksIHR3byB0aHJvdHRsaW5nIHN0cmF0ZWd5IG9mIDEgc2Vjb25kLCBpdCB3aWxsIHJlc3VsdCBpbiBhIHRocm90dGxlIG9mIDIgc2Vjb25kcy5cbiAqIEBwYXJhbSBzdHJhdGVnaWVzIEEgc3RyYXRlZ3kgbGlzdCB0byBjaGFpbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYWluKC4uLnN0cmF0ZWdpZXMpIHtcbiAgICByZXR1cm4gYXN5bmMgKGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBzdHJhdGVnaWVzKSB7XG4gICAgICAgICAgICBhd2FpdCBhKGNhbmlzdGVySWQsIHJlcXVlc3RJZCwgc3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJhdGVneS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/polling/strategy.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/public_key.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/public_key.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ed25519PublicKey: function() { return /* binding */ Ed25519PublicKey; }\n/* harmony export */ });\n/* harmony import */ var _der__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./der */ \"../../../node_modules/@dfinity/agent/lib/esm/der.js\");\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Ed25519PublicKey_rawKey, _Ed25519PublicKey_derKey;\n\nclass Ed25519PublicKey {\n    // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n    constructor(key) {\n        _Ed25519PublicKey_rawKey.set(this, void 0);\n        _Ed25519PublicKey_derKey.set(this, void 0);\n        if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n            throw new Error('An Ed25519 public key must be exactly 32bytes long');\n        }\n        __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, key, \"f\");\n        __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, Ed25519PublicKey.derEncode(key), \"f\");\n    }\n    static from(key) {\n        return this.fromDer(key.toDer());\n    }\n    static fromRaw(rawKey) {\n        return new Ed25519PublicKey(rawKey);\n    }\n    static fromDer(derKey) {\n        return new Ed25519PublicKey(this.derDecode(derKey));\n    }\n    static derEncode(publicKey) {\n        return (0,_der__WEBPACK_IMPORTED_MODULE_0__.wrapDER)(publicKey, _der__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID).buffer;\n    }\n    static derDecode(key) {\n        const unwrapped = (0,_der__WEBPACK_IMPORTED_MODULE_0__.unwrapDER)(key, _der__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID);\n        if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n            throw new Error('An Ed25519 public key must be exactly 32bytes long');\n        }\n        return unwrapped;\n    }\n    get rawKey() {\n        return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, \"f\");\n    }\n    get derKey() {\n        return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, \"f\");\n    }\n    toDer() {\n        return this.derKey;\n    }\n    toRaw() {\n        return this.rawKey;\n    }\n}\n_Ed25519PublicKey_rawKey = new WeakMap(), _Ed25519PublicKey_derKey = new WeakMap();\n// The length of Ed25519 public keys is always 32 bytes.\nEd25519PublicKey.RAW_KEY_LENGTH = 32;\n//# sourceMappingURL=public_key.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcHVibGljX2tleS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDhCQUE4QixTQUFJLElBQUksU0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0Q7QUFDakQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2Q0FBTyxZQUFZLDZDQUFXO0FBQzdDO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQVMsTUFBTSw2Q0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcHVibGljX2tleS5qcz81NGEwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfRWQyNTUxOVB1YmxpY0tleV9yYXdLZXksIF9FZDI1NTE5UHVibGljS2V5X2RlcktleTtcbmltcG9ydCB7IEVEMjU1MTlfT0lELCB1bndyYXBERVIsIHdyYXBERVIgfSBmcm9tICcuL2Rlcic7XG5leHBvcnQgY2xhc3MgRWQyNTUxOVB1YmxpY0tleSB7XG4gICAgLy8gYGZyb21SYXdgIGFuZCBgZnJvbURlcmAgc2hvdWxkIGJlIHVzZWQgZm9yIGluc3RhbnRpYXRpb24sIG5vdCB0aGlzIGNvbnN0cnVjdG9yLlxuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICBfRWQyNTUxOVB1YmxpY0tleV9yYXdLZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9FZDI1NTE5UHVibGljS2V5X2RlcktleS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgaWYgKGtleS5ieXRlTGVuZ3RoICE9PSBFZDI1NTE5UHVibGljS2V5LlJBV19LRVlfTEVOR1RIKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIEVkMjU1MTkgcHVibGljIGtleSBtdXN0IGJlIGV4YWN0bHkgMzJieXRlcyBsb25nJyk7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRWQyNTUxOVB1YmxpY0tleV9yYXdLZXksIGtleSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9FZDI1NTE5UHVibGljS2V5X2RlcktleSwgRWQyNTUxOVB1YmxpY0tleS5kZXJFbmNvZGUoa2V5KSwgXCJmXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbURlcihrZXkudG9EZXIoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmF3KHJhd0tleSkge1xuICAgICAgICByZXR1cm4gbmV3IEVkMjU1MTlQdWJsaWNLZXkocmF3S2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21EZXIoZGVyS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRWQyNTUxOVB1YmxpY0tleSh0aGlzLmRlckRlY29kZShkZXJLZXkpKTtcbiAgICB9XG4gICAgc3RhdGljIGRlckVuY29kZShwdWJsaWNLZXkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBERVIocHVibGljS2V5LCBFRDI1NTE5X09JRCkuYnVmZmVyO1xuICAgIH1cbiAgICBzdGF0aWMgZGVyRGVjb2RlKGtleSkge1xuICAgICAgICBjb25zdCB1bndyYXBwZWQgPSB1bndyYXBERVIoa2V5LCBFRDI1NTE5X09JRCk7XG4gICAgICAgIGlmICh1bndyYXBwZWQubGVuZ3RoICE9PSB0aGlzLlJBV19LRVlfTEVOR1RIKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIEVkMjU1MTkgcHVibGljIGtleSBtdXN0IGJlIGV4YWN0bHkgMzJieXRlcyBsb25nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVud3JhcHBlZDtcbiAgICB9XG4gICAgZ2V0IHJhd0tleSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0VkMjU1MTlQdWJsaWNLZXlfcmF3S2V5LCBcImZcIik7XG4gICAgfVxuICAgIGdldCBkZXJLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FZDI1NTE5UHVibGljS2V5X2RlcktleSwgXCJmXCIpO1xuICAgIH1cbiAgICB0b0RlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVyS2V5O1xuICAgIH1cbiAgICB0b1JhdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmF3S2V5O1xuICAgIH1cbn1cbl9FZDI1NTE5UHVibGljS2V5X3Jhd0tleSA9IG5ldyBXZWFrTWFwKCksIF9FZDI1NTE5UHVibGljS2V5X2RlcktleSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBUaGUgbGVuZ3RoIG9mIEVkMjU1MTkgcHVibGljIGtleXMgaXMgYWx3YXlzIDMyIGJ5dGVzLlxuRWQyNTUxOVB1YmxpY0tleS5SQVdfS0VZX0xFTkdUSCA9IDMyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGljX2tleS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/public_key.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/request_id.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/request_id.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   hashOfMap: function() { return /* binding */ hashOfMap; },\n/* harmony export */   hashValue: function() { return /* binding */ hashValue; },\n/* harmony export */   requestIdOf: function() { return /* binding */ requestIdOf; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ \"../../../node_modules/@dfinity/candid/lib/esm/index.js\");\n/* harmony import */ var borc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! borc */ \"../../../node_modules/borc/src/index.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"../../../node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/buffer */ \"../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\");\n\n\n\n\n/**\n * sha256 hash the provided Buffer\n * @param data - input to hash function\n */\nfunction hash(data) {\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.uint8ToBuf)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256.create().update(new Uint8Array(data)).digest());\n}\n/**\n *\n * @param value unknown value\n * @returns ArrayBuffer\n */\nfunction hashValue(value) {\n    if (value instanceof borc__WEBPACK_IMPORTED_MODULE_1__.Tagged) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return hashValue(value.value);\n    }\n    else if (typeof value === 'string') {\n        return hashString(value);\n    }\n    else if (typeof value === 'number') {\n        return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(value));\n    }\n    else if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {\n        return hash(value);\n    }\n    else if (Array.isArray(value)) {\n        const vals = value.map(hashValue);\n        return hash((0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...vals));\n    }\n    else if (value && typeof value === 'object' && value._isPrincipal) {\n        return hash(value.toUint8Array());\n    }\n    else if (typeof value === 'object' &&\n        value !== null &&\n        typeof value.toHash === 'function') {\n        return hashValue(value.toHash());\n        // TODO This should be move to a specific async method as the webauthn flow required\n        // the flow to be synchronous to ensure Safari touch id works.\n        // } else if (value instanceof Promise) {\n        //   return value.then(x => hashValue(x));\n    }\n    else if (typeof value === 'object') {\n        return hashOfMap(value);\n    }\n    else if (typeof value === 'bigint') {\n        // Do this check much later than the other bigint check because this one is much less\n        // type-safe.\n        // So we want to try all the high-assurance type guards before this 'probable' one.\n        return hash((0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebEncode)(value));\n    }\n    throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${value}`), {\n        // include so logs/callers can understand the confusing value.\n        // (when stringified in error message, prototype info is lost)\n        value,\n    });\n}\nconst hashString = (value) => {\n    const encoded = new TextEncoder().encode(value);\n    return hash(encoded);\n};\n/**\n * Get the RequestId of the provided ic-ref request.\n * RequestId is the result of the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param request - ic-ref request to hash into RequestId\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction requestIdOf(request) {\n    return hashOfMap(request);\n}\n/**\n * Hash a map into an ArrayBuffer using the representation-independent-hash function.\n * https://sdk.dfinity.org/docs/interface-spec/index.html#hash-of-map\n * @param map - Any non-nested object\n * @returns ArrayBuffer\n */\nfunction hashOfMap(map) {\n    const hashed = Object.entries(map)\n        .filter(([, value]) => value !== undefined)\n        .map(([key, value]) => {\n        const hashedKey = hashString(key);\n        const hashedValue = hashValue(value);\n        return [hashedKey, hashedValue];\n    });\n    const traversed = hashed;\n    const sorted = traversed.sort(([k1], [k2]) => {\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.compare)(k1, k2);\n    });\n    const concatenated = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...sorted.map(x => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_2__.concat)(...x)));\n    const result = hash(concatenated);\n    return result;\n}\n//# sourceMappingURL=request_id.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcmVxdWVzdF9pZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE0QztBQUNwQjtBQUNzQjtBQUNlO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLHlEQUFVLENBQUMsd0RBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx5QkFBeUIsd0NBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwREFBUztBQUM3QjtBQUNBLGtGQUFrRixNQUFNO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxzREFBTztBQUN0QixLQUFLO0FBQ0wseUJBQXlCLHFEQUFNLG9CQUFvQixxREFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vcmVxdWVzdF9pZC5qcz80NjM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxlYkVuY29kZSB9IGZyb20gJ0BkZmluaXR5L2NhbmRpZCc7XG5pbXBvcnQgYm9yYyBmcm9tICdib3JjJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IGNvbXBhcmUsIGNvbmNhdCwgdWludDhUb0J1ZiB9IGZyb20gJy4vdXRpbHMvYnVmZmVyJztcbi8qKlxuICogc2hhMjU2IGhhc2ggdGhlIHByb3ZpZGVkIEJ1ZmZlclxuICogQHBhcmFtIGRhdGEgLSBpbnB1dCB0byBoYXNoIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGRhdGEpIHtcbiAgICByZXR1cm4gdWludDhUb0J1ZihzaGEyNTYuY3JlYXRlKCkudXBkYXRlKG5ldyBVaW50OEFycmF5KGRhdGEpKS5kaWdlc3QoKSk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdmFsdWUgdW5rbm93biB2YWx1ZVxuICogQHJldHVybnMgQXJyYXlCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGJvcmMuVGFnZ2VkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBoYXNoVmFsdWUodmFsdWUudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBoYXNoU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gaGFzaChsZWJFbmNvZGUodmFsdWUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBoYXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgdmFscyA9IHZhbHVlLm1hcChoYXNoVmFsdWUpO1xuICAgICAgICByZXR1cm4gaGFzaChjb25jYXQoLi4udmFscykpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9pc1ByaW5jaXBhbCkge1xuICAgICAgICByZXR1cm4gaGFzaCh2YWx1ZS50b1VpbnQ4QXJyYXkoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLnRvSGFzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaGFzaFZhbHVlKHZhbHVlLnRvSGFzaCgpKTtcbiAgICAgICAgLy8gVE9ETyBUaGlzIHNob3VsZCBiZSBtb3ZlIHRvIGEgc3BlY2lmaWMgYXN5bmMgbWV0aG9kIGFzIHRoZSB3ZWJhdXRobiBmbG93IHJlcXVpcmVkXG4gICAgICAgIC8vIHRoZSBmbG93IHRvIGJlIHN5bmNocm9ub3VzIHRvIGVuc3VyZSBTYWZhcmkgdG91Y2ggaWQgd29ya3MuXG4gICAgICAgIC8vIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIC8vICAgcmV0dXJuIHZhbHVlLnRoZW4oeCA9PiBoYXNoVmFsdWUoeCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBoYXNoT2ZNYXAodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIC8vIERvIHRoaXMgY2hlY2sgbXVjaCBsYXRlciB0aGFuIHRoZSBvdGhlciBiaWdpbnQgY2hlY2sgYmVjYXVzZSB0aGlzIG9uZSBpcyBtdWNoIGxlc3NcbiAgICAgICAgLy8gdHlwZS1zYWZlLlxuICAgICAgICAvLyBTbyB3ZSB3YW50IHRvIHRyeSBhbGwgdGhlIGhpZ2gtYXNzdXJhbmNlIHR5cGUgZ3VhcmRzIGJlZm9yZSB0aGlzICdwcm9iYWJsZScgb25lLlxuICAgICAgICByZXR1cm4gaGFzaChsZWJFbmNvZGUodmFsdWUpKTtcbiAgICB9XG4gICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoYEF0dGVtcHQgdG8gaGFzaCBhIHZhbHVlIG9mIHVuc3VwcG9ydGVkIHR5cGU6ICR7dmFsdWV9YCksIHtcbiAgICAgICAgLy8gaW5jbHVkZSBzbyBsb2dzL2NhbGxlcnMgY2FuIHVuZGVyc3RhbmQgdGhlIGNvbmZ1c2luZyB2YWx1ZS5cbiAgICAgICAgLy8gKHdoZW4gc3RyaW5naWZpZWQgaW4gZXJyb3IgbWVzc2FnZSwgcHJvdG90eXBlIGluZm8gaXMgbG9zdClcbiAgICAgICAgdmFsdWUsXG4gICAgfSk7XG59XG5jb25zdCBoYXNoU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgZW5jb2RlZCA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSk7XG4gICAgcmV0dXJuIGhhc2goZW5jb2RlZCk7XG59O1xuLyoqXG4gKiBHZXQgdGhlIFJlcXVlc3RJZCBvZiB0aGUgcHJvdmlkZWQgaWMtcmVmIHJlcXVlc3QuXG4gKiBSZXF1ZXN0SWQgaXMgdGhlIHJlc3VsdCBvZiB0aGUgcmVwcmVzZW50YXRpb24taW5kZXBlbmRlbnQtaGFzaCBmdW5jdGlvbi5cbiAqIGh0dHBzOi8vc2RrLmRmaW5pdHkub3JnL2RvY3MvaW50ZXJmYWNlLXNwZWMvaW5kZXguaHRtbCNoYXNoLW9mLW1hcFxuICogQHBhcmFtIHJlcXVlc3QgLSBpYy1yZWYgcmVxdWVzdCB0byBoYXNoIGludG8gUmVxdWVzdElkXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdElkT2YocmVxdWVzdCkge1xuICAgIHJldHVybiBoYXNoT2ZNYXAocmVxdWVzdCk7XG59XG4vKipcbiAqIEhhc2ggYSBtYXAgaW50byBhbiBBcnJheUJ1ZmZlciB1c2luZyB0aGUgcmVwcmVzZW50YXRpb24taW5kZXBlbmRlbnQtaGFzaCBmdW5jdGlvbi5cbiAqIGh0dHBzOi8vc2RrLmRmaW5pdHkub3JnL2RvY3MvaW50ZXJmYWNlLXNwZWMvaW5kZXguaHRtbCNoYXNoLW9mLW1hcFxuICogQHBhcmFtIG1hcCAtIEFueSBub24tbmVzdGVkIG9iamVjdFxuICogQHJldHVybnMgQXJyYXlCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hPZk1hcChtYXApIHtcbiAgICBjb25zdCBoYXNoZWQgPSBPYmplY3QuZW50cmllcyhtYXApXG4gICAgICAgIC5maWx0ZXIoKFssIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2hlZEtleSA9IGhhc2hTdHJpbmcoa2V5KTtcbiAgICAgICAgY29uc3QgaGFzaGVkVmFsdWUgPSBoYXNoVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gW2hhc2hlZEtleSwgaGFzaGVkVmFsdWVdO1xuICAgIH0pO1xuICAgIGNvbnN0IHRyYXZlcnNlZCA9IGhhc2hlZDtcbiAgICBjb25zdCBzb3J0ZWQgPSB0cmF2ZXJzZWQuc29ydCgoW2sxXSwgW2syXSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tcGFyZShrMSwgazIpO1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbmNhdGVuYXRlZCA9IGNvbmNhdCguLi5zb3J0ZWQubWFwKHggPT4gY29uY2F0KC4uLngpKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gaGFzaChjb25jYXRlbmF0ZWQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0X2lkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/request_id.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/utils/bls.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/utils/bls.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blsVerify: function() { return /* binding */ blsVerify; },\n/* harmony export */   verify: function() { return /* binding */ verify; }\n/* harmony export */ });\n/* harmony import */ var _vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vendor/bls/bls */ \"../../../node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js\");\n\nlet verify;\n/**\n *\n * @param pk primary key: Uint8Array\n * @param sig signature: Uint8Array\n * @param msg message: Uint8Array\n * @returns Promise resolving a boolean\n */\nasync function blsVerify(pk, sig, msg) {\n    if (!verify) {\n        await (0,_vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        if ((0,_vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__.bls_init)() !== 0) {\n            throw new Error('Cannot initialize BLS');\n        }\n        verify = (pk1, sig1, msg1) => {\n            // Reorder things from what the WASM expects (sig, m, w).\n            return (0,_vendor_bls_bls__WEBPACK_IMPORTED_MODULE_0__.bls_verify)(sig1, msg1, pk1) === 0;\n        };\n    }\n    return verify(pk, sig, msg);\n}\n//# sourceMappingURL=bls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvYmxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErRDtBQUN4RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGNBQWMsMkRBQUk7QUFDbEIsWUFBWSx5REFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS91dGlscy9ibHMuanM/OTYyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaW5pdCwgeyBibHNfaW5pdCwgYmxzX3ZlcmlmeSB9IGZyb20gJy4uL3ZlbmRvci9ibHMvYmxzJztcbmV4cG9ydCBsZXQgdmVyaWZ5O1xuLyoqXG4gKlxuICogQHBhcmFtIHBrIHByaW1hcnkga2V5OiBVaW50OEFycmF5XG4gKiBAcGFyYW0gc2lnIHNpZ25hdHVyZTogVWludDhBcnJheVxuICogQHBhcmFtIG1zZyBtZXNzYWdlOiBVaW50OEFycmF5XG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyBhIGJvb2xlYW5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJsc1ZlcmlmeShwaywgc2lnLCBtc2cpIHtcbiAgICBpZiAoIXZlcmlmeSkge1xuICAgICAgICBhd2FpdCBpbml0KCk7XG4gICAgICAgIGlmIChibHNfaW5pdCgpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbml0aWFsaXplIEJMUycpO1xuICAgICAgICB9XG4gICAgICAgIHZlcmlmeSA9IChwazEsIHNpZzEsIG1zZzEpID0+IHtcbiAgICAgICAgICAgIC8vIFJlb3JkZXIgdGhpbmdzIGZyb20gd2hhdCB0aGUgV0FTTSBleHBlY3RzIChzaWcsIG0sIHcpLlxuICAgICAgICAgICAgcmV0dXJuIGJsc192ZXJpZnkoc2lnMSwgbXNnMSwgcGsxKSA9PT0gMDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcmlmeShwaywgc2lnLCBtc2cpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/utils/bls.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js":
/*!********************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bufEquals: function() { return /* binding */ bufEquals; },\n/* harmony export */   compare: function() { return /* binding */ compare; },\n/* harmony export */   concat: function() { return /* binding */ concat; },\n/* harmony export */   fromHex: function() { return /* binding */ fromHex; },\n/* harmony export */   toHex: function() { return /* binding */ toHex; },\n/* harmony export */   uint8ToBuf: function() { return /* binding */ uint8ToBuf; }\n/* harmony export */ });\n/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nfunction concat(...buffers) {\n    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n    let index = 0;\n    for (const b of buffers) {\n        result.set(new Uint8Array(b), index);\n        index += b.byteLength;\n    }\n    return result.buffer;\n}\n/**\n * Transforms a buffer to an hexadecimal string. This will use the buffer as an Uint8Array.\n * @param buffer The buffer to return the hexadecimal string of.\n */\nfunction toHex(buffer) {\n    return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');\n}\nconst hexRe = new RegExp(/^([0-9A-F]{2})*$/i);\n/**\n * Transforms a hexadecimal string into an array buffer.\n * @param hex The hexadecimal string to use.\n */\nfunction fromHex(hex) {\n    if (!hexRe.test(hex)) {\n        throw new Error('Invalid hexadecimal string.');\n    }\n    const buffer = [...hex]\n        .reduce((acc, curr, i) => {\n        acc[(i / 2) | 0] = (acc[(i / 2) | 0] || '') + curr;\n        return acc;\n    }, [])\n        .map(x => Number.parseInt(x, 16));\n    return new Uint8Array(buffer).buffer;\n}\n/**\n *\n * @param b1 array buffer 1\n * @param b2 array buffer 2\n * @returns number - negative if b1 < b2, positive if b1 > b2, 0 if b1 === b2\n */\nfunction compare(b1, b2) {\n    if (b1.byteLength !== b2.byteLength) {\n        return b1.byteLength - b2.byteLength;\n    }\n    const u1 = new Uint8Array(b1);\n    const u2 = new Uint8Array(b2);\n    for (let i = 0; i < u1.length; i++) {\n        if (u1[i] !== u2[i]) {\n            return u1[i] - u2[i];\n        }\n    }\n    return 0;\n}\n/**\n * Checks two array buffers for equality.\n * @param b1 array buffer 1\n * @param b2 array buffer 2\n * @returns boolean\n */\nfunction bufEquals(b1, b2) {\n    return compare(b1, b2) === 0;\n}\n/**\n * Returns a true ArrayBuffer from a Uint8Array, as Uint8Array.buffer is unsafe.\n * @param {Uint8Array} arr Uint8Array to convert\n * @returns ArrayBuffer\n */\nfunction uint8ToBuf(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength).buffer;\n}\n//# sourceMappingURL=buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3V0aWxzL2J1ZmZlci5qcz8zZmE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgYXJyYXkgYnVmZmVycy5cbiAqIEBwYXJhbSBidWZmZXJzIFRoZSBidWZmZXJzIHRvIGNvbmNhdGVuYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLmJ1ZmZlcnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShidWZmZXJzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLmJ5dGVMZW5ndGgsIDApKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgYiBvZiBidWZmZXJzKSB7XG4gICAgICAgIHJlc3VsdC5zZXQobmV3IFVpbnQ4QXJyYXkoYiksIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn1cbi8qKlxuICogVHJhbnNmb3JtcyBhIGJ1ZmZlciB0byBhbiBoZXhhZGVjaW1hbCBzdHJpbmcuIFRoaXMgd2lsbCB1c2UgdGhlIGJ1ZmZlciBhcyBhbiBVaW50OEFycmF5LlxuICogQHBhcmFtIGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHJldHVybiB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nIG9mLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoYnVmZmVyKSB7XG4gICAgcmV0dXJuIFsuLi5uZXcgVWludDhBcnJheShidWZmZXIpXS5tYXAoeCA9PiB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbn1cbmNvbnN0IGhleFJlID0gbmV3IFJlZ0V4cCgvXihbMC05QS1GXXsyfSkqJC9pKTtcbi8qKlxuICogVHJhbnNmb3JtcyBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnRvIGFuIGFycmF5IGJ1ZmZlci5cbiAqIEBwYXJhbSBoZXggVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byB1c2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KGhleCkge1xuICAgIGlmICghaGV4UmUudGVzdChoZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFsuLi5oZXhdXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgY3VyciwgaSkgPT4ge1xuICAgICAgICBhY2NbKGkgLyAyKSB8IDBdID0gKGFjY1soaSAvIDIpIHwgMF0gfHwgJycpICsgY3VycjtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSlcbiAgICAgICAgLm1hcCh4ID0+IE51bWJlci5wYXJzZUludCh4LCAxNikpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpLmJ1ZmZlcjtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBiMSBhcnJheSBidWZmZXIgMVxuICogQHBhcmFtIGIyIGFycmF5IGJ1ZmZlciAyXG4gKiBAcmV0dXJucyBudW1iZXIgLSBuZWdhdGl2ZSBpZiBiMSA8IGIyLCBwb3NpdGl2ZSBpZiBiMSA+IGIyLCAwIGlmIGIxID09PSBiMlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShiMSwgYjIpIHtcbiAgICBpZiAoYjEuYnl0ZUxlbmd0aCAhPT0gYjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gYjEuYnl0ZUxlbmd0aCAtIGIyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHUxID0gbmV3IFVpbnQ4QXJyYXkoYjEpO1xuICAgIGNvbnN0IHUyID0gbmV3IFVpbnQ4QXJyYXkoYjIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdTEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHUxW2ldICE9PSB1MltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHUxW2ldIC0gdTJbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG4vKipcbiAqIENoZWNrcyB0d28gYXJyYXkgYnVmZmVycyBmb3IgZXF1YWxpdHkuXG4gKiBAcGFyYW0gYjEgYXJyYXkgYnVmZmVyIDFcbiAqIEBwYXJhbSBiMiBhcnJheSBidWZmZXIgMlxuICogQHJldHVybnMgYm9vbGVhblxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmRXF1YWxzKGIxLCBiMikge1xuICAgIHJldHVybiBjb21wYXJlKGIxLCBiMikgPT09IDA7XG59XG4vKipcbiAqIFJldHVybnMgYSB0cnVlIEFycmF5QnVmZmVyIGZyb20gYSBVaW50OEFycmF5LCBhcyBVaW50OEFycmF5LmJ1ZmZlciBpcyB1bnNhZmUuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFyciBVaW50OEFycmF5IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIEFycmF5QnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1aW50OFRvQnVmKGFycikge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKS5idWZmZXI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/utils/buffer.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExpirableMap: function() { return /* binding */ ExpirableMap; }\n/* harmony export */ });\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ExpirableMap_inner, _ExpirableMap_expirationTime, _a, _b;\n/**\n * A map that expires entries after a given time.\n * Defaults to 10 minutes.\n */\nclass ExpirableMap {\n    /**\n     * Create a new ExpirableMap.\n     * @param {ExpirableMapOptions<any, any>} options - options for the map.\n     * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.\n     * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.\n     */\n    constructor(options = {}) {\n        // Internals\n        _ExpirableMap_inner.set(this, void 0);\n        _ExpirableMap_expirationTime.set(this, void 0);\n        this[_a] = this.entries.bind(this);\n        this[_b] = 'ExpirableMap';\n        const { source = [], expirationTime = 10 * 60 * 1000 } = options;\n        const currentTime = Date.now();\n        __classPrivateFieldSet(this, _ExpirableMap_inner, new Map([...source].map(([key, value]) => [key, { value, timestamp: currentTime }])), \"f\");\n        __classPrivateFieldSet(this, _ExpirableMap_expirationTime, expirationTime, \"f\");\n    }\n    /**\n     * Prune removes all expired entries.\n     */\n    prune() {\n        const currentTime = Date.now();\n        for (const [key, entry] of __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries()) {\n            if (currentTime - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, \"f\")) {\n                __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n            }\n        }\n        return this;\n    }\n    // Implementing the Map interface\n    /**\n     * Set the value for the given key. Prunes expired entries.\n     * @param key for the entry\n     * @param value of the entry\n     * @returns this\n     */\n    set(key, value) {\n        this.prune();\n        const entry = {\n            value,\n            timestamp: Date.now(),\n        };\n        __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").set(key, entry);\n        return this;\n    }\n    /**\n     * Get the value associated with the key, if it exists and has not expired.\n     * @param key K\n     * @returns the value associated with the key, or undefined if the key is not present or has expired.\n     */\n    get(key) {\n        const entry = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").get(key);\n        if (entry === undefined) {\n            return undefined;\n        }\n        if (Date.now() - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, \"f\")) {\n            __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n            return undefined;\n        }\n        return entry.value;\n    }\n    /**\n     * Clear all entries.\n     */\n    clear() {\n        __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").clear();\n    }\n    /**\n     * Entries returns the entries of the map, without the expiration time.\n     * @returns an iterator over the entries of the map.\n     */\n    entries() {\n        const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries();\n        const generator = function* () {\n            for (const [key, value] of iterator) {\n                yield [key, value.value];\n            }\n        };\n        return generator();\n    }\n    /**\n     * Values returns the values of the map, without the expiration time.\n     * @returns an iterator over the values of the map.\n     */\n    values() {\n        const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").values();\n        const generator = function* () {\n            for (const value of iterator) {\n                yield value.value;\n            }\n        };\n        return generator();\n    }\n    /**\n     * Keys returns the keys of the map\n     * @returns an iterator over the keys of the map.\n     */\n    keys() {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").keys();\n    }\n    /**\n     * forEach calls the callbackfn on each entry of the map.\n     * @param callbackfn to call on each entry\n     * @param thisArg to use as this when calling the callbackfn\n     */\n    forEach(callbackfn, thisArg) {\n        for (const [key, value] of __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").entries()) {\n            callbackfn.call(thisArg, value.value, key, this);\n        }\n    }\n    /**\n     * has returns true if the key exists and has not expired.\n     * @param key K\n     * @returns true if the key exists and has not expired.\n     */\n    has(key) {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").has(key);\n    }\n    /**\n     * delete the entry for the given key.\n     * @param key K\n     * @returns true if the key existed and has been deleted.\n     */\n    delete(key) {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").delete(key);\n    }\n    /**\n     * get size of the map.\n     * @returns the size of the map.\n     */\n    get size() {\n        return __classPrivateFieldGet(this, _ExpirableMap_inner, \"f\").size;\n    }\n}\n_ExpirableMap_inner = new WeakMap(), _ExpirableMap_expirationTime = new WeakMap(), _a = Symbol.iterator, _b = Symbol.toStringTag;\n//# sourceMappingURL=expirableMap.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvZXhwaXJhYmxlTWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFJLElBQUksU0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QyxlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLFFBQVE7QUFDdkI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBK0M7QUFDL0Q7QUFDQSw0R0FBNEcsK0JBQStCO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS91dGlscy9leHBpcmFibGVNYXAuanM/M2UzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0V4cGlyYWJsZU1hcF9pbm5lciwgX0V4cGlyYWJsZU1hcF9leHBpcmF0aW9uVGltZSwgX2EsIF9iO1xuLyoqXG4gKiBBIG1hcCB0aGF0IGV4cGlyZXMgZW50cmllcyBhZnRlciBhIGdpdmVuIHRpbWUuXG4gKiBEZWZhdWx0cyB0byAxMCBtaW51dGVzLlxuICovXG5leHBvcnQgY2xhc3MgRXhwaXJhYmxlTWFwIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgRXhwaXJhYmxlTWFwLlxuICAgICAqIEBwYXJhbSB7RXhwaXJhYmxlTWFwT3B0aW9uczxhbnksIGFueT59IG9wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgbWFwLlxuICAgICAqIEBwYXJhbSB7SXRlcmFibGU8W2FueSwgYW55XT59IG9wdGlvbnMuc291cmNlIC0gYW4gb3B0aW9uYWwgc291cmNlIG9mIGVudHJpZXMgdG8gaW5pdGlhbGl6ZSB0aGUgbWFwIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuZXhwaXJhdGlvblRpbWUgLSB0aGUgdGltZSBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggZW50cmllcyB3aWxsIGV4cGlyZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gSW50ZXJuYWxzXG4gICAgICAgIF9FeHBpcmFibGVNYXBfaW5uZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9FeHBpcmFibGVNYXBfZXhwaXJhdGlvblRpbWUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIHRoaXNbX2FdID0gdGhpcy5lbnRyaWVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXNbX2JdID0gJ0V4cGlyYWJsZU1hcCc7XG4gICAgICAgIGNvbnN0IHsgc291cmNlID0gW10sIGV4cGlyYXRpb25UaW1lID0gMTAgKiA2MCAqIDEwMDAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBuZXcgTWFwKFsuLi5zb3VyY2VdLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LCB7IHZhbHVlLCB0aW1lc3RhbXA6IGN1cnJlbnRUaW1lIH1dKSksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2V4cGlyYXRpb25UaW1lLCBleHBpcmF0aW9uVGltZSwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcnVuZSByZW1vdmVzIGFsbCBleHBpcmVkIGVudHJpZXMuXG4gICAgICovXG4gICAgcHJ1bmUoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBcImZcIikuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRpbWUgLSBlbnRyeS50aW1lc3RhbXAgPiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfZXhwaXJhdGlvblRpbWUsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBJbXBsZW1lbnRpbmcgdGhlIE1hcCBpbnRlcmZhY2VcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5LiBQcnVuZXMgZXhwaXJlZCBlbnRyaWVzLlxuICAgICAqIEBwYXJhbSBrZXkgZm9yIHRoZSBlbnRyeVxuICAgICAqIEBwYXJhbSB2YWx1ZSBvZiB0aGUgZW50cnlcbiAgICAgKiBAcmV0dXJucyB0aGlzXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcnVuZSgpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9O1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5zZXQoa2V5LCBlbnRyeSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LCBpZiBpdCBleGlzdHMgYW5kIGhhcyBub3QgZXhwaXJlZC5cbiAgICAgKiBAcGFyYW0ga2V5IEtcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXksIG9yIHVuZGVmaW5lZCBpZiB0aGUga2V5IGlzIG5vdCBwcmVzZW50IG9yIGhhcyBleHBpcmVkLlxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBlbnRyeS50aW1lc3RhbXAgPiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfZXhwaXJhdGlvblRpbWUsIFwiZlwiKSkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBcImZcIikuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGVudHJpZXMuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVudHJpZXMgcmV0dXJucyB0aGUgZW50cmllcyBvZiB0aGUgbWFwLCB3aXRob3V0IHRoZSBleHBpcmF0aW9uIHRpbWUuXG4gICAgICogQHJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgZW50cmllcyBvZiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRXhwaXJhYmxlTWFwX2lubmVyLCBcImZcIikuZW50cmllcygpO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBnZW5lcmF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsdWVzIHJldHVybnMgdGhlIHZhbHVlcyBvZiB0aGUgbWFwLCB3aXRob3V0IHRoZSBleHBpcmF0aW9uIHRpbWUuXG4gICAgICogQHJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgdmFsdWVzIG9mIHRoZSBtYXAuXG4gICAgICovXG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLnZhbHVlcygpO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ2VuZXJhdG9yKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEtleXMgcmV0dXJucyB0aGUga2V5cyBvZiB0aGUgbWFwXG4gICAgICogQHJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUga2V5cyBvZiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5rZXlzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGZvckVhY2ggY2FsbHMgdGhlIGNhbGxiYWNrZm4gb24gZWFjaCBlbnRyeSBvZiB0aGUgbWFwLlxuICAgICAqIEBwYXJhbSBjYWxsYmFja2ZuIHRvIGNhbGwgb24gZWFjaCBlbnRyeVxuICAgICAqIEBwYXJhbSB0aGlzQXJnIHRvIHVzZSBhcyB0aGlzIHdoZW4gY2FsbGluZyB0aGUgY2FsbGJhY2tmblxuICAgICAqL1xuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZS52YWx1ZSwga2V5LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBoYXMgcmV0dXJucyB0cnVlIGlmIHRoZSBrZXkgZXhpc3RzIGFuZCBoYXMgbm90IGV4cGlyZWQuXG4gICAgICogQHBhcmFtIGtleSBLXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IGV4aXN0cyBhbmQgaGFzIG5vdCBleHBpcmVkLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLmhhcyhrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBkZWxldGUgdGhlIGVudHJ5IGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgS1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGtleSBleGlzdGVkIGFuZCBoYXMgYmVlbiBkZWxldGVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0V4cGlyYWJsZU1hcF9pbm5lciwgXCJmXCIpLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXQgc2l6ZSBvZiB0aGUgbWFwLlxuICAgICAqIEByZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBtYXAuXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FeHBpcmFibGVNYXBfaW5uZXIsIFwiZlwiKS5zaXplO1xuICAgIH1cbn1cbl9FeHBpcmFibGVNYXBfaW5uZXIgPSBuZXcgV2Vha01hcCgpLCBfRXhwaXJhYmxlTWFwX2V4cGlyYXRpb25UaW1lID0gbmV3IFdlYWtNYXAoKSwgX2EgPSBTeW1ib2wuaXRlcmF0b3IsIF9iID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwaXJhYmxlTWFwLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/utils/leb.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/utils/leb.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeLeb128: function() { return /* binding */ decodeLeb128; },\n/* harmony export */   decodeTime: function() { return /* binding */ decodeTime; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/candid */ \"../../../node_modules/@dfinity/candid/lib/esm/index.js\");\n\nconst decodeLeb128 = (buf) => {\n    return (0,_dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.lebDecode)(new _dfinity_candid__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(buf));\n};\n// time is a LEB128-encoded Nat\nconst decodeTime = (buf) => {\n    const decoded = decodeLeb128(buf);\n    // nanoseconds to milliseconds\n    return new Date(Number(decoded) / 1000000);\n};\n//# sourceMappingURL=leb.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvbGViLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2RDtBQUN0RDtBQUNQLFdBQVcsMERBQVMsS0FBSyw0REFBZTtBQUN4QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS91dGlscy9sZWIuanM/ZGE2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlQXJyYXlCdWZmZXIsIGxlYkRlY29kZSB9IGZyb20gJ0BkZmluaXR5L2NhbmRpZCc7XG5leHBvcnQgY29uc3QgZGVjb2RlTGViMTI4ID0gKGJ1ZikgPT4ge1xuICAgIHJldHVybiBsZWJEZWNvZGUobmV3IFBpcGVBcnJheUJ1ZmZlcihidWYpKTtcbn07XG4vLyB0aW1lIGlzIGEgTEVCMTI4LWVuY29kZWQgTmF0XG5leHBvcnQgY29uc3QgZGVjb2RlVGltZSA9IChidWYpID0+IHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlTGViMTI4KGJ1Zik7XG4gICAgLy8gbmFub3NlY29uZHMgdG8gbWlsbGlzZWNvbmRzXG4gICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcihkZWNvZGVkKSAvIDEwMDAwMDApO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/utils/leb.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/utils/random.js":
/*!********************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/utils/random.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   randomNumber: function() { return /* binding */ randomNumber; }\n/* harmony export */ });\n/**\n * Generates a random unsigned 32-bit integer between 0 and 0xffffffff\n * @returns {number} a random number\n */\nconst randomNumber = () => {\n    // determine whether browser crypto is available\n    if (typeof window !== 'undefined' && !!window.crypto && !!window.crypto.getRandomValues) {\n        const array = new Uint32Array(1);\n        window.crypto.getRandomValues(array);\n        return array[0];\n    }\n    // A second check for webcrypto, in case it is loaded under global instead of window\n    if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n        const array = new Uint32Array(1);\n        crypto.getRandomValues(array);\n        return array[0];\n    }\n    // determine whether node crypto is available\n    if (typeof crypto !== 'undefined' && crypto.randomInt) {\n        return crypto.randomInt(0, 0xffffffff);\n    }\n    // fall back to Math.random\n    return Math.floor(Math.random() * 0xffffffff);\n};\n//# sourceMappingURL=random.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdXRpbHMvcmFuZG9tLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS91dGlscy9yYW5kb20uanM/Yzc2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDB4ZmZmZmZmZmZcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGEgcmFuZG9tIG51bWJlclxuICovXG5leHBvcnQgY29uc3QgcmFuZG9tTnVtYmVyID0gKCkgPT4ge1xuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIGJyb3dzZXIgY3J5cHRvIGlzIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5jcnlwdG8gJiYgISF3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheSgxKTtcbiAgICAgICAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXJyYXlbMF07XG4gICAgfVxuICAgIC8vIEEgc2Vjb25kIGNoZWNrIGZvciB3ZWJjcnlwdG8sIGluIGNhc2UgaXQgaXMgbG9hZGVkIHVuZGVyIGdsb2JhbCBpbnN0ZWFkIG9mIHdpbmRvd1xuICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KDEpO1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGFycmF5WzBdO1xuICAgIH1cbiAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBub2RlIGNyeXB0byBpcyBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbUludCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUludCgwLCAweGZmZmZmZmZmKTtcbiAgICB9XG4gICAgLy8gZmFsbCBiYWNrIHRvIE1hdGgucmFuZG9tXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmRvbS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/utils/random.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js":
/*!**********************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bls_init: function() { return /* binding */ bls_init; },\n/* harmony export */   bls_verify: function() { return /* binding */ bls_verify; }\n/* harmony export */ });\n/* harmony import */ var base64_arraybuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! base64-arraybuffer */ \"../../../node_modules/base64-arraybuffer/lib/base64-arraybuffer.js\");\n/* harmony import */ var _wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wasm */ \"../../../node_modules/@dfinity/agent/lib/esm/vendor/bls/wasm.js\");\n\n// This WASM is generated from the miracl BLS Rust code (see\n// https://github.com/dfinity/miracl_core_bls12381/)\n\nlet wasm;\nconst wasmBytes = base64_arraybuffer__WEBPACK_IMPORTED_MODULE_0__.decode(_wasm__WEBPACK_IMPORTED_MODULE_1__.wasmBytesBase64);\n/**\n * @returns {number}\n */\nfunction bls_init() {\n    let ret = wasm.bls_init();\n    return ret;\n}\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1);\n    getUint8Memory0().set(arg, ptr / 1);\n    return [ptr, arg.length];\n}\n/**\n * @param {Uint8Array} sig\n * @param {Uint8Array} m\n * @param {Uint8Array} w\n * @returns {number}\n */\nfunction bls_verify(sig, m, w) {\n    const [ptr0, len0] = passArray8ToWasm0(sig, wasm.__wbindgen_malloc);\n    const [ptr1, len1] = passArray8ToWasm0(m, wasm.__wbindgen_malloc);\n    const [ptr2, len2] = passArray8ToWasm0(w, wasm.__wbindgen_malloc);\n    const ret = wasm.bls_verify(ptr0, len0, ptr1, len1, ptr2, len2);\n    return ret;\n}\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n    }\n    else {\n        const instance = await WebAssembly.instantiate(module, imports);\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n        }\n        else {\n            return instance;\n        }\n    }\n}\nasync function init() {\n    const imports = {};\n    const { instance, module } = await load(wasmBytes, imports);\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    return wasm;\n}\n/**\n * If `module_or_path` is {RequestInfo} or {URL}, makes a request and\n * for everything else, calls `WebAssembly.instantiate` directly.\n *\n * @param {InitInput | Promise<InitInput>} module_or_path\n *\n * @returns {Promise<InitOutput>}\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = (init);\n//# sourceMappingURL=bls.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdmVuZG9yL2Jscy9ibHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RDtBQUN4RDtBQUNBO0FBQ3lDO0FBQ3pDO0FBQ0Esa0JBQWtCLHNEQUF3QixDQUFDLGtEQUFlO0FBQzFEO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhLElBQUksSUFBSTtBQUNoRDtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrREFBZSxJQUFJLEVBQUM7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9saWIvZXNtL3ZlbmRvci9ibHMvYmxzLmpzPzUzMWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYmFzZTY0QXJyYXlidWZmZXIgZnJvbSAnYmFzZTY0LWFycmF5YnVmZmVyJztcbi8vIFRoaXMgV0FTTSBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgbWlyYWNsIEJMUyBSdXN0IGNvZGUgKHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RmaW5pdHkvbWlyYWNsX2NvcmVfYmxzMTIzODEvKVxuaW1wb3J0IHsgd2FzbUJ5dGVzQmFzZTY0IH0gZnJvbSAnLi93YXNtJztcbmxldCB3YXNtO1xuY29uc3Qgd2FzbUJ5dGVzID0gYmFzZTY0QXJyYXlidWZmZXIuZGVjb2RlKHdhc21CeXRlc0Jhc2U2NCk7XG4vKipcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBibHNfaW5pdCgpIHtcbiAgICBsZXQgcmV0ID0gd2FzbS5ibHNfaW5pdCgpO1xuICAgIHJldHVybiByZXQ7XG59XG5sZXQgY2FjaGVnZXRVaW50OE1lbW9yeTAgPSBudWxsO1xuZnVuY3Rpb24gZ2V0VWludDhNZW1vcnkwKCkge1xuICAgIGlmIChjYWNoZWdldFVpbnQ4TWVtb3J5MCA9PT0gbnVsbCB8fCBjYWNoZWdldFVpbnQ4TWVtb3J5MC5idWZmZXIgIT09IHdhc20ubWVtb3J5LmJ1ZmZlcikge1xuICAgICAgICBjYWNoZWdldFVpbnQ4TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWdldFVpbnQ4TWVtb3J5MDtcbn1cbmZ1bmN0aW9uIHBhc3NBcnJheThUb1dhc20wKGFyZywgbWFsbG9jKSB7XG4gICAgY29uc3QgcHRyID0gbWFsbG9jKGFyZy5sZW5ndGggKiAxKTtcbiAgICBnZXRVaW50OE1lbW9yeTAoKS5zZXQoYXJnLCBwdHIgLyAxKTtcbiAgICByZXR1cm4gW3B0ciwgYXJnLmxlbmd0aF07XG59XG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gc2lnXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gd1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJsc192ZXJpZnkoc2lnLCBtLCB3KSB7XG4gICAgY29uc3QgW3B0cjAsIGxlbjBdID0gcGFzc0FycmF5OFRvV2FzbTAoc2lnLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICBjb25zdCBbcHRyMSwgbGVuMV0gPSBwYXNzQXJyYXk4VG9XYXNtMChtLCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICBjb25zdCBbcHRyMiwgbGVuMl0gPSBwYXNzQXJyYXk4VG9XYXNtMCh3LCB3YXNtLl9fd2JpbmRnZW5fbWFsbG9jKTtcbiAgICBjb25zdCByZXQgPSB3YXNtLmJsc192ZXJpZnkocHRyMCwgbGVuMCwgcHRyMSwgbGVuMSwgcHRyMiwgbGVuMik7XG4gICAgcmV0dXJuIHJldDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWQobW9kdWxlLCBpbXBvcnRzKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGUgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IGF3YWl0IG1vZHVsZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnl0ZXMsIGltcG9ydHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShtb2R1bGUsIGltcG9ydHMpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2UsIG1vZHVsZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBjb25zdCBpbXBvcnRzID0ge307XG4gICAgY29uc3QgeyBpbnN0YW5jZSwgbW9kdWxlIH0gPSBhd2FpdCBsb2FkKHdhc21CeXRlcywgaW1wb3J0cyk7XG4gICAgd2FzbSA9IGluc3RhbmNlLmV4cG9ydHM7XG4gICAgaW5pdC5fX3diaW5kZ2VuX3dhc21fbW9kdWxlID0gbW9kdWxlO1xuICAgIHJldHVybiB3YXNtO1xufVxuLyoqXG4gKiBJZiBgbW9kdWxlX29yX3BhdGhgIGlzIHtSZXF1ZXN0SW5mb30gb3Ige1VSTH0sIG1ha2VzIGEgcmVxdWVzdCBhbmRcbiAqIGZvciBldmVyeXRoaW5nIGVsc2UsIGNhbGxzIGBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZWAgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtJbml0SW5wdXQgfCBQcm9taXNlPEluaXRJbnB1dD59IG1vZHVsZV9vcl9wYXRoXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8SW5pdE91dHB1dD59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGluaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/vendor/bls/bls.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/lib/esm/vendor/bls/wasm.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/lib/esm/vendor/bls/wasm.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wasmBytesBase64: function() { return /* binding */ wasmBytesBase64; }\n/* harmony export */ });\nconst wasmBytesBase64 = `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akE4ENABGiACQbgDakEBNgIAIAJBwANqQTgQ0AEaIAJB+ANqQQE2AgAgAkGABGpBOBDQARogAkEBNgK4BCACQcAEakE4ENABGiACQfgEakEBNgIAIAJBgAVqQTgQ0AEaIAJBuAVqQQE2AgAgAkHABWpBOBDQARogAkH4BWpBATYCACACQYAGakE4ENABGiACQQE2ArgGIAJBwAZqQTgQ0AEaIAJB+AZqQQE2AgAgAkGAB2pBOBDQARogAkG4B2pBATYCACACQcAHakE4ENABGiACQfgHakEBNgIAIAIgARAYAkAgASgCgAZBBEYNACAAKAKABkEERg0AIAJBgARqIgMgAEGAAmoQlgEgAyABQYACahAYDAYLIAJBwAxqIgdBOBDQARogAkEBNgL4DCACQYANakE4ENABGiACQbgNakEBNgIAIAJBgAhqIgRBOBDQARogAkEBNgK4CCACQcAIakE4ENABGiACQfgIakEBNgIAIAJBgApqIgMgAEGAA2oiBRBeIAQgAxCZASADIAFBgANqIgYQXiAEIAMQESAHELYBIAEoAoAGQQRHDQMMBAsgACABEAMMBgsgAkHADGoiAyABQYAFahBeIAJBgAxqIgQgA0HAABDRARogAkGABmogBBCnAQsgAkGABmoQZCACQYAIaiIDIAIQlgEgAxArIAJBgAJqIgQgAxCXASAGIAQQlgEgAkGABGoiByADEJYBIAMgABCWASADIAUQlwEgAxCwASACQYAKaiIEIAEQlgEgBCABQYAEahCXASAEELABIAMgBBAYIAcgAxCXASADIAUQlgECQCABKAKABkECRwRAIAJBwAxqIgMgAUGABWoQXiACQYAIaiADEKYBDAELIAJBwAxqIgMgAUGABWoQXiACQYAMaiIBIANBwAAQ0QEaIAJBgAhqIAEQpwELIAJBgAhqIgEQZCACQYAKaiIDIAEQlgEgAxArIAUgAkGABGoQlgEgBSADEJcBIAJBgAZqIgQgAxCXASABEGQgBiABEJcBIAQQsAEgBBBkIAAgAhCWASAAIAQQlwEMAwsgAkGACmoiAyAFEF4gAkHADGoiBCADEJkBIAMgAUGAAmoQXiAEIAMQEQsgACgCgAZBBEcEQCACQYAKaiIDIABBgAJqEF4gAkHADGoiBCADEJkBIAMgBhBeIAQgAxARCyACQYAEaiIDIAJB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AEHcu8AAKAIAQX4gA0EDdndxNgIACyAAIAEQoAEgAEH0vsAAKAIARw0BQey+wAAgATYCAAsPCyABQYACTwRAIAAgARAWDwsgAUEDdiICQQN0QeS7wABqIQECf0Hcu8AAKAIAIgNBASACdCICcQRAIAEoAggMAQtB3LvAACACIANyNgIAIAELIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIC+UDAQN/IwBB0CJrIgMkACADQcAWaiIEQcitwAAQSSADQcgcaiIFQYCuwAAQSSADQQhqIAQgBRBLIANBiAFqQTgQ0AEaIANBwAFqQTgQ0AEaIANB+AFqED0CQCACEIYBBEAgABBVDAELIANB+ARqIgQQPSAEIAEQfSAEEEcgA0H4B2oiARBnIAEgAhB4IAEQRiADQcgcaiICIAEQkAEgA0G4CWogAhCQASACIANBuAhqEJABIANB+AlqIAIQkAEgA0G4CmoiARA9IANBuA1qEFUgASAEEH0gA0HAE2oiARA9IAEgBBB9IAEQogEgA0HAAWogA0GIAWoQUEECayECA0AgAkEBakEBTQRAIANBuA1qIgEQngEgACABQYgGENEBGgUgA0G4DWoQGiADQcAWaiADQbgKaiADQbgJaiADQfgJahALAkACQAJAIANBwAFqIAIQUyADQYgBaiACEFNrQQFqDgMBAgACCyADQcgcaiIBIANBuApqIANB+ARqIANBuAlqIANB+AlqEAogA0HAFmogARADDAELIANByBxqIgEgA0G4CmogA0HAE2ogA0G4CWogA0H4CWoQCiADQcAWaiABEAMLIAJBAWshAiADQbgNaiADQcAWahABDAELCwsgA0HQImokAAvBAwEVfwNAIANBwAFGBEACQCAAQShqIQsgAEEUaigCACIMIQggAEEQaigCACINIQIgAEEMaigCACIOIQEgACgCCCIPIQMgAEEYaigCACIQIQogAEEcaigCACIRIQQgAEEgaigCACISIQcgAEEkaigCACITIQYDQCAHIQkgBCEHIAohBCAFQYACRg0BIAEgAnEhFCABIAJzIRUgBSALaigCACAFQcCiwABqKAIAIAkgBEF/c3EgBCAHcXIgBmogBEEadyAEQRV3cyAEQQd3c2pqaiIGIAhqIQogBUEEaiEFIAIhCCABIQIgAyIBQR53IAFBE3dzIAFBCndzIBQgASAVcXNqIAZqIQMgCSEGDAALAAsFIAAgA2oiAkHoAGogAkEoaigCACACQcwAaigCACACQeAAaigCACIBQQ93IAFBDXdzIAFBCnZzamogAkEsaigCACIBQRl3IAFBDndzIAFBA3ZzajYCACADQQRqIQMMAQsLIAAgBiATajYCJCAAIAkgEmo2AiAgACAHIBFqNgIcIAAgBCAQajYCGCAAIAggDGo2AhQgACACIA1qNgIQIAAgASAOajYCDCAAIAMgD2o2AggL5AEBAn8jAEGAA2siAyQAIAMQPSAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbyAAIAFBgANqIAJBAXNBAWtBH3YQbyAAIAFBgAZqIAJBAnNBAWtBH3YQbyAAIAFBgAlqIAJBA3NBAWtBH3YQbyAAIAFBgAxqIAJBBHNBAWtBH3YQbyAAIAFBgA9qIAJBBXNBAWtBH3YQbyAAIAFBgBJqIAJBBnNBAWtBH3YQbyAAIAFBgBVqIAJBB3NBAWtBH3YQbyADIAAQfSADEKIBIAAgAyAEQQFxEG8gA0GAA2okAAvlAwEIfyMAQZAGayICJAAgAEFAayEIAkAgAUH4AGooAgAgASgCOGqsIABB+ABqKAIAIgcgACgCOCIEaqx+Qv///w9XDQAgBEEBSgR/IAAQHiAAKAJ4BSAHC0EBTA0AIAgQHgsgAkHYpMAAEEkgAkE4aiIHQfAAENABGiACIQNBACECA0AgAkE4RgRAAkAgB0E4aiEEQQAhAgNAIAJBOEYNASACIARqIAIgA2opAwA3AwAgAkEIaiECDAALAAsFIAIgB2pCADcDACACQQhqIQIMAQsLIANBqAFqIgYgABBdIANB4AFqIgUgARBdIANBmAJqIgIgACABEAUgA0GIA2oiBCAIIAFBQGsiARAFIAYgCBBgIAYQQiAFIAEQYCAFEEIgA0H4A2oiCSAGIAUQBUEAIQEgA0HoBGoiBkHwABDQASEFA0AgAUHwAEcEQCABIAVqIAEgAmopAwA3AwAgAUEIaiEBDAELCyAGIAQQYkEAIQEDQCABQfAARwRAIAEgBGoiBSABIAdqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAiAEEGIgAhBIIAkgBhBjIAkQSCADQdgFaiIBIAIQayAAIAEQaiAAQQM2AjggASAJEGsgCCABEGogAEECNgJ4IANBkAZqJAALowIBCH8jAEGABmsiAiQAIAIgAEGAAWoiBxBeIAJBgAFqIgQgBxBeIAQQLSACQYACaiIFIAIQXiAFIABBgAJqIgMQESACQYADaiIBIAMQXiABEC0gAyAEEJkBIAMgBBCaASADEKkBIAMQuAEgAxC4ASADEKkBIAFBDBCrASABEHwgARCpASACQYAEaiIIIAEQXiAIIAMQESACQYAFaiIGIAQQXiAGIAEQmgEgBhCpASADIAUQESAFIAEQmQEgBSABEJoBIAEgBRCaASABEKkBIAQgARB7IAQQqQEgBiAEEBEgBiAIEJoBIAUgABCZASAFIAIQESAAIAQQmQEgABCpASAAIAUQESAAELgBIAAQqQEgByAGEJkBIAcQqQEgAkGABmokAAu8AgEGfyMAQYAIayIBJAAgASAAEIwBIAFBgAJqIgMgAEGABGoiBRCMASABQYAEaiIEIABBgAJqIgYQjAEgAUGABmoiAkE4ENABGiABQQE2ArgGIAFBwAZqQTgQ0AEaIAFB+AZqQQE2AgAgAUGAB2pBOBDQARogAUG4B2pBATYCACABQcAHakE4ENABGiABQfgHakEBNgIAIAAQISACIAAQlgEgAiAAEJcBIAAgAhCXASAAELABIAEQyQEgARCzASAAIAEQlwEgAxAhIAMQZCACIAMQlgEgAiADEJcBIAMgAhCXASADELABIAQQISACIAQQlgEgAiAEEJcBIAQgAhCXASAEELABIAYQsgEgBhCzASAFEMkBIAUQswEgBiADEJcBIAUgBBCXASAAQQU2AoAGIAAQnAEgAUGACGokAAv/AQEHfyMAQcACayIBJAAgASAAQUBrIgYQkAEgARBMIAFBQGsiAyAGEJABIAMgAEGAAWoiAhBKIAFBgAFqIgQgAhCQASAEEEwgAiABEK4BIAIgARB3IAIQQiACEIIBIAIQggEgAhBCIARBDBA0IAFBwAFqIgcgBBCQASAHIAIQSiABQYACaiIFIAEQkAEgBSAEEHcgBRBCIAIgAxBKIAMgBBCuASADIAQQdyAEIAMQdyABIAQQfiABEEIgBSABEEogBSAHEHcgAyAAEK4BIAMgBhBKIAAgARCuASAAEEIgACADEEogABCCASAAEEIgBiAFEK4BIAYQQiABQcACaiQAC84CAgd/An4CQAJAAkBBDSABQTpuIgJrIgRBDU0EQEEMIAJrIgNBDk8NASAAIAAgA0EDdGopAwBBOiABIAJBOmxrIgNrrSIKhyAAIARBA3RqKQMAIAOtIgmGhDcDaCAEQQ1rIQUgAEHgAGohBCACQQFqIQZBACACQQN0ayEHQQshAwNAAkAgA0ECaiAGTQRAIAFBrAZPDQEgACACQQN0aiAAKQMAIAmGQv//////////A4M3AwADQCACRQ0HIABCADcDACACQQFrIQIgAEEIaiEADAALAAsgAyAFakEOTw0EIAQgBCAHaiIIQQhrKQMAIAqHIAgpAwAgCYZC//////////8Dg4Q3AwAgA0EBayEDIARBCGshBAwBCwsgAkEOQYCywAAQOwALIARBDkHQscAAEDsACyADQQ5B4LHAABA7AAtBf0EOQfCxwAAQOwALC6cCAQR/IABCADcCECAAAn9BACABQYACSQ0AGkEfIAFB////B0sNABogAUEGIAFBCHZnIgNrdkEBcSADQQF0a0E+agsiBDYCHCAEQQJ0Qey9wABqIQMgACECAkACQAJAAkBB4LvAACgCACIAQQEgBHQiBXEEQCADKAIAIQMgBBCfASEAIAMQywEgAUcNASADIQAMAgtB4LvAACAAIAVyNgIAIAMgAjYCAAwDCyABIAB0IQQDQCADIARBHXZBBHFqQRBqIgUoAgAiAEUNAiAEQQF0IQQgACIDEMsBIAFHDQALCyAAKAIIIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCCACQQA2AhgPCyAFIAI2AgALIAIgAzYCGCACIAI2AgggAiACNgIMC7YCAQV/IAAoAhghBAJAAkAgACAAKAIMRgRAIABBFEEQIABBFGoiASgCACIDG2ooAgAiAg0BQQAhAQwCCyAAKAIIIgIgACgCDCIBNgIMIAEgAjYCCAwBCyABIABBEGogAxshAwNAIAMhBSACIgFBFGoiAygCACICRQRAIAFBEGohAyABKAIQIQILIAINAAsgBUEANgIACwJAIARFDQACQCAAIAAoAhxBAnRB7L3AAGoiAigCAEcEQCAEQRBBFCAEKAIQIABGG2ogATYCACABDQEMAgsgAiABNgIAIAENAEHgu8AAQeC7wAAoAgBBfiAAKAIcd3E2AgAPCyABIAQ2AhggACgCECICBEAgASACNgIQIAIgATYCGAsgAEEUaigCACIARQ0AIAFBFGogADYCACAAIAE2AhgLC+UBAQZ/IwBBgARrIgIkACACIAAQXiACQYABaiIFIABBgAFqIgYQXiACQYACaiIDQTgQ0AEaIAJBATYCuAIgAkHAAmpBOBDQARogAkH4AmpBATYCACACQYADaiIEIAYQXiACIAEQESAFIAFBgAFqIgcQESADIAcQmQEgAyABEJoBIAQgABCaASADEKkBIAQQqQEgBCADEBEgAyACEJkBIAMQNiAEIAMQmgEgBBCpASADIAUQmQEgAxA2IAYgBBCZASAGIAMQmgEgBRB8IAAgBRCZASAAIAIQmgEgABCwASACQYAEaiQAC28BDH9BjL/AACgCACICRQRAQZy/wABB/x82AgBBAA8LQYS/wAAhBgNAIAIiASgCCCECIAEoAgQhAyABKAIAIQQgAUEMaigCABogASEGIAVBAWohBSACDQALQZy/wAAgBUH/HyAFQf8fSxs2AgBBAAuAAgEGfyMAQYAIayIBJAAgACgCgAZBAUcEQCABIAAQjAEgAUGAAmoiAiAAQYACaiIEEIwBIAFBgARqIgUgAEGABGoiAxCMASABQYAGaiIGIAAQjAEgARAhIAIgAxAYIAIQswEgAhCwASAFECEgBiAEEBggBhCzASADIAAQlwEgAyAEEJcBIAMQsAEgAxAhIAAgARCWASABIAIQlwEgARCwASABIAUQlwEgASAGEJcBIAEQsAEgARArIAIQZCAFEGQgACACEJcBIAQgBRCWASAEIAYQlwEgAyABEJcBIABBBEEFIAAoAoAGQX5xQQJGGzYCgAYgABCdAQsgAUGACGokAAuZAgEBfyMAQYANayIDJAAgAyABEGkgAxCdASADQYgGaiIBIAIQXSABEEIgA0HABmoiAiABEF0gAkEDECkaIAIQQiADQfgGaiADEGkCQCACEFdFBEAgA0HABmoQKkECayECA0AgAkEBakEBTQRAIANB+AZqIgEQnAEMAwUgA0H4BmoQEwJAAkACQCADQcAGaiACEFMgA0GIBmogAhBTa0EBag4DAQIAAgsgA0H4BmogAxAHDAELIAMQngEgA0H4BmogAxAHIAMQngELIAJBAWshAgwBCwALAAsgA0H4BmoiARC3ASABQYABahC2ASABQYACahCxASABQYAEahCxASABQQE2AoAGCyAAIAFBiAYQ0QEaIANBgA1qJAALhgICBH8BfiMAQTBrIgIkACABQQRqIQQgASgCBEUEQCABKAIAIQMgAkEQaiIFQQA2AgAgAkIBNwMIIAIgAkEIajYCFCACQShqIANBEGopAgA3AwAgAkEgaiADQQhqKQIANwMAIAIgAykCADcDGCACQRRqIAJBGGoQDBogBEEIaiAFKAIANgIAIAQgAikDCDcCAAsgAkEgaiIDIARBCGooAgA2AgAgAUEMakEANgIAIAQpAgAhBiABQgE3AgQgAiAGNwMYQQxBBBC5ASIBRQRAQQxBBBDPAQALIAEgAikDGDcCACABQQhqIAMoAgA2AgAgAEGEt8AANgIEIAAgATYCACACQTBqJAAL5AEBAn8jAEHAAWsiAyQAIAMQZyAAIAEgAkEfdSIEIAJzIARBf3NqQQJtIgJBAWtBH3YQbiAAIAFBwAFqIAJBAXNBAWtBH3YQbiAAIAFBgANqIAJBAnNBAWtBH3YQbiAAIAFBwARqIAJBA3NBAWtBH3YQbiAAIAFBgAZqIAJBBHNBAWtBH3YQbiAAIAFBwAdqIAJBBXNBAWtBH3YQbiAAIAFBgAlqIAJBBnNBAWtBH3YQbiAAIAFBwApqIAJBB3NBAWtBH3YQbiADIAAQeCADEKQBIAAgAyAEQQFxEG4gA0HAAWokAAvDAwIGfwN+IwBB8ABrIgEkACABQcCywAAQSSABQThqIAEQXSAAEEICQAJAAkAgAQJ/IAAoAjgiAkEQTARAIAJBAWsQNQwBCyABKQMwIghCAXwiByAIVA0BIAApAzAiCEKAgICAgICAgIB/USAHQn9RcQ0CIAFBOGoiAiAIIAd/pxApIQcgASABKQNoIAdCOoZ8NwNoIAAgAhBhIAAQQkECCyIEECgDQCAERQ0DQQAhAyABIAEpAwgiCEI5hkKAgICAgICAgAKDIAEpAwBCAYeEIgc3AwAgACkDACAHfSEHIABBCGohBSAAIAFBOGoiAkEBA38gAiADaiAHQv//////////A4M3AwAgB0I6hyEHIANBKEYEfyABIAEpAzBCAYciCDcDMCACIAApAzAgCH0gB3wiBzcDMCAHQj+IpwUgASADaiIGQQhqIAhCAYcgBkEQaikDACIIQjmGQoCAgICAgICAAoOEIgk3AwAgAyAFaikDACAHfCAJfSEHIANBCGohAwwBCwtrEDAgBEEBayEEDAALAAtB4LPAAEEZQcSzwAAQWQALQYC0wABBH0HEs8AAEFkACyAAQQE2AjggAUHwAGokAAvuAQECfyMAQbABayIDJAAgA0EwENABIQMCQAJAA0AgAkEwRgRAIANBMGogAxBwIAFBMGohAUEAIQIDQCACQTBGDQMgAkEwRg0EIAIgA2ogASACai0AADoAACACQQFqIQIMAAsACyACQeAARwRAIAIgA2ogASACai0AADoAACACQQFqIQIMAQsLQeAAQeAAQYCmwAAQOwALIANB8ABqIgEgAxBwIABBOBDQASIAQQE2AjggAEFAa0E4ENABIABB+ABqQQE2AgAgACABEK4BIANBMGoQrgEgA0GwAWokAA8LIAJBMGpB4ABBkKbAABA7AAuPAgEDfyMAQSBrIgUkAEEBIQZB2LvAAEHYu8AAKAIAIgdBAWo2AgACQEGgv8AALQAABEBBpL/AACgCAEEBaiEGDAELQaC/wABBAToAAAtBpL/AACAGNgIAAkACQCAHQQBIIAZBAktyDQAgBSAEOgAYIAUgAzYCFCAFIAI2AhBBzLvAACgCACICQQBIDQBBzLvAACACQQFqIgI2AgBBzLvAAEHUu8AAKAIAIgMEf0HQu8AAKAIAIAUgACABKAIQEQAAIAUgBSkDADcDCCAFQQhqIAMoAhQRAABBzLvAACgCAAUgAgtBAWs2AgAgBkEBSw0AIAQNAQsACyMAQRBrIgIkACACIAE2AgwgAiAANgIIAAucAQEEfyMAQYADayICJAAgAiAAEF4gAkGAAWoiASAAQYABaiIEEF4gAkGAAmoiAyAAEF4gAyAEEBEgAiAEEJoBIAEQfCABIAAQmgEgAhCpASABEKkBIAAgAhCZASAAIAEQESABIAMQmQEgARB8IAEgAxCaASABEKkBIAEQNiAAIAEQmgEgAxC4ASAEIAMQmQEgABCwASACQYADaiQAC7kBAQJ/IwBBIGsiAyQAAkAgASABIAJqIgFLDQAgAEEEaigCACICQQF0IgQgASABIARJGyIBQQggAUEISxshAQJAIAIEQCADQRhqQQE2AgAgAyACNgIUIAMgACgCADYCEAwBCyADQQA2AhALIAMgASADQRBqECYgAygCAARAIANBCGooAgAiAEUNASADKAIEIAAQzwEACyADKAIEIQIgAEEEaiABNgIAIAAgAjYCACADQSBqJAAPCxBlAAusAQECfyMAQYADayIDJAAgA0EIaiABEJABAkAgAgRAIANBCGogAhCuAQwBCyADQQhqEDoLIANByABqIgJB8LTAABBJIANBgAFqIAIQjgEgA0HAAWoiAiADQQhqIgQQkAEgAhBMIAIgARBKIAAgARCQASAAIAQQSiADQYACaiACEJABIAAQViEBIANBwAJqIgIgABCQASACEEMgAhBCIAAgAiABEHIgA0GAA2okAAueAQEFfyMAQYABayICJAAgAkE4ENABIgJBATYCOCACQUBrIgNBOBDQARogAkEBNgJ4IAIgABCuASACIAFBgAFqIgUQSiADIAEQrgEgAyAAQYABaiIGEEoCQCACIAMQWEUNACACIABBQGsQrgEgAiAFEEogAkFAayIAIAFBQGsQrgEgACAGEEogAiAAEFhFDQBBASEECyACQYABaiQAIAQLpwEBA38jAEEwayICJAAgAUEEaiEDIAEoAgRFBEAgASgCACEBIAJBEGoiBEEANgIAIAJCATcDCCACIAJBCGo2AhQgAkEoaiABQRBqKQIANwMAIAJBIGogAUEIaikCADcDACACIAEpAgA3AxggAkEUaiACQRhqEAwaIANBCGogBCgCADYCACADIAIpAwg3AgALIABBhLfAADYCBCAAIAM2AgAgAkEwaiQAC5UBAQJ/AkACQAJAAkACfwJAAkACf0EBIgMgAUEASA0AGiACKAIAIgRFDQEgAigCBCICDQQgAQ0CQQEMAwshA0EAIQEMBgsgAQ0AQQEMAQsgAUEBELkBCyICRQ0BDAILIAQgARCsASICDQELIAAgATYCBEEBIQEMAQsgACACNgIEQQAhAwsgACADNgIAIABBCGogATYCAAvvMwISfwV+IwBBMGsiDiQAIA5BEGogACABEFsgDiAOKAIUIgA2AhwgDiAOKAIQIgg2AhggDkEIaiACIAMQWyAOIA4oAgwiATYCJCAOIA4oAggiAzYCICAOIAQgBRBbIA4gDigCBCIFNgIsIA4gDigCACINNgIoIAAhBCMAQZAVayICJAAjAEGwBmsiCiQAIApBEGpBOBDQARogCkHQAGpBOBDQASEVIApBiAFqQQE2AgAgCkEBNgJIIApBkAFqIgBB2KTAABBJIAAQKiEPIApByAFqIhNBgAIQ0AEaIApB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ABBJAkACQAJAAkADQAJAIAxBMEYEQCAAIAAtAABBH3E6AAAgAEHoAGogABC+ASAEDQFBAEEAQZiBwAAQOwALIAQgDEYNAiAAIAxqIAggDGotAAA6AAAgDEEBaiEMDAELC0EAIQwgCCwAACIJQQBIDQIgCEEwaiEDIARBMCAEQTBLG0EwayEIA0AgDEEwRgRAIABBoAFqIgQgABC+ASMAQYABayIDJAAgARBnIAEgAEHoAGoQwAEgAUFAayIIIAQQwAEgAUGAAWoQygEgARBCIAMgARBPIANBQGsiBCAIEJABIAQQTCAEIAMQWEUEQCABEJIBCyADQYABaiQADAULIAggDEYNAiAAIAxqIAMgDGotAAA6AAAgDEEBaiEMDAALAAsgBCAEQYiBwAAQOwALIAxBMGogBEGogcAAEDsACyMAQcABayIDJAAgAEGgAWoiBBBnIANBOBDQASIDQQE2AjggBCAAQegAahDAASAEEEIgBEGAAWoQygEgA0FAayIIIAQQTwJAAkACQCAIIAMQWkEBRgRAIANBgAFqIgggA0FAayADECMgCBBWDQEMAgsgBBCSAQwCCyADQYABaiIIEEMgCBBCCyAEQUBrIANBgAFqEK4BCyADQcABaiQAIAlBIHEiA0EAIABB4AFqEE0iBEEBRxtBASADIARBAUdyGwRAIABBoAFqEKQBCyABIABBoAFqQcABENEBGgsgAEHgAmokAAJ/QQAhAyMAQcAFayIAJAACQCABEIYBDQAgAEEIaiIIQZCtwAAQSSAAQYAEaiIEQbiuwAAQSSAAQUBrIgkgBBCOASAAQYABaiIEEGcgBCABEHggBCAJEEogAEHAAmoiBCABIAgQvQEgASAEECQNACAAQYAEaiIEIABBwAJqIgEgAEEIahC9ASABIARBwAEQ0QEaIAEQpAEgAEGAAWogARAkRQ0AQQEhAwsgAEHABWokAEF/IANFDQAaIAJBwAFqEKQBIAJBgANqIQhBACEAIwBB4ARrIgEkACABQeAAENABIQECQCAFBEADQCAAQeAARgRAIAEgAS0AAEEfcToAACABQeAAaiABEB9BACEAAkAgDSwAACILQQBOBEAgDUHgAGohAyAFQeAAIAVB4ABLG0HgAGshBANAIABB4ABGBEAgAUHgAWoiACABEB8gCCABQeAAaiAAED8MAwsgACAERwRA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AWoQmQEgACAEEBEgAEGAAWoiASAFQYABahCZASABIAgQESAAIAEQeg0BC0EADAELQQELIQEgAEGAAmokACANQcAHaiQAQX8gAUUNABojAEHgA2siACQAIABBgAFqIgFBwKjAABBJIABBuAFqIgNB+KjAABBJIAAgASADEEsgAEHwAmoiAUGwqcAAEEkgAEGoA2oiA0HoqcAAEEkgAEHwAWoiBCABIAMQSyACQYAGaiIBIAAgBBA/IABB4ANqJAAgAkGACWohByACQYADaiEIIwBBkDRrIgAkACAAQYAoaiIDQcitwAAQSSAAQYguaiIEQYCuwAAQSSAAIAMgBBBLIABBgAFqQTgQ0AEaIABBuAFqQTgQ0AEaIABB8AFqED0CQCACQcABaiIEEIYBRQRAIAIQhgEEQCAHIAEgBBAODAILIABB8ARqIgMQPSADIAEQfSADEEcgAEHwB2oiBRBnIAUgBBB4IAUQRiAAQbAJaiIEED0gBCAIEH0gBBBHIABBsAxqIggQZyAIIAIQeCAIEEYgAEGILmoiASAFEJABIABB8A1qIAEQkAEgASAAQbAIahCQASAAQbAOaiABEJABIAEgCBCQASAAQfAOaiABEJABIAEgAEHwDGoQkAEgAEGwD2ogARCQASAAQfAPaiIBED0gAEHwEmoiBRA9IABB8BVqEFUgASADEH0gBSAEEH0gAEH4G2oiARA9IAEgAxB9IAEQogEgAEH4HmoiARA9IAEgBBB9IAEQogEgAEG4AWogAEGAAWoQUEECayEBA0AgAUEBakEBTQRAIABB8BVqIgEQngEgByABQYgGENEBGgwDBSAAQfAVaiIEEBogAEH4IWoiAyAAQfAPaiAAQfANaiAAQbAOahALIABBgChqIgUgAEHwEmogAEHwDmogAEGwD2oQCyADIAUQAyAEIAMQAQJAAkACQCAAQbgBaiABEFMgAEGAAWogARBTa0EBag4DAQIAAgsgAEGILmoiAyAAQfAPaiAAQfAEaiAAQfANaiAAQbAOahAKIABB+CFqIgQgA0GIBhDRARogAyAAQfASaiAAQbAJaiAAQfAOaiAAQbAPahAKIAQgAxADIABB8BVqIAQQAQwBCyAAQYguaiIDIABB8A9qIABB+BtqIABB8A1qIABBsA5qEAogAEH4IWoiBCADQYgGENEBGiADIABB8BJqIABB+B5qIABB8A5qIABBsA9qEAogBCADEAMgAEHwFWogBBABCyABQQFrIQEMAQsACwALIAcgCCACEA4LIABBkDRqJAAjAEHgH2siCCQAIAhB0BNqIgFByK3AABBJIAhB2BlqIg1BgK7AABBJIAggASANEEsgCEGAAWoiC0GQrcAAEEkgAkGID2oiACAHEGkgCEG4AWoiBSAAEGkjAEGACGsiAyQAIAMgBRCMASADQYACaiIJIAVBgAJqIg8QjAEgA0GABGoiCiAFEIwBIANBgAZqIgRBOBDQARogA0EBNgK4BiADQcAGakE4ENABGiADQfgGakEBNgIAIANBgAdqQTgQ0AEaIANBuAdqQQE2AgAgA0HAB2pBOBDQARogA0H4B2pBATYCACAFEJ0BIAMQISAJIAVBgARqIgwQGCAJEGQgAyAJEHkgAxCwASAJIAwQlgEgCRAhIAkQZCAKIA8QGCAJIAoQeSAJELABIAogDxCWASAKECEgBCAFEJYBIAQgDBAYIAogBBB5IAoQsAEgBCAPEJYBIAQgChAYIAQQZCAFIAMQGCAEIAUQlwEgDCAJEBggDBBkIAQgDBCXASAEELABIwBBgAJrIgYkACAGIAQQXiAGQYABaiIQIARBgAFqIhIQXiAGEC0gEBAtIBAQfCAQEKkBIAYgEBB7IAYQPiAEIAYQESAGEDYgBhCpASASIAYQESAGQYACaiQAIAUgAxCWASAFIAQQGCAPIAkQlgEgDyAEEBggDCAKEJYBIAwgBBAYIAVBBTYCgAYgA0GACGokACAAEJ4BIAAgBRAHIAUgABBtIAAgCBAyIAAgCBAyIAAgBRAHIAhBwAdqIgQgABBpIAQQEyAEIAAQByANIAAgCxAbIAhByA1qIgMgDRBpIAMQngEgASAAEGkgARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gARCeASAAIAMQbSAAIAEQByANIAAgCxAbIAMgDRBtIAMQngEgASAAEG0gASAIEDIgACADEG0gACABEAcgDSAAIAsQGyADIA0QbSANIAMgCxAbIAMgDRBtIAEgABBtIAEgCBAyIAEgCBAyIAMgARAHIAEgABBtIAEQngEgACADEG0gACABEAcgACAEEAcgABCcASAIQeAfaiQAIAcgAEGIBhDRARpBACEAIwBBgAJrIgEkACABEGwCQCAHIAEQegR/IAdBgAFqIAFBgAFqEHoFQQALRQ0AIAdBgAJqEIcBRQ0AIAdBgARqEIcBIQALIAFBgAJqJABBACAADQAaQX8LIAJBkBVqJAAgDkEoahC0ASAOQSBqELQBIA5BGGoQtAEgDkEwaiQAC58BAgJ/BX4gAEEwaiICKQMAIAFBP3GtIgSGIQUgACkDKCIGQTogAWtBP3GtIgiHIQdBBiEBA38gAiAFIAeENwMAIAFBAU0EfyAAIAApAwAgBIZC//////////8DgzcDACAAKQMwQiSHpwUgAUEBayEBIAJBEGsiA0EIaiECIAYgBIZC//////////8DgyEHIAMpAwAiBiAIhyEFDAELCxoLiAECA34DfyMAQRBrIgUkAAN+IAZBOEYEfiAFQRBqJAAgAwUgBSAAIAZqIgcpAwAiAiACQj+HIAGsIgIgAkI/hxAvIAcgBSkDACIEIAN8IgJC//////////8DgzcDACACIARUrSAFQQhqKQMAIANCP4d8fEIGhiACQjqIhCEDIAZBCGohBgwBCwsLigECA38BfiMAQUBqIgIkACACQQhqIgEgABBdIAEQQiACQThqIQFBBiEDQdwCIQACQAJAA0AgA0EATgRAIAEpAwAiBEIAUg0CIAFBCGshASAAQTprIQAgA0EBayEDDAELC0EAIQAMAQsDQCAEUA0BIABBAWohACAEQgJ/IQQMAAsACyACQUBrJAAgAAuHAQEDfyMAQYACayIBJAAgABCwASABIAAQXiABQYABaiICQTgQ0AEaIAFBATYCuAEgAUHAAWpBOBDQARogAUH4AWpBATYCACABIABBgAFqIgMQmgEgARA2IAIgARCZASACIAMQmgEgAyABEJkBIAMgABCaASAAIAIQmQEgABCwASABQYACaiQAC30CBH4BfyABQT9xrSECQTogAWtBP3GtIQRBACEBIAApAwAiBSEDA38gAUEwRgR/IAAgACkDMCAChzcDMCAFQn8gAoZCf4WDpwUgACABaiIGIAMgAocgBkEIaikDACIDIASGQv//////////A4OENwMAIAFBCGohAQwBCwsaC2kBBH8jAEHAAWsiASQAIAEgABCQASABQUBrIgIgABCQASABQYABaiIDIABBQGsiBBCQASABIAQQdyACIAAQdyACEEIgBCACEEogAxBDIAAgAxB3IAEQQiAAEEIgACABEEogAUHAAWokAAuCAQIBfwF+IABB8AAQ0AEhAANAIAJBOEYEQAJAIAAgASkDMCIDQjqHNwM4IAAgA0L//////////wODNwMwIABBQGshAEEAIQIDQCACQTBGDQEgACACakIANwMAIAJBCGohAgwACwALBSAAIAJqIAEgAmopAwA3AwAgAkEIaiECDAELCwtuAQZ+IAAgA0L/////D4MiBSABQv////8PgyIGfiIHIAUgAUIgiCIIfiIJIAYgA0IgiCIGfnwiBUIghnwiCjcDACAAIAcgClatIAYgCH4gBSAJVK1CIIYgBUIgiIR8fCABIAR+IAIgA358fDcDCAtqAgF/BX4gASkDCCAAKQMAhSIGQgGGQgGHIQdBACACa6whCAN+IANBOEYEfiAFBSAAIANqIgIgAikDACIEIAaFIAEgA2opAwAgBIUgCIOFIgQgB4U3AwAgBCAFhSEFIANBCGohAwwBCwsaC18CAX8EfkIBIQNBMCECA38gAkF4RgR/IARCAYYgA3ynQQFrBSABIAJqKQMAIgUgACACaikDACIGfUI6hyADgyAEhCEEIAJBCGshAiAFIAaFQgF9QjqHIAODIQMMAQsLC2kBBH8jAEGAAmsiAiQAIAIgARBeIAJBgAFqIgMgARBeIAIQLSADIAIQESAAIAMQmAEgAEGAAmoiBCADEJgBIABBgARqIgUgAxCYASAEIAEQpgEgBSACEKYBIABBBTYCgAYgAkGAAmokAAtiAQJ/IwBBQGoiAiQAIAAQQiACIAAQkAECQCABBEAgACABEK4BDAELIAAQOgtBACEBA0AgA0UEQCAAEExBASABQQFqIAFBAUYiAxshAQwBCwsgACACEEogABAeIAJBQGskAAtnAQJ/IwBBQGoiAyQAAkAgASABQR91IgJqIAJzIgIgACgCOGxBgICAEE4EQCADIAIQOSAAIAMQSgwBCyAAIAIQKRogACAAKAI4IAJsNgI4CyABQQBIBEAgABBDIAAQQgsgA0FAayQAC2cAIABBAXYgAHIiAEECdiAAciIAQQR2IAByIgBBCHYgAHIiAEEQdiAAciIAIABBAXZB1arVqgVxayIAQQJ2QbPmzJkDcSAAQbPmzJkDcWoiAEEEdiAAakGPnrz4AHFBgYKECGxBGHYLYQEDfyMAQYABayIBJAAgASAAEJABIAFBQGsiAkE4ENABGiABQQE2AnggASAAQUBrIgMQdyABEEMgAiABEK4BIAIgAxB3IAMgARCuASADIAAQdyAAIAIQrgEgAUGAAWokAAtVAgJ/AX4jAEHwAGsiASQAIAFBwLLAABBJIAApAwAhAyABQThqIgIgABBdIABBARAsIAIgARBgIAIQQiACQQEQLCAAIAIgA0ICgacQMCABQfAAaiQAC5gBAQZ/IwBBwAFrIgMkACAAIAEQXiAAEC0gA0GIAWoiBkHop8AAEEkjAEFAaiIEJAAgA0EIaiICQTgQ0AEiBUEBNgI4IAVBQGtBOBDQASAFQfgAakEBNgIAIAQgBhCOASAFIAQQrgEQwQEgBEFAayQAIAIQqQEgAhB8IAIQqQEgACABEBEgACACEJoBIAAQtQEgA0HAAWokAAtZAQJ/IwBBQGoiAyQAIABBOBDQASIAQQE2AjgCQCABQQBOBEAgACABEJMBDAELIANBCGoiAkHAssAAEEkgAiABEJMBIAIQQiAAIAIQagsgABBUIANBQGskAAu9CAEKfyMAQYABayIHJAAgB0EIaiIDQcCywAAQSSADQQEQlAECQAJAA0AgAUEwRgRAIANBMGogAykDMEIBhzcDACADQThqIQEDQCACRQ0EIAFCADcDACACQQFrIQIgAUEIaiEBDAALAAsgAUE4Rg0BIAFBOEcEQCABIANqIAEgA2oiBEEIaikDAEI5hkL//////////wODIAQpAwBCAYeENwMAIAVBAWohBSABQQhqIQEMAQsLQQdBB0GEm8AAEDsACyAFQQdB9JrAABA7AAsgA0EBEJQBIANBARAsIAdBQGshBUEAIQIjAEGgCmsiASQAIAFBOBDQASIBQUBrQTgQ0AEhBiABQYABakE4ENABGiABQcABakE4ENABGiABQYACakE4ENABGiABQcACakE4ENABGiABQYADakE4ENABGiABQcADakE4ENABGiABQYAEakE4ENABGiABQcAEakE4ENABGiABQYAFakE4ENABGiABQcAFakE4ENABGiABQYAGakE4ENABGiABQcAGakE4ENABGiABQYAHakE4ENABGiABQcAHakE4ENABGiABQfgHakEBNgIAIAFBuAdqQQE2AgAgAUH4BmpBATYCACABQbgGakEBNgIAIAFB+AVqQQE2AgAgAUG4BWpBATYCACABQfgEakEBNgIAIAFBuARqQQE2AgAgAUH4A2pBATYCACABQbgDakEBNgIAIAFB+AJqQQE2AgAgAUG4AmpBATYCACABQfgBakEBNgIAIAFBuAFqQQE2AgAgAUH4AGpBATYCACABQQE2AjggAUGBCGpB5wAQ0AEaIAFB6AhqIgQgABCQASAEEEIgAUGoCWoiBCADEF0gBBBCIAQQKkEDaiIIQQJ2IgNBAWohCQJAA0AgAiAJRgRAIAEQygEgBiABQegIahCuASABQeAJakE4ENABGiABQQE2ApgKQYB5IQIMAgsgAUGoCWoiBCAEQQQQjwEiChCUASAEEEIgAkHnAEcEQCABQYEIaiACaiAKOgAAIAFBqAlqQQQQLCACQQFqIQIMAQsLQecAQecAQaC0wAAQOwALA0AgAgRAIAFB4AlqIgQgASACaiIGQcAHahCuASAGQYAIaiIGIAQQrgEgBiABQegIahBKIAJBQGshAgwBCwsCQAJAAkACQCAIQZwDSQRAIAFBgQhqIANqLAAAIgJBEE8NASAFIAEgAkEGdGoQkAEgA0EBayICQeYASyEEA0AgAkF/Rg0DIAUQTCAFEEwgBRBMIAUQTCAEDQQgAUGBCGogAmotAAAiA0EQSQRAIAUgASADQQZ0ahBKIAJBAWshAgwBCwsgA0EYdEEYdUEQQeC0wAAQOwALIANB5wBBsLTAABA7AAsgAkEQQcC0wAAQOwALIAUQHiABQaAKaiQADAELIAJB5wBB0LTAABA7AAsgACAFEK4BIAdBgAFqJAALbAEBfyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQE2AgAgA0ICNwIMIANB2LjAADYCCCADQQE2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEGYAC2UBAn8gACAAKAIAIgJBCGoiAzYCACAAIAJBA3ZBPHFqQShqIgIgAUH/AXEgAigCAEEIdHI2AgACQAJAIANFBEAgAEEANgIAIAAgACgCBEEBajYCBAwBCyADQf8DcQ0BCyAAEA8LC1wAIABBOBDQASIAQQE2AjggAEFAa0E4ENABGiAAQfgAakEBNgIAIABBgAFqEFEgAEGAAmpBOBDQARogAEG4AmpBATYCACAAQcACakE4ENABGiAAQfgCakEBNgIAC1sBA38jAEGAAWsiASQAIAAQqQEgASAAEJABIAFBQGsiAiAAQUBrIgMQkAEgARBMIAIQTCABIAIQdyABQQAQMyAAIAEQSiABEEMgARBCIAMgARBKIAFBgAFqJAALYQEBfyMAQYACayIDJAAgABA9IAAgARCZASAAQYABaiIBIAIQmQEgAEGAAmoQtwEgABCpASADIAAQOCADQYABaiICIAEQXiACEC0gAiADEHpFBEAgABCbAQsgA0GAAmokAAtUAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqIAJBCGoQDCACQSBqJAALZwAjAEEwayIBJABBpLvAAC0AAARAIAFBHGpBATYCACABQgI3AgwgAUGQtsAANgIIIAFBATYCJCABIAA2AiwgASABQSBqNgIYIAEgAUEsajYCICABQQhqQbi2wAAQZgALIAFBMGokAAtiAgF+An8gACkDACEBA34gACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkEoRgR+IAAgACkDMCABfCIBNwMwIAFCJIcFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLGgt8AQV/IwBBQGoiAyQAIANBCGoiAkHAssAAEEkgAiAAKAI4QQFrEDUiBBAoA0AgAUE4RwRAIAAgAWoiBSABIAJqKQMAIAUpAwB9NwMAIAFBCGohAQwBCwsgAEEBIARBAWp0IgI2AjggAkH///8PSgRAIAAQHgsgA0FAayQAC3sBAn8gAEEoaiECA0AgAUGAAkYEQCAAQufMp9DW0Ouzu383AgggAEIANwIAIABBIGpCq7OP/JGjs/DbADcCACAAQRhqQv+kuYjFkdqCm383AgAgAEEQakLy5rvjo6f9p6V/NwIABSABIAJqQQA2AgAgAUEEaiEBDAELCwtUACAAQTgQ0AEiAEEBNgI4IABBQGtBOBDQARogAEH4AGpBATYCACAAQYABakE4ENABGiAAQbgBakEBNgIAIABBwAFqQTgQ0AEaIABB+AFqQQE2AgALWAECfyMAQUBqIgEkAAJAIAAQhgENACABQQEQOSAAQYABaiICIAEQWA0AIAJBABAzIAAgAhBKIAAQHiAAQUBrIgAgAhBKIAAQHiACIAEQrgELIAFBQGskAAtZAQJ/IwBBgAFrIgEkAAJAIAAQigENACABEFEgAEGAAmoiAiABEHoNACACED4gACACEBEgABC1ASAAQYABaiIAIAIQESAAELUBIAIgARCZAQsgAUGAAWokAAtbAgF+An8gACkDACEBA0AgACACaiIDIAFC//////////8DgzcDACABQjqHIQEgAkHgAEYEQCAAIAApA2ggAXw3A2gFIAJBCGohAiADQQhqKQMAIAF8IQEMAQsLC08BAX8gAEE4ENABGgJAA0AgAkEHRwRAIAJBB0YNAiAAIAEpAwA3AwAgAEEIaiEAIAFBCGohASACQQFqIQIMAQsLDwtBB0EHQeSawAAQOwALVAECfyMAQbABayICJAAgATQCOCAANAI4fkL///8PVQRAIAAQHgsgAkEIaiIDIAAgARAFIAJB+ABqIgEgAxBrIAAgARBqIABBAjYCOCACQbABaiQAC1EBAn8jAEFAaiIDJAAgAEE4ENABIgBBATYCOCAAQUBrQTgQ0AEgAEH4AGpBATYCACADIAEQjgEgACADEK4BIAMgAhCOASADEK4BIANBQGskAAvwDAIRfwh+IwBBsAFrIg8kACAANAI4IhIgEn5C////D1YEQCAAEB4LIwBB0AFrIgEkACAPQQhqIgZBCGpB0AAQ0AEaIAFBwAFqIAApAwAiFyAXQj+HIhYgFyAWEC8gBiABKQPAASISQv//////////A4M3AwAgAUHIAWopAwAiFUIGhiASQjqIhCETIBVCOoghGCAAQQhqIgwhDSAAIQlBASEKQQEhBwJAA0AgCkEERgRAIABBGGohCiAAQRBqIQkgAEEoaiEMIAApAzAhF0EHIQUgAUHIAGohCwNAIAVBC0kEQCABQUBrIAVBA3QiCCAAakEwaykDACISIBJCP4cgFyAXQj+HIhYQLyAFQQFqIg1BAXYhByALKQMAIRUgASkDQCESIAkhAiAMIQQgBUEFayIOIQMDQCADIAdJBEAgASACKQMAIhQgFEI/hyAEKQMAIhQgFEI/hxAvIAEpAwAiFCASfCISIBRUrSABQQhqKQMAIBV8fCEVIAJBCGohAiAEQQhrIQQgA0EBaiEDDAELCyAGIAhqIBJCAYYiFCATfCITQv//////////A4M3AwAgAUEwaiAAIA5BA3RqKQMAIhkgGUI/hyAXIBYQLyATIBRU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aikDADcDACACQQhqIQIMAQsLC4QJAg1/Cn4jAEFAaiILJAAgC0EIaiIJQcCywAAQSSMAQZACayICJAAgAEEwENABIQogAkHoAGpB8AAQ0AEaIAJB4AFqQTAQ0AEaIAoQcSACIAEiDCkDACIQQv3/8//P///5AX5C//////////8DgyISNwPYASACQdgAaiASQgAgCSkDACIXIBdCP4ciGBAvIBAgAikDWCIPfCITIA9UrSACQeAAaikDACAQQj+HfHwiEEI6hyABKQMIIg9CP4d8IA8gEEIGhiATQjqIhCITfCIQIBNUrXwhD0EBIQBCACETAkACQANAAkAgAEEHRgRAQQYhB0EAIQhBByEADAELIABBAXYiAUEBaiEGIAggAWshAyABQQN0IgFBCGohBCAHIAFrIQUgAkHIAGogCSAAQQN0Ig1qKQMAIhUgFUI/hyIWIBJCABAvIAJB0ABqKQMAIBAgECATfCIRVq0gDyAUfHx8IBEgAikDSHwiDyARVK18IRAgAEEBaiEBA0AgACAGTQRAIAJB2AFqIA1qIA9C/f/z/8////kBfkL//////////wODIhE3AwAgAkE4aiARQgAgFyAYEC8gAkEoaiARQgAgFSAWEC8gAkHoAGogAEEEdGoiACACQTBqKQMAIhE3AwggACACKQMoIhU3AwAgDyACKQM4IhZ8Ig8gFlStIAJBQGspAwAgEHx8IhBCOocgDCABQQN0aikDACIWQj+HfCAWIBBCBoYgD0I6iIQiD3wiECAPVK18IQ8gEyAVfCITIBVUrSARIBR8fCEUIAdBCGohByAIQQFqIQggASEADAMLIANBB08NAyACQRhqIAQgCWopAwAgBSAJaikDAH0iESARQj+HIAJB2AFqIg4gBWopAwAgBCAOaikDAH0iESARQj+HEC8gAikDGCIRIA98Ig8gEVStIAJBIGopAwAgEHx8IRAgBkEBaiEGIARBCGohBCAFQQhrIQUgA0EBayEDDAALAAsLA0ACQAJAIABBDUcEQCAHIABBAXYiBmshAyAIIAZBA3QiAWshBCABQQhqIQUgDyAUfCAQIBN8Ig8gEFStfCEQIABBAWohAQNAIAZBBUsNAyADQQdPDQIgAkEIaiAFIAlqKQMAIAQgCWpBMGopAwB9IhIgEkI/hyACIARqQYgCaikDACACQdgBaiAFaikDAH0iEiASQj+HEC8gAikDCCISIA98Ig8gElStIAJBEGopAwAgEHx8IRAgBkEBaiEGIARBCGshBCADQQFrIQMgBUEIaiEFDAALAAsgCiAQQv//////////A4M3AzAgAkGQAmokAAwECyADQQdBpJzAABA7AAsgAEEDdCAKakE4ayAPQv//////////A4M3AwAgEEI6hyAMIAFBA3RqKQMAIhJCP4d8IBIgEEIGhiAPQjqIhCIPfCIQIA9UrXwhDyAUIABBBHQgAmpBCGoiAEEIaikDAH0gEyAAKQMAIhJUrX0hFCAIQQhqIQggB0EBaiEHIBMgEn0hEyABIQAMAAsACyADQQdBlJzAABA7AAsgC0FAayQACy4BAX8jAEGAAWsiASQAIAAQRSABEFEgACABEJkBIABBgAFqELYBIAFBgAFqJAALMwAgACABEJYBIABBgAJqIAFBgAJqEJYBIABBgARqIAFBgARqEJYBIAAgASgCgAY2AoAGCygAIAAgASACEHIgAEFAayABQUBrIAIQciAAQYABaiABQYABaiACEHILLQAgACABIAIQjQEgAEGAAWogAUGAAWogAhCNASAAQYACaiABQYACaiACEI0BCycBAn8jAEFAaiICJAAgAkEIaiIDIAEQvgEgACADEI4BIAJBQGskAAsiAQF/A0AgAUE4RwRAIAAgAWpCADcDACABQQhqIQEMAQsLCyUAIAAgASACEDAgAEEAIAJrIAAoAjgiACABKAI4c3EgAHM2AjgLJwAgACAAKAIEQQFxIAFyQQJyNgIEIAAgAWoiACAAKAIEQQFyNgIECyMAA0AgAgRAIAAgAS0AABA8IAJBAWshAiABQQFqIQEMAQsLCywAIAAQiwEgACABEJYBIABBgAJqIAIQlgEgAEGABGogAxCWASAAQQU2AoAGCyMBAX8jAEFAaiIBJAAgASAAEJABIAEQHiABEFcgAUFAayQACykAIAAgARBgIAAgACgCOCABKAI4aiIBNgI4IAFB////D0oEQCAAEB4LCyUAIAAgARCuASAAQUBrIAFBQGsQrgEgAEGAAWogAUGAAWoQrgELKAEBfyMAQYACayICJAAgAiABEIwBIAIQKyAAIAIQlwEgAkGAAmokAAscAQF/IAAgARBYBH8gAEFAayABQUBrEFgFQQALCycBAX8jAEGAAWsiAiQAIAIg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DCELDQALCyAMpyICQeMASwRAIABBAmsiACAGQQlqaiAMpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXRB6LjAAGovAAA7AAALAkAgAkEKTwRAIABBAmsiACAGQQlqaiACQQF0Qei4wABqLwAAOwAADAELIABBAWsiACAGQQlqaiACQTBqOgAACwJ/IAZBCWogAGohCEErQYCAxAAgASgCACIDQQFxIgIbIQQgAkEnIABrIglqIQJBlLjAAEEAIANBBHEbIQUCQAJAIAEoAghFBEBBASEAIAEgBCAFEFINAQwCCwJAAkACQAJAIAIgAUEMaigCACIDSQRAIAEtAABBCHENBEEAIQAgAyACayICIQNBASABLQAgIgcgB0EDRhtBA3FBAWsOAgECAwtBASEAIAEgBCAFEFINBAwFC0EAIQMgAiEADAELIAJBAXYhACACQQFqQQF2IQMLIABBAWohACABQRxqKAIAIQcgASgCBCECIAEoAhghCgJAA0AgAEEBayIARQ0BIAogAiAHKAIQEQQARQ0AC0EBDAQLQQEhACACQYCAxABGDQEgASAEIAUQUg0BIAEoAhggCCAJIAEoAhwoAgwRBQANASABKAIcIQQgASgCGCEBQQAhAAJ/A0AgAyAAIANGDQEaIABBAWohACABIAIgBCgCEBEEAEUNAAsgAEEBawsgA0khAAwBCyABKAIEIQcgAUEwNgIEIAEtACAhCkEBIQAgAUEBOgAgIAEgBCAFEFINAEEAIQAgAyACayICIQMCQAJAAkBBASABLQAgIgQgBEEDRhtBA3FBAWsOAgABAgtBACEDIAIhAAwBCyACQQF2IQAgAkEBakEBdiEDCyAAQQFqIQAgAUEcaigCACECIAEoAgQhBCABKAIYIQUCQANAIABBAWsiAEUNASAFIAQgAigCEBEEAEUNAAtBAQwDC0EBIQAgBEGAgMQARg0AIAEoAhggCCAJIAEoAhwoAgwRBQANACABKAIcIQAgASgCGCEFQQAhAgJAA0AgAiADRg0BIAJBAWohAiAFIAQgACgCEBEEAEUNAAtBASEAIAJBAWsgA0kNAQsgASAKOgAgIAEgBzYCBEEADAILIAAMAQsgASgCGCAIIAkgAUEcaigCACgCDBEFAAsgBkEwaiQACwsAIAAQNiAAELABCysCAX8BfkIBIQIDQCAAIAFq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AAANAEHgs8AAC8EHYXR0ZW1wdCB0byBkaXZpZGUgYnkgemVybwAAAAAAAABhdHRlbXB0IHRvIGRpdmlkZSB3aXRoIG92ZXJmbG93ALAZEAASAAAADAIAAA0AAACwGRAAEgAAABgCAAAmAAAAsBkQABIAAAAYAgAAIwAAALAZEAASAAAAHgIAABcAAACwGRAAEgAAAB4CAAAUAAAAqqr//////gHu//9UrP//AupBYg9rDyoBw5z9ShTOEwJLd2TXrEtDAu3pxpKm+V8Cox4RoAEAAAADAAAABAAAAAQAAAAEAAAABQAAAAYAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAoAAOsaEAAVAAAAABsQAA4AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnMgGxAAGAAAAEkBAAAJAAAAbGlicmFyeS9zdGQvc3JjL3Bhbmlja2luZy5yc0gbEAAcAAAARgIAAB8AAABIGxAAHAAAAEcCAAAeAAAABwAAAAwAAAAEAAAACAAAAAMAAAAIAAAABAAAAAkAAAAKAAAAEAAAAAQAAAALAAAADAAAAAMAAAAIAAAABAAAAA0AAAAOAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAA6BsQABEAAADMGxAAHAAAAAUCAAAFAAAAEAAAAAAAAAABAAAAEQAAAGluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAAAkHBAAIAAAAEQcEAASAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5yc3JhbmdlIGVuZCBpbmRleCAAAABxHRAAEAAAADAdEAAiAAAAUh0QAB8AAABJAAAABQB7CXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS42MS4wIChmZTViMTNkNjggMjAyMi0wNS0xOCkGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4SMC4yLjgxICgwNjJhYTVmNzAp`;\n//# sourceMappingURL=wasm.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L2xpYi9lc20vdmVuZG9yL2Jscy93YXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYWdlbnQvbGliL2VzbS92ZW5kb3IvYmxzL3dhc20uanM/ZmZiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3Qgd2FzbUJ5dGVzQmFzZTY0ID0gYEFHRnpiUUVBQUFBQlhnOWdBbjkvQUdBQmZ3QmdBWDhCZjJBRGYzOS9BR0FDZjM4QmYyQURmMzkvQVg5Z0JIOS9mMzhBWUFGL0FYNWdCWDkvZjM5L0FHQUFBWDlnQm45L2YzOS9md0JnQm45L2YzOS9md0YvWUFKL2Z3RitZQVYvZm41K2ZnQmdBQUFEM3dIZEFRSUFBQUFCQXdvQUFBQUlCZ1FBQXdFREFBRUJBUUFBQVFBSkFRTUFBd0VBQ0FFREF3UUFBd3NBREFJQkFBRUFEUU1FQUFBQUFnRUJBQUFCQXdBQkFRTUVBQUVCQVFFQkFRRUFBQU1CQWdVQUJBRUZCQUVCQWdJRUF3UURBQUFBQXdBQUFBQUJEZ0FCQWdBQUFBRUFBd01BQVFNQUF3WUNBQUFBQkFBQkFBQUJBUVlCQXdBQUFnSUNBZ0lCQUFNQUJBQUNBUUFBQXdBQUFBQUFBUUVCQVFJQUFBRUVBUU1BQUFBQkFBQUVBZ0FCQVFFQkFRRUJBUUVCQkFRQUFnTUFBQUFCQUFJQ0FBSUVCQUVCQWdJQ0FnQUVCUVFFQWdJSkJ3Y0hBUU1EQkFVQmNBRVNFZ1VEQVFBUkJna0Jmd0ZCZ0lEQUFBc0hOd1FHYldWdGIzSjVBZ0FJWW14elgybHVhWFFBMWdFS1lteHpYM1psY21sbWVRQW5FVjlmZDJKcGJtUm5aVzVmYldGc2JHOWpBR2dKSVFFQVFRRUxFY2dCUWRvQlRyb0JRSC9YQWRnQmdBRWNKVnk3QWNjQjJnSFpBUXI0NFFMZEFkMGhBZzkvQVg0akFFRVFheUlJSkFBQ1FBSkFJQUJCOVFGUEJFQkJnSUI4UVFoQkNCQ2pBVUVVUVFnUW93RnFRUkJCQ0JDakFXcHJRWGR4UVFOcklnSkJBRUVRUVFnUW93RkJBblJySWdVZ0FpQUZTUnNnQUUwTkFpQUFRUVJxUVFnUW93RWhCRUhndThBQUtBSUFSUTBCUVFBZ0JHc2hBUUpBQWtBQ2YwRUFJQVJCZ0FKSkRRQWFRUjhnQkVILy8vOEhTdzBBR2lBRVFRWWdCRUVJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxQ3lJSFFRSjBRZXk5d0FCcUtBSUFJZ0FFUUNBRUlBY1Fud0YwSVFaQkFDRUNBMEFDUUNBQUVNc0JJZ1VnQkVrTkFDQUZJQVJySWdVZ0FVOE5BQ0FBSVFJZ0JTSUJEUUJCQUNFQkRBTUxJQUJCRkdvb0FnQWlCU0FESUFVZ0FDQUdRUjEyUVFSeGFrRVFhaWdDQUNJQVJ4c2dBeUFGR3lFRElBWkJBWFFoQmlBQURRQUxJQU1FUUNBRElRQU1BZ3NnQWcwQ0MwRUFJUUpCQVNBSGRCQ3RBVUhndThBQUtBSUFjU0lBUlEwRElBQVF3d0ZvUVFKMFFleTl3QUJxS0FJQUlnQkZEUU1MQTBBZ0FDQUNJQUFReXdFaUFpQUVUeUFDSUFScklnTWdBVWx4SWdVYklRSWdBeUFCSUFVYklRRWdBQkNSQVNJQURRQUxJQUpGRFFJTElBUkI3TDdBQUNnQ0FDSUFUU0FCSUFBZ0JHdFBjUTBCSUFJZ0JCRFNBU0VBSUFJUUZ3SkFRUkJCQ0JDakFTQUJUUVJBSUFJZ0JCREZBU0FBSUFFUW9BRWdBVUdBQWs4RVFDQUFJQUVRRmd3Q0N5QUJRUU4ySWdOQkEzUkI1THZBQUdvaEFRSi9RZHk3d0FBb0FnQWlCVUVCSUFOMElnTnhCRUFnQVNnQ0NBd0JDMEhjdThBQUlBTWdCWEkyQWdBZ0FRc2hBeUFCSUFBMkFnZ2dBeUFBTmdJTUlBQWdBVFlDRENBQUlBTTJBZ2dNQVFzZ0FpQUJJQVJxRUlVQkN5QUNFTlFCSWdGRkRRRU1BZ3RCRUNBQVFRUnFRUkJCQ0JDakFVRUZheUFBU3h0QkNCQ2pBU0VFQWtBQ1FBSkFBbjhDUUFKQVFkeTd3QUFvQWdBaUJTQUVRUU4ySWdGMklnQkJBM0ZGQkVBZ0JFSHN2c0FBS0FJQVRRMEhJQUFOQVVIZ3U4QUFLQUlBSWdCRkRRY2dBQkREQVdoQkFuUkI3TDNBQUdvb0FnQWlBaERMQVNBRWF5RUJJQUlRa1FFaUFBUkFBMEFnQUJETEFTQUVheUlESUFFZ0FTQURTeUlER3lFQklBQWdBaUFER3lFQ0lBQVFrUUVpQUEwQUN3c2dBaUFFRU5JQklRVWdBaEFYUVJCQkNCQ2pBU0FCU3cwRklBSWdCQkRGQVNBRklBRVFvQUZCN0w3QUFDZ0NBQ0lBUlEwRUlBQkJBM1lpQmtFRGRFSGt1OEFBYWlFQVFmUyt3QUFvQWdBaEEwSGN1OEFBS0FJQUlnZEJBU0FHZENJR2NVVU5BaUFBS0FJSURBTUxBa0FnQUVGL2MwRUJjU0FCYWlJQVFRTjBJZ05CN0x2QUFHb29BZ0FpQVVFSWFpZ0NBQ0lDSUFOQjVMdkFBR29pQTBjRVFDQUNJQU0yQWd3Z0F5QUNOZ0lJREFFTFFkeTd3QUFnQlVGK0lBQjNjVFlDQUFzZ0FTQUFRUU4wRUlVQklBRVExQUVoQVF3SEN3SkFRUUVnQVVFZmNTSUJkQkN0QVNBQUlBRjBjUkREQVdnaUFFRURkQ0lEUWV5N3dBQnFLQUlBSWdKQkNHb29BZ0FpQVNBRFFlUzd3QUJxSWdOSEJFQWdBU0FETmdJTUlBTWdBVFlDQ0F3QkMwSGN1OEFBUWR5N3dBQW9BZ0JCZmlBQWQzRTJBZ0FMSUFJZ0JCREZBU0FDSUFRUTBnRWlCU0FBUVFOMElBUnJJZ1FRb0FGQjdMN0FBQ2dDQUNJQUJFQWdBRUVEZGlJRFFRTjBRZVM3d0FCcUlRQkI5TDdBQUNnQ0FDRUJBbjlCM0x2QUFDZ0NBQ0lHUVFFZ0EzUWlBM0VFUUNBQUtBSUlEQUVMUWR5N3dBQWdBeUFHY2pZQ0FDQUFDeUVESUFBZ0FUWUNDQ0FESUFFMkFnd2dBU0FBTmdJTUlBRWdBellDQ0F0QjlMN0FBQ0FGTmdJQVFleSt3QUFnQkRZQ0FDQUNFTlFCSVFFTUJndEIzTHZBQUNBR0lBZHlOZ0lBSUFBTElRWWdBQ0FETmdJSUlBWWdBellDRENBRElBQTJBZ3dnQXlBR05nSUlDMEgwdnNBQUlBVTJBZ0JCN0w3QUFDQUJOZ0lBREFFTElBSWdBU0FFYWhDRkFRc2dBaERVQVNJQkRRRUxBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUVRZXkrd0FBb0FnQWlBVXNFUUVId3ZzQUFLQUlBSWdBZ0JFc05Ba0VJUVFnUW93RWdCR3BCRkVFSUVLTUJha0VRUVFnUW93RnFRWUNBQkJDakFTSUJRUkIyUUFBaEFDQUlRUUEyQWdnZ0NFRUFJQUZCZ0lCOGNTQUFRWDlHSWdFYk5nSUVJQWhCQUNBQVFSQjBJQUViTmdJQUlBZ29BZ0FpQVEwQlFRQWhBUXdKQzBIMHZzQUFLQUlBSVFCQkVFRUlFS01CSUFFZ0JHc2lBVXNFUUVIMHZzQUFRUUEyQWdCQjdMN0FBQ2dDQUNFQlFleSt3QUJCQURZQ0FDQUFJQUVRaFFFZ0FCRFVBU0VCREFrTElBQWdCQkRTQVNFQ1FleSt3QUFnQVRZQ0FFSDB2c0FBSUFJMkFnQWdBaUFCRUtBQklBQWdCQkRGQVNBQUVOUUJJUUVNQ0FzZ0NDZ0NDQ0VGUWZ5K3dBQWdDQ2dDQkNJRFFmeSt3QUFvQWdCcUlnQTJBZ0JCZ0wvQUFFR0F2OEFBS0FJQUlnSWdBQ0FBSUFKSkd6WUNBQUpBQWtCQitMN0FBQ2dDQUFSQVFZUy93QUFoQUFOQUlBQVF4Z0VnQVVZTkFpQUFLQUlJSWdBTkFBc01BZ3RCbUwvQUFDZ0NBQ0lBUlNBQUlBRkxjZzBEREFjTElBQVF6UUVOQUNBQUVNNEJJQVZIRFFBZ0FDZ0NBQ0lDUWZpK3dBQW9BZ0FpQmswRWZ5QUNJQUFvQWdScUlBWkxCVUVBQ3cwREMwR1l2OEFBUVppL3dBQW9BZ0FpQUNBQklBQWdBVWtiTmdJQUlBRWdBMm9oQWtHRXY4QUFJUUFDUUFKQUEwQWdBaUFBS0FJQVJ3UkFJQUFvQWdnaUFBMEJEQUlMQ3lBQUVNMEJEUUFnQUJET0FTQUZSZzBCQzBINHZzQUFLQUlBSVFKQmhML0FBQ0VBQWtBRFFDQUNJQUFvQWdCUEJFQWdBQkRHQVNBQ1N3MENDeUFBS0FJSUlnQU5BQXRCQUNFQUN5QUNJQUFReGdFaUQwRVVRUWdRb3dFaURtdEJGMnNpQUJEVUFTSUdRUWdRb3dFZ0Jtc2dBR29pQUNBQVFSQkJDQkNqQVNBQ2Fra2JJZ1lRMUFFaEJ5QUdJQTRRMGdFaEFFRUlRUWdRb3dFaENVRVVRUWdRb3dFaEMwRVFRUWdRb3dFaERFSDR2c0FBSUFFZ0FSRFVBU0lLUVFnUW93RWdDbXNpRFJEU0FTSUtOZ0lBUWZDK3dBQWdBMEVJYWlBTUlBa2dDMnBxSUExcWF5SUpOZ0lBSUFvZ0NVRUJjallDQkVFSVFRZ1Fvd0VoQzBFVVFRZ1Fvd0VoREVFUVFRZ1Fvd0VoRFNBS0lBa1EwZ0VnRFNBTUlBdEJDR3RxYWpZQ0JFR1V2OEFBUVlDQWdBRTJBZ0FnQmlBT0VNVUJRWVMvd0FBcEFnQWhFQ0FIUVFocVFZeS93QUFwQWdBM0FnQWdCeUFRTndJQVFaQy93QUFnQlRZQ0FFR0l2OEFBSUFNMkFnQkJoTC9BQUNBQk5nSUFRWXkvd0FBZ0J6WUNBQU5BSUFCQkJCRFNBU0VCSUFCQkJ6WUNCQ0FQSUFFaUFFRUVha3NOQUFzZ0FpQUdSZzBISUFJZ0JpQUNheUlBSUFJZ0FCRFNBUkNEQVNBQVFZQUNUd1JBSUFJZ0FCQVdEQWdMSUFCQkEzWWlBVUVEZEVIa3U4QUFhaUVBQW45QjNMdkFBQ2dDQUNJRFFRRWdBWFFpQVhFRVFDQUFLQUlJREFFTFFkeTd3QUFnQVNBRGNqWUNBQ0FBQ3lFQklBQWdBallDQ0NBQklBSTJBZ3dnQWlBQU5nSU1JQUlnQVRZQ0NBd0hDeUFBS0FJQUlRVWdBQ0FCTmdJQUlBQWdBQ2dDQkNBRGFqWUNCQ0FCRU5RQklnQkJDQkNqQVNFQ0lBVVExQUVpQTBFSUVLTUJJUVlnQVNBQ0lBQnJhaUlDSUFRUTBnRWhBU0FDSUFRUXhRRWdCU0FHSUFOcmFpSUFJQUlnQkdwcklRUWdBRUg0dnNBQUtBSUFSd1JBUWZTK3dBQW9BZ0FnQUVZTkJDQUFLQUlFUVFOeFFRRkhEUVVDUUNBQUVNc0JJZ05CZ0FKUEJFQWdBQkFYREFFTElBQkJER29vQWdBaUJTQUFRUWhxS0FJQUlnWkhCRUFnQmlBRk5nSU1JQVVnQmpZQ0NBd0JDMEhjdThBQVFkeTd3QUFvQWdCQmZpQURRUU4yZDNFMkFnQUxJQU1nQkdvaEJDQUFJQU1RMGdFaEFBd0ZDMEg0dnNBQUlBRTJBZ0JCOEw3QUFFSHd2c0FBS0FJQUlBUnFJZ0EyQWdBZ0FTQUFRUUZ5TmdJRUlBSVExQUVoQVF3SEMwSHd2c0FBSUFBZ0JHc2lBVFlDQUVINHZzQUFRZmkrd0FBb0FnQWlBQ0FFRU5JQklnSTJBZ0FnQWlBQlFRRnlOZ0lFSUFBZ0JCREZBU0FBRU5RQklRRU1CZ3RCbUwvQUFDQUJOZ0lBREFNTElBQWdBQ2dDQkNBRGFqWUNCRUh3dnNBQUtBSUFJQU5xSVFGQitMN0FBQ2dDQUNJQUlBQVExQUVpQUVFSUVLTUJJQUJySWdJUTBnRWhBRUh3dnNBQUlBRWdBbXNpQVRZQ0FFSDR2c0FBSUFBMkFnQWdBQ0FCUVFGeU5nSUVRUWhCQ0JDakFTRUNRUlJCQ0JDakFTRURRUkJCQ0JDakFTRUZJQUFnQVJEU0FTQUZJQU1nQWtFSWEycHFOZ0lFUVpTL3dBQkJnSUNBQVRZQ0FBd0RDMEgwdnNBQUlBRTJBZ0JCN0w3QUFFSHN2c0FBS0FJQUlBUnFJZ0EyQWdBZ0FTQUFFS0FCSUFJUTFBRWhBUXdEQ3lBQklBUWdBQkNEQVNBRVFZQUNUd1JBSUFFZ0JCQVdJQUlRMUFFaEFRd0RDeUFFUVFOMklnTkJBM1JCNUx2QUFHb2hBQUovUWR5N3dBQW9BZ0FpQlVFQklBTjBJZ054QkVBZ0FDZ0NDQXdCQzBIY3U4QUFJQU1nQlhJMkFnQWdBQXNoQXlBQUlBRTJBZ2dnQXlBQk5nSU1JQUVnQURZQ0RDQUJJQU0yQWdnZ0FoRFVBU0VCREFJTFFaeS93QUJCL3g4MkFnQkJrTC9BQUNBRk5nSUFRWWkvd0FBZ0F6WUNBRUdFdjhBQUlBRTJBZ0JCOEx2QUFFSGt1OEFBTmdJQVFmaTd3QUJCN0x2QUFEWUNBRUhzdThBQVFlUzd3QUEyQWdCQmdMekFBRUgwdThBQU5nSUFRZlM3d0FCQjdMdkFBRFlDQUVHSXZNQUFRZnk3d0FBMkFnQkIvTHZBQUVIMHU4QUFOZ0lBUVpDOHdBQkJoTHpBQURZQ0FFR0V2TUFBUWZ5N3dBQTJBZ0JCbUx6QUFFR012TUFBTmdJQVFZeTh3QUJCaEx6QUFEWUNBRUdndk1BQVFaUzh3QUEyQWdCQmxMekFBRUdNdk1BQU5nSUFRYWk4d0FCQm5MekFBRFlDQUVHY3ZNQUFRWlM4d0FBMkFnQkJzTHpBQUVHa3ZNQUFOZ0lBUWFTOHdBQkJuTHpBQURZQ0FFR3N2TUFBUWFTOHdBQTJBZ0JCdUx6QUFFR3N2TUFBTmdJQVFiUzh3QUJCckx6QUFEWUNBRUhBdk1BQVFiUzh3QUEyQWdCQnZMekFBRUcwdk1BQU5nSUFRY2k4d0FCQnZMekFBRFlDQUVIRXZNQUFRYnk4d0FBMkFnQkIwTHpBQUVIRXZNQUFOZ0lBUWN5OHdBQkJ4THpBQURZQ0FFSFl2TUFBUWN5OHdBQTJBZ0JCMUx6QUFFSE12TUFBTmdJQVFlQzh3QUJCMUx6QUFEWUNBRUhjdk1BQVFkUzh3QUEyQWdCQjZMekFBRUhjdk1BQU5nSUFRZVM4d0FCQjNMekFBRFlDQUVId3ZNQUFRZVM4d0FBMkFnQkIrTHpBQUVIc3ZNQUFOZ0lBUWV5OHdBQkI1THpBQURZQ0FFR0F2Y0FBUWZTOHdBQTJBZ0JCOUx6QUFFSHN2TUFBTmdJQVFZaTl3QUJCL0x6QUFEWUNBRUg4dk1BQVFmUzh3QUEyQWdCQmtMM0FBRUdFdmNBQU5nSUFRWVM5d0FCQi9MekFBRFlDQUVHWXZjQUFRWXk5d0FBMkFnQkJqTDNBQUVHRXZjQUFOZ0lBUWFDOXdBQkJsTDNBQURZQ0FFR1V2Y0FBUVl5OXdBQTJBZ0JCcUwzQUFFR2N2Y0FBTmdJQVFaeTl3QUJCbEwzQUFEWUNBRUd3dmNBQVFhUzl3QUEyQWdCQnBMM0FBRUdjdmNBQU5nSUFRYmk5d0FCQnJMM0FBRFlDQUVHc3ZjQUFRYVM5d0FBMkFnQkJ3TDNBQUVHMHZjQUFOZ0lBUWJTOXdBQkJyTDNBQURZQ0FFSEl2Y0FBUWJ5OXdBQTJBZ0JCdkwzQUFFRzB2Y0FBTmdJQVFkQzl3QUJCeEwzQUFEWUNBRUhFdmNBQVFieTl3QUEyQWdCQjJMM0FBRUhNdmNBQU5nSUFRY3k5d0FCQnhMM0FBRFlDQUVIZ3ZjQUFRZFM5d0FBMkFnQkIxTDNBQUVITXZjQUFOZ0lBUWVpOXdBQkIzTDNBQURZQ0FFSGN2Y0FBUWRTOXdBQTJBZ0JCNUwzQUFFSGN2Y0FBTmdJQVFRaEJDQkNqQVNFQ1FSUkJDQkNqQVNFRlFSQkJDQkNqQVNFR1FmaSt3QUFnQVNBQkVOUUJJZ0JCQ0JDakFTQUFheUlCRU5JQklnQTJBZ0JCOEw3QUFDQURRUWhxSUFZZ0FpQUZhbW9nQVdwcklnRTJBZ0FnQUNBQlFRRnlOZ0lFUVFoQkNCQ2pBU0VDUVJSQkNCQ2pBU0VEUVJCQkNCQ2pBU0VGSUFBZ0FSRFNBU0FGSUFNZ0FrRUlhMnBxTmdJRVFaUy93QUJCZ0lDQUFUWUNBQXRCQUNFQlFmQyt3QUFvQWdBaUFDQUVUUTBBUWZDK3dBQWdBQ0FFYXlJQk5nSUFRZmkrd0FCQitMN0FBQ2dDQUNJQUlBUVEwZ0VpQWpZQ0FDQUNJQUZCQVhJMkFnUWdBQ0FFRU1VQklBQVExQUVoQVFzZ0NFRVFhaVFBSUFFTCtBNEJDWDhqQUVIQURXc2lBaVFBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFBb0FvQUdJZ1ZCQVVjRVFDQUJLQUtBQmlJR1FRRkdEUWtnQmtFRFN3MEJJQVZCZm5GQkFrWU5BaUFDSUFBUWpBRWdBa0dBQW1vaUJFRTRFTkFCR2lBQ1FRRTJBcmdDSUFKQndBSnFRVGdRMEFFYUlBSkIrQUpxUVFFMkFnQWdBa0dBQTJwQk9CRFFBUm9nQWtHNEEycEJBVFlDQUNBQ1FjQURha0U0RU5BQkdpQUNRZmdEYWtFQk5nSUFJQUpCZ0FScVFUZ1EwQUVhSUFKQkFUWUN1QVFnQWtIQUJHcEJPQkRRQVJvZ0FrSDRCR3BCQVRZQ0FDQUNRWUFGYWtFNEVOQUJHaUFDUWJnRmFrRUJOZ0lBSUFKQndBVnFRVGdRMEFFYUlBSkIrQVZxUVFFMkFnQWdBa0dBQm1vaUIwRTRFTkFCR2lBQ1FRRTJBcmdHSUFKQndBWnFRVGdRMEFFYUlBSkIrQVpxUVFFMkFnQWdBa0dBQjJwQk9CRFFBUm9nQWtHNEIycEJBVFlDQUNBQ1FjQUhha0U0RU5BQkdpQUNRZmdIYWtFQk5nSUFJQUpCZ0FocUlnTWdBQkNNQVNBQ1FZQUtha0U0RU5BQkdpQUNRUUUyQXJnS0lBSkJ3QXBxUVRnUTBBRWFJQUpCK0FwcVFRRTJBZ0FnQWtHQUMycEJPQkRRQVJvZ0FrRzRDMnBCQVRZQ0FDQUNRY0FMYWtFNEVOQUJHaUFDUWZnTGFrRUJOZ0lBSUFJZ0FSQVlJQU1nQUVHQUFtb2lCaENYQVNBREVMQUJJQVFnQXhDV0FTQUVJQUVRR0NBRElBWVFsZ0VnQXlBQVFZQUVhaUlGRUpjQklBTVFzQUVnQnlBREVKWUJJQUVvQW9BR1FRSkdEUU1nQWtIQURHb2lBeUFCUVlBRmFoQmVJQUpCZ0FacUlBTVFwZ0VNQkFzZ0FDQUJFRzBNQ0FzZ0FpQUFFSXdCSUFKQmdBSnFRVGdRMEFFYUlBSkJBVFlDdUFJZ0FrSEFBbXBCT0JEUUFSb2dBa0g0QW1wQkFUWUNBQ0FDUVlBRGFrRTRFTkFCR2lBQ1FiZ0Rha0VCTmdJQUlBSkJ3QU5xUVRnUTBBRWFJQUpCK0FOcVFRRTJBZ0FnQWtHQUJHcEJPQkRRQVJvZ0FrRUJOZ0s0QkNBQ1FjQUVha0U0RU5BQkdpQUNRZmdFYWtFQk5nSUFJQUpCZ0FWcVFUZ1EwQUVhSUFKQnVBVnFRUUUyQWdBZ0FrSEFCV3BCT0JEUUFSb2dBa0g0QldwQkFUWUNBQ0FDUVlBR2FrRTRFTkFCR2lBQ1FRRTJBcmdHSUFKQndBWnFRVGdRMEFFYUlBSkIrQVpxUVFFMkFnQWdBa0dBQjJwQk9CRFFBUm9nQWtHNEIycEJBVFlDQUNBQ1FjQUhha0U0RU5BQkdpQUNRZmdIYWtFQk5nSUFJQUlnQVJBWUFrQWdBU2dDZ0FaQkJFWU5BQ0FBS0FLQUJrRUVSZzBBSUFKQmdBUnFJZ01nQUVHQUFtb1FsZ0VnQXlBQlFZQUNhaEFZREFZTElBSkJ3QXhxSWdkQk9CRFFBUm9nQWtFQk5nTDREQ0FDUVlBTmFrRTRFTkFCR2lBQ1FiZ05ha0VCTmdJQUlBSkJnQWhxSWdSQk9CRFFBUm9nQWtFQk5nSzRDQ0FDUWNBSWFrRTRFTkFCR2lBQ1FmZ0lha0VCTmdJQUlBSkJnQXBxSWdNZ0FFR0FBMm9pQlJCZUlBUWdBeENaQVNBRElBRkJnQU5xSWdZUVhpQUVJQU1RRVNBSEVMWUJJQUVvQW9BR1FRUkhEUU1NQkFzZ0FDQUJFQU1NQmdzZ0FrSEFER29pQXlBQlFZQUZhaEJlSUFKQmdBeHFJZ1FnQTBIQUFCRFJBUm9nQWtHQUJtb2dCQkNuQVFzZ0FrR0FCbW9RWkNBQ1FZQUlhaUlESUFJUWxnRWdBeEFySUFKQmdBSnFJZ1FnQXhDWEFTQUdJQVFRbGdFZ0FrR0FCR29pQnlBREVKWUJJQU1nQUJDV0FTQURJQVVRbHdFZ0F4Q3dBU0FDUVlBS2FpSUVJQUVRbGdFZ0JDQUJRWUFFYWhDWEFTQUVFTEFCSUFNZ0JCQVlJQWNnQXhDWEFTQURJQVVRbGdFQ1FDQUJLQUtBQmtFQ1J3UkFJQUpCd0F4cUlnTWdBVUdBQldvUVhpQUNRWUFJYWlBREVLWUJEQUVMSUFKQndBeHFJZ01nQVVHQUJXb1FYaUFDUVlBTWFpSUJJQU5Cd0FBUTBRRWFJQUpCZ0FocUlBRVFwd0VMSUFKQmdBaHFJZ0VRWkNBQ1FZQUthaUlESUFFUWxnRWdBeEFySUFVZ0FrR0FCR29RbGdFZ0JTQURFSmNCSUFKQmdBWnFJZ1FnQXhDWEFTQUJFR1FnQmlBQkVKY0JJQVFRc0FFZ0JCQmtJQUFnQWhDV0FTQUFJQVFRbHdFTUF3c2dBa0dBQ21vaUF5QUZFRjRnQWtIQURHb2lCQ0FERUprQklBTWdBVUdBQW1vUVhpQUVJQU1RRVFzZ0FDZ0NnQVpCQkVjRVFDQUNRWUFLYWlJRElBQkJnQUpxRUY0Z0FrSEFER29pQkNBREVKa0JJQU1nQmhCZUlBUWdBeEFSQ3lBQ1FZQUVhaUlESUFKQndBeHFJQUpCZ0FocUVLVUJJQU1RWkFzZ0FrR0FDR29pQXlBQUVJd0JJQUpCZ0FwcUlnUWdBUkNNQVNBRElBQkJnQUpxSWdVUWx3RWdBeEN3QVNBRUlBRkJnQUpxSWdnUWx3RWdCQkN3QVNBQ1FZQUNhaUlKSUFNUWxnRWdDU0FFRUJnZ0F5QUZFSllCSUFNZ0FFR0FCR29pQmhDWEFTQURFTEFCSUFRZ0NCQ1dBU0FFSUFGQmdBUnFJZ2dRbHdFZ0JCQ3dBU0FDUVlBR2FpSUhJQU1RbGdFZ0J5QUVFQmdnQXlBQ0VKWUJJQU1RS3lBRUlBSkJnQVJxSWdvUWxnRWdCQkFySUFrZ0F4Q1hBU0FGSUFrUWxnRWdCU0FFRUpjQklBY2dCQkNYQVNBS0lBTVFsd0VnQXlBQUVKWUJJQU1nQmhDWEFTQURFTEFCSUFRZ0FSQ1dBU0FFSUFnUWx3RWdCQkN3QVNBRElBUVFHQ0FLSUFNUWx3RWdBeUFHRUpZQklBTWdDQkFZSUFRZ0F4Q1dBU0FFRUNzZ0JpQUtFSllCSUFZZ0JCQ1hBU0FISUFRUWx3RWdBeEJrSUFVZ0F4Q1hBU0FIRUxBQklBY1FaQ0FBSUFJUWxnRWdBQ0FIRUpjQkN5QUFRUVUyQW9BR0lBQVFuUUVMSUFKQndBMXFKQUFMcUFzQkVYOGpBRUdBQzJzaUFpUUFJQUpCQ0dvUVp5QUNRY2dCYWlJS1FUZ1EwQUVhSUFKQkFUWUNnQUlnQWtHSUFtb2lEMEU0RU5BQkdpQUNRUUUyQXNBQ0lBSkJ5QUpxSWhCQk9CRFFBUm9nQWtFQk5nS0FBeUFDUVlnRGFpSUpRVGdRMEFFYUlBSkJBVFlDd0FNZ0FrSElBMm9pRGtFNEVOQUJHaUFDUVFFMkFvQUVJQUpCaUFScUloRkJBUkE1SUFKQnlBUnFJZ3RCT0JEUUFSb2dBa0VCTmdLQUJTQUNRWWdGYWlJRVFUZ1EwQUVhSUFKQkFUWUN3QVVnQWtISUJXb2lCU0FCRUpBQklBSkJpQVpxSWdOQk9CRFFBUm9nQWtFQk5nTEFCaUFDUWNnR2FpSUdRVGdRMEFFYUlBSkJBVFlDZ0FjZ0FrR0lCMm9pREVFNEVOQUJHaUFDUVFFMkFzQUhJQUpCeUFkcUlnaEJPQkRRQVJvZ0FrRUJOZ0tBQ0NBRkVGWWhFaUFDUWNnSmFpSU5RWkNDd0FBUVNTQUNRWWdLYWlJSElBMFFqZ0VnQ2lBSEVLNEJJQTFCeUlMQUFCQkpJQWNnRFJDT0FTQVBJQWNRcmdFZ0JSQk1JQVZCQ3hBMElBTWdCUkN1QVNBRElCRVFkeUFERUVJZ0F5QUZFRW9nQkNBS0VLNEJJQVFnQXhCS0lBTWdFUkIzSUFKQmlBWnFFRUlnQXlBUEVFb2dBeEJESUFKQmlBWnFFRUlnQ1NBREVLNEJJQTRnQlJDdUFTQU9JQWtRU2lBSUlBa1FyZ0VnQ0JCTUlBWWdCQkN1QVNBR0VFd2dBeUFLRUs0QklBTWdCaEJLSUFnZ0F4QjNJQWdRUWlBSUlBa1FTaUFHSUFRUVNpQURJQThRcmdFZ0F5QUdFRW9nQ0NBREVIY2dBa0hJQjJvUVFpQURJQWdRcmdFZ0F5QUVFRW9nQXlBTUVGb2hDaUFFSUFNUXJnRWdCQ0FNRURNZ0JDQUlFRW9nQ1NBRUVFb2dEaUFFRUVvZ0JTQUJFRW9nQmlBRUVLNEJJQVlRVENBRUlBWVFyZ0VnQkNBRkVFb2dCU0FERUs0QklBVkJDeEEwSUExQmdJUEFBQkJKSUFjZ0RSQ09BU0FRSUFjUXJnRWdFQ0FNRUVvZ0NTQU9RUUVnQ21zaUFSQnlJQVlnQkNBQkVISWdBeUFGSUFFUWNpQU1JQkFnQVJCeUlBY2dBeUFNRUNNZ0N5QUhFSzRCSUFzZ0JoQktJQXNRVmlFQklBTWdDeEN1QVNBREVFTWdBa0dJQm1vUVFpQUxJQU1nQVNBU2N4QnlJQWRCdUlQQUFCQkpJQUpCaUFocUlBY1FqZ0ZCT0NFQkEwQWdBVUdnQlVaRkJFQWdBa0dJQ0dvaUF5QUNRWWdEYWhCS0lBSkJ5QWxxSWdRZ0FVRzRnOEFBYWhCSklBRkJPR29oQVNBQ1FZZ0thaUlGSUFRUWpnRWdBa0dJQm1vaUJDQUZFSzRCSUFNZ0JCQjNJQU1RUWd3QkN3c2dBa0hJQ0dvaUFTQUNRWWdEYWhDUUFTQUNRY2dKYWlJRFFkaUl3QUFRU1NBQ1FZZ0thaUlFSUFNUWpnRWdBa0dJQm1vaUF5QUVFSzRCSUFFZ0F4QjNJQUVRUWtFQUlRRURRQ0FCUWZnRFJrVUVRQ0FDUWNnSWFpSURJQUpCaUFOcUVFb2dBa0hJQ1dvaUJDQUJRWkNKd0FCcUVFa2dBVUU0YWlFQklBSkJpQXBxSWdVZ0JCQ09BU0FDUVlnR2FpSUVJQVVRcmdFZ0F5QUVFSGNnQXhCQ0RBRUxDeUFDUVlnS2FpSUJRWWlOd0FBUVNTQUNRWWdKYWlBQkVJNEJRUUFoQVFOQUlBRkJ5QVpHUlFSQUlBSkJpQWxxSWdNZ0FrR0lBMm9RU2lBQ1FjZ0phaUlFSUFGQndJM0FBR29RU1NBQlFUaHFJUUVnQWtHSUNtb2lCU0FFRUk0QklBSkJpQVpxSWdRZ0JSQ3VBU0FESUFRUWR5QURFRUlNQVFzTElBSkJ5QWxxSWdFZ0FrR0lBMm9Ra0FFZ0FrSElDbW9pQTBHSWxNQUFFRWtnQWtHSUNtb2lCQ0FERUk0QklBSkJpQVpxSWdNZ0JCQ3VBU0FCSUFNUWR5QUJFRUpCQUNFQkEwQWdBVUdRQmtZRVFDQUNRWWdKYWlJRElBSkJ5QVJxRUVvZ0FrR0lCbW9pQVNBQ1FZZ0lhaEN1QVNBQklBSkJ5QWxxSWdRUVNpQUNRUWhxSWdVZ0FSQ3VBU0FCSUFNUXJnRWdBU0FDUWNnSWFpSURFRW9nQWtISUFHb2dBUkN1QVNBQklBTVFyZ0VnQVNBRUVFb2dBa0dJQVdvZ0FSQ3VBU0FBSUFWQndBRVEwUUVhSUFKQmdBdHFKQUFGSUFKQnlBbHFJZ01nQWtHSUEyb1FTaUFDUWNnS2FpSUVJQUZCd0pUQUFHb1FTU0FCUVRocUlRRWdBa0dJQ21vaUJTQUVFSTRCSUFKQmlBWnFJZ1FnQlJDdUFTQURJQVFRZHlBREVFSU1BUXNMQy9vR0FReC9Jd0JCZ0FscklnTWtBQ0FEUVlBSWFpSUNJQUFRWGlBRElBSVFYaUFDSUFCQmdBRnFJZ29RWGlBRFFZQUJhaUlFSUFJUVhpQUNJQUVRWGlBRElBSVFFU0FDSUFGQmdBRnFJZ3NRWGlBRUlBSVFFUUpBSUFFb0FvQUdJZ0pCQWtZZ0FDZ0NnQVlpQkVFQ1JuSkZCRUFnQTBHQUNHb2lBaUFBUVlBRmFoQmVJQU5CZ0FKcUlnUWdBaEJlSUFJZ0FVR0FCV29RWGlBRUlBSVFFUXdCQ3lBQ1FRSkdJQVJCQWtaeFJRUkFJQUpCQWtZRVFDQURRWUFJYWlJQ0lBQkJnQVZxRUY0Z0EwR0FBbW9pQkNBQ0VGNGdBaUFCUVlBRmFoQmVJQU5CZ0FkcUlnVWdBa0hBQUJEUkFSb2dCQ0FGRUtvQkRBSUxJQU5CZ0FocUlnSWdBVUdBQldvUVhpQURRWUFDYWlJRUlBSVFYaUFDSUFCQmdBVnFFRjRnQTBHQUIyb2lCU0FDUWNBQUVORUJHaUFFSUFVUXFnRU1BUXNnQTBHQUNHb2lBaUFBUVlBRmFoQmVJQU5CZ0FkcUlnUWdBa0hBQUJEUkFSb2dBMEdBQm1vaUJTQUVFSkFCSUFJZ0FVR0FCV29RWGlBRUlBSkJ3QUFRMFFFYUlBVWdCQkJLSUFOQmdBSnFRVGdRMEFFaUFrRUJOZ0k0SUFKQlFHdEJPQkRRQVNBQ1FmZ0Fha0VCTmdJQUlBSWdCUkN1QVJEQkFRc2dBMEdBQ0dvaUFpQUFFRjRnQTBHQUEyb2lCQ0FDRUY0Z0FpQUJFRjRnQTBHQUJHb2lCU0FDRUY0Z0FpQUtFRjRnQkNBQ0VKb0JJQVFRcVFFZ0FpQUxFRjRnQlNBQ0VKb0JJQVVRcVFFZ0EwR0FCV29pQnlBRUVGNGdCeUFGRUJFZ0EwR0FCbW9pQmlBREVGNGdCaUFEUVlBQmFpSUlFSm9CSUFZUU5pQUhJQVlRbWdFZ0FpQUFFRjRnQkNBQ0VKa0JJQUlnQUVHQUJXb2lEQkJlSUFRZ0FoQ2FBU0FFRUtrQklBSWdBUkJlSUFVZ0FoQ1pBU0FDSUFGQmdBVnFJZzBRWGlBRklBSVFtZ0VnQlJDcEFTQURRWUFIYWlJSklBUVFYaUFKSUFVUUVTQUdJQU1RbVFFZ0JpQURRWUFDYWlJQkVKb0JJQVlRTmlBSklBWVFtZ0VnQWlBS0VGNGdCQ0FDRUprQklBSWdEQkJlSUFRZ0FoQ2FBU0FFRUtrQklBSWdDeEJlSUFVZ0FoQ1pBU0FDSUEwUVhpQUZJQUlRbWdFZ0JSQ3BBU0FDSUFRUVhpQUNJQVVRRVNBR0lBZ1FtUUVnQmlBQkVKb0JJQVlRTmlBQ0lBWVFtZ0VnQ0JCOElBTWdDQkNhQVNBQUlBTWdCeENsQVNBQkVId2dBUkNwQVNBQVFZQUNhaUlFUVlBQmFpQUJFSmtCSUFRUXRnRWdBaENwQVNBQ0VId2dBRUdBQkdvaUFTQUNJQWtRcFFFZ0FCQ3dBU0FCRUxBQklBQkJCRFlDZ0FZZ0EwR0FDV29rQUF1SEJ3RUZmeUFBRU5VQklnQWdBQkRMQVNJQ0VOSUJJUUVDUUFKQUFrQWdBQkRNQVEwQUlBQW9BZ0FoQXdKQUlBQVF4QUZGQkVBZ0FpQURhaUVDSUFBZ0F4RFRBU0lBUWZTK3dBQW9BZ0JIRFFFZ0FTZ0NCRUVEY1VFRFJ3MENRZXkrd0FBZ0FqWUNBQ0FBSUFJZ0FSQ0RBUThMSUFJZ0EycEJFR29oQUF3Q0N5QURRWUFDVHdSQUlBQVFGd3dCQ3lBQVFReHFLQUlBSWdRZ0FFRUlhaWdDQUNJRlJ3UkFJQVVnQkRZQ0RDQUVJQVUyQWdnTUFRdEIzTHZBQUVIY3U4QUFLQUlBUVg0Z0EwRURkbmR4TmdJQUN3SkFJQUVRdkFFRVFDQUFJQUlnQVJDREFRd0JDd0pBQWtBQ1FFSDR2c0FBS0FJQUlBRkhCRUFnQVVIMHZzQUFLQUlBUncwQlFmUyt3QUFnQURZQ0FFSHN2c0FBUWV5K3dBQW9BZ0FnQW1vaUFUWUNBQ0FBSUFFUW9BRVBDMEg0dnNBQUlBQTJBZ0JCOEw3QUFFSHd2c0FBS0FJQUlBSnFJZ0UyQWdBZ0FDQUJRUUZ5TmdJRUlBQkI5TDdBQUNnQ0FFWU5BUXdDQ3lBQkVNc0JJZ01nQW1vaEFnSkFJQU5CZ0FKUEJFQWdBUkFYREFFTElBRkJER29vQWdBaUJDQUJRUWhxS0FJQUlnRkhCRUFnQVNBRU5nSU1JQVFnQVRZQ0NBd0JDMEhjdThBQVFkeTd3QUFvQWdCQmZpQURRUU4yZDNFMkFnQUxJQUFnQWhDZ0FTQUFRZlMrd0FBb0FnQkhEUUpCN0w3QUFDQUNOZ0lBREFNTFFleSt3QUJCQURZQ0FFSDB2c0FBUVFBMkFnQUxRWlMvd0FBb0FnQWdBVThOQVVHQWdIeEJDRUVJRUtNQlFSUkJDQkNqQVdwQkVFRUlFS01CYW10QmQzRkJBMnNpQUVFQVFSQkJDQkNqQVVFQ2RHc2lBU0FBSUFGSkcwVU5BVUg0dnNBQUtBSUFSUTBCUVFoQkNCQ2pBU0VBUVJSQkNCQ2pBU0VCUVJCQkNCQ2pBU0VDUVFBQ1FFSHd2c0FBS0FJQUlnUWdBaUFCSUFCQkNHdHFhaUlDVFEwQVFmaSt3QUFvQWdBaEFVR0V2OEFBSVFBQ1FBTkFJQUVnQUNnQ0FFOEVRQ0FBRU1ZQklBRkxEUUlMSUFBb0FnZ2lBQTBBQzBFQUlRQUxJQUFRelFFTkFDQUFRUXhxS0FJQUdnd0FDMEVBRUJsclJ3MEJRZkMrd0FBb0FnQkJsTC9BQUNnQ0FFME5BVUdVdjhBQVFYODJBZ0FQQ3lBQ1FZQUNTUTBCSUFBZ0FoQVdRWnkvd0FCQm5ML0FBQ2dDQUVFQmF5SUFOZ0lBSUFBTkFCQVpHZzhMRHdzZ0FrRURkaUlEUVFOMFFlUzd3QUJxSVFFQ2YwSGN1OEFBS0FJQUlnSkJBU0FEZENJRGNRUkFJQUVvQWdnTUFRdEIzTHZBQUNBQ0lBTnlOZ0lBSUFFTElRTWdBU0FBTmdJSUlBTWdBRFlDRENBQUlBRTJBZ3dnQUNBRE5nSUlDNGtIQWdWK0VIOGpBRUdRQW1zaUNTUUFJQUJCNkFBUTBBRWhFaUFKUVRCcUlnQkI0QUVRMEFFYUEwQWdDRUU0UmdSQUlBRkJDR29oRkNBQ1FRaHFJUlVnQWlFTklBRWhFMEVCSVFzZ0NTa0RNQ0lESVFZZ0NVRTRhaWtEQUNJRUlRY0ZJQWxCSUdvZ0FpQUlhaWtEQUNJRElBTkNQNGNnQVNBSWFpa0RBQ0lESUFOQ1A0Y1FMeUFBSUFsQktHb3BBd0EzQXdnZ0FDQUpLUU1nTndNQUlBQkJFR29oQUNBSVFRaHFJUWdNQVFzTEEwQWdFaUFRUVFOMGFpQURRdi8vLy8vLy8vLy9BNE0zQXdBZ0JFSUdoaUFEUWpxSWhDRURJQVJDT29jaEJBSkFBa0FDUUNBTFFRZEdCRUJCQnlFS1FRQWhEa0VHSVFzTUFRc2dFQ0FMUVFGMklnQnJJUXdnRFNBQVFRTjBJaEZySVJZZ0V5QVJheUVYSUFRZ0NVRXdhaUFMUVFSMGFpSUtRUWhxS1FNQUlBZDhJQW9wQXdBaUJDQUdmQ0lHSUFSVXJYd2lCM3dnQXlBR2ZDSURJQVpVclh3aEJDQUxRUUZxSVE5Qk1DRUlJQlFoQ2lBVklRNERRQ0FBSUF0UERRTWdDQ0FSUmcwQ0lBeEJCMGtFUUNBSlFSQnFJQWdnRm1wQk1Hc3BBd0FnRGlBUmFpa0RBSDBpQlNBRlFqK0hJQW9nRVdvcEF3QWdDQ0FYYWtFd2F5a0RBSDBpQlNBRlFqK0hFQzhnQ1NrREVDSUZJQU44SWdNZ0JWU3RJQWxCR0dvcEF3QWdCSHg4SVFRZ0FFRUJhaUVBSUF4QkFXc2hEQ0FLUVFocUlRb2dEa0VJYWlFT0lBaEJDR3NoQ0F3QkN3c2dERUVIUWRTYndBQVFPd0FMQTBBQ1FDQUtRUTFIQkVBZ0N5QUtRUUYySWcxcklRd2dEaUFOUVFOMElnQnJJUWdnQUVFSWFpRUFJQVFnQnlBS1FRUjBJQWxxUVVCcUlnOUJDR29wQXdCOUlBWWdEeWtEQUNJRVZLMTlJZ2Q4SUFZZ0JIMGlCaUFEZkNJRElBWlVyWHdoQkNBS1FRRnFJUThEUUNBTlFRVkxEUUlnREVFR1RRUkFJQWtnQWlBSWFrRXdhaWtEQUNBQUlBSnFLUU1BZlNJRklBVkNQNGNnQUNBQmFpa0RBQ0FCSUFocVFUQnFLUU1BZlNJRklBVkNQNGNRTHlBSktRTUFJZ1VnQTN3aUF5QUZWSzBnQ1VFSWFpa0RBQ0FFZkh3aEJDQU5RUUZxSVEwZ0NFRUlheUVJSUF4QkFXc2hEQ0FBUVFocUlRQU1BUXNMSUF4QkIwSGttOEFBRURzQUN5QVNJQU0zQTJnZ0NVR1FBbW9rQUE4TElCSWdDa0VEZEdvZ0EwTC8vLy8vLy8vLy93T0ROd01BSUFSQ0JvWWdBMEk2aUlRaEF5QU9RUWhxSVE0Z0MwRUJhaUVMSUFSQ09vY2hCQ0FQSVFvTUFBc0FDMEVIUVFkQnhKdkFBQkE3QUFzZ0RVRUlhaUVOSUJOQkNHb2hFeUFRUVFGcUlSQWdEeUVMREFBTEFBdXFBd0VCZnlNQVFkQUdheUlHSkFBZ0JrSEFBQkRRQVNJR1FVQnJRYWdDRU5BQkVFUURRQ0FCQkVBZ0JrRkFhMEVBRUR3Z0FVRUJheUVCREFFRklBSUVRQ0FHUVVCcklBSWdBeEIwQ3dzTElBUUVRQ0FHUVVCcklBUWdCUkIwQ3lBR1FaQUdhaUlEUWdBM0FBQWdBMEVZYWtJQU53QUFJQU5CRUdwQ0FEY0FBQ0FEUVFocVFnQTNBQUFnQmtGQWF5SUJLQUlFSVFRZ0FTZ0NBQ0VGUVlBQklRSURRQ0FCSUFJUVBFRUFJUUlnQVNnQ0FFSC9BM0ZCd0FOSERRQUxJQUZCNUFCcUlBVTJBZ0FnQVVIZ0FHb2dCRFlDQUNBQkVBOUJBQ0VFQTBBZ0FrRWdSZ1JBSUFFUVJBVWdBaUFEYWlBQklBSkJmSEZxUVFocUtBSUFJQVJCZjNOQkdIRjJPZ0FBSUFSQkNHb2hCQ0FDUVFGcUlRSU1BUXNMUVFBaEFRTkFJQUZCSUVjRVFDQUJJQVpxSUFaQmtBWnFJQUZxTFFBQU9nQUFJQUZCQVdvaEFRd0JDd3RCQUNFQkFrQUNRQU5BQWtBZ0FVRWdSZzBESUFGQndBQkdEUUFnQVVIQUFFWU5BaUFBSUFGcUlBRWdCbW90QUFBNkFBQWdBVUVCYWlFQkRBRUxDMEhBQUVIQUFFSDhxc0FBRURzQUMwSEFBRUhBQUVHTXE4QUFFRHNBQ3lBR1FkQUdhaVFBQzc0RUFRbC9Jd0JCZ0F4cklnSWtBQ0FDSUFBUWpBRWdBa0dBQW1vaUNVRTRFTkFCR2lBQ1FRRTJBcmdDSUFKQndBSnFRVGdRMEFFYUlBSkIrQUpxUVFFMkFnQWdBa0dBQTJwQk9CRFFBUm9nQWtHNEEycEJBVFlDQUNBQ1FjQURha0U0RU5BQkdpQUNRZmdEYWtFQk5nSUFJQUpCZ0FScUlnWWdBRUdBQW1vaUJ4Q01BU0FDUVlBR2FpSUZRVGdRMEFFYUlBSkJBVFlDdUFZZ0FrSEFCbXBCT0JEUUFSb2dBa0g0Qm1wQkFUWUNBQ0FDUVlBSGFrRTRFTkFCR2lBQ1FiZ0hha0VCTmdJQUlBSkJ3QWRxUVRnUTBBRWFJQUpCK0FkcVFRRTJBZ0FnQWtHQUNHb2lBeUFBRUl3QklBSkJnQXBxSWdRZ0FSQ01BU0FDSUFFUUdDQUdJQUZCZ0FKcUlnZ1FHQ0FESUFjUWx3RWdCQ0FJRUpjQklBTVFzQUVnQkJDd0FTQUpJQU1RbGdFZ0NTQUVFQmdnQXlBSEVKWUJJQU1nQUVHQUJHb2lDaENYQVNBRUlBZ1FsZ0VnQkNBQlFZQUVhaUlJRUpjQklBTVFzQUVnQkJDd0FTQUZJQU1RbGdFZ0JTQUVFQmdnQXlBQ0VKWUJJQU1RS3lBRUlBWVFsZ0VnQkJBcklBa2dBeENYQVNBSElBa1FsZ0VnQnlBRUVKY0JJQVVnQkJDWEFTQUdJQU1RbHdFZ0F5QUFFSllCSUFNZ0NoQ1hBU0FERUxBQklBUWdBUkNXQVNBRUlBZ1Fsd0VnQkJDd0FTQURJQVFRR0NBR0lBTVFsd0VnQXlBS0VKWUJJQU1nQ0JBWUlBUWdBeENXQVNBRUVDc2dDaUFHRUpZQklBb2dCQkNYQVNBRklBUVFsd0VnQXhCa0lBY2dBeENYQVNBRkVMQUJJQVVRWkNBQUlBSVFsZ0VnQUNBRkVKY0JJQUJCQlRZQ2dBWWdBQkNkQVNBQ1FZQU1haVFBQzRvRUFRcC9Jd0JCZ0FocklnSWtBQ0FDSUFBUVhpQUNJQUVRRVNBQ1FZQUJhaUlISUFCQmdBRnFJZ2tRWGlBSElBRkJnQUZxSWdRUUVTQUNRWUFDYWlJR0lBQkJnQUpxSWdvUVhpQUdJQUZCZ0FKcUlnc1FFU0FDUVlBRGFpSUlJQUFRWGlBSUlBa1FtZ0VnQ0JDcEFTQUNRWUFFYWlJRklBRVFYaUFGSUFRUW1nRWdCUkNwQVNBSUlBVVFFU0FGSUFJUW1RRWdCU0FIRUpvQklBZ2dCUkI3SUFnUXFRRWdCU0FKRUprQklBVWdDaENhQVNBRkVLa0JJQUpCZ0FWcUlnTWdCQkJlSUFNZ0N4Q2FBU0FERUtrQklBVWdBeEFSSUFNZ0J4Q1pBU0FESUFZUW1nRWdCU0FERUhzZ0JSQ3BBU0FESUFBUW1RRWdBeUFLRUpvQklBTVFxUUVnQWtHQUJtb2lCQ0FCRUY0Z0JDQUxFSm9CSUFRUXFRRWdBeUFFRUJFZ0JDQUNFSmtCSUFRZ0JoQ2FBU0FFSUFNUXZ3RWdCQkNwQVNBRElBSVFtUUVnQXlBQ0VKb0JJQUlnQXhDYUFTQUNFS2tCSUFaQkRCQ3JBU0FHRUh3Z0JoQ3BBU0FDUVlBSGFpSUJJQWNRWGlBQklBWVFtZ0VnQVJDcEFTQUhJQVlRZXlBSEVLa0JJQVJCREJDckFTQUVFSHdnQkJDcEFTQURJQVFRbVFFZ0F5QUZFQkVnQmlBSUVKa0JJQVlnQnhBUklBTWdCaEMvQVNBRUlBSVFFU0FISUFFUUVTQUVJQWNRbWdFZ0FpQUlFQkVnQVNBRkVCRWdBU0FDRUpvQklBQWdBeENaQVNBQUVLa0JJQWtnQkJDWkFTQUpFS2tCSUFvZ0FSQ1pBU0FLRUtrQklBSkJnQWhxSkFBTDhnTUJDbjhqQUVHQUJHc2lBaVFBSUFJZ0FCQ1FBU0FDSUFFUVNpQUNRVUJySWdZZ0FFRkFheUlKRUpBQklBWWdBVUZBYXlJRUVFb2dBa0dBQVdvaUJ5QUFRWUFCYWlJS0VKQUJJQWNnQVVHQUFXb2lDeEJLSUFKQndBRnFJZ2dnQUJDUUFTQUlJQWtRZHlBSUVFSWdBa0dBQW1vaUJTQUJFSkFCSUFVZ0JCQjNJQVVRUWlBSUlBVVFTaUFGSUFJUXJnRWdCU0FHRUhjZ0NDQUZFSDRnQWtIQUFXb1FRaUFGSUFrUXJnRWdCU0FLRUhjZ0FrR0FBbW9RUWlBQ1FjQUNhaUlESUFRUWtBRWdBeUFMRUhjZ0F4QkNJQVVnQXhCS0lBTWdCaEN1QVNBRElBY1FkeUFGSUFNUWZpQUNRWUFDYWhCQ0lBTWdBQkN1QVNBRElBb1FkeUFDUWNBQ2FoQkNJQUpCZ0FOcUlnUWdBUkNRQVNBRUlBc1FkeUFFRUVJZ0F5QUVFRW9nQkNBQ0VLNEJJQVFnQnhCM0lBUWdBeERDQVNBQ1FZQURhaEJDSUFNZ0FoQ3VBU0FESUFJUWR5QUNJQU1RZHlBQ0VFSWdCMEVNRURRZ0FrSEFBMm9pQVNBR0VKQUJJQUVnQnhCM0lBRVFRaUFHSUFjUWZpQUdFRUlnQkVFTUVEUWdBeUFFRUs0QklBTWdCUkJLSUFjZ0NCQ3VBU0FISUFZUVNpQURJQWNRd2dFZ0JDQUNFRW9nQmlBQkVFb2dCQ0FHRUhjZ0FpQUlFRW9nQVNBRkVFb2dBU0FDRUhjZ0FDQURFSzRCSUFBUVFpQUpJQVFRcmdFZ0NSQkNJQW9nQVJDdUFTQUtFRUlnQWtHQUJHb2tBQXUvQlFFSmZ5TUFRWUFMYXlJSEpBQWdCMEU0RU5BQklnVkJBVFlDT0NBRlFVQnJRVGdRMEFFYUlBVkIrQUJxUVFFMkFnQWdCVUdBQVdwQk9CRFFBUm9nQlVHNEFXcEJBVFlDQUNBRlFjQUJha0U0RU5BQkdpQUZRZmdCYWtFQk5nSUFJQVZCZ0FKcUlnMUJPQkRRQVJvZ0JVRUJOZ0s0QWlBRlFjQUNha0U0RU5BQkdpQUZRZmdDYWtFQk5nSUFJQVZCZ0FOcVFUZ1EwQUVhSUFWQnVBTnFRUUUyQWdBZ0JVSEFBMnBCT0JEUUFSb2dCVUg0QTJwQkFUWUNBQ0FGUVlBRWFpSUxRVGdRMEFFYUlBVkJBVFlDdUFRZ0JVSEFCR3BCT0JEUUFSb2dCVUg0QkdwQkFUWUNBQ0FGUVlBRmFrRTRFTkFCR2lBRlFiZ0Zha0VCTmdJQUlBVkJ3QVZxUVRnUTBBRWFJQVZCK0FWcVFRRTJBZ0FnQlVHQUJtb2lDRUU0RU5BQkdpQUZRUUUyQXJnR0lBVkJ3QVpxUVRnUTBBRWFJQVZCK0FacVFRRTJBZ0FnQlVHQUIyb2lDVUU0RU5BQkdpQUZRUUUyQXJnSElBVkJ3QWRxUVRnUTBBRWFJQVZCK0FkcVFRRTJBZ0FnQlVHQUNHb2lCMEU0RU5BQkdpQUZRUUUyQXJnSUlBVkJ3QWhxUVRnUTBBRWFJQVZCK0FocVFRRTJBZ0FqQUVHQUFtc2lDaVFBSUFwQmdBRnFJZ1lnQVJCZUlBZ2dCaENaQVNBR0lBRkJnQUZxRUY0Z0J5QUdFSmtCSUFZZ0FVR0FBbW9pREJCZUlBb2dCaEJlSUFZZ0RCQmVJQWtnQmhDWkFTQUdJQUpCZ0FGcUlnd1FYaUFLSUFZUUVTQUdJQUlRWGlBSklBWVFFU0FJSUFrUWV5QUlFS2tCSUFjZ0NoQjdJQWNRcVFFZ0NpQUlFSmtCSUFnUWZDQUlFS2tCSUFZZ0RCQmVJQW9nQmhBUklBa2dCeENaQVNBR0lBSVFYaUFKSUFZUUVTQUpJQW9RZXlBSkVLa0JJQWNRTmlBSEVLa0JJQUVnQWhBSUlBcEJnQUpxSkFBZ0J5QURFS29CSUFnZ0JCQ3FBU0FGUVlBSmFpSUJJQWdnQ1JDVkFTQUZJQUVRbGdFZ0FTQUhFS0VCSUFzZ0FSQ1dBU0FMRUdRZ0FDQUZJQTBnQ3hCMUlBQkJBellDZ0FZZ0JVR0FDMm9rQUF1SkJRRUlmeU1BUVlBTGF5SUZKQUFnQlVFNEVOQUJJZ1JCQVRZQ09DQUVRVUJyUVRnUTBBRWFJQVJCK0FCcVFRRTJBZ0FnQkVHQUFXcEJPQkRRQVJvZ0JFRzRBV3BCQVRZQ0FDQUVRY0FCYWtFNEVOQUJHaUFFUWZnQmFrRUJOZ0lBSUFSQmdBSnFJZ3RCT0JEUUFSb2dCRUVCTmdLNEFpQUVRY0FDYWtFNEVOQUJHaUFFUWZnQ2FrRUJOZ0lBSUFSQmdBTnFRVGdRMEFFYUlBUkJ1QU5xUVFFMkFnQWdCRUhBQTJwQk9CRFFBUm9nQkVINEEycEJBVFlDQUNBRVFZQUVhaUlLUVRnUTBBRWFJQVJCQVRZQ3VBUWdCRUhBQkdwQk9CRFFBUm9nQkVINEJHcEJBVFlDQUNBRVFZQUZha0U0RU5BQkdpQUVRYmdGYWtFQk5nSUFJQVJCd0FWcVFUZ1EwQUVhSUFSQitBVnFRUUUyQWdBZ0JFR0FCbW9pQmtFNEVOQUJHaUFFUVFFMkFyZ0dJQVJCd0FacVFUZ1EwQUVhSUFSQitBWnFRUUUyQWdBZ0JFR0FCMm9pQlVFNEVOQUJHaUFFUVFFMkFyZ0hJQVJCd0FkcVFUZ1EwQUVhSUFSQitBZHFRUUUyQWdBZ0JFR0FDR29pQ0VFNEVOQUJHaUFFUVFFMkFyZ0lJQVJCd0FocVFUZ1EwQUVhSUFSQitBaHFRUUUyQWdBakFFR0FBbXNpQnlRQUlBZEJnQUZxSWdrZ0FSQmVJQWdnQ1JDWkFTQUpJQUZCZ0FGcUVGNGdCeUFKRUY0Z0NTQUJRWUFDYWhCZUlBVWdDUkNaQVNBR0lBY1FtUUVnQmlBRkVCRWdDQkF0SUFjUUxTQUZFQzBnQmhDNEFTQUdFRFlnQmhDcEFTQUdFSHdnQmhDcEFTQUZRUXdRcXdFZ0NFRURFS3NCSUFVUWZDQUZFS2tCSUFVZ0J4QjdJQVVRcVFFZ0FSQVNJQWRCZ0FKcUpBQWdDQ0FDRUtvQklBWWdBeENxQVNBRVFZQUphaUlCSUFZZ0JSQ1ZBU0FFSUFFUWxnRWdBU0FJRUtFQklBb2dBUkNXQVNBS0VHUWdBQ0FFSUFzZ0NoQjFJQUJCQXpZQ2dBWWdCRUdBQzJva0FBdUJCUUVMZnlNQVFUQnJJZ0lrQUNBQ1FTUnFRYWkxd0FBMkFnQWdBa0VET2dBb0lBSkNnSUNBZ0lBRU53TUlJQUlnQURZQ0lDQUNRUUEyQWhnZ0FrRUFOZ0lRQWtBQ1FBSkFJQUVvQWdnaUNrVUVRQ0FCUVJScUtBSUFJZ1JGRFFFZ0FTZ0NBQ0VESUFFb0FoQWhBQ0FFUVFGclFmLy8vLzhCY1VFQmFpSUhJUVVEUUNBRFFRUnFLQUlBSWdRRVFDQUNLQUlnSUFNb0FnQWdCQ0FDS0FJa0tBSU1FUVVBRFFRTElBQW9BZ0FnQWtFSWFpQUFRUVJxS0FJQUVRUUFEUU1nQUVFSWFpRUFJQU5CQ0dvaEF5QUZRUUZySWdVTkFBc01BUXNnQVVFTWFpZ0NBQ0lBUlEwQUlBQkJCWFFoQ3lBQVFRRnJRZi8vL3o5eFFRRnFJUWNnQVNnQ0FDRURBMEFnQTBFRWFpZ0NBQ0lBQkVBZ0FpZ0NJQ0FES0FJQUlBQWdBaWdDSkNnQ0RCRUZBQTBEQ3lBQ0lBVWdDbW9pQkVFY2FpMEFBRG9BS0NBQ0lBUkJCR29wQWdCQ0lJazNBd2dnQkVFWWFpZ0NBQ0VHSUFFb0FoQWhDRUVBSVFsQkFDRUFBa0FDUUFKQUlBUkJGR29vQWdCQkFXc09BZ0FDQVFzZ0JrRURkQ0FJYWlJTUtBSUVRUTlIRFFFZ0RDZ0NBQ2dDQUNFR0MwRUJJUUFMSUFJZ0JqWUNGQ0FDSUFBMkFoQWdCRUVRYWlnQ0FDRUFBa0FDUUFKQUlBUkJER29vQWdCQkFXc09BZ0FDQVFzZ0FFRURkQ0FJYWlJR0tBSUVRUTlIRFFFZ0JpZ0NBQ2dDQUNFQUMwRUJJUWtMSUFJZ0FEWUNIQ0FDSUFrMkFoZ2dDQ0FFS0FJQVFRTjBhaUlBS0FJQUlBSkJDR29nQUNnQ0JCRUVBQTBDSUFOQkNHb2hBeUFMSUFWQklHb2lCVWNOQUFzTFFRQWhBQ0FISUFFb0FnUkpJZ05GRFFFZ0FpZ0NJQ0FCS0FJQUlBZEJBM1JxUVFBZ0F4c2lBU2dDQUNBQktBSUVJQUlvQWlRb0Fnd1JCUUJGRFFFTFFRRWhBQXNnQWtFd2FpUUFJQUFMMXdRQkJIOGdBQ0FCRU5JQklRSUNRQUpBQWtBZ0FCRE1BUTBBSUFBb0FnQWhBd0pBSUFBUXhBRkZCRUFnQVNBRGFpRUJJQUFnQXhEVEFTSUFRZlMrd0FBb0FnQkhEUUVnQWlnQ0JFRURjVUVEUncwQ1FleSt3QUFnQVRZQ0FDQUFJQUVnQWhDREFROExJQUVnQTJwQkVHb2hBQXdDQ3lBRFFZQUNUd1JBSUFBUUZ3d0JDeUFBUVF4cUtBSUFJZ1FnQUVFSWFpZ0NBQ0lGUndSQUlBVWdCRFlDRENBRUlBVTJBZ2dNQVF0QjNMdkFBRUhjdThBQUtBSUFRWDRnQTBFRGRuZHhOZ0lBQ3lBQ0VMd0JCRUFnQUNBQklBSVFnd0VNQWdzQ1FFSDR2c0FBS0FJQUlBSkhCRUFnQWtIMHZzQUFLQUlBUncwQlFmUyt3QUFnQURZQ0FFSHN2c0FBUWV5K3dBQW9BZ0FnQVdvaUFUWUNBQ0FBSUFFUW9BRVBDMEg0dnNBQUlBQTJBZ0JCOEw3QUFFSHd2c0FBS0FJQUlBRnFJZ0UyQWdBZ0FDQUJRUUZ5TmdJRUlBQkI5TDdBQUNnQ0FFY05BVUhzdnNBQVFRQTJBZ0JCOUw3QUFFRUFOZ0lBRHdzZ0FoRExBU0lESUFGcUlRRUNRQ0FEUVlBQ1R3UkFJQUlRRnd3QkN5QUNRUXhxS0FJQUlnUWdBa0VJYWlnQ0FDSUNSd1JBSUFJZ0JEWUNEQ0FFSUFJMkFnZ01BUXRCM0x2QUFFSGN1OEFBS0FJQVFYNGdBMEVEZG5keE5nSUFDeUFBSUFFUW9BRWdBRUgwdnNBQUtBSUFSdzBCUWV5K3dBQWdBVFlDQUFzUEN5QUJRWUFDVHdSQUlBQWdBUkFXRHdzZ0FVRURkaUlDUVFOMFFlUzd3QUJxSVFFQ2YwSGN1OEFBS0FJQUlnTkJBU0FDZENJQ2NRUkFJQUVvQWdnTUFRdEIzTHZBQUNBQ0lBTnlOZ0lBSUFFTElRSWdBU0FBTmdJSUlBSWdBRFlDRENBQUlBRTJBZ3dnQUNBQ05nSUlDK1VEQVFOL0l3QkIwQ0pySWdNa0FDQURRY0FXYWlJRVFjaXR3QUFRU1NBRFFjZ2NhaUlGUVlDdXdBQVFTU0FEUVFocUlBUWdCUkJMSUFOQmlBRnFRVGdRMEFFYUlBTkJ3QUZxUVRnUTBBRWFJQU5CK0FGcUVEMENRQ0FDRUlZQkJFQWdBQkJWREFFTElBTkIrQVJxSWdRUVBTQUVJQUVRZlNBRUVFY2dBMEg0QjJvaUFSQm5JQUVnQWhCNElBRVFSaUFEUWNnY2FpSUNJQUVRa0FFZ0EwRzRDV29nQWhDUUFTQUNJQU5CdUFocUVKQUJJQU5CK0FscUlBSVFrQUVnQTBHNENtb2lBUkE5SUFOQnVBMXFFRlVnQVNBRUVIMGdBMEhBRTJvaUFSQTlJQUVnQkJCOUlBRVFvZ0VnQTBIQUFXb2dBMEdJQVdvUVVFRUNheUVDQTBBZ0FrRUJha0VCVFFSQUlBTkJ1QTFxSWdFUW5nRWdBQ0FCUVlnR0VORUJHZ1VnQTBHNERXb1FHaUFEUWNBV2FpQURRYmdLYWlBRFFiZ0phaUFEUWZnSmFoQUxBa0FDUUFKQUlBTkJ3QUZxSUFJUVV5QURRWWdCYWlBQ0VGTnJRUUZxRGdNQkFnQUNDeUFEUWNnY2FpSUJJQU5CdUFwcUlBTkIrQVJxSUFOQnVBbHFJQU5CK0FscUVBb2dBMEhBRm1vZ0FSQUREQUVMSUFOQnlCeHFJZ0VnQTBHNENtb2dBMEhBRTJvZ0EwRzRDV29nQTBINENXb1FDaUFEUWNBV2FpQUJFQU1MSUFKQkFXc2hBaUFEUWJnTmFpQURRY0FXYWhBQkRBRUxDd3NnQTBIUUltb2tBQXZCQXdFVmZ3TkFJQU5Cd0FGR0JFQUNRQ0FBUVNocUlRc2dBRUVVYWlnQ0FDSU1JUWdnQUVFUWFpZ0NBQ0lOSVFJZ0FFRU1haWdDQUNJT0lRRWdBQ2dDQ0NJUElRTWdBRUVZYWlnQ0FDSVFJUW9nQUVFY2FpZ0NBQ0lSSVFRZ0FFRWdhaWdDQUNJU0lRY2dBRUVrYWlnQ0FDSVRJUVlEUUNBSElRa2dCQ0VISUFvaEJDQUZRWUFDUmcwQklBRWdBbkVoRkNBQklBSnpJUlVnQlNBTGFpZ0NBQ0FGUWNDaXdBQnFLQUlBSUFrZ0JFRi9jM0VnQkNBSGNYSWdCbW9nQkVFYWR5QUVRUlYzY3lBRVFRZDNjMnBxYWlJR0lBaHFJUW9nQlVFRWFpRUZJQUloQ0NBQklRSWdBeUlCUVI1M0lBRkJFM2R6SUFGQkNuZHpJQlFnQVNBVmNYTnFJQVpxSVFNZ0NTRUdEQUFMQUFzRklBQWdBMm9pQWtIb0FHb2dBa0VvYWlnQ0FDQUNRY3dBYWlnQ0FDQUNRZUFBYWlnQ0FDSUJRUTkzSUFGQkRYZHpJQUZCQ25aemFtb2dBa0VzYWlnQ0FDSUJRUmwzSUFGQkRuZHpJQUZCQTNaemFqWUNBQ0FEUVFScUlRTU1BUXNMSUFBZ0JpQVRhallDSkNBQUlBa2dFbW8yQWlBZ0FDQUhJQkZxTmdJY0lBQWdCQ0FRYWpZQ0dDQUFJQWdnREdvMkFoUWdBQ0FDSUExcU5nSVFJQUFnQVNBT2FqWUNEQ0FBSUFNZ0QybzJBZ2dMNUFFQkFuOGpBRUdBQTJzaUF5UUFJQU1RUFNBQUlBRWdBa0VmZFNJRUlBSnpJQVJCZjNOcVFRSnRJZ0pCQVd0QkgzWVFieUFBSUFGQmdBTnFJQUpCQVhOQkFXdEJIM1lRYnlBQUlBRkJnQVpxSUFKQkFuTkJBV3RCSDNZUWJ5QUFJQUZCZ0FscUlBSkJBM05CQVd0QkgzWVFieUFBSUFGQmdBeHFJQUpCQkhOQkFXdEJIM1lRYnlBQUlBRkJnQTlxSUFKQkJYTkJBV3RCSDNZUWJ5QUFJQUZCZ0JKcUlBSkJCbk5CQVd0QkgzWVFieUFBSUFGQmdCVnFJQUpCQjNOQkFXdEJIM1lRYnlBRElBQVFmU0FERUtJQklBQWdBeUFFUVFGeEVHOGdBMEdBQTJva0FBdmxBd0VJZnlNQVFaQUdheUlDSkFBZ0FFRkFheUVJQWtBZ0FVSDRBR29vQWdBZ0FTZ0NPR3FzSUFCQitBQnFLQUlBSWdjZ0FDZ0NPQ0lFYXF4K1F2Ly8vdzlYRFFBZ0JFRUJTZ1IvSUFBUUhpQUFLQUo0QlNBSEMwRUJUQTBBSUFnUUhnc2dBa0hZcE1BQUVFa2dBa0U0YWlJSFFmQUFFTkFCR2lBQ0lRTkJBQ0VDQTBBZ0FrRTRSZ1JBQWtBZ0IwRTRhaUVFUVFBaEFnTkFJQUpCT0VZTkFTQUNJQVJxSUFJZ0Eyb3BBd0EzQXdBZ0FrRUlhaUVDREFBTEFBc0ZJQUlnQjJwQ0FEY0RBQ0FDUVFocUlRSU1BUXNMSUFOQnFBRnFJZ1lnQUJCZElBTkI0QUZxSWdVZ0FSQmRJQU5CbUFKcUlnSWdBQ0FCRUFVZ0EwR0lBMm9pQkNBSUlBRkJRR3NpQVJBRklBWWdDQkJnSUFZUVFpQUZJQUVRWUNBRkVFSWdBMEg0QTJvaUNTQUdJQVVRQlVFQUlRRWdBMEhvQkdvaUJrSHdBQkRRQVNFRkEwQWdBVUh3QUVjRVFDQUJJQVZxSUFFZ0Ftb3BBd0EzQXdBZ0FVRUlhaUVCREFFTEN5QUdJQVFRWWtFQUlRRURRQ0FCUWZBQVJ3UkFJQUVnQkdvaUJTQUJJQWRxS1FNQUlBVXBBd0I5TndNQUlBRkJDR29oQVF3QkN3c2dBaUFFRUdJZ0FoQklJQWtnQmhCaklBa1FTQ0FEUWRnRmFpSUJJQUlRYXlBQUlBRVFhaUFBUVFNMkFqZ2dBU0FKRUdzZ0NDQUJFR29nQUVFQ05nSjRJQU5Ca0FacUpBQUxvd0lCQ0g4akFFR0FCbXNpQWlRQUlBSWdBRUdBQVdvaUJ4QmVJQUpCZ0FGcUlnUWdCeEJlSUFRUUxTQUNRWUFDYWlJRklBSVFYaUFGSUFCQmdBSnFJZ01RRVNBQ1FZQURhaUlCSUFNUVhpQUJFQzBnQXlBRUVKa0JJQU1nQkJDYUFTQURFS2tCSUFNUXVBRWdBeEM0QVNBREVLa0JJQUZCREJDckFTQUJFSHdnQVJDcEFTQUNRWUFFYWlJSUlBRVFYaUFJSUFNUUVTQUNRWUFGYWlJR0lBUVFYaUFHSUFFUW1nRWdCaENwQVNBRElBVVFFU0FGSUFFUW1RRWdCU0FCRUpvQklBRWdCUkNhQVNBQkVLa0JJQVFnQVJCN0lBUVFxUUVnQmlBRUVCRWdCaUFJRUpvQklBVWdBQkNaQVNBRklBSVFFU0FBSUFRUW1RRWdBQkNwQVNBQUlBVVFFU0FBRUxnQklBQVFxUUVnQnlBR0VKa0JJQWNRcVFFZ0FrR0FCbW9rQUF1OEFnRUdmeU1BUVlBSWF5SUJKQUFnQVNBQUVJd0JJQUZCZ0FKcUlnTWdBRUdBQkdvaUJSQ01BU0FCUVlBRWFpSUVJQUJCZ0FKcUlnWVFqQUVnQVVHQUJtb2lBa0U0RU5BQkdpQUJRUUUyQXJnR0lBRkJ3QVpxUVRnUTBBRWFJQUZCK0FacVFRRTJBZ0FnQVVHQUIycEJPQkRRQVJvZ0FVRzRCMnBCQVRZQ0FDQUJRY0FIYWtFNEVOQUJHaUFCUWZnSGFrRUJOZ0lBSUFBUUlTQUNJQUFRbGdFZ0FpQUFFSmNCSUFBZ0FoQ1hBU0FBRUxBQklBRVF5UUVnQVJDekFTQUFJQUVRbHdFZ0F4QWhJQU1RWkNBQ0lBTVFsZ0VnQWlBREVKY0JJQU1nQWhDWEFTQURFTEFCSUFRUUlTQUNJQVFRbGdFZ0FpQUVFSmNCSUFRZ0FoQ1hBU0FFRUxBQklBWVFzZ0VnQmhDekFTQUZFTWtCSUFVUXN3RWdCaUFERUpjQklBVWdCQkNYQVNBQVFRVTJBb0FHSUFBUW5BRWdBVUdBQ0dva0FBdi9BUUVIZnlNQVFjQUNheUlCSkFBZ0FTQUFRVUJySWdZUWtBRWdBUkJNSUFGQlFHc2lBeUFHRUpBQklBTWdBRUdBQVdvaUFoQktJQUZCZ0FGcUlnUWdBaENRQVNBRUVFd2dBaUFCRUs0QklBSWdBUkIzSUFJUVFpQUNFSUlCSUFJUWdnRWdBaEJDSUFSQkRCQTBJQUZCd0FGcUlnY2dCQkNRQVNBSElBSVFTaUFCUVlBQ2FpSUZJQUVRa0FFZ0JTQUVFSGNnQlJCQ0lBSWdBeEJLSUFNZ0JCQ3VBU0FESUFRUWR5QUVJQU1RZHlBQklBUVFmaUFCRUVJZ0JTQUJFRW9nQlNBSEVIY2dBeUFBRUs0QklBTWdCaEJLSUFBZ0FSQ3VBU0FBRUVJZ0FDQURFRW9nQUJDQ0FTQUFFRUlnQmlBRkVLNEJJQVlRUWlBQlFjQUNhaVFBQzg0Q0FnZC9BbjRDUUFKQUFrQkJEU0FCUVRwdUlnSnJJZ1JCRFUwRVFFRU1JQUpySWdOQkRrOE5BU0FBSUFBZ0EwRURkR29wQXdCQk9pQUJJQUpCT214cklnTnJyU0lLaHlBQUlBUkJBM1JxS1FNQUlBT3RJZ21HaERjRGFDQUVRUTFySVFVZ0FFSGdBR29oQkNBQ1FRRnFJUVpCQUNBQ1FRTjBheUVIUVFzaEF3TkFBa0FnQTBFQ2FpQUdUUVJBSUFGQnJBWlBEUUVnQUNBQ1FRTjBhaUFBS1FNQUlBbUdRdi8vLy8vLy8vLy9BNE0zQXdBRFFDQUNSUTBISUFCQ0FEY0RBQ0FDUVFGcklRSWdBRUVJYWlFQURBQUxBQXNnQXlBRmFrRU9UdzBFSUFRZ0JDQUhhaUlJUVFocktRTUFJQXFISUFncEF3QWdDWVpDLy8vLy8vLy8vLzhEZzRRM0F3QWdBMEVCYXlFRElBUkJDR3NoQkF3QkN3c2dBa0VPUVlDeXdBQVFPd0FMSUFSQkRrSFFzY0FBRURzQUN5QURRUTVCNExIQUFCQTdBQXRCZjBFT1FmQ3h3QUFRT3dBTEM2Y0NBUVIvSUFCQ0FEY0NFQ0FBQW45QkFDQUJRWUFDU1EwQUdrRWZJQUZCLy8vL0Iwc05BQm9nQVVFR0lBRkJDSFpuSWdOcmRrRUJjU0FEUVFGMGEwRSthZ3NpQkRZQ0hDQUVRUUowUWV5OXdBQnFJUU1nQUNFQ0FrQUNRQUpBQWtCQjRMdkFBQ2dDQUNJQVFRRWdCSFFpQlhFRVFDQURLQUlBSVFNZ0JCQ2ZBU0VBSUFNUXl3RWdBVWNOQVNBRElRQU1BZ3RCNEx2QUFDQUFJQVZ5TmdJQUlBTWdBallDQUF3REN5QUJJQUIwSVFRRFFDQURJQVJCSFhaQkJIRnFRUkJxSWdVb0FnQWlBRVVOQWlBRVFRRjBJUVFnQUNJREVNc0JJQUZIRFFBTEN5QUFLQUlJSWdFZ0FqWUNEQ0FBSUFJMkFnZ2dBaUFBTmdJTUlBSWdBVFlDQ0NBQ1FRQTJBaGdQQ3lBRklBSTJBZ0FMSUFJZ0F6WUNHQ0FDSUFJMkFnZ2dBaUFDTmdJTUM3WUNBUVYvSUFBb0FoZ2hCQUpBQWtBZ0FDQUFLQUlNUmdSQUlBQkJGRUVRSUFCQkZHb2lBU2dDQUNJREcyb29BZ0FpQWcwQlFRQWhBUXdDQ3lBQUtBSUlJZ0lnQUNnQ0RDSUJOZ0lNSUFFZ0FqWUNDQXdCQ3lBQklBQkJFR29nQXhzaEF3TkFJQU1oQlNBQ0lnRkJGR29pQXlnQ0FDSUNSUVJBSUFGQkVHb2hBeUFCS0FJUUlRSUxJQUlOQUFzZ0JVRUFOZ0lBQ3dKQUlBUkZEUUFDUUNBQUlBQW9BaHhCQW5SQjdMM0FBR29pQWlnQ0FFY0VRQ0FFUVJCQkZDQUVLQUlRSUFCR0cyb2dBVFlDQUNBQkRRRU1BZ3NnQWlBQk5nSUFJQUVOQUVIZ3U4QUFRZUM3d0FBb0FnQkJmaUFBS0FJY2QzRTJBZ0FQQ3lBQklBUTJBaGdnQUNnQ0VDSUNCRUFnQVNBQ05nSVFJQUlnQVRZQ0dBc2dBRUVVYWlnQ0FDSUFSUTBBSUFGQkZHb2dBRFlDQUNBQUlBRTJBaGdMQytVQkFRWi9Jd0JCZ0FScklnSWtBQ0FDSUFBUVhpQUNRWUFCYWlJRklBQkJnQUZxSWdZUVhpQUNRWUFDYWlJRFFUZ1EwQUVhSUFKQkFUWUN1QUlnQWtIQUFtcEJPQkRRQVJvZ0FrSDRBbXBCQVRZQ0FDQUNRWUFEYWlJRUlBWVFYaUFDSUFFUUVTQUZJQUZCZ0FGcUlnY1FFU0FESUFjUW1RRWdBeUFCRUpvQklBUWdBQkNhQVNBREVLa0JJQVFRcVFFZ0JDQURFQkVnQXlBQ0VKa0JJQU1RTmlBRUlBTVFtZ0VnQkJDcEFTQURJQVVRbVFFZ0F4QTJJQVlnQkJDWkFTQUdJQU1RbWdFZ0JSQjhJQUFnQlJDWkFTQUFJQUlRbWdFZ0FCQ3dBU0FDUVlBRWFpUUFDMjhCREg5QmpML0FBQ2dDQUNJQ1JRUkFRWnkvd0FCQi94ODJBZ0JCQUE4TFFZUy93QUFoQmdOQUlBSWlBU2dDQ0NFQ0lBRW9BZ1FoQXlBQktBSUFJUVFnQVVFTWFpZ0NBQm9nQVNFR0lBVkJBV29oQlNBQ0RRQUxRWnkvd0FBZ0JVSC9IeUFGUWY4ZlN4czJBZ0JCQUF1QUFnRUdmeU1BUVlBSWF5SUJKQUFnQUNnQ2dBWkJBVWNFUUNBQklBQVFqQUVnQVVHQUFtb2lBaUFBUVlBQ2FpSUVFSXdCSUFGQmdBUnFJZ1VnQUVHQUJHb2lBeENNQVNBQlFZQUdhaUlHSUFBUWpBRWdBUkFoSUFJZ0F4QVlJQUlRc3dFZ0FoQ3dBU0FGRUNFZ0JpQUVFQmdnQmhDekFTQURJQUFRbHdFZ0F5QUVFSmNCSUFNUXNBRWdBeEFoSUFBZ0FSQ1dBU0FCSUFJUWx3RWdBUkN3QVNBQklBVVFsd0VnQVNBR0VKY0JJQUVRc0FFZ0FSQXJJQUlRWkNBRkVHUWdBQ0FDRUpjQklBUWdCUkNXQVNBRUlBWVFsd0VnQXlBQkVKY0JJQUJCQkVFRklBQW9Bb0FHUVg1eFFRSkdHellDZ0FZZ0FCQ2RBUXNnQVVHQUNHb2tBQXVaQWdFQmZ5TUFRWUFOYXlJREpBQWdBeUFCRUdrZ0F4Q2RBU0FEUVlnR2FpSUJJQUlRWFNBQkVFSWdBMEhBQm1vaUFpQUJFRjBnQWtFREVDa2FJQUlRUWlBRFFmZ0dhaUFERUdrQ1FDQUNFRmRGQkVBZ0EwSEFCbW9RS2tFQ2F5RUNBMEFnQWtFQmFrRUJUUVJBSUFOQitBWnFJZ0VRbkFFTUF3VWdBMEg0Qm1vUUV3SkFBa0FDUUNBRFFjQUdhaUFDRUZNZ0EwR0lCbW9nQWhCVGEwRUJhZzREQVFJQUFnc2dBMEg0Qm1vZ0F4QUhEQUVMSUFNUW5nRWdBMEg0Qm1vZ0F4QUhJQU1RbmdFTElBSkJBV3NoQWd3QkN3QUxBQXNnQTBINEJtb2lBUkMzQVNBQlFZQUJhaEMyQVNBQlFZQUNhaEN4QVNBQlFZQUVhaEN4QVNBQlFRRTJBb0FHQ3lBQUlBRkJpQVlRMFFFYUlBTkJnQTFxSkFBTGhnSUNCSDhCZmlNQVFUQnJJZ0lrQUNBQlFRUnFJUVFnQVNnQ0JFVUVRQ0FCS0FJQUlRTWdBa0VRYWlJRlFRQTJBZ0FnQWtJQk53TUlJQUlnQWtFSWFqWUNGQ0FDUVNocUlBTkJFR29wQWdBM0F3QWdBa0VnYWlBRFFRaHFLUUlBTndNQUlBSWdBeWtDQURjREdDQUNRUlJxSUFKQkdHb1FEQm9nQkVFSWFpQUZLQUlBTmdJQUlBUWdBaWtEQ0RjQ0FBc2dBa0VnYWlJRElBUkJDR29vQWdBMkFnQWdBVUVNYWtFQU5nSUFJQVFwQWdBaEJpQUJRZ0UzQWdRZ0FpQUdOd01ZUVF4QkJCQzVBU0lCUlFSQVFReEJCQkRQQVFBTElBRWdBaWtER0RjQ0FDQUJRUWhxSUFNb0FnQTJBZ0FnQUVHRXQ4QUFOZ0lFSUFBZ0FUWUNBQ0FDUVRCcUpBQUw1QUVCQW44akFFSEFBV3NpQXlRQUlBTVFaeUFBSUFFZ0FrRWZkU0lFSUFKeklBUkJmM05xUVFKdElnSkJBV3RCSDNZUWJpQUFJQUZCd0FGcUlBSkJBWE5CQVd0QkgzWVFiaUFBSUFGQmdBTnFJQUpCQW5OQkFXdEJIM1lRYmlBQUlBRkJ3QVJxSUFKQkEzTkJBV3RCSDNZUWJpQUFJQUZCZ0FacUlBSkJCSE5CQVd0QkgzWVFiaUFBSUFGQndBZHFJQUpCQlhOQkFXdEJIM1lRYmlBQUlBRkJnQWxxSUFKQkJuTkJBV3RCSDNZUWJpQUFJQUZCd0FwcUlBSkJCM05CQVd0QkgzWVFiaUFESUFBUWVDQURFS1FCSUFBZ0F5QUVRUUZ4RUc0Z0EwSEFBV29rQUF2REF3SUdmd04rSXdCQjhBQnJJZ0VrQUNBQlFjQ3l3QUFRU1NBQlFUaHFJQUVRWFNBQUVFSUNRQUpBQWtBZ0FRSi9JQUFvQWpnaUFrRVFUQVJBSUFKQkFXc1FOUXdCQ3lBQktRTXdJZ2hDQVh3aUJ5QUlWQTBCSUFBcEF6QWlDRUtBZ0lDQWdJQ0FnSUIvVVNBSFFuOVJjUTBDSUFGQk9Hb2lBaUFJSUFkL3B4QXBJUWNnQVNBQktRTm9JQWRDT29aOE53Tm9JQUFnQWhCaElBQVFRa0VDQ3lJRUVDZ0RRQ0FFUlEwRFFRQWhBeUFCSUFFcEF3Z2lDRUk1aGtLQWdJQ0FnSUNBZ0FLRElBRXBBd0JDQVllRUlnYzNBd0FnQUNrREFDQUhmU0VISUFCQkNHb2hCU0FBSUFGQk9Hb2lBa0VCQTM4Z0FpQURhaUFIUXYvLy8vLy8vLy8vQTRNM0F3QWdCMEk2aHlFSElBTkJLRVlFZnlBQklBRXBBekJDQVljaUNEY0RNQ0FDSUFBcEF6QWdDSDBnQjN3aUJ6Y0RNQ0FIUWorSXB3VWdBU0FEYWlJR1FRaHFJQWhDQVljZ0JrRVFhaWtEQUNJSVFqbUdRb0NBZ0lDQWdJQ0FBb09FSWdrM0F3QWdBeUFGYWlrREFDQUhmQ0FKZlNFSElBTkJDR29oQXd3QkN3dHJFREFnQkVFQmF5RUVEQUFMQUF0QjRMUEFBRUVaUWNTendBQVFXUUFMUVlDMHdBQkJIMEhFczhBQUVGa0FDeUFBUVFFMkFqZ2dBVUh3QUdva0FBdnVBUUVDZnlNQVFiQUJheUlESkFBZ0EwRXdFTkFCSVFNQ1FBSkFBMEFnQWtFd1JnUkFJQU5CTUdvZ0F4QndJQUZCTUdvaEFVRUFJUUlEUUNBQ1FUQkdEUU1nQWtFd1JnMEVJQUlnQTJvZ0FTQUNhaTBBQURvQUFDQUNRUUZxSVFJTUFBc0FDeUFDUWVBQVJ3UkFJQUlnQTJvZ0FTQUNhaTBBQURvQUFDQUNRUUZxSVFJTUFRc0xRZUFBUWVBQVFZQ213QUFRT3dBTElBTkI4QUJxSWdFZ0F4QndJQUJCT0JEUUFTSUFRUUUyQWpnZ0FFRkFhMEU0RU5BQklBQkIrQUJxUVFFMkFnQWdBQ0FCRUs0QklBTkJNR29RcmdFZ0EwR3dBV29rQUE4TElBSkJNR3BCNEFCQmtLYkFBQkE3QUF1UEFnRURmeU1BUVNCcklnVWtBRUVCSVFaQjJMdkFBRUhZdThBQUtBSUFJZ2RCQVdvMkFnQUNRRUdndjhBQUxRQUFCRUJCcEwvQUFDZ0NBRUVCYWlFR0RBRUxRYUMvd0FCQkFUb0FBQXRCcEwvQUFDQUdOZ0lBQWtBQ1FDQUhRUUJJSUFaQkFrdHlEUUFnQlNBRU9nQVlJQVVnQXpZQ0ZDQUZJQUkyQWhCQnpMdkFBQ2dDQUNJQ1FRQklEUUJCekx2QUFDQUNRUUZxSWdJMkFnQkJ6THZBQUVIVXU4QUFLQUlBSWdNRWYwSFF1OEFBS0FJQUlBVWdBQ0FCS0FJUUVRQUFJQVVnQlNrREFEY0RDQ0FGUVFocUlBTW9BaFFSQUFCQnpMdkFBQ2dDQUFVZ0FndEJBV3MyQWdBZ0JrRUJTdzBBSUFRTkFRc0FDeU1BUVJCcklnSWtBQ0FDSUFFMkFnd2dBaUFBTmdJSUFBdWNBUUVFZnlNQVFZQURheUlDSkFBZ0FpQUFFRjRnQWtHQUFXb2lBU0FBUVlBQmFpSUVFRjRnQWtHQUFtb2lBeUFBRUY0Z0F5QUVFQkVnQWlBRUVKb0JJQUVRZkNBQklBQVFtZ0VnQWhDcEFTQUJFS2tCSUFBZ0FoQ1pBU0FBSUFFUUVTQUJJQU1RbVFFZ0FSQjhJQUVnQXhDYUFTQUJFS2tCSUFFUU5pQUFJQUVRbWdFZ0F4QzRBU0FFSUFNUW1RRWdBQkN3QVNBQ1FZQURhaVFBQzdrQkFRSi9Jd0JCSUdzaUF5UUFBa0FnQVNBQklBSnFJZ0ZMRFFBZ0FFRUVhaWdDQUNJQ1FRRjBJZ1FnQVNBQklBUkpHeUlCUVFnZ0FVRUlTeHNoQVFKQUlBSUVRQ0FEUVJocVFRRTJBZ0FnQXlBQ05nSVVJQU1nQUNnQ0FEWUNFQXdCQ3lBRFFRQTJBaEFMSUFNZ0FTQURRUkJxRUNZZ0F5Z0NBQVJBSUFOQkNHb29BZ0FpQUVVTkFTQURLQUlFSUFBUXp3RUFDeUFES0FJRUlRSWdBRUVFYWlBQk5nSUFJQUFnQWpZQ0FDQURRU0JxSkFBUEN4QmxBQXVzQVFFQ2Z5TUFRWUFEYXlJREpBQWdBMEVJYWlBQkVKQUJBa0FnQWdSQUlBTkJDR29nQWhDdUFRd0JDeUFEUVFocUVEb0xJQU5CeUFCcUlnSkI4TFRBQUJCSklBTkJnQUZxSUFJUWpnRWdBMEhBQVdvaUFpQURRUWhxSWdRUWtBRWdBaEJNSUFJZ0FSQktJQUFnQVJDUUFTQUFJQVFRU2lBRFFZQUNhaUFDRUpBQklBQVFWaUVCSUFOQndBSnFJZ0lnQUJDUUFTQUNFRU1nQWhCQ0lBQWdBaUFCRUhJZ0EwR0FBMm9rQUF1ZUFRRUZmeU1BUVlBQmF5SUNKQUFnQWtFNEVOQUJJZ0pCQVRZQ09DQUNRVUJySWdOQk9CRFFBUm9nQWtFQk5nSjRJQUlnQUJDdUFTQUNJQUZCZ0FGcUlnVVFTaUFESUFFUXJnRWdBeUFBUVlBQmFpSUdFRW9DUUNBQ0lBTVFXRVVOQUNBQ0lBQkJRR3NRcmdFZ0FpQUZFRW9nQWtGQWF5SUFJQUZCUUdzUXJnRWdBQ0FHRUVvZ0FpQUFFRmhGRFFCQkFTRUVDeUFDUVlBQmFpUUFJQVFMcHdFQkEzOGpBRUV3YXlJQ0pBQWdBVUVFYWlFRElBRW9BZ1JGQkVBZ0FTZ0NBQ0VCSUFKQkVHb2lCRUVBTmdJQUlBSkNBVGNEQ0NBQ0lBSkJDR28yQWhRZ0FrRW9haUFCUVJCcUtRSUFOd01BSUFKQklHb2dBVUVJYWlrQ0FEY0RBQ0FDSUFFcEFnQTNBeGdnQWtFVWFpQUNRUmhxRUF3YUlBTkJDR29nQkNnQ0FEWUNBQ0FESUFJcEF3ZzNBZ0FMSUFCQmhMZkFBRFlDQkNBQUlBTTJBZ0FnQWtFd2FpUUFDNVVCQVFKL0FrQUNRQUpBQWtBQ2Z3SkFBa0FDZjBFQklnTWdBVUVBU0EwQUdpQUNLQUlBSWdSRkRRRWdBaWdDQkNJQ0RRUWdBUTBDUVFFTUF3c2hBMEVBSVFFTUJnc2dBUTBBUVFFTUFRc2dBVUVCRUxrQkN5SUNSUTBCREFJTElBUWdBUkNzQVNJQ0RRRUxJQUFnQVRZQ0JFRUJJUUVNQVFzZ0FDQUNOZ0lFUVFBaEF3c2dBQ0FETmdJQUlBQkJDR29nQVRZQ0FBdnZNd0lTZndWK0l3QkJNR3NpRGlRQUlBNUJFR29nQUNBQkVGc2dEaUFPS0FJVUlnQTJBaHdnRGlBT0tBSVFJZ2cyQWhnZ0RrRUlhaUFDSUFNUVd5QU9JQTRvQWd3aUFUWUNKQ0FPSUE0b0FnZ2lBellDSUNBT0lBUWdCUkJiSUE0Z0RpZ0NCQ0lGTmdJc0lBNGdEaWdDQUNJTk5nSW9JQUFoQkNNQVFaQVZheUlDSkFBakFFR3dCbXNpQ2lRQUlBcEJFR3BCT0JEUUFSb2dDa0hRQUdwQk9CRFFBU0VWSUFwQmlBRnFRUUUyQWdBZ0NrRUJOZ0pJSUFwQmtBRnFJZ0JCMktUQUFCQkpJQUFRS2lFUElBcEJ5QUZxSWhOQmdBSVEwQUVhSUFwQnlBTnFRWUFCRU5BQkdpTUFRZEFBYXlJUkpBQWdFVUVRYWtIQUFCRFFBUm9nQVNFSlFRQWhBQ01BUVlBRWF5SUhKQUFnQjBFdmFrR0JBaERRQVJvZ0IwR3dBbXBCd0FBUTBBRWFJQWRCOEFKcVFjQUFFTkFCR2lBSFFiQURha0hBQUJEUUFSb2dCeUFQUWY4QWFrRURka0VCYWlJU1FRRjBJZ0ZCQ0hRZ0FVR0EvZ054UVFoMmNqc0FMQ0FCUVFGclFRVjJRUUZxSVFzQ1FBTkFJQVlnQjJwQkxtb2dBRG9BQUNBR1FTdEdCRUFnQjBFc2FpSUdRUzVxUVNzNkFBQWdCMEVnYWlBR1FTOFFYMEVBSVFBZ0IwR3dBbXBCd0FBZ0F5QUpJQWNvQWlBZ0J5Z0NKQkFHSUFkQkFEb0ErQU1nQnlBTE5nTDBBMEVBSUFGcklSUWdCMEVCTmdMd0F5QUdRU3hxSVJZTUFnc2dCa0dCQWtjRVFDQUdRY0Nsd0FCcUxRQUFJUUFnQmtFQmFpRUdEQUVMQ3lBR1FRTnFRWVFDUWZDcndBQVFPd0FMQTBBQ1FDQUhRUmhxSVFsQkFDRUdRUUFoQ3dKQUlBZEI4QU5xSWdNdEFBZ05BQ0FES0FJQUlnc2dBeWdDQkNJWFN3MEFJQXNnRjA4RVFFRUJJUVlnQTBFQk9nQUlEQUVMUVFFaEJpQURJQXRCQVdvMkFnQUxJQWtnQ3pZQ0JDQUpJQVkyQWdBQ1FDQUhLQUlZQkVBZ0J5Z0NIQ0VEUVFBaEJnTkFJQVpCSUVZRVFDQUhJQU02QUN4QkFDRUdBa0FDUUFOQUlBWkJLMFlFUUNBV1FTczZBQUFqQUVFUWF5SURKQUFnQTBFSWFpQUhRYkFEYWtIQUFFRWdFSUVCSUFNb0Fnd2hDU0FIUVJCcUlnWWdBeWdDQ0RZQ0FDQUdJQWsyQWdRZ0EwRVFhaVFBSUFjb0FoUWhBeUFIS0FJUUlRa2dCMEVJYWlBSFFTeHFRUzBRWDBFQUlRWWdCMEh3QW1wQkFDQUpJQU1nQnlnQ0NDQUhLQUlNRUFaQkFFR0FBaUFBYXlJRElBTkJnQUpMR3lFRElBQWdFMm9oQ1NBQUlCUnFJUXNEUUNBR1FTQkdEUWdnQmtIQUFFWU5CQ0FESUFaR0RRTWdCaUFKYWlBSFFmQUNhaUFHYWkwQUFEb0FBQ0FHUVFGcUlnWWdDMm9OQUFzZ0FTRUFEQWtMSUFaQmd3SkhCRUFnQmlBSGFrRXRhaUFHUWNDbHdBQnFMUUFBT2dBQUlBWkJBV29oQmd3QkN3c2dCa0VCYWtHRUFrR3dyTUFBRURzQUN5QUFJQVpxUVlBQ1FZQ3R3QUFRT3dBTFFjQUFRY0FBUWZDc3dBQVFPd0FMSUFaQndBQkhCRUFnQjBId0Ftb2dCbW9pQ1NBSkxRQUFJQWRCc0FKcUlBWnFMUUFBY3lJSk9nQUFJQWRCc0FOcUlBWnFJQWs2QUFBZ0JrRUJhaUVHREFFTEMwSEFBRUhBQUVHZ3JNQUFFRHNBQ3lBSFFZQUVhaVFBREFFTElBQWdCbW9oQUF3QkN3c2dFVUhRQUdva0FDQVNRUU4wSUE5cklRbEJBQ0VBQWtBQ1FBTkFJQUJCQWtjRVFDQUFRUUZxSUFwQnlBRnFJQkJxSVFaQkFDRURBa0FEUUNBRElCSkdEUUVnQXlBUWFpSUhRZjhCU3cwRUlBTkJnQUZIQkVBZ0NrSElBMm9nQTJvZ0F5QUdhaTBBQURvQUFDQURRUUZxSVFNTUFRc0xRWUFCUVlBQlFhQ2x3QUFRT3dBTEl3QkJFR3NpQXlRQUlBTkJDR29nQ2tISUEycEJnQUVnRWhDQkFTQURLQUlNSVFZZ0NrRUlhaUlISUFNb0FnZzJBZ0FnQnlBR05nSUVJQU5CRUdva0FDQUtLQUlJSVFNZ0NpZ0NEQ0VMSUFwQndBVnFJZzlCOEFBUTBBRWhCZ05BSUFzRVFDQUdRUWdRRlNBR0lBWXBBd0FnQXpFQUFIdzNBd0FnQzBFQmF5RUxJQU5CQVdvaEF3d0JDd3NnQ2tHSUJXb2hFeU1BUWVBQmF5SUxKQUFnRHhCSUlBc2dDa0dRQVdvUUxpQUxRZkFBYWtId0FCRFFBUm9nQ3lBSklnTVFGUU5BSUF0QjhBQnFJUVpCQUNFSEEwQWdCMEh3QUVjRVFDQUdJQWRxSUFjZ0Qyb3BBd0EzQXdBZ0IwRUlhaUVIREFFTEN5QUdJQXNRWXlBR0VFaEJBQ0VIUWdBaEdDQUdLUU1JSUE4cEF3Q0ZJaGxDQVlaQ0FZY2hHMEYvSUFzcEE5Z0JRaitIcDJ1c0lSd0RmaUFIUWZBQVJnUitJQmdGSUFjZ0Qyb2lFU0FSS1FNQUlob2dHWVVnQmlBSGFpa0RBQ0FhaFNBY2c0VWlHaUFiaFRjREFDQVlJQnFGSVJnZ0IwRUlhaUVIREFFTEN4b2dBd1JBUVFBaEJrRUFJUWRCQUNFUkFrQUNRQU5BSUFaQjZBQkdCRUFnQzBIb0FHb2dDeWtEYUVJQmh6Y0RBQ0FMUWZBQWFpRUdBMEFnQjBVTkJDQUdRZ0EzQXdBZ0IwRUJheUVISUFaQkNHb2hCZ3dBQ3dBTElBWkI4QUJHRFFFZ0JrSHdBRWNFUUNBR0lBdHFJaFFnRkVFSWFpa0RBRUk1aGtMLy8vLy8vLy8vL3dPRElCUXBBd0JDQVllRU53TUFJQkZCQVdvaEVTQUdRUWhxSVFZTUFRc0xRUTVCRGtHZ3NzQUFFRHNBQ3lBUlFRNUJrTExBQUJBN0FBc2dBMEVCYXlFRERBRUZJQk1nRHhCZElBdEI0QUZxSkFBTEN5QUtRY2dFYWlJRElCTVFqZ0VnQ2tFUWFpQUFRUVowYWlBRFFjQUFFTkVCR2lBUUlCSnFJUkFoQUF3QkN3c2dBaUFLUVJCcUVBSWdDa0hJQVdvaUFDQVZFQUlnQWlBQUVBa2pBRUdBQW1zaUFDUUFJQUJCQ0dvaUFVSFlnY0FBRUVrZ0FFRkFheUlESUFJZ0FSQzlBU0FDSUFNUWVDQUFRWUFDYWlRQUlBSVFSaUFLUWJBR2FpUUFEQUVMSUFkQmdBSkJrS1hBQUJBN0FBc2dBa0hBQVdvaEFTTUFRZUFDYXlJQUpBQWdBRUV3RU5BQklnQkJNR3BCMElEQUFCQkpBa0FDUUFKQUFrQURRQUpBSUF4Qk1FWUVRQ0FBSUFBdEFBQkJIM0U2QUFBZ0FFSG9BR29nQUJDK0FTQUVEUUZCQUVFQVFaaUJ3QUFRT3dBTElBUWdERVlOQWlBQUlBeHFJQWdnREdvdEFBQTZBQUFnREVFQmFpRU1EQUVMQzBFQUlRd2dDQ3dBQUNJSlFRQklEUUlnQ0VFd2FpRURJQVJCTUNBRVFUQkxHMEV3YXlFSUEwQWdERUV3UmdSQUlBQkJvQUZxSWdRZ0FCQytBU01BUVlBQmF5SURKQUFnQVJCbklBRWdBRUhvQUdvUXdBRWdBVUZBYXlJSUlBUVF3QUVnQVVHQUFXb1F5Z0VnQVJCQ0lBTWdBUkJQSUFOQlFHc2lCQ0FJRUpBQklBUVFUQ0FFSUFNUVdFVUVRQ0FCRUpJQkN5QURRWUFCYWlRQURBVUxJQWdnREVZTkFpQUFJQXhxSUFNZ0RHb3RBQUE2QUFBZ0RFRUJhaUVNREFBTEFBc2dCQ0FFUVlpQndBQVFPd0FMSUF4Qk1Hb2dCRUdvZ2NBQUVEc0FDeU1BUWNBQmF5SURKQUFnQUVHZ0FXb2lCQkJuSUFOQk9CRFFBU0lEUVFFMkFqZ2dCQ0FBUWVnQWFoREFBU0FFRUVJZ0JFR0FBV29ReWdFZ0EwRkFheUlJSUFRUVR3SkFBa0FDUUNBSUlBTVFXa0VCUmdSQUlBTkJnQUZxSWdnZ0EwRkFheUFERUNNZ0NCQldEUUVNQWdzZ0JCQ1NBUXdDQ3lBRFFZQUJhaUlJRUVNZ0NCQkNDeUFFUVVCcklBTkJnQUZxRUs0QkN5QURRY0FCYWlRQUlBbEJJSEVpQTBFQUlBQkI0QUZxRUUwaUJFRUJSeHRCQVNBRElBUkJBVWR5R3dSQUlBQkJvQUZxRUtRQkN5QUJJQUJCb0FGcVFjQUJFTkVCR2dzZ0FFSGdBbW9rQUFKL1FRQWhBeU1BUWNBRmF5SUFKQUFDUUNBQkVJWUJEUUFnQUVFSWFpSUlRWkN0d0FBUVNTQUFRWUFFYWlJRVFiaXV3QUFRU1NBQVFVQnJJZ2tnQkJDT0FTQUFRWUFCYWlJRUVHY2dCQ0FCRUhnZ0JDQUpFRW9nQUVIQUFtb2lCQ0FCSUFnUXZRRWdBU0FFRUNRTkFDQUFRWUFFYWlJRUlBQkJ3QUpxSWdFZ0FFRUlhaEM5QVNBQklBUkJ3QUVRMFFFYUlBRVFwQUVnQUVHQUFXb2dBUkFrUlEwQVFRRWhBd3NnQUVIQUJXb2tBRUYvSUFORkRRQWFJQUpCd0FGcUVLUUJJQUpCZ0FOcUlRaEJBQ0VBSXdCQjRBUnJJZ0VrQUNBQlFlQUFFTkFCSVFFQ1FDQUZCRUFEUUNBQVFlQUFSZ1JBSUFFZ0FTMEFBRUVmY1RvQUFDQUJRZUFBYWlBQkVCOUJBQ0VBQWtBZ0RTd0FBQ0lMUVFCT0JFQWdEVUhnQUdvaEF5QUZRZUFBSUFWQjRBQkxHMEhnQUdzaEJBTkFJQUJCNEFCR0JFQWdBVUhnQVdvaUFDQUJFQjhnQ0NBQlFlQUFhaUFBRUQ4TUF3c2dBQ0FFUndSQUlBQWdBV29nQUNBRGFpMEFBRG9BQUNBQVFRRnFJUUFNQVFzTElBQkI0QUJxSUFWQjFLZkFBQkE3QUFzakFFSEFBV3NpQXlRQUlBRkI0QUZxSWdBUVBTQURRVGdRMEFFaURVRUJOZ0k0SUFBZ0FVSGdBR29RbVFFZ0FFR0FBV29pRHhDM0FTQUFRWUFDYWhDM0FTQUFFS2tCSUExQlFHc2lCQ0FBRURnakFFSEFBV3NpQXlRQUlBTWdCQkJlSUFNUXBBRWdBeUFFRUJFZ0EwR0FBV29pQkNBRFFjQUFFTkVCR2lBRUlBMFFXaUVFSUFOQndBRnFKQUFDUUFKQUFrQWdCRUVCUmdSQUl3QkJ3QU5ySWdBa0FDQU5RVUJySWdRUWlBRkZCRUFnQUNBRVFVQnJJZ2NRa0FFZ0FFRkFheUlESUFRUWtBRWdBRUdBQVdvaUJTQUVFSkFCSUFCQndBRnFJZ1pCT0JEUUFSb2dBRUVCTmdMNEFTQUFRWUFDYWlJS1FUZ1EwQUVhSUFCQkFUWUN1QUlnQUJCTUlBTVFUQ0FBSUFNUWR5QUFFRUlnQUVIQUFtb2lDU0FBSUEwUUl5QURJQWtRcmdFZ0FDQURFSzRCSUFNZ0JCQ3VBU0FESUFBUWR5QURFRUlnQXhBM0lBQWdCeEN1QVNBQUVEY2dBeUFLRUZvaERDQUZJQW9RcmdFZ0JSQkRJQVVRUWlBR0lBTVFyZ0VnQmhCRElBWVFRaUFESUFaQkFTQU1heUlNRUhJZ0NpQUZJQXdRY2lBSklBTWdDaEFqSUFRZ0NSQ3VBU0FGSUFNUXJnRWdCU0FLRURNZ0JTQUVFRW9nQnlBRkVLNEJJQWNnQUJCS0lBWWdCQkN1QVNBRUlBY2dEQkJ5SUFjZ0JpQU1FSElnQkJDSkFTRURJQWtnQkJCZUlBa1FOaUFKRUtrQklBUWdDU0FERUkwQkN5QUFRY0FEYWlRQUlBUVFpUUVOQVF3Q0N5QUFFSnNCREFJTElBMUJRR3NRTmdzZ0RVRkFheUlBRUxVQklBOGdBQkNaQVFzZ0RVSEFBV29rQUVFQUlRQUNRQ0FCUWVBQ2FpSURFSWdCRFFBZ0EwRkFheEJOSWdBTkFDQURFRTBoQUFzZ0MwRWdjU0lEUVFBZ0FFRUJSeUlBRzBFQklBQWdBM0liQkVBZ0FVSGdBV29Rb2dFTElBZ2dBVUhnQVdwQmdBTVEwUUVhQ3lBQlFlQUVhaVFBREFNTElBQWdCVWNFUUNBQUlBRnFJQUFnRFdvdEFBQTZBQUFnQUVFQmFpRUFEQUVMQ3lBRklBVkJ4S2ZBQUJBN0FBdEJBRUVBUWJTbndBQVFPd0FMSXdCQndBZHJJZzBrQUNBTlFjQUJhaUlEUWNpdHdBQVFTU0FOUWNBRWFpSUZRWUN1d0FBUVNTQU5RUWhxSWdFZ0F5QUZFRXNnQVJBK0lBRVFxUUVnRFVHSUFXb2lDVUdRcmNBQUVFa2dBeEE5SUFNZ0NCQjlJd0JCZ0FGcklnQWtBQ0FBSUFFUVhpQUFFQzBnQXhDa0FTQURRWUFCYWlJRUVLUUJJQU5CZ0FKcUlnWVFwQUVnQmhDMUFTQURJQUFRRVNBRUlBQVFFU0FFSUFFUUVTQUFRWUFCYWlRQVFRQWhCQ01BUWZBMmF5SUFKQUFnQUVFNEVOQUJJZ0ZCT0dwQk9CRFFBUm9nQVVId0FHb1FQU0FCUWZBRGFoQTlJQUZCOEFacUVEMENRQUpBSUFnUWlnRkZCRUFnQVVId0lXb2lCaEE5SUFGQjhDUnFJZ2NRUFNBQlFmQW5haUlLRUQwZ0FVSHdLbW9pREJBOUlBRkI4QzFxSWdzUVBTQUJRZkF3YWlJUEVEMGdBVUh3TTJvaUFCQTlJQUZCOEI1cUVEMGdBVUh3Q1dvaUVDQUdRWUFERU5FQkdpQUJRZkFNYWlBSFFZQURFTkVCR2lBQlFmQVBhaUFLUVlBREVORUJHaUFCUWZBU2FpQU1RWUFERU5FQkdpQUJRZkFWYWlBTFFZQURFTkVCR2lBQlFmQVlhaUFQUVlBREVORUJHaUFCUWZBYmFpQUFRWUFERU5FQkdpQUFRZWNBRU5BQkdpQUJRZkFEYWlJQUlBZ1FmU0FBRUJJZ0VDQUlFSDBNQVFzZ0JTQUJRZkFBYWtHQUF4RFJBUm9NQVFzRFFDQUVRWUFWUndSQUlBRkI4QVpxSWdBZ0FVSHdDV29nQkdvaUJoQjlJQVpCZ0FOcUlnWWdBQkI5SUFZZ0FVSHdBMm9RQ0NBRVFZQURhaUVFREFFTEN5QUJRVGhxSWdBZ0NSQnFJQUVwQXpnaEdDQUFRUUVRa3dFZ0FCQkNJQUVwQXpnaEdTQUJJQUFRYWlBQlFRRVFrd0VnQVJCQ0lBQWdBU0FZUWdLQnB4QXdJQUZCOEFOcUlnUWdDQ0FaUWdLQnB4QnZJQUZCOEFacUlBUVFmU0FBRUNwQkEyb2lCa0VDZGlJQVFRRnFJUWhCQUNFRUFrQUNRQU5BSUFGQk9HcEJCUkNQQVNFSklBUWdDRVlFUUNBR1FaZ0RUdzBDSUFGQjhETnFJQWhxSUFrNkFBQWdBVUh3QUdvZ0FVSHdDV29nQ1VFWWRFRVlkUkFRREFNTElBUkI1d0JIQkVBZ0FVSHdNMm9nQkdvZ0NVRVFheUlIT2dBQUlBRkJPR29pQ1NBSFFSaDBRUmgxRUpRQklBa1FRaUFKUVFRUUxDQUVRUUZxSVFRTUFRc0xRZWNBUWVjQVFhQ293QUFRT3dBTElBaEI1d0JCc0tqQUFCQTdBQXNEUUNBQVFYOUhCRUFnQVVId0Eyb2lDQ0FCUWZBSmFpQUJRZkF6YWlBQWFpd0FBQkFRSUFCQkFXc2hBQ0FCUWZBQWFpSUVFQklnQkJBU0lBUVFFaUFFRUJJZ0JDQUlFQWdNQVFzTEl3QkJnQU5ySWdBa0FDQUFFRDBnQUNBQlFmQUdhaEI5SUFBUW9nRWdBVUh3QUdvaUJDQUFFQWdnQUVHQUEyb2tBQ0FGSUFSQmdBTVEwUUVhQ3lBQlFmQTJhaVFBSUFVUW9nRWpBRUdBQW1zaUFDUUFJQUFnQXhCZUlBQkJnQUZxSWdFZ0JSQmVJQUFnQlVHQUFtb2lCQkFSSUFFZ0EwR0FBbW9pQ0JBUkFuOENRQ0FBSUFFUWVnUkFJQUFnQTBHQUFXb1FtUUVnQUNBRUVCRWdBRUdBQVdvaUFTQUZRWUFCYWhDWkFTQUJJQWdRRVNBQUlBRVFlZzBCQzBFQURBRUxRUUVMSVFFZ0FFR0FBbW9rQUNBTlFjQUhhaVFBUVg4Z0FVVU5BQm9qQUVIZ0Eyc2lBQ1FBSUFCQmdBRnFJZ0ZCd0tqQUFCQkpJQUJCdUFGcUlnTkIrS2pBQUJCSklBQWdBU0FERUVzZ0FFSHdBbW9pQVVHd3FjQUFFRWtnQUVHb0Eyb2lBMEhvcWNBQUVFa2dBRUh3QVdvaUJDQUJJQU1RU3lBQ1FZQUdhaUlCSUFBZ0JCQS9JQUJCNEFOcUpBQWdBa0dBQ1dvaEJ5QUNRWUFEYWlFSUl3QkJrRFJySWdBa0FDQUFRWUFvYWlJRFFjaXR3QUFRU1NBQVFZZ3VhaUlFUVlDdXdBQVFTU0FBSUFNZ0JCQkxJQUJCZ0FGcVFUZ1EwQUVhSUFCQnVBRnFRVGdRMEFFYUlBQkI4QUZxRUQwQ1FDQUNRY0FCYWlJRUVJWUJSUVJBSUFJUWhnRUVRQ0FISUFFZ0JCQU9EQUlMSUFCQjhBUnFJZ01RUFNBRElBRVFmU0FERUVjZ0FFSHdCMm9pQlJCbklBVWdCQkI0SUFVUVJpQUFRYkFKYWlJRUVEMGdCQ0FJRUgwZ0JCQkhJQUJCc0F4cUlnZ1FaeUFJSUFJUWVDQUlFRVlnQUVHSUxtb2lBU0FGRUpBQklBQkI4QTFxSUFFUWtBRWdBU0FBUWJBSWFoQ1FBU0FBUWJBT2FpQUJFSkFCSUFFZ0NCQ1FBU0FBUWZBT2FpQUJFSkFCSUFFZ0FFSHdER29Ra0FFZ0FFR3dEMm9nQVJDUUFTQUFRZkFQYWlJQkVEMGdBRUh3RW1vaUJSQTlJQUJCOEJWcUVGVWdBU0FERUgwZ0JTQUVFSDBnQUVINEcyb2lBUkE5SUFFZ0F4QjlJQUVRb2dFZ0FFSDRIbW9pQVJBOUlBRWdCQkI5SUFFUW9nRWdBRUc0QVdvZ0FFR0FBV29RVUVFQ2F5RUJBMEFnQVVFQmFrRUJUUVJBSUFCQjhCVnFJZ0VRbmdFZ0J5QUJRWWdHRU5FQkdnd0RCU0FBUWZBVmFpSUVFQm9nQUVINElXb2lBeUFBUWZBUGFpQUFRZkFOYWlBQVFiQU9haEFMSUFCQmdDaHFJZ1VnQUVId0Vtb2dBRUh3RG1vZ0FFR3dEMm9RQ3lBRElBVVFBeUFFSUFNUUFRSkFBa0FDUUNBQVFiZ0JhaUFCRUZNZ0FFR0FBV29nQVJCVGEwRUJhZzREQVFJQUFnc2dBRUdJTG1vaUF5QUFRZkFQYWlBQVFmQUVhaUFBUWZBTmFpQUFRYkFPYWhBS0lBQkIrQ0ZxSWdRZ0EwR0lCaERSQVJvZ0F5QUFRZkFTYWlBQVFiQUphaUFBUWZBT2FpQUFRYkFQYWhBS0lBUWdBeEFESUFCQjhCVnFJQVFRQVF3QkN5QUFRWWd1YWlJRElBQkI4QTlxSUFCQitCdHFJQUJCOEExcUlBQkJzQTVxRUFvZ0FFSDRJV29pQkNBRFFZZ0dFTkVCR2lBRElBQkI4QkpxSUFCQitCNXFJQUJCOEE1cUlBQkJzQTlxRUFvZ0JDQURFQU1nQUVId0ZXb2dCQkFCQ3lBQlFRRnJJUUVNQVFzQUN3QUxJQWNnQ0NBQ0VBNExJQUJCa0RScUpBQWpBRUhnSDJzaUNDUUFJQWhCMEJOcUlnRkJ5SzNBQUJCSklBaEIyQmxxSWcxQmdLN0FBQkJKSUFnZ0FTQU5FRXNnQ0VHQUFXb2lDMEdRcmNBQUVFa2dBa0dJRDJvaUFDQUhFR2tnQ0VHNEFXb2lCU0FBRUdrakFFR0FDR3NpQXlRQUlBTWdCUkNNQVNBRFFZQUNhaUlKSUFWQmdBSnFJZzhRakFFZ0EwR0FCR29pQ2lBRkVJd0JJQU5CZ0FacUlnUkJPQkRRQVJvZ0EwRUJOZ0s0QmlBRFFjQUdha0U0RU5BQkdpQURRZmdHYWtFQk5nSUFJQU5CZ0FkcVFUZ1EwQUVhSUFOQnVBZHFRUUUyQWdBZ0EwSEFCMnBCT0JEUUFSb2dBMEg0QjJwQkFUWUNBQ0FGRUowQklBTVFJU0FKSUFWQmdBUnFJZ3dRR0NBSkVHUWdBeUFKRUhrZ0F4Q3dBU0FKSUF3UWxnRWdDUkFoSUFrUVpDQUtJQThRR0NBSklBb1FlU0FKRUxBQklBb2dEeENXQVNBS0VDRWdCQ0FGRUpZQklBUWdEQkFZSUFvZ0JCQjVJQW9Rc0FFZ0JDQVBFSllCSUFRZ0NoQVlJQVFRWkNBRklBTVFHQ0FFSUFVUWx3RWdEQ0FKRUJnZ0RCQmtJQVFnREJDWEFTQUVFTEFCSXdCQmdBSnJJZ1lrQUNBR0lBUVFYaUFHUVlBQmFpSVFJQVJCZ0FGcUloSVFYaUFHRUMwZ0VCQXRJQkFRZkNBUUVLa0JJQVlnRUJCN0lBWVFQaUFFSUFZUUVTQUdFRFlnQmhDcEFTQVNJQVlRRVNBR1FZQUNhaVFBSUFVZ0F4Q1dBU0FGSUFRUUdDQVBJQWtRbGdFZ0R5QUVFQmdnRENBS0VKWUJJQXdnQkJBWUlBVkJCVFlDZ0FZZ0EwR0FDR29rQUNBQUVKNEJJQUFnQlJBSElBVWdBQkJ0SUFBZ0NCQXlJQUFnQ0JBeUlBQWdCUkFISUFoQndBZHFJZ1FnQUJCcElBUVFFeUFFSUFBUUJ5QU5JQUFnQ3hBYklBaEJ5QTFxSWdNZ0RSQnBJQU1RbmdFZ0FTQUFFR2tnQVJDZUFTQUFJQU1RYlNBQUlBRVFCeUFOSUFBZ0N4QWJJQU1nRFJCdElBTVFuZ0VnQVNBQUVHMGdBUkNlQVNBQUlBTVFiU0FBSUFFUUJ5QU5JQUFnQ3hBYklBTWdEUkJ0SUFNUW5nRWdBU0FBRUcwZ0FTQUlFRElnQUNBREVHMGdBQ0FCRUFjZ0RTQUFJQXNRR3lBRElBMFFiU0FOSUFNZ0N4QWJJQU1nRFJCdElBRWdBQkJ0SUFFZ0NCQXlJQUVnQ0JBeUlBTWdBUkFISUFFZ0FCQnRJQUVRbmdFZ0FDQURFRzBnQUNBQkVBY2dBQ0FFRUFjZ0FCQ2NBU0FJUWVBZmFpUUFJQWNnQUVHSUJoRFJBUnBCQUNFQUl3QkJnQUpySWdFa0FDQUJFR3dDUUNBSElBRVFlZ1IvSUFkQmdBRnFJQUZCZ0FGcUVIb0ZRUUFMUlEwQUlBZEJnQUpxRUljQlJRMEFJQWRCZ0FScUVJY0JJUUFMSUFGQmdBSnFKQUJCQUNBQURRQWFRWDhMSUFKQmtCVnFKQUFnRGtFb2FoQzBBU0FPUVNCcUVMUUJJQTVCR0dvUXRBRWdEa0V3YWlRQUM1OEJBZ0ovQlg0Z0FFRXdhaUlDS1FNQUlBRkJQM0d0SWdTR0lRVWdBQ2tES0NJR1FUb2dBV3RCUDNHdElnaUhJUWRCQmlFQkEzOGdBaUFGSUFlRU53TUFJQUZCQVUwRWZ5QUFJQUFwQXdBZ0JJWkMvLy8vLy8vLy8vOERnemNEQUNBQUtRTXdRaVNIcHdVZ0FVRUJheUVCSUFKQkVHc2lBMEVJYWlFQ0lBWWdCSVpDLy8vLy8vLy8vLzhEZ3lFSElBTXBBd0FpQmlBSWh5RUZEQUVMQ3hvTGlBRUNBMzREZnlNQVFSQnJJZ1VrQUFOK0lBWkJPRVlFZmlBRlFSQnFKQUFnQXdVZ0JTQUFJQVpxSWdjcEF3QWlBaUFDUWorSElBR3NJZ0lnQWtJL2h4QXZJQWNnQlNrREFDSUVJQU44SWdKQy8vLy8vLy8vLy84RGd6Y0RBQ0FDSUFSVXJTQUZRUWhxS1FNQUlBTkNQNGQ4ZkVJR2hpQUNRanFJaENFRElBWkJDR29oQmd3QkN3c0xpZ0VDQTM4QmZpTUFRVUJxSWdJa0FDQUNRUWhxSWdFZ0FCQmRJQUVRUWlBQ1FUaHFJUUZCQmlFRFFkd0NJUUFDUUFKQUEwQWdBMEVBVGdSQUlBRXBBd0FpQkVJQVVnMENJQUZCQ0dzaEFTQUFRVHBySVFBZ0EwRUJheUVEREFFTEMwRUFJUUFNQVFzRFFDQUVVQTBCSUFCQkFXb2hBQ0FFUWdKL0lRUU1BQXNBQ3lBQ1FVQnJKQUFnQUF1SEFRRURmeU1BUVlBQ2F5SUJKQUFnQUJDd0FTQUJJQUFRWGlBQlFZQUJhaUlDUVRnUTBBRWFJQUZCQVRZQ3VBRWdBVUhBQVdwQk9CRFFBUm9nQVVINEFXcEJBVFlDQUNBQklBQkJnQUZxSWdNUW1nRWdBUkEySUFJZ0FSQ1pBU0FDSUFNUW1nRWdBeUFCRUprQklBTWdBQkNhQVNBQUlBSVFtUUVnQUJDd0FTQUJRWUFDYWlRQUMzMENCSDRCZnlBQlFUOXhyU0VDUVRvZ0FXdEJQM0d0SVFSQkFDRUJJQUFwQXdBaUJTRURBMzhnQVVFd1JnUi9JQUFnQUNrRE1DQUNoemNETUNBRlFuOGdBb1pDZjRXRHB3VWdBQ0FCYWlJR0lBTWdBb2NnQmtFSWFpa0RBQ0lESUFTR1F2Ly8vLy8vLy8vL0E0T0VOd01BSUFGQkNHb2hBUXdCQ3dzYUMya0JCSDhqQUVIQUFXc2lBU1FBSUFFZ0FCQ1FBU0FCUVVCcklnSWdBQkNRQVNBQlFZQUJhaUlESUFCQlFHc2lCQkNRQVNBQklBUVFkeUFDSUFBUWR5QUNFRUlnQkNBQ0VFb2dBeEJESUFBZ0F4QjNJQUVRUWlBQUVFSWdBQ0FCRUVvZ0FVSEFBV29rQUF1Q0FRSUJmd0YrSUFCQjhBQVEwQUVoQUFOQUlBSkJPRVlFUUFKQUlBQWdBU2tETUNJRFFqcUhOd000SUFBZ0EwTC8vLy8vLy8vLy93T0ROd013SUFCQlFHc2hBRUVBSVFJRFFDQUNRVEJHRFFFZ0FDQUNha0lBTndNQUlBSkJDR29oQWd3QUN3QUxCU0FBSUFKcUlBRWdBbW9wQXdBM0F3QWdBa0VJYWlFQ0RBRUxDd3R1QVFaK0lBQWdBMEwvLy8vL0Q0TWlCU0FCUXYvLy8vOFBneUlHZmlJSElBVWdBVUlnaUNJSWZpSUpJQVlnQTBJZ2lDSUdmbndpQlVJZ2hud2lDamNEQUNBQUlBY2dDbGF0SUFZZ0NINGdCU0FKVksxQ0lJWWdCVUlnaUlSOGZDQUJJQVIrSUFJZ0EzNThmRGNEQ0F0cUFnRi9CWDRnQVNrRENDQUFLUU1BaFNJR1FnR0dRZ0dISVFkQkFDQUNhNndoQ0FOK0lBTkJPRVlFZmlBRkJTQUFJQU5xSWdJZ0Fpa0RBQ0lFSUFhRklBRWdBMm9wQXdBZ0JJVWdDSU9GSWdRZ0I0VTNBd0FnQkNBRmhTRUZJQU5CQ0dvaEF3d0JDd3NhQzE4Q0FYOEVma0lCSVFOQk1DRUNBMzhnQWtGNFJnUi9JQVJDQVlZZ0EzeW5RUUZyQlNBQklBSnFLUU1BSWdVZ0FDQUNhaWtEQUNJR2ZVSTZoeUFEZ3lBRWhDRUVJQUpCQ0dzaEFpQUZJQWFGUWdGOVFqcUhJQU9ESVFNTUFRc0xDMmtCQkg4akFFR0FBbXNpQWlRQUlBSWdBUkJlSUFKQmdBRnFJZ01nQVJCZUlBSVFMU0FESUFJUUVTQUFJQU1RbUFFZ0FFR0FBbW9pQkNBREVKZ0JJQUJCZ0FScUlnVWdBeENZQVNBRUlBRVFwZ0VnQlNBQ0VLWUJJQUJCQlRZQ2dBWWdBa0dBQW1va0FBdGlBUUovSXdCQlFHb2lBaVFBSUFBUVFpQUNJQUFRa0FFQ1FDQUJCRUFnQUNBQkVLNEJEQUVMSUFBUU9ndEJBQ0VCQTBBZ0EwVUVRQ0FBRUV4QkFTQUJRUUZxSUFGQkFVWWlBeHNoQVF3QkN3c2dBQ0FDRUVvZ0FCQWVJQUpCUUdza0FBdG5BUUovSXdCQlFHb2lBeVFBQWtBZ0FTQUJRUjkxSWdKcUlBSnpJZ0lnQUNnQ09HeEJnSUNBRUU0RVFDQURJQUlRT1NBQUlBTVFTZ3dCQ3lBQUlBSVFLUm9nQUNBQUtBSTRJQUpzTmdJNEN5QUJRUUJJQkVBZ0FCQkRJQUFRUWdzZ0EwRkFheVFBQzJjQUlBQkJBWFlnQUhJaUFFRUNkaUFBY2lJQVFRUjJJQUJ5SWdCQkNIWWdBSElpQUVFUWRpQUFjaUlBSUFCQkFYWkIxYXJWcWdWeGF5SUFRUUoyUWJQbXpKa0RjU0FBUWJQbXpKa0RjV29pQUVFRWRpQUFha0dQbnJ6NEFIRkJnWUtFQ0d4QkdIWUxZUUVEZnlNQVFZQUJheUlCSkFBZ0FTQUFFSkFCSUFGQlFHc2lBa0U0RU5BQkdpQUJRUUUyQW5nZ0FTQUFRVUJySWdNUWR5QUJFRU1nQWlBQkVLNEJJQUlnQXhCM0lBTWdBUkN1QVNBRElBQVFkeUFBSUFJUXJnRWdBVUdBQVdva0FBdFZBZ0ovQVg0akFFSHdBR3NpQVNRQUlBRkJ3TExBQUJCSklBQXBBd0FoQXlBQlFUaHFJZ0lnQUJCZElBQkJBUkFzSUFJZ0FSQmdJQUlRUWlBQ1FRRVFMQ0FBSUFJZ0EwSUNnYWNRTUNBQlFmQUFhaVFBQzVnQkFRWi9Jd0JCd0FGcklnTWtBQ0FBSUFFUVhpQUFFQzBnQTBHSUFXb2lCa0hvcDhBQUVFa2pBRUZBYWlJRUpBQWdBMEVJYWlJQ1FUZ1EwQUVpQlVFQk5nSTRJQVZCUUd0Qk9CRFFBU0FGUWZnQWFrRUJOZ0lBSUFRZ0JoQ09BU0FGSUFRUXJnRVF3UUVnQkVGQWF5UUFJQUlRcVFFZ0FoQjhJQUlRcVFFZ0FDQUJFQkVnQUNBQ0VKb0JJQUFRdFFFZ0EwSEFBV29rQUF0WkFRSi9Jd0JCUUdvaUF5UUFJQUJCT0JEUUFTSUFRUUUyQWpnQ1FDQUJRUUJPQkVBZ0FDQUJFSk1CREFFTElBTkJDR29pQWtIQXNzQUFFRWtnQWlBQkVKTUJJQUlRUWlBQUlBSVFhZ3NnQUJCVUlBTkJRR3NrQUF1OUNBRUtmeU1BUVlBQmF5SUhKQUFnQjBFSWFpSURRY0N5d0FBUVNTQURRUUVRbEFFQ1FBSkFBMEFnQVVFd1JnUkFJQU5CTUdvZ0F5a0RNRUlCaHpjREFDQURRVGhxSVFFRFFDQUNSUTBFSUFGQ0FEY0RBQ0FDUVFGcklRSWdBVUVJYWlFQkRBQUxBQXNnQVVFNFJnMEJJQUZCT0VjRVFDQUJJQU5xSUFFZ0Eyb2lCRUVJYWlrREFFSTVoa0wvLy8vLy8vLy8vd09ESUFRcEF3QkNBWWVFTndNQUlBVkJBV29oQlNBQlFRaHFJUUVNQVFzTFFRZEJCMEdFbThBQUVEc0FDeUFGUVFkQjlKckFBQkE3QUFzZ0EwRUJFSlFCSUFOQkFSQXNJQWRCUUdzaEJVRUFJUUlqQUVHZ0Ntc2lBU1FBSUFGQk9CRFFBU0lCUVVCclFUZ1EwQUVoQmlBQlFZQUJha0U0RU5BQkdpQUJRY0FCYWtFNEVOQUJHaUFCUVlBQ2FrRTRFTkFCR2lBQlFjQUNha0U0RU5BQkdpQUJRWUFEYWtFNEVOQUJHaUFCUWNBRGFrRTRFTkFCR2lBQlFZQUVha0U0RU5BQkdpQUJRY0FFYWtFNEVOQUJHaUFCUVlBRmFrRTRFTkFCR2lBQlFjQUZha0U0RU5BQkdpQUJRWUFHYWtFNEVOQUJHaUFCUWNBR2FrRTRFTkFCR2lBQlFZQUhha0U0RU5BQkdpQUJRY0FIYWtFNEVOQUJHaUFCUWZnSGFrRUJOZ0lBSUFGQnVBZHFRUUUyQWdBZ0FVSDRCbXBCQVRZQ0FDQUJRYmdHYWtFQk5nSUFJQUZCK0FWcVFRRTJBZ0FnQVVHNEJXcEJBVFlDQUNBQlFmZ0Vha0VCTmdJQUlBRkJ1QVJxUVFFMkFnQWdBVUg0QTJwQkFUWUNBQ0FCUWJnRGFrRUJOZ0lBSUFGQitBSnFRUUUyQWdBZ0FVRzRBbXBCQVRZQ0FDQUJRZmdCYWtFQk5nSUFJQUZCdUFGcVFRRTJBZ0FnQVVINEFHcEJBVFlDQUNBQlFRRTJBamdnQVVHQkNHcEI1d0FRMEFFYUlBRkI2QWhxSWdRZ0FCQ1FBU0FFRUVJZ0FVR29DV29pQkNBREVGMGdCQkJDSUFRUUtrRURhaUlJUVFKMklnTkJBV29oQ1FKQUEwQWdBaUFKUmdSQUlBRVF5Z0VnQmlBQlFlZ0lhaEN1QVNBQlFlQUpha0U0RU5BQkdpQUJRUUUyQXBnS1FZQjVJUUlNQWdzZ0FVR29DV29pQkNBRVFRUVFqd0VpQ2hDVUFTQUVFRUlnQWtIbkFFY0VRQ0FCUVlFSWFpQUNhaUFLT2dBQUlBRkJxQWxxUVFRUUxDQUNRUUZxSVFJTUFRc0xRZWNBUWVjQVFhQzB3QUFRT3dBTEEwQWdBZ1JBSUFGQjRBbHFJZ1FnQVNBQ2FpSUdRY0FIYWhDdUFTQUdRWUFJYWlJR0lBUVFyZ0VnQmlBQlFlZ0lhaEJLSUFKQlFHc2hBZ3dCQ3dzQ1FBSkFBa0FDUUNBSVFad0RTUVJBSUFGQmdRaHFJQU5xTEFBQUlnSkJFRThOQVNBRklBRWdBa0VHZEdvUWtBRWdBMEVCYXlJQ1FlWUFTeUVFQTBBZ0FrRi9SZzBESUFVUVRDQUZFRXdnQlJCTUlBVVFUQ0FFRFFRZ0FVR0JDR29nQW1vdEFBQWlBMEVRU1FSQUlBVWdBU0FEUVFaMGFoQktJQUpCQVdzaEFnd0JDd3NnQTBFWWRFRVlkVUVRUWVDMHdBQVFPd0FMSUFOQjV3QkJzTFRBQUJBN0FBc2dBa0VRUWNDMHdBQVFPd0FMSUFVUUhpQUJRYUFLYWlRQURBRUxJQUpCNXdCQjBMVEFBQkE3QUFzZ0FDQUZFSzRCSUFkQmdBRnFKQUFMYkFFQmZ5TUFRVEJySWdNa0FDQURJQUUyQWdRZ0F5QUFOZ0lBSUFOQkhHcEJBallDQUNBRFFTeHFRUUUyQWdBZ0EwSUNOd0lNSUFOQjJMakFBRFlDQ0NBRFFRRTJBaVFnQXlBRFFTQnFOZ0lZSUFNZ0F6WUNLQ0FESUFOQkJHbzJBaUFnQTBFSWFpQUNFR1lBQzJVQkFuOGdBQ0FBS0FJQUlnSkJDR29pQXpZQ0FDQUFJQUpCQTNaQlBIRnFRU2hxSWdJZ0FVSC9BWEVnQWlnQ0FFRUlkSEkyQWdBQ1FBSkFJQU5GQkVBZ0FFRUFOZ0lBSUFBZ0FDZ0NCRUVCYWpZQ0JBd0JDeUFEUWY4RGNRMEJDeUFBRUE4TEMxd0FJQUJCT0JEUUFTSUFRUUUyQWpnZ0FFRkFhMEU0RU5BQkdpQUFRZmdBYWtFQk5nSUFJQUJCZ0FGcUVGRWdBRUdBQW1wQk9CRFFBUm9nQUVHNEFtcEJBVFlDQUNBQVFjQUNha0U0RU5BQkdpQUFRZmdDYWtFQk5nSUFDMXNCQTM4akFFR0FBV3NpQVNRQUlBQVFxUUVnQVNBQUVKQUJJQUZCUUdzaUFpQUFRVUJySWdNUWtBRWdBUkJNSUFJUVRDQUJJQUlRZHlBQlFRQVFNeUFBSUFFUVNpQUJFRU1nQVJCQ0lBTWdBUkJLSUFGQmdBRnFKQUFMWVFFQmZ5TUFRWUFDYXlJREpBQWdBQkE5SUFBZ0FSQ1pBU0FBUVlBQmFpSUJJQUlRbVFFZ0FFR0FBbW9RdHdFZ0FCQ3BBU0FESUFBUU9DQURRWUFCYWlJQ0lBRVFYaUFDRUMwZ0FpQURFSHBGQkVBZ0FCQ2JBUXNnQTBHQUFtb2tBQXRVQVFGL0l3QkJJR3NpQWlRQUlBSWdBQ2dDQURZQ0JDQUNRUmhxSUFGQkVHb3BBZ0EzQXdBZ0FrRVFhaUFCUVFocUtRSUFOd01BSUFJZ0FTa0NBRGNEQ0NBQ1FRUnFJQUpCQ0dvUURDQUNRU0JxSkFBTFp3QWpBRUV3YXlJQkpBQkJwTHZBQUMwQUFBUkFJQUZCSEdwQkFUWUNBQ0FCUWdJM0Fnd2dBVUdRdHNBQU5nSUlJQUZCQVRZQ0pDQUJJQUEyQWl3Z0FTQUJRU0JxTmdJWUlBRWdBVUVzYWpZQ0lDQUJRUWhxUWJpMndBQVFaZ0FMSUFGQk1Hb2tBQXRpQWdGK0FuOGdBQ2tEQUNFQkEzNGdBQ0FDYWlJRElBRkMvLy8vLy8vLy8vOERnemNEQUNBQlFqcUhJUUVnQWtFb1JnUitJQUFnQUNrRE1DQUJmQ0lCTndNd0lBRkNKSWNGSUFKQkNHb2hBaUFEUVFocUtRTUFJQUY4SVFFTUFRc0xHZ3Q4QVFWL0l3QkJRR29pQXlRQUlBTkJDR29pQWtIQXNzQUFFRWtnQWlBQUtBSTRRUUZyRURVaUJCQW9BMEFnQVVFNFJ3UkFJQUFnQVdvaUJTQUJJQUpxS1FNQUlBVXBBd0I5TndNQUlBRkJDR29oQVF3QkN3c2dBRUVCSUFSQkFXcDBJZ0kyQWpnZ0FrSC8vLzhQU2dSQUlBQVFIZ3NnQTBGQWF5UUFDM3NCQW44Z0FFRW9haUVDQTBBZ0FVR0FBa1lFUUNBQVF1Zk1wOURXME91enUzODNBZ2dnQUVJQU53SUFJQUJCSUdwQ3E3T1AvSkdqcy9EYkFEY0NBQ0FBUVJocVF2K2t1WWpGa2RxQ20zODNBZ0FnQUVFUWFrTHk1cnZqbzZmOXA2Vi9Od0lBQlNBQklBSnFRUUEyQWdBZ0FVRUVhaUVCREFFTEN3dFVBQ0FBUVRnUTBBRWlBRUVCTmdJNElBQkJRR3RCT0JEUUFSb2dBRUg0QUdwQkFUWUNBQ0FBUVlBQmFrRTRFTkFCR2lBQVFiZ0Jha0VCTmdJQUlBQkJ3QUZxUVRnUTBBRWFJQUJCK0FGcVFRRTJBZ0FMV0FFQ2Z5TUFRVUJxSWdFa0FBSkFJQUFRaGdFTkFDQUJRUUVRT1NBQVFZQUJhaUlDSUFFUVdBMEFJQUpCQUJBeklBQWdBaEJLSUFBUUhpQUFRVUJySWdBZ0FoQktJQUFRSGlBQ0lBRVFyZ0VMSUFGQlFHc2tBQXRaQVFKL0l3QkJnQUZySWdFa0FBSkFJQUFRaWdFTkFDQUJFRkVnQUVHQUFtb2lBaUFCRUhvTkFDQUNFRDRnQUNBQ0VCRWdBQkMxQVNBQVFZQUJhaUlBSUFJUUVTQUFFTFVCSUFJZ0FSQ1pBUXNnQVVHQUFXb2tBQXRiQWdGK0FuOGdBQ2tEQUNFQkEwQWdBQ0FDYWlJRElBRkMvLy8vLy8vLy8vOERnemNEQUNBQlFqcUhJUUVnQWtIZ0FFWUVRQ0FBSUFBcEEyZ2dBWHczQTJnRklBSkJDR29oQWlBRFFRaHFLUU1BSUFGOElRRU1BUXNMQzA4QkFYOGdBRUU0RU5BQkdnSkFBMEFnQWtFSFJ3UkFJQUpCQjBZTkFpQUFJQUVwQXdBM0F3QWdBRUVJYWlFQUlBRkJDR29oQVNBQ1FRRnFJUUlNQVFzTER3dEJCMEVIUWVTYXdBQVFPd0FMVkFFQ2Z5TUFRYkFCYXlJQ0pBQWdBVFFDT0NBQU5BSTRma0wvLy84UFZRUkFJQUFRSGdzZ0FrRUlhaUlESUFBZ0FSQUZJQUpCK0FCcUlnRWdBeEJySUFBZ0FSQnFJQUJCQWpZQ09DQUNRYkFCYWlRQUMxRUJBbjhqQUVGQWFpSURKQUFnQUVFNEVOQUJJZ0JCQVRZQ09DQUFRVUJyUVRnUTBBRWdBRUg0QUdwQkFUWUNBQ0FESUFFUWpnRWdBQ0FERUs0QklBTWdBaENPQVNBREVLNEJJQU5CUUdza0FBdndEQUlSZndoK0l3QkJzQUZySWc4a0FDQUFOQUk0SWhJZ0VuNUMvLy8vRDFZRVFDQUFFQjRMSXdCQjBBRnJJZ0VrQUNBUFFRaHFJZ1pCQ0dwQjBBQVEwQUVhSUFGQndBRnFJQUFwQXdBaUZ5QVhRaitISWhZZ0Z5QVdFQzhnQmlBQktRUEFBU0lTUXYvLy8vLy8vLy8vQTRNM0F3QWdBVUhJQVdvcEF3QWlGVUlHaGlBU1FqcUloQ0VUSUJWQ09vZ2hHQ0FBUVFocUlnd2hEU0FBSVFsQkFTRUtRUUVoQndKQUEwQWdDa0VFUmdSQUlBQkJHR29oQ2lBQVFSQnFJUWtnQUVFb2FpRU1JQUFwQXpBaEYwRUhJUVVnQVVISUFHb2hDd05BSUFWQkMwa0VRQ0FCUVVCcklBVkJBM1FpQ0NBQWFrRXdheWtEQUNJU0lCSkNQNGNnRnlBWFFqK0hJaFlRTHlBRlFRRnFJZzFCQVhZaEJ5QUxLUU1BSVJVZ0FTa0RRQ0VTSUFraEFpQU1JUVFnQlVFRmF5SU9JUU1EUUNBRElBZEpCRUFnQVNBQ0tRTUFJaFFnRkVJL2h5QUVLUU1BSWhRZ0ZFSS9oeEF2SUFFcEF3QWlGQ0FTZkNJU0lCUlVyU0FCUVFocUtRTUFJQlY4ZkNFVklBSkJDR29oQWlBRVFRaHJJUVFnQTBFQmFpRUREQUVMQ3lBR0lBaHFJQkpDQVlZaUZDQVRmQ0lUUXYvLy8vLy8vLy8vQTRNM0F3QWdBVUV3YWlBQUlBNUJBM1JxS1FNQUloa2dHVUkvaHlBWElCWVFMeUFUSUJSVXJTQVZRZ0dHSUJKQ1A0aUVJQmg4ZkNFWUlBVkJCR3NoQXlBRlFRSnFJZ1ZCQVhZaENDQUJRVGhxS1FNQUlSVWdBU2tETUNFU0lBb2hBaUFNSVFRRFFDQURJQWhQQkVBZ0FVRWdhaUFBSUFkQkEzUnFLUU1BSWhZZ0ZrSS9oeUlVSUJZZ0ZCQXZJQVlnRFVFRGRHb2dFa0lCaGlJVUlCaENCb1lnRTBJNmlJUjhJaE1nQVNrRElId2lGa0wvLy8vLy8vLy8vd09ETndNQUlCTWdGbGF0SUFGQktHb3BBd0FnRXlBVVZLMGdGVUlCaGlBU1FqK0loQ0FZUWpxSGZIeDhmQ0lTUWpxSElSZ2dFa0lHaGlBV1FqcUloQ0VUSUFwQkVHb2hDaUFKUVJCcUlRa01Bd1VnQVVFUWFpQUNLUU1BSWhZZ0ZrSS9oeUFFS1FNQUloWWdGa0kvaHhBdklBRXBBeEFpRmlBU2ZDSVNJQlpVclNBQlFSaHFLUU1BSUJWOGZDRVZJQUpCQ0dvaEFpQUVRUWhySVFRZ0EwRUJhaUVEREFFTEFBc0FDd3NnQVVIUUFHb2dGeUFYUWorSEloSWdBQ2tES0NJVklCVkNQNGNRTHlBR0lCTWdBU2tEVUNJV1FnR0dJaFI4SWhWQy8vLy8vLy8vLy84RGd6Y0RXQ0FCUWVBQWFpQVhJQklnRnlBU0VDOGdCaUFVSUJWV3JTQUJRZGdBYWlrREFFSUJoaUFXUWorSWhDQVlmSHdpRjBJR2hpQVZRanFJaENJVklBRXBBMkI4SWhKQy8vLy8vLy8vLy84RGd6Y0RZQ0FHSUJJZ0ZWU3RJQUZCNkFCcUtRTUFJQmRDT29kOGZFSUdoaUFTUWpxSWhEY0RhQ0FCUWRBQmFpUUFEQUlMSUFGQnNBRnFJQUFnQjBFRGRDSU9haWtEQUNJU0lCSkNQNGNnRnlBV0VDOGdCMEVCYWlJUVFRRjJJUkVnQVVHNEFXb3BBd0FoRlNBQktRT3dBU0VTSUFVaEF5QU1JUVFnQ1NFTElBZ2hBZ05BSUFORkJFQWdCaUFPYWlBU1FnR0dJaFFnRTN3aUUwTC8vLy8vLy8vLy93T0ROd01BSUFGQmtBRnFJQUFnRUVFRGRDSU9haWtEQUNJWklCbENQNGNnRnlBV0VDOGdFeUFVVkswZ0ZVSUJoaUFTUWorSWhDQVlmSHdpRWtJNmh5RVlJQkpDQm9ZZ0UwSTZpSVFoRkNBSFFRSnFJUXNnQVVHWUFXb3BBd0FoRlVFQUlRTWdBU2tEa0FFaEVpQU1JUUlnRFNFRUEwQWdBeUFGYWtVRVFDQUJRZkFBYWlBQUlCRkJBM1JxS1FNQUloTWdFMEkvaHlJWklCTWdHUkF2SUFZZ0Rtb2dFa0lCaGlJWklCUjhJaE1nQVNrRGNId2lGRUwvLy8vLy8vLy8vd09ETndNQUlCTWdGRmF0SUFGQitBQnFLUU1BSUJNZ0dWU3RJQlZDQVlZZ0VrSS9pSVFnR0h4OGZId2lFa0k2aHlFWUlCSkNCb1lnRkVJNmlJUWhFeUFOUVJCcUlRMGdCVUVCYWlFRklBbEJFR29oQ1NBSVFRSnFJUWdnQ2tFQmFpRUtJQXNoQnd3RUN5QURJQWRxSWhCQkIwa0VRQ0FCUVlBQmFpQUNLUU1BSWhNZ0UwSS9oeUFFS1FNQUloTWdFMEkvaHhBdklBRXBBNEFCSWhNZ0Vud2lFaUFUVkswZ0FVR0lBV29wQXdBZ0ZYeDhJUlVnQWtFSWFpRUNJQVJCQ0dzaEJDQURRUUZySVFNTUFRc0xJQkJCQjBHRW5NQUFFRHNBQ3lBQ1FRZEpCRUFnQVVHZ0FXb2dCQ2tEQUNJVUlCUkNQNGNnQ3lrREFDSVVJQlJDUDRjUUx5QUJLUU9nQVNJVUlCSjhJaElnRkZTdElBRkJxQUZxS1FNQUlCVjhmQ0VWSUFOQkFXc2hBeUFFUVFocUlRUWdDMEVJYXlFTElBSkJBV3NoQWd3QkN3c0xJQUpCQjBIMG04QUFFRHNBQ3lBUFFmZ0FhaUlDSUFZUWF5QUFJQUlRYWlBQVFRSTJBamdnRDBHd0FXb2tBQXRIQVFKL0l3QkI4QUJySWdFa0FDQUFFSFpGQkVBZ0FVSEFzc0FBRUVrZ0FVRTRhaUlDSUFBUWhBRWdBU0FDRUdFZ0FSQkNJQUlnQVJBeElRSUxJQUZCOEFCcUpBQWdBZ3RQQVFKL0lBSWdBQ2dDQUNJRFFRUnFLQUlBSUFOQkNHb2lCQ2dDQUNJQWEwc0VRQ0FESUFBZ0FoQWlJQVFvQWdBaEFBc2dBeWdDQUNBQWFpQUJJQUlRMFFFYUlBUWdBQ0FDYWpZQ0FFRUFDMHdCQTM4akFFR0FBV3NpQWlRQUlBQWdBUkNRQVNBQUVFd2dBa0hJQUdvaUEwR0FnTUFBRUVrZ0FrRUlhaUlFSUFNUWpnRWdBQ0FCRUVvZ0FDQUVFSGNnQUJBZUlBSkJnQUZxSkFBTFFRRUNmeU1BUVVCcUlnSWtBQ0FDUVFocUlnTkJrSzNBQUJCSklBRWdBeEJxSUFFUVFpQUFJQUVRYWlBQVFRTVFLUm9nQUJCQ0lBQVFLaUFDUVVCckpBQUxSd0VDZnlNQVFVQnFJZ0VrQUNBQVFUZ1EwQUVpQUVFQk5nSTRJQUJCUUd0Qk9CRFFBU0FBUWZnQWFrRUJOZ0lBSUFGQkFSQTVJQUFnQVJDdUFSREJBU0FCUVVCckpBQUxTd0FDUUFKL0lBRkJnSURFQUVjRVFFRUJJQUFvQWhnZ0FTQUFRUnhxS0FJQUtBSVFFUVFBRFFFYUN5QUNEUUZCQUFzUEN5QUFLQUlZSUFKQkFDQUFRUnhxS0FJQUtBSU1FUVVBQzBNQ0FYOEJmaUFCUVRwdUlRSWdBVUdWQTAwRVFDQUFJQUpCQTNScUtRTUFRZ0VnQVVILy93TnhRVHB3clNJRGhvTWdBNGluRHdzZ0FrRUhRYlNid0FBUU93QUxSUUVEZnlNQVFlQUJheUlCSkFBZ0FVSDRzc0FBRUVrZ0FVRTRhaUlDSUFBZ0FSQUZJQUZCcUFGcUlnTWdBaEJySUFBZ0F4QnFJQUJCQWpZQ09DQUJRZUFCYWlRQUMwQUJBWDhqQUVHQUFtc2lBU1FBSUFBUWl3RWdBUkJzSUFBZ0FSQ1dBU0FBUVlBQ2FoQ3hBU0FBUVlBRWFoQ3hBU0FBUVFFMkFvQUdJQUZCZ0FKcUpBQUxQQUlDZndGK0l3QkJnQUZySWdFa0FDQUJRUWhxSWdJZ0FCQ1FBU0FDRUI0Z0FVSElBR29nQWhDRUFTQUJLUU5JSUFGQmdBRnFKQUJDQW9HbkN6d0NBWDhCZmdOL0lBRkJPRVlFZnlBQ1FnRjlRb0NBZ0lDQWdJQ0FCSU5DT29pbkJTQUFJQUZxS1FNQUlBS0VJUUlnQVVFSWFpRUJEQUVMQ3dzNEFRRi9Jd0JCZ0FGcklnSWtBQ0FDSUFBUWtBRWdBa0ZBYXlJQUlBRVFrQUVnQWhBZUlBQVFIaUFDSUFBUU1TQUNRWUFCYWlRQVJRdEhBUUYvSXdCQklHc2lBeVFBSUFOQkZHcEJBRFlDQUNBRFFaUzR3QUEyQWhBZ0EwSUJOd0lFSUFNZ0FUWUNIQ0FESUFBMkFoZ2dBeUFEUVJocU5nSUFJQU1nQWhCbUFBdWtBUUlDZndGK0l3QkJRR29pQWlRQUlBSWdBQkNRQVNBQ0VEb2dBUVJBSUFFZ0FoQ3VBUXNnQWhCTUlBSWdBQkJLSXdCQmdBRnJJZ0VrQUNBQlFRaHFJZ0FnQWhDUUFTQUFFQjRnQVVISUFHb2lBeUFBRUlRQlFRZ2hBQU4vSUFCQk9FWUVmeUFFUWdGOUlBTXBBd0JDQVlWQ0FYMkRRanFJcDBFQmNRVWdBQ0FEYWlrREFDQUVoQ0VFSUFCQkNHb2hBQXdCQ3dzZ0FVR0FBV29rQUNBQ1FVQnJKQUFMeFFNQkJuOGpBRUVnYXlJR0pBQWdCaUFDTmdJWUlBWWdBallDRkNBR0lBRTJBaEFnQmtFUWFpSUNLQUlJSWdFZ0FpZ0NCRWtFUUFKQUl3QkJFR3NpQlNRQUl3QkJJR3NpQkNRQUFrQUNRQ0FCSUFJb0FnUk5CRUFnQkVFSWFpRURBa0FnQWlnQ0JDSUhCRUFnQXlBSE5nSUVJQU5CQ0dwQkFUWUNBQ0FESUFJb0FnQTJBZ0FNQVFzZ0EwRUFOZ0lBQ3dKQUFrQWdCQ2dDQ0NJSUJFQWdCRUVRYWlnQ0FDRURJQVFvQWd3aEJ3SkFBa0FnQVVVRVFFRUJJUU1NQVFzZ0EwRUJSZzBESUFGQkFSQzVBU0lEUlEwQklBTWdDQ0FCRU5FQkdnc2dDQ0FIRUtnQkRBVUxEQUlMSUFWQkFEWUNBQXdFQ3lBSUlBRVFyQUVpQXcwQ0N5QUZJQUUyQWdRZ0JVRUJOZ0lBSUFWQkNHcEJBVFlDQUF3Q0N5QUVRUnhxUVFBMkFnQWdCRUcwbk1BQU5nSVlJQVJDQVRjQ0RDQUVRZGljd0FBMkFnZ2dCRUVJYWtHc25jQUFFR1lBQ3lBQ0lBRTJBZ1FnQWlBRE5nSUFJQVZCQURZQ0FBc2dCRUVnYWlRQUFrQWdCU2dDQUFSQUlBVkJDR29vQWdBaUFFVU5BU0FGS0FJRUlBQVF6d0VBQ3lBRlFSQnFKQUFNQVFzUVpRQUxDeUFHUVFocUlnRWdBaWdDQ0RZQ0JDQUJJQUlvQWdBMkFnQWdBQ0FHS1FNSU53TUFJQVpCSUdva0FBdEdBUUovSUFFb0FnUWhBaUFCS0FJQUlRTkJDRUVFRUxrQklnRkZCRUJCQ0VFRUVNOEJBQXNnQVNBQ05nSUVJQUVnQXpZQ0FDQUFRWlMzd0FBMkFnUWdBQ0FCTmdJQUN6RUJBWDhnQUVFNEVOQUJJUUFEUUNBQ1FUaEhCRUFnQUNBQ2FpQUJJQUpxS1FNQU53TUFJQUpCQ0dvaEFnd0JDd3NMTmdFQmZ5QUFRVGdRMEFFaUFFRUJOZ0k0SUFCQlFHdEJPQkRRQVNBQVFmZ0Fha0VCTmdJQUlBQWdBUkN1QVNBQlFVQnJFSzRCQ3pzQkFYOGpBRUVRYXlJREpBQWdBMEVJYWlBQlFZUUNJQUlRZ1FFZ0F5Z0NEQ0VCSUFBZ0F5Z0NDRFlDQUNBQUlBRTJBZ1FnQTBFUWFpUUFDd3NBSUFBZ0FVRTRFTnNCQ3dzQUlBQWdBVUU0RU53QkN3d0FJQUFnQVVId0FCRGJBUXNNQUNBQUlBRkI4QUFRM0FFTE9RRUNmeU1BUVlBQmF5SUJKQUFnQVNBQVFZQUJhaUlDRUY0Z0FpQUFFSmtCSUFFUWZDQUFJQUVRbVFFZ0FCQ3dBU0FCUVlBQmFpUUFDejhCQVg4akFFRWdheUlBSkFBZ0FFRWNha0VBTmdJQUlBQkJ6TGZBQURZQ0dDQUFRZ0UzQWd3Z0FFSDh0OEFBTmdJSUlBQkJDR3BCaExqQUFCQm1BQXU4QWdFRGZ5TUFRU0JySWdJa0FDQUNRUUU2QUJnZ0FpQUJOZ0lVSUFJZ0FEWUNFQ0FDUVpTNHdBQTJBZ3dnQWtHVXVNQUFOZ0lJSXdCQkVHc2lBQ1FBSUFKQkNHb2lBU2dDRENJQ1JRUkFRY0Mxd0FCQkswSGt0c0FBRUZrQUN5QUJLQUlJSWdSRkJFQkJ3TFhBQUVFclFmUzJ3QUFRV1FBTElBQWdBallDQ0NBQUlBRTJBZ1FnQUNBRU5nSUFJQUFvQWdBaEFTQUFLQUlFSVFJZ0FDZ0NDQ0VFSXdCQkVHc2lBQ1FBSUFGQkZHb29BZ0FoQXdKQUFuOENRQUpBSUFGQkJHb29BZ0FPQWdBQkF3c2dBdzBDUVFBaEFVSEF0Y0FBREFFTElBTU5BU0FCS0FJQUlnTW9BZ1FoQVNBREtBSUFDeUVESUFBZ0FUWUNCQ0FBSUFNMkFnQWdBRUc0dDhBQUlBSW9BZ2dnQkNBQ0xRQVFFQ0FBQ3lBQVFRQTJBZ1FnQUNBQk5nSUFJQUJCcExmQUFDQUNLQUlJSUFRZ0FpMEFFQkFnQUFzd0FDQUFRVGdRMEFFaUFFRUJOZ0k0SUFCQlFHdEJBUkE1SUFCQmdBRnFRVGdRMEFFYUlBQkJ1QUZxUVFFMkFnQUxLd0FDUUNBQVFYeExEUUFnQUVVRVFFRUVEd3NnQUNBQVFYMUpRUUowRUxrQklnQkZEUUFnQUE4TEFBczRBQ0FBRUlzQklBQWdBUkNXQVNBQVFZQUNhaUFCUVlBQ2FoQ1dBU0FBUVlBRWFpQUJRWUFFYWhDV0FTQUFJQUVvQW9BR05nS0FCZ3NvQVFGL0EwQWdBa0U0UndSQUlBQWdBbW9nQVNBQ2Fpa0RBRGNEQUNBQ1FRaHFJUUlNQVFzTEM0UUpBZzEvQ240akFFRkFhaUlMSkFBZ0MwRUlhaUlKUWNDeXdBQVFTU01BUVpBQ2F5SUNKQUFnQUVFd0VOQUJJUW9nQWtIb0FHcEI4QUFRMEFFYUlBSkI0QUZxUVRBUTBBRWFJQW9RY1NBQ0lBRWlEQ2tEQUNJUVF2My84Ly9QLy8vNUFYNUMvLy8vLy8vLy8vOERneUlTTndQWUFTQUNRZGdBYWlBU1FnQWdDU2tEQUNJWElCZENQNGNpR0JBdklCQWdBaWtEV0NJUGZDSVRJQTlVclNBQ1FlQUFhaWtEQUNBUVFqK0hmSHdpRUVJNmh5QUJLUU1JSWc5Q1A0ZDhJQThnRUVJR2hpQVRRanFJaENJVGZDSVFJQk5Vclh3aEQwRUJJUUJDQUNFVEFrQUNRQU5BQWtBZ0FFRUhSZ1JBUVFZaEIwRUFJUWhCQnlFQURBRUxJQUJCQVhZaUFVRUJhaUVHSUFnZ0FXc2hBeUFCUVFOMElnRkJDR29oQkNBSElBRnJJUVVnQWtISUFHb2dDU0FBUVFOMElnMXFLUU1BSWhVZ0ZVSS9oeUlXSUJKQ0FCQXZJQUpCMEFCcUtRTUFJQkFnRUNBVGZDSVJWcTBnRHlBVWZIeDhJQkVnQWlrRFNId2lEeUFSVksxOElSQWdBRUVCYWlFQkEwQWdBQ0FHVFFSQUlBSkIyQUZxSUExcUlBOUMvZi96LzgvLy8va0Jma0wvLy8vLy8vLy8vd09ESWhFM0F3QWdBa0U0YWlBUlFnQWdGeUFZRUM4Z0FrRW9haUFSUWdBZ0ZTQVdFQzhnQWtIb0FHb2dBRUVFZEdvaUFDQUNRVEJxS1FNQUloRTNBd2dnQUNBQ0tRTW9JaFUzQXdBZ0R5QUNLUU00SWhaOElnOGdGbFN0SUFKQlFHc3BBd0FnRUh4OEloQkNPb2NnRENBQlFRTjBhaWtEQUNJV1FqK0hmQ0FXSUJCQ0JvWWdEMEk2aUlRaUQzd2lFQ0FQVksxOElROGdFeUFWZkNJVElCVlVyU0FSSUJSOGZDRVVJQWRCQ0dvaEJ5QUlRUUZxSVFnZ0FTRUFEQU1MSUFOQkIwOE5BeUFDUVJocUlBUWdDV29wQXdBZ0JTQUphaWtEQUgwaUVTQVJRaitISUFKQjJBRnFJZzRnQldvcEF3QWdCQ0FPYWlrREFIMGlFU0FSUWorSEVDOGdBaWtER0NJUklBOThJZzhnRVZTdElBSkJJR29wQXdBZ0VIeDhJUkFnQmtFQmFpRUdJQVJCQ0dvaEJDQUZRUWhySVFVZ0EwRUJheUVEREFBTEFBc0xBMEFDUUFKQUlBQkJEVWNFUUNBSElBQkJBWFlpQm1zaEF5QUlJQVpCQTNRaUFXc2hCQ0FCUVFocUlRVWdEeUFVZkNBUUlCTjhJZzhnRUZTdGZDRVFJQUJCQVdvaEFRTkFJQVpCQlVzTkF5QURRUWRQRFFJZ0FrRUlhaUFGSUFscUtRTUFJQVFnQ1dwQk1Hb3BBd0I5SWhJZ0VrSS9oeUFDSUFScVFZZ0NhaWtEQUNBQ1FkZ0JhaUFGYWlrREFIMGlFaUFTUWorSEVDOGdBaWtEQ0NJU0lBOThJZzhnRWxTdElBSkJFR29wQXdBZ0VIeDhJUkFnQmtFQmFpRUdJQVJCQ0dzaEJDQURRUUZySVFNZ0JVRUlhaUVGREFBTEFBc2dDaUFRUXYvLy8vLy8vLy8vQTRNM0F6QWdBa0dRQW1va0FBd0VDeUFEUVFkQnBKekFBQkE3QUFzZ0FFRURkQ0FLYWtFNGF5QVBRdi8vLy8vLy8vLy9BNE0zQXdBZ0VFSTZoeUFNSUFGQkEzUnFLUU1BSWhKQ1A0ZDhJQklnRUVJR2hpQVBRanFJaENJUGZDSVFJQTlVclh3aER5QVVJQUJCQkhRZ0FtcEJDR29pQUVFSWFpa0RBSDBnRXlBQUtRTUFJaEpVclgwaEZDQUlRUWhxSVFnZ0IwRUJhaUVISUJNZ0VuMGhFeUFCSVFBTUFBc0FDeUFEUVFkQmxKekFBQkE3QUFzZ0MwRkFheVFBQ3k0QkFYOGpBRUdBQVdzaUFTUUFJQUFRUlNBQkVGRWdBQ0FCRUprQklBQkJnQUZxRUxZQklBRkJnQUZxSkFBTE13QWdBQ0FCRUpZQklBQkJnQUpxSUFGQmdBSnFFSllCSUFCQmdBUnFJQUZCZ0FScUVKWUJJQUFnQVNnQ2dBWTJBb0FHQ3lnQUlBQWdBU0FDRUhJZ0FFRkFheUFCUVVCcklBSVFjaUFBUVlBQmFpQUJRWUFCYWlBQ0VISUxMUUFnQUNBQklBSVFqUUVnQUVHQUFXb2dBVUdBQVdvZ0FoQ05BU0FBUVlBQ2FpQUJRWUFDYWlBQ0VJMEJDeWNCQW44akFFRkFhaUlDSkFBZ0FrRUlhaUlESUFFUXZnRWdBQ0FERUk0QklBSkJRR3NrQUFzaUFRRi9BMEFnQVVFNFJ3UkFJQUFnQVdwQ0FEY0RBQ0FCUVFocUlRRU1BUXNMQ3lVQUlBQWdBU0FDRURBZ0FFRUFJQUpySUFBb0FqZ2lBQ0FCS0FJNGMzRWdBSE0yQWpnTEp3QWdBQ0FBS0FJRVFRRnhJQUZ5UVFKeU5nSUVJQUFnQVdvaUFDQUFLQUlFUVFGeU5nSUVDeU1BQTBBZ0FnUkFJQUFnQVMwQUFCQThJQUpCQVdzaEFpQUJRUUZxSVFFTUFRc0xDeXdBSUFBUWl3RWdBQ0FCRUpZQklBQkJnQUpxSUFJUWxnRWdBRUdBQkdvZ0F4Q1dBU0FBUVFVMkFvQUdDeU1CQVg4akFFRkFhaUlCSkFBZ0FTQUFFSkFCSUFFUUhpQUJFRmNnQVVGQWF5UUFDeWtBSUFBZ0FSQmdJQUFnQUNnQ09DQUJLQUk0YWlJQk5nSTRJQUZCLy8vL0Qwb0VRQ0FBRUI0TEN5VUFJQUFnQVJDdUFTQUFRVUJySUFGQlFHc1FyZ0VnQUVHQUFXb2dBVUdBQVdvUXJnRUxLQUVCZnlNQVFZQUNheUlDSkFBZ0FpQUJFSXdCSUFJUUt5QUFJQUlRbHdFZ0FrR0FBbW9rQUFzY0FRRi9JQUFnQVJCWUJIOGdBRUZBYXlBQlFVQnJFRmdGUVFBTEN5Y0JBWDhqQUVHQUFXc2lBaVFBSUFJZ0FSQmVJQUlRTmlBQUlBSVFtZ0VnQWtHQUFXb2tBQXRSQVFOL0l3QkJnQUZySWdFa0FDQUJJQUFRWGlNQVFVQnFJZ0lrQUNBQ0lBQVFrQUVnQUNBQVFVQnJJZ01RcmdFZ0FCQkRJQU1nQWhDdUFTQUNRVUJySkFBZ0FDQUJFSm9CSUFGQmdBRnFKQUFMSndBZ0FDQUJFSmtCSUFCQmdBRnFJQUZCZ0FGcUVKa0JJQUJCZ0FKcUlBRkJnQUpxRUprQkN5VUJBWDhqQUVGQWFpSUNKQUFnQWlBQkVKQUJJQUlRUXlBQUlBSVFkeUFDUVVCckpBQUxIZ0FDUUNBQVFRUnFLQUlBUlEwQUlBQW9BZ0FpQUVVTkFDQUFFQVFMQ3lBQkFYOENRQ0FBS0FJRUlnRkZEUUFnQUVFSWFpZ0NBRVVOQUNBQkVBUUxDNE1CQUNBQ0lBTkpCRUFqQUVFd2F5SUFKQUFnQUNBQ05nSUVJQUFnQXpZQ0FDQUFRUnhxUVFJMkFnQWdBRUVzYWtFQk5nSUFJQUJDQWpjQ0RDQUFRWVM3d0FBMkFnZ2dBRUVCTmdJa0lBQWdBRUVnYWpZQ0dDQUFJQUJCQkdvMkFpZ2dBQ0FBTmdJZ0lBQkJDR3BCbEx2QUFCQm1BQXNnQUNBRE5nSUVJQUFnQVRZQ0FBdElBUUovQTBBZ0FVRTRSd1JBSUFBZ0FXb2lBaUFDS1FNQVFnR0dOd01BSUFGQkNHb2hBUXdCQ3dzZ0FDQUFLQUk0UVFGMElnRTJBamdnQVVILy8vOFBTZ1JBSUFBUUhnc0xJd0FnQWlBQ0tBSUVRWDV4TmdJRUlBQWdBVUVCY2pZQ0JDQUFJQUZxSUFFMkFnQUxJZ0VCZnlNQVFmQUFheUlDSkFBZ0FpQUJFQzRnQUNBQ0VHc2dBa0h3QUdva0FBc2VBQ0FBSUFGQkEzSTJBZ1FnQUNBQmFpSUFJQUFvQWdSQkFYSTJBZ1FMRmdFQmZ5QUFFSFlFZnlBQVFZQUJhaEIyQlVFQUN3c1lBUUYvSUFBUWlBRUVmeUFBUVlBQmFoQ0lBUVZCQUFzTEZRRUJmeUFBRUhZRWZ5QUFRVUJyRUhZRlFRQUxDeG9CQVg4Z0FCQldJZ0VnQUVGQWF4QldJQUZ6SUFBUWRuRnpDeGdCQVg4Z0FCQ0lBUVIvSUFCQmdBSnFFSWdCQlVFQUN3c2VBQ0FBRUVVZ0FFR0FBbW9RUlNBQVFZQUVhaEJGSUFCQkFEWUNnQVlMSEFBZ0FCQkZJQUFnQVJDWkFTQUFRWUFCYWlBQlFZQUJhaENaQVFzWUFDQUFJQUVnQWhCeUlBQkJRR3NnQVVGQWF5QUNFSElMR2dBZ0FFRTRFTkFCSWdCQkFUWUNPQ0FBSUFFUWFpQUFFRlFMRkFBZ0FCQkNJQUFvQWdCQmZ5QUJkRUYvYzNFTEdRQWdBRUU0RU5BQklnQWdBUkJxSUFBZ0FTZ0NPRFlDT0FzWkFRRi9JQUFvQWhBaUFRUi9JQUVGSUFCQkZHb29BZ0FMQ3hnQUlBQVF3UUVnQUVGQWF4REtBU0FBUVlBQmFoREJBUXNVQUNBQUVFSWdBQ0FBS1FNQUlBR3NmRGNEQUFzVUFDQUFFRUlnQUNBQUtRTUFJQUdzZlRjREFBc1lBQ0FBRUVVZ0FDQUJFSmtCSUFCQmdBRnFJQUlRbVFFTEdBQWdBQ0FCRUprQklBQkJnQUZxSUFGQmdBRnFFSmtCQ3hnQUlBQWdBUkNhQVNBQVFZQUJhaUFCUVlBQmFoQ2FBUXNZQUNBQUVLUUJJQUJCZ0FGcUlnQVFwQUVnQUNBQkVCRUxGZ0FnQUNBQkVLNEJJQUJCUUdzZ0FVRkFheEN1QVFzVUFDQUFJQUVRZHlBQVFVQnJJQUZCUUdzUWR3c1pBQ0FBRUxZQklBQkJnQUZxRUxjQklBQkJnQUpxRUxZQkN4a0FJQUFRcndFZ0FFR0FBbW9RcndFZ0FFR0FCR29RcndFTEdRQWdBQkN3QVNBQVFZQUNhaEN3QVNBQVFZQUVhaEN3QVFzWkFDQUFFTElCSUFCQmdBSnFFTWtCSUFCQmdBUnFFTElCQ3hJQVFRQkJHU0FBUVFGMmF5QUFRUjlHR3dzV0FDQUFJQUZCQVhJMkFnUWdBQ0FCYWlBQk5nSUFDeFlBSUFBUVJTQUFJQUVRbVFFZ0FFR0FBV29RdGdFTEZnQWdBRUdBQVdvaUFCQ3BBU0FBRURZZ0FCQ3BBUXNRQUNBQUlBRnFRUUZyUVFBZ0FXdHhDdzhBSUFCQlFHc2lBQkJESUFBUVFnc1VBQ0FBSUFFUW1RRWdBRUdBQVdvZ0FoQ1pBUXNTQUNBQUlBRVFFU0FBUVlBQmFpQUJFQkVMRkFBZ0FDQUJFS29CSUFCQmdBRnFJQUVRcWdFTEN3QWdBUVJBSUFBUUJBc0xEUUFnQUJCQ0lBQkJRR3NRUWdzUkFDQUFJQUVRU2lBQVFVQnJJQUVRU2dzUkFDQUFJQUVRTkNBQVFVQnJJQUVRTkF1K0JRRUhmd0ovQWtBQ1FFR0FnSHhCQ0VFSUVLTUJRUlJCQ0JDakFXcEJFRUVJRUtNQmFtdEJkM0ZCQTJzaUFrRUFRUkJCQ0JDakFVRUNkR3NpQkNBQ0lBUkpHeUFCVFEwQVFSQWdBVUVFYWtFUVFRZ1Fvd0ZCQldzZ0FVc2JRUWdRb3dFaEFpQUFFTlVCSWdRZ0JCRExBU0lGRU5JQklRTUNRQUpBQWtBQ1FBSkFBa0FDUUNBRUVNUUJSUVJBSUFJZ0JVME5BU0FEUWZpK3dBQW9BZ0JHRFFJZ0EwSDB2c0FBS0FJQVJnMERJQU1RdkFFTkJ5QURFTXNCSWdZZ0JXb2lCeUFDU1EwSElBY2dBbXNoQlNBR1FZQUNTUTBFSUFNUUZ3d0ZDeUFFRU1zQklRTWdBa0dBQWtrTkJpQURJQUpyUVlHQUNFa2dBa0VFYWlBRFRYRU5CU0FFS0FJQUdpQUNRUjlxUVlDQUJCQ2pBUm9NQmd0QkVFRUlFS01CSUFVZ0Ftc2lBMHNOQkNBRUlBSVEwZ0VoQlNBRUlBSVFjeUFGSUFNUWN5QUZJQU1RRFF3RUMwSHd2c0FBS0FJQUlBVnFJZ1VnQWswTkJDQUVJQUlRMGdFaEF5QUVJQUlRY3lBRElBVWdBbXNpQWtFQmNqWUNCRUh3dnNBQUlBSTJBZ0JCK0w3QUFDQUROZ0lBREFNTFFleSt3QUFvQWdBZ0JXb2lCU0FDU1EwREFrQkJFRUVJRUtNQklBVWdBbXNpQTBzRVFDQUVJQVVRYzBFQUlRTkJBQ0VGREFFTElBUWdBaERTQVNJRklBTVEwZ0VoQmlBRUlBSVFjeUFGSUFNUW9BRWdCaUFHS0FJRVFYNXhOZ0lFQzBIMHZzQUFJQVUyQWdCQjdMN0FBQ0FETmdJQURBSUxJQU5CREdvb0FnQWlDQ0FEUVFocUtBSUFJZ05IQkVBZ0F5QUlOZ0lNSUFnZ0F6WUNDQXdCQzBIY3U4QUFRZHk3d0FBb0FnQkJmaUFHUVFOMmQzRTJBZ0FMUVJCQkNCQ2pBU0FGVFFSQUlBUWdBaERTQVNFRElBUWdBaEJ6SUFNZ0JSQnpJQU1nQlJBTkRBRUxJQVFnQnhCekN5QUVEUUlMSUFFUUFDSUNSUTBBSUFJZ0FDQUJJQVFReXdGQmVFRjhJQVFReEFFYmFpSUNJQUVnQWtrYkVORUJJQUFRQkF3Q0MwRUFEQUVMSUFRUXhBRWFJQVFRMUFFTEN3OEFJQUJCQVhRaUFFRUFJQUJyY2dzU0FDQUFJQUVRYWlBQUlBRW9BamcyQWpnTEVBQWdBQkMxQVNBQVFZQUJhaEMxQVFzUUFDQUFFS2tCSUFCQmdBRnFFS2tCQ3hBQUlBQVF0Z0VnQUVHQUFXb1F0Z0VMRHdBZ0FFR0FBV29RTmlBQUVMQUJDeEFBSUFBUXVBRWdBRUdBQVdvUXVBRUxEd0FnQUNnQ0FDQUFLQUlFRUtnQkN3MEFJQUFRSGlBQVFVQnJFQjRMRHdBZ0FCREJBU0FBUVVCckVNRUJDdzhBSUFBUXlnRWdBRUZBYXhEQkFRc1BBQ0FBRUlJQklBQkJRR3NRZ2dFTGd3TUJBMzhDZndKQUFrQUNRQUpBSUFGQkNVOEVRRUVRUVFnUW93RWdBVXNOQVF3Q0N5QUFFQUFoQXd3Q0MwRVFRUWdRb3dFaEFRdEJnSUI4UVFoQkNCQ2pBVUVVUVFnUW93RnFRUkJCQ0JDakFXcHJRWGR4UVFOcklnUkJBRUVRUVFnUW93RkJBblJySWdJZ0FpQUVTeHNnQVdzZ0FFME5BQ0FCUVJBZ0FFRUVha0VRUVFnUW93RkJCV3NnQUVzYlFRZ1Fvd0VpQkdwQkVFRUlFS01CYWtFRWF4QUFJZ0pGRFFBZ0FoRFZBU0VBQWtBZ0FVRUJheUlESUFKeFJRUkFJQUFoQVF3QkN5QUNJQU5xUVFBZ0FXdHhFTlVCSVFKQkVFRUlFS01CSVFNZ0FCRExBU0FDUVFBZ0FTQUNJQUJySUFOTEcyb2lBU0FBYXlJQ2F5RURJQUFReEFGRkJFQWdBU0FERUhNZ0FDQUNFSE1nQUNBQ0VBME1BUXNnQUNnQ0FDRUFJQUVnQXpZQ0JDQUJJQUFnQW1vMkFnQUxJQUVReEFFTkFTQUJFTXNCSWdKQkVFRUlFS01CSUFScVRRMEJJQUVnQkJEU0FTRUFJQUVnQkJCeklBQWdBaUFFYXlJRUVITWdBQ0FFRUEwTUFRc2dBd3dCQ3lBQkVOUUJJQUVReEFFYUN3dU9CQUVGZnlBQUtBSUFJUUFqQUVFUWF5SUVKQUFDUUFKL0FrQWdBVUdBQVU4RVFDQUVRUUEyQWd3Z0FVR0FFRThOQVNBRUlBRkJQM0ZCZ0FGeU9nQU5JQVFnQVVFR2RrSEFBWEk2QUF4QkFnd0NDeUFBS0FJSUlnSWdBRUVFYWlnQ0FFWUVRQ01BUVNCcklnTWtBQUpBQWtBZ0FpQUNRUUZxSWdWTERRQWdBRUVFYWlnQ0FDSUNRUUYwSWdZZ0JTQUZJQVpKR3lJRlFRZ2dCVUVJU3hzaEJRSkFJQUlFUUNBRFFSaHFRUUUyQWdBZ0F5QUNOZ0lVSUFNZ0FDZ0NBRFlDRUF3QkN5QURRUUEyQWhBTElBTWdCU0FEUVJCcUVDWWdBeWdDQUFSQUlBTkJDR29vQWdBaUFFVU5BU0FES0FJRUlBQVF6d0VBQ3lBREtBSUVJUUlnQUVFRWFpQUZOZ0lBSUFBZ0FqWUNBQ0FEUVNCcUpBQU1BUXNRWlFBTElBQW9BZ2doQWdzZ0FDQUNRUUZxTmdJSUlBQW9BZ0FnQW1vZ0FUb0FBQXdDQ3lBQlFZQ0FCRThFUUNBRUlBRkJQM0ZCZ0FGeU9nQVBJQVFnQVVFU2RrSHdBWEk2QUF3Z0JDQUJRUVoyUVQ5eFFZQUJjam9BRGlBRUlBRkJESFpCUDNGQmdBRnlPZ0FOUVFRTUFRc2dCQ0FCUVQ5eFFZQUJjam9BRGlBRUlBRkJESFpCNEFGeU9nQU1JQVFnQVVFR2RrRS9jVUdBQVhJNkFBMUJBd3NoQVNBQklBQkJCR29vQWdBZ0FFRUlhaUlES0FJQUlnSnJTd1JBSUFBZ0FpQUJFQ0lnQXlnQ0FDRUNDeUFBS0FJQUlBSnFJQVJCREdvZ0FSRFJBUm9nQXlBQklBSnFOZ0lBQ3lBRVFSQnFKQUJCQUFzVEFDQUFRWlMzd0FBMkFnUWdBQ0FCTmdJQUN3MEFJQUF0QUFSQkFuRkJBWFlMNVFZQ0RIOENmaU1BUWJBY2F5SURKQUFDUUFKQUFrQWdBaEJYRFFBZ0FSQ0dBUTBBSUFOQkNHb1FaeUFEUWNnQmFpSUZJQUlRWFFOQUlBUkJPRWNFUUNBRUlBVnFJZ1lnQmlrREFDQUNJQVJxS1FNQWhEY0RBQ0FFUVFocUlRUU1BUXNMSUFVUUtpRUhRUUFoQkNBRFFZQUNha0U0RU5BQkdpQURRYmdDYWtFNEVOQUJHaUFEUWZBQ2FpSUZFR2NnQTBHd0JHb1FaeUFEUWZBUmFpSUlFR2NnQTBHd0Uyb2lDUkJuSUFOQjhCUnFJZ29RWnlBRFFiQVdhaUlMRUdjZ0EwSHdGMm9pREJCbklBTkJzQmxxSWcwUVp5QURRZkFhYWlJR0VHY2dBMEd3RUdvUVp5QURRZkFGYWlJT0lBaEJ3QUVRMFFFYUlBTkJzQWRxSUFsQndBRVEwUUVhSUFOQjhBaHFJQXBCd0FFUTBRRWFJQU5Cc0FwcUlBdEJ3QUVRMFFFYUlBTkI4QXRxSUF4QndBRVEwUUVhSUFOQnNBMXFJQTFCd0FFUTBRRWFJQU5COEE1cUlBWkJ3QUVRMFFFYUlBWkI1d0FRMEFFYUlBVWdBUkI0SUFVUUZDQU9JQUVRZUF3QkN5QUFFR2NNQVFzRFFDQUVRY0FLUndSQUlBTkJzQVJxSWdVZ0EwSHdCV29nQkdvaUJoQjRJQVpCd0FGcUlnWWdCUkI0SUFZZ0EwSHdBbW9RQ1NBRVFjQUJhaUVFREFFTEN5QURRYmdDYWlJRUlBSVFhaUFES1FPNEFpRVBJQVJCQVJDVEFTQUVFRUlnQXlrRHVBSWhFQ0FEUVlBQ2FpSUNJQVFRYWlBQ1FRRVFrd0VnQWhCQ0lBUWdBaUFQUWdLQnB4QXdJQU5COEFKcUlnUWdBU0FRUWdLQnB4QnVJQWRCQTJvaUJrRUNkaUlCUVFGcUlRSWdBMEd3QkdvZ0JCQjRRUUFoQkFKQUFrQURRQ0FEUWJnQ2FrRUZFSThCSVFVZ0FpQUVSZ1JBSUFaQm1BTlBEUUlnQTBId0dtb2dBbW9nQlRvQUFDQURRUWhxSUFOQjhBVnFJQVZCR0hSQkdIVVFIUXdEQ3lBRVFlY0FSd1JBSUFOQjhCcHFJQVJxSUFWQkVHc2lCem9BQUNBRFFiZ0NhaUlGSUFkQkdIUkJHSFVRbEFFZ0JSQkNJQVZCQkJBc0lBUkJBV29oQkF3QkN3dEI1d0JCNXdCQnVJSEFBQkE3QUFzZ0FrSG5BRUhJZ2NBQUVEc0FDd05BSUFGQmYwY0VRQ0FEUWZBQ2FpSUVJQU5COEFWcUlBTkI4QnBxSUFGcUxBQUFFQjBnQVVFQmF5RUJJQU5CQ0dvaUFoQVVJQUlRRkNBQ0VCUWdBaEFVSUFJZ0JCQUpEQUVMQ3lNQVFjQUJheUlCSkFBZ0FSQm5JQUVnQTBHd0JHb1FlQ0FCRUtRQklBTkJDR29pQWlBQkVBa2dBVUhBQVdva0FDQUFJQUpCd0FFUTBRRWFDeUFEUWJBY2FpUUFDMUFCQVg4Z0FFRTRFTkFCSVFBQ1FBTkFJQUpCTUVZTkFTQUFRUWdRS0NBQ1FUQkhCRUFnQUNBQUtRTUFJQUVnQW1veEFBQjhOd01BSUFKQkFXb2hBZ3dCQ3dzZ0FrRXdRYVNid0FBUU93QUxDdzBBSUFBUU5pQUFJQUVRbWdFTERBQWdBQ0FCRUdvZ0FCQlVDdzBBSUFBUWNTQUFRUUUyQWpnTERBQWdBQkJESUFBZ0FSQjNDd29BUVFBZ0FHc2dBSEVMQ3dBZ0FDMEFCRUVEY1VVTERBQWdBQ0FCUVFOeU5nSUVDdzBBSUFBb0FnQWdBQ2dDQkdvTERnQWdBQ2dDQUJvRFFBd0FDd0FMZ1FnQ0NYOENmaUFBTlFJQUlRc2pBRUV3YXlJR0pBQkJKeUVBQWtBZ0MwS1F6Z0JVQkVBZ0N5RU1EQUVMQTBBZ0JrRUphaUFBYWlJQ1FRUnJJQXNnQzBLUXpnQ0FJZ3hDa000QWZuMm5JZ05CLy84RGNVSGtBRzRpQkVFQmRFSG91TUFBYWk4QUFEc0FBQ0FDUVFKcklBTWdCRUhrQUd4clFmLy9BM0ZCQVhSQjZMakFBR292QUFBN0FBQWdBRUVFYXlFQUlBdEMvOEhYTDFZZ0RDRUxEUUFMQ3lBTXB5SUNRZU1BU3dSQUlBQkJBbXNpQUNBR1FRbHFhaUFNcHlJQ0lBSkIvLzhEY1VIa0FHNGlBa0hrQUd4clFmLy9BM0ZCQVhSQjZMakFBR292QUFBN0FBQUxBa0FnQWtFS1R3UkFJQUJCQW1zaUFDQUdRUWxxYWlBQ1FRRjBRZWk0d0FCcUx3QUFPd0FBREFFTElBQkJBV3NpQUNBR1FRbHFhaUFDUVRCcU9nQUFDd0ovSUFaQkNXb2dBR29oQ0VFclFZQ0F4QUFnQVNnQ0FDSURRUUZ4SWdJYklRUWdBa0VuSUFCcklnbHFJUUpCbExqQUFFRUFJQU5CQkhFYklRVUNRQUpBSUFFb0FnaEZCRUJCQVNFQUlBRWdCQ0FGRUZJTkFRd0NDd0pBQWtBQ1FBSkFJQUlnQVVFTWFpZ0NBQ0lEU1FSQUlBRXRBQUJCQ0hFTkJFRUFJUUFnQXlBQ2F5SUNJUU5CQVNBQkxRQWdJZ2NnQjBFRFJodEJBM0ZCQVdzT0FnRUNBd3RCQVNFQUlBRWdCQ0FGRUZJTkJBd0ZDMEVBSVFNZ0FpRUFEQUVMSUFKQkFYWWhBQ0FDUVFGcVFRRjJJUU1MSUFCQkFXb2hBQ0FCUVJ4cUtBSUFJUWNnQVNnQ0JDRUNJQUVvQWhnaENnSkFBMEFnQUVFQmF5SUFSUTBCSUFvZ0FpQUhLQUlRRVFRQVJRMEFDMEVCREFRTFFRRWhBQ0FDUVlDQXhBQkdEUUVnQVNBRUlBVVFVZzBCSUFFb0FoZ2dDQ0FKSUFFb0Fod29BZ3dSQlFBTkFTQUJLQUljSVFRZ0FTZ0NHQ0VCUVFBaEFBSi9BMEFnQXlBQUlBTkdEUUVhSUFCQkFXb2hBQ0FCSUFJZ0JDZ0NFQkVFQUVVTkFBc2dBRUVCYXdzZ0Ewa2hBQXdCQ3lBQktBSUVJUWNnQVVFd05nSUVJQUV0QUNBaENrRUJJUUFnQVVFQk9nQWdJQUVnQkNBRkVGSU5BRUVBSVFBZ0F5QUNheUlDSVFNQ1FBSkFBa0JCQVNBQkxRQWdJZ1FnQkVFRFJodEJBM0ZCQVdzT0FnQUJBZ3RCQUNFRElBSWhBQXdCQ3lBQ1FRRjJJUUFnQWtFQmFrRUJkaUVEQ3lBQVFRRnFJUUFnQVVFY2FpZ0NBQ0VDSUFFb0FnUWhCQ0FCS0FJWUlRVUNRQU5BSUFCQkFXc2lBRVVOQVNBRklBUWdBaWdDRUJFRUFFVU5BQXRCQVF3REMwRUJJUUFnQkVHQWdNUUFSZzBBSUFFb0FoZ2dDQ0FKSUFFb0Fod29BZ3dSQlFBTkFDQUJLQUljSVFBZ0FTZ0NHQ0VGUVFBaEFnSkFBMEFnQWlBRFJnMEJJQUpCQVdvaEFpQUZJQVFnQUNnQ0VCRUVBRVVOQUF0QkFTRUFJQUpCQVdzZ0Ewa05BUXNnQVNBS09nQWdJQUVnQnpZQ0JFRUFEQUlMSUFBTUFRc2dBU2dDR0NBSUlBa2dBVUVjYWlnQ0FDZ0NEQkVGQUFzZ0JrRXdhaVFBQ3dzQUlBQVFOaUFBRUxBQkN5c0NBWDhCZmtJQklRSURRQ0FBSUFGcUlBSTNBd0JDQUNFQ0lBRkJDR29pQVVFNFJ3MEFDeUFBRUZRTENnQWdBQ2dDQkVGNGNRc0tBQ0FBS0FJRVFRRnhDd29BSUFBb0FneEJBWEVMQ2dBZ0FDZ0NERUVCZGdzWkFDQUFJQUZCeUx2QUFDZ0NBQ0lBUVFJZ0FCc1JBQUFBQzU4QkFRTi9Ba0FnQVNJQ1FROU5CRUFnQUNFQkRBRUxJQUJCQUNBQWEwRURjU0lFYWlFRElBUUVRQ0FBSVFFRFFDQUJRUUE2QUFBZ0FVRUJhaUlCSUFOSkRRQUxDeUFESUFJZ0JHc2lBa0Y4Y1NJRWFpRUJJQVJCQUVvRVFBTkFJQU5CQURZQ0FDQURRUVJxSWdNZ0FVa05BQXNMSUFKQkEzRWhBZ3NnQWdSQUlBRWdBbW9oQWdOQUlBRkJBRG9BQUNBQlFRRnFJZ0VnQWtrTkFBc0xJQUFMdUFJQkIzOENRQ0FDSWdSQkQwMEVRQ0FBSVFJTUFRc2dBRUVBSUFCclFRTnhJZ05xSVFVZ0F3UkFJQUFoQWlBQklRWURRQ0FDSUFZdEFBQTZBQUFnQmtFQmFpRUdJQUpCQVdvaUFpQUZTUTBBQ3dzZ0JTQUVJQU5ySWdoQmZIRWlCMm9oQWdKQUlBRWdBMm9pQTBFRGNRUkFJQWRCQUV3TkFTQURRUU4wSWdSQkdIRWhDU0FEUVh4eElnWkJCR29oQVVFQUlBUnJRUmh4SVFRZ0JpZ0NBQ0VHQTBBZ0JTQUdJQWwySUFFb0FnQWlCaUFFZEhJMkFnQWdBVUVFYWlFQklBVkJCR29pQlNBQ1NRMEFDd3dCQ3lBSFFRQk1EUUFnQXlFQkEwQWdCU0FCS0FJQU5nSUFJQUZCQkdvaEFTQUZRUVJxSWdVZ0Fra05BQXNMSUFoQkEzRWhCQ0FESUFkcUlRRUxJQVFFUUNBQ0lBUnFJUU1EUUNBQ0lBRXRBQUE2QUFBZ0FVRUJhaUVCSUFKQkFXb2lBaUFEU1EwQUN3c2dBQXNIQUNBQUlBRnFDd2NBSUFBZ0FXc0xCd0FnQUVFSWFnc0hBQ0FBUVFockN3UUFRUUFMRFFCQzBvR2Mzc0hGL08rb2Z3c05BRUtMNU9lVjhyaVAxN2gvQ3cwQVF1N3U1OXZNcjVIbzVnQUxBd0FCQ3pBQkFuOERRQ0FESUFKSEJFQWdBQ0FEYWlJRUlBUXBBd0FnQVNBRGFpa0RBSHczQXdBZ0EwRUlhaUVEREFFTEN3c3dBUUovQTBBZ0F5QUNSd1JBSUFBZ0Eyb2lCQ0FFS1FNQUlBRWdBMm9wQXdCOU53TUFJQU5CQ0dvaEF3d0JDd3NMQy9rNUJ3QkJnSURBQUFzQkJBQkJ1SURBQUF1cEFYTnlZeTlpYkhNeE1qTTRNUzlsWTNBdWNuTUFBQUFBQUt1cS8vLy8vLzRCN3YvL1ZLei8vd0xxUVdJUGF3OHFBY09jL1VvVXpoTUNTM2RrMTZ4TFF3THQ2Y2FTcHZsZkFxTWVFYUFCQUFBQU9BQVFBQk1BQUFET0FRQUFGZ0FBQURnQUVBQVRBQUFBMGdFQUFCRUFBQUE0QUJBQUV3QUFBTlFCQUFBYUFBQUFPQUFRQUJNQUFBQjBCQUFBRVFBQUFEZ0FFQUFUQUFBQWVRUUFBQTBBQUFBQkFBRUFBQUFCQWpRQVFaQ0N3QUFMMlNVZFRGZ3RDQ2owQU5kZlBqaG80OXNBaWNrYWlQMnVnUUdpWTZPYXVROU9BWmpxc0lKSmJja0NnRTVhejFBNjdnQ0thVVFCQUFBQUFPQXJGNDdwU013QmRLazZXNHhXeUFDaVZlODE3L3dVQU9lQ3dnRTl5Y01Ed1JZZ08rNCtkUUM2eEdJQURDQmFBTkVJS1M0QkFBQUF1Q0hvdldJUXhRRGYvaFdYTzBpbEFZc0lNZndEMUwwQnV4SDhKelJTMGdNZDhCTGFHOWVqQVNvOXpqYmRMOXNDeUdKMEh3QUFBQUFwMHFLTExycklBZXBIVHBNdDRNWUNKSXkyeGlTODhRTUNqL0RlSUl2NEFaM1hNVDN1N1lFRGlLVkhMNXlEaVFOSXdnaHVBQUFBQUh2N0JSWS8zMmNDTW5zWEN1UEgzUUpwYjRZVU93QTJBeXRVVy83aG1YY0R6SDM2RFZ0VzBnRUNPN2FjK0lGekFnZmFJUU1CQUFBQW5ndzV2bWNRSkFOZjNza0F0OHRDQWpINnQ3RkxyMHNCakoxbGNqSG9BQUxMTHQwaWp4TmRBZFFOZ3d2eDZmTUM0Zml4YVFFQUFBQVg0NWVFYXBoeEFWdWwwNjJsZktVQSt1UWRYWXlTYkFFV2k5SlZmWjZ6QVhVN3hBMlp2bU1CelN6a0h2SGphUUlmejlPQUFBQUFBSTdJOE9NWVZzc0E1MnNkUFRJKzhnR2JNMU1uRCs5aUFBdWF4alp0bmF3QzVXMDFVMzRSMFFBaERoMjYrUFpxQUhEbmdYc0JBQUFBaE8wNW9TWHkxd0czc2t0Qk1FcVVBTnFvc29hY2p5RUNJMENHTXo0OG1RQ0dGYkcvVXVhS0E3REpqVnBLRS9rRFUyWHQxZ0FBQUFDREtXVnZ4c0VUQVhOR3o3bHlTOE1CQ0FyNWFINEp1UUpPZTI3bVNXWDNBYkU4MjdWS3AvY0RCa2gwd1AvRVhBTlFNZ3hqQVFBQUFObVZpS3pwVEJVQkZQR2RCOHdiaWdLRmljSDZnbG0yQXJzaC9PeGZTV2dCbWR1WlZJNFI1QU1zclpEWkVIMW1BS01tbCtrQUFBQUFZV2liSFdTSXN3SHhaQnpFT0plNEFUTTFDRE1ibnlnRHpNYVgvRGFxbFFIazlkY1NWT1VIQTNTQ2dkTnRHL01EWm5HT2R3RUFBQUN3M0o2c25aOFhBUGluWElKS2p3OERXTWtsanNZZVVBTGpvWlVQWnFYTUFTUUR6aHVhQ3RFQk1SSkVCenVlWFFMYkJVRFZBQUFBQUx1RHk3UHg3alFBdXRVd3hyeXBQQUtEdElZZURjY3pBcGZWWHhDcXZXd0I1eGQ4SEtoSElRS3NMbUxCeStwUUFqN3RsSElCQUFBQXQwbEdjMklXckFLclc0dTVmTFV3QUdHRkxFN2JiTFVEaWNsL0FWeUxJZ0krTUd1RkZaalpBUWRFQWk3UXpLQURzZklGR2dFQUFBQUszZXhvMFlSakFRdEFHZDdTa3RNQk1WbkJNWStYTXdGOTI5MUEzMXU2QTdTQzlvQm1wYk1DajF2YkViVktlZ0tyRS95VkFBQUFBRUhXb1hrNjdIWURFZHlRN3Fxa21RQTRVSU9ZODJmYUFFRFFyZG1FeFhVQWpYL2d6S1BIcndIUGdxU1g0Rk5wQTJyUERxRUFBQUFBWGxyTXZadlo5d0hFdEhoRUoxSnVBZnFBeFNLWTN4d0NXMmFnb2lsdkNBTmpmMjZaQWM5MEFHejlMSXdzS2xrRHFjSjZTZ0VBQUFBNlN1aHVTWFFsQURzYmVNUGoxT3dBcDg3cDdTb0djd0M0T0NXR1RyMW1BbGNQVnlGbldlQURHSVBQUTRaTldnRFBxaXgzQUFBQUFLVUVZNStpK1MwQWNNU2pDUEdTTkFCQTk0S0pTL0xPQXc0cE5MVnlPcWNETlZjNTZjWUdCUVBmUTA1VjdwazVBWTVmTmVjQUFBQUFIcUl5TlZzNW5RTlVCMTdOQitxbUFMMnBiVEE3ZzA0QXJUWHVpb0dFWmdISDMvOTlvT2REQTFmSG13SXFSWW9BSUJhT09nRUFBQURZTE1hTmsrZ05Bd1J4UGJzUFNiVUJsd1Q5MWlpOGlnSXlVMFdWeFZyOEFDUUlXMVRyUUh3RCs2c09zcis0WWdFYVdDVTBBQUFBQUJrK3VGeTZPY0lBUDdjL0paOGw5QUJxemVxc0VRdmdBSm55UnpQR2FiMEJRWWx2SDVueXZ3R0srVTJnbDhqb0FlVXZscklBQUFBQS96c3J5RzRueUFGNXVna3NHeUdxQWoxeDlZdkVpQ1VBbXdRd0FNSXpLQVBvUVhBMk51V1lBa1FjTGRJUVo5VUMzcVZoSlFFQUFBQWNHOUpBK3ZrOEFTWitENDF2b0RVQ1ZTdkdpdndYaGdCV2N1b2liWTB1QWUvVkFXLzYwMHNEaTdrc2htdkdQd05JMWFpTUFBQUFBQVMyeUdtK1ZyUUF3UjBIc0wrZlFBRm1LeHZ3V3FsUEFiZGU1V2haRWo0Q0hSakx0UzdmUWdQT1FxbVQ4OEJEQXVua2ExNEJBQUFBU3lKMVZIRWVhd0xoN1d0ZTJTWkJBTHBHenFlVzAvVUFyR2FqbGFGZkJ3STlaMTc4bzhSSUEzMVdxRURFTTVFRFJaWVNYQUFBQUFBekFaamI5ZFBaQWhDWnlnaEhLK1FEYk14WkJzVFRNZ0taVHdCV01EVWdBRHQ3ZGR3VjQzc0NLd0MvM0theVJ3TktPVm9rQUFBQUFQZ2Vsd3Z3QkV3QmczeUVaR1J3RkFKczhETkdlNEFPQVp3QU84S2EwS2dBc2FkNlJELzFCQUJZUWxWMDV1UUdBTUhLZ3JFQUFBQUFqazBIMEtUSUJ3S3pnVFhSQm4xekFwMGtRL1lSK2VjRHI3a1lDY09yNGdKWk5WTE03ZEwrQTFBd1JxNjN2YzBEQ0tsR2l3RUFBQUF5d1JIUUduRVRBRHEvN284emw4NERHd05obmpnVzVBTmdSUDhrdmJJdEE4c3Z6WlA3UXgwRDQwSi9nMjgwM3dCNTVCT1hBUUFBQURBY2M4cnJxcThEeXB1dVUzY1YzQU96dVVOTkh1M25BV0VhK050clJaNENEQ3JFSTBxaHJRTjVyNDVJYmE5aEFLR251K0VBQUFBQWg2WGJlMWNPTndEWTZJSGhjWUNVQVozbXF3enlvZVlDTFhxd0NYZWVXUUM5T28rN29VMGVBb2duSS9vU21tVURpd0hFbndBQUFBQXArM0FZbzB4ZUFXaE4rcmMvVkpFQkwyUkN5Q1pzMmdBTzlIOWc5NDcvQWdVS0YzVEdwaXdCcjBtbTl4dXV6Z0JUalh5WUFBQUFBUExXNlYrRitHRUJzbGZRZzVHd0hnSjZkUE0wMXNRVEFNVklMUk9HcnlnRHVGdm5QR3Q1SndEMFhiSXM3d2JyQTd5NXNFb0FBQUFBOEtVek5yRTZzZ0dtSEtCV3NzbllBd1BpUkZXdDA4TUJRZG4xM3JhK1VnUFFwM1NncHZDNEFVZDRoSWphMGhnQXBQd0RaZ0VBQUFEYi91ank3TnEyQVJBcUVHUUNOLzRCN3NLdFVSTWkvUU1NNXVGQ09ZL3ZBelpWR2NRcEZhSUMrTk1yMThRLytBUGVQOENNQUFBQUFNdjA1YkIzWERVQ0tYdUhzYWV1RmdEa25jOVJNc0ErQXBJbmNPU3RPK1FDcHlyVVYyZDAyQUpHSFNaZUNBY21BbTQzaGg4QUFBQUE5dUV0eDBEaTN3RHVTQUVzaW9WVUF5WjkyZ0FVdWVRREVnMkxjNHhpV1FQaVVpV1VTVHRxQURMaEtMMlptNlVDdW9iSERBQUFBQUNXeGtFdVd1ZVhBUGd2Nm90bHhGa0JiRTNUZXJZK05BSkJQdlRnUEpXd0Fla2pFb05HKzNZRHRRMUVkUVNXT3dFUWFwazBBUUFBQURPN0I1ZHhSWmdDci9Eb3pxYTdIZ1BRUEQxVVZzbjJBa3F0U0tXaElqa0NFNjBSK3R5QVNRSENSMmNKdUpQb0FvRjgyWkFBQUFBQWowdGpIVHBIRlFBUjRDVk5QRnk5QU1vRm9zcFdZODBETzhsTTRjNkpsd0VQeEhIQkdYZ05BbGNKeVpvUGNMY0JnUjM2NEFBQUFBRDNCdTBtRTl6NkFUUWdNOFZoNzBVQklPU0FKSlFuM3dEU0xRZWZwSnhUQWx0V3YvSjJ6Vk1CUS9laTJNNlR5d0lPUUdBbUFBQUFBTXhGTTFjNHNaa0NSN0JDN3ZqWUFRQXdhYmpaQUpydkFuUDFtUWg4SzJZRFJqTlVsaFJmdEFCUlROancrSjhkQXhTVmE2MEFBQUFBa2hCVzRpbTFoQUtsK3E3Zkd5WmFBbTlSRTNucWpLZ0JQakJLQ3ptL0t3TC9sSDlIRE1WSUFnZExZZjNQUUFjQ2RMYkxyQUFBQUFDb2FvKzZuTFQ0QUFDQndlRFRwM0FCR29kY2FtTnVzd0ZrT2FTWWh1M21BTkJ0bkIyUjBob0FLQVE4VW04QnFRT2VKUzlOQUFBQUFGVS9rYmlMOUc0QWpkZHNTdldvRndKenZFOTk2dWVTQVNGTTdSNzJoSThCOXhZeWtJUksyUU5sZ2FBNmg1dkNBZHBjcFdjQkFBQUFTbDFUVlowOUl3UGFJSkxrN3IzNEF5eUZ0RG0veEZBREZhK0NaTDBha3dNTSsvbkVUTmZSQTFQNWhzWklHTnNBMDQ1c2hnRUFBQURaTG9FVldrSHVBQmk1ZHdBQ2JEMEFraXNUVjJNZy9RRE4rbDgvZmVoN0FUZWs1VzcvcHJzQ2ZqZnZnUHFwandPTDhENXFBUUFBQUZ4M2FoS1pFeG9CVCs3SFlta0Fwd0pmSFFXZ0FNUmJBazEzdmVNek5Pb0QvZXhlUzRMcHJBRE5vZTd3eTNhbUFnaDhBR1lCQUFBQXJMZjVxbjlIeGdLQU9IUHFkMjdqQUo5RXB2WHd0b2NCc3hjSFlrTlZHUU5TQWJlQ01YaXNBcnFaN0dmTHRtRUFsMUtlalFBQUFBQWRBS1VSSXhRNUFuWjd1L1FEZDhVQ0lHcVI3SjM4b0FHN1VNSHVwajE4QXB6Unh0eU5JdmdDUkRJRExQblFGd0dWQnc2K0FBQUFBQlpVWDBTWWJkSUFhdXVsb0xBODJRQW5GL1JxY3A1SUF2WklPRXp6ZG04RHhSWFIwYlR0aVFQdlNJTjg1WlJqQW9jb2ZXc0JBQUFBOG1lL1BiVTRKUUpINGx1K2pUVmZBV2ZLTHMxNTBsMEMxakRFL0xsR1ZRR0Z4SGhYc1k1dUFaK3I2dHVKTnBBQkJqUGZXQUFBQUFBOW9Fa3VMQkQyQWt5TnA5VFlnUWtCaXZjQlBrVnZOUUNFa25KV0U4ZmNBMC9JaGJoSXcwTUFXeStEaGdkSTRBRENkUzJXQVFBQUFNRmpOckJUa2tjQlFCc0lnNzBqMmdCL29PZHl2clV5QWd5N215OWc0cFVEYlJwZzZlclErZ0JRQklhVUxDYW5Bc1BFRW1FQkFBQUFjM0pqTDJKc2N6RXlNemd4TDJKcFp5NXljd0JRRFJBQUV3QUFBRTRBQUFBV0FBQUFVQTBRQUJNQUFBRHRBQUFBR2dBQUFGQU5FQUFUQUFBQTdRQUFBQTBBQUFCUURSQUFFd0FBQU84QUFBQUpBQUFBVUEwUUFCTUFBQUNtQVFBQUZ3QUFBRkFORUFBVEFBQUFMUUlBQUJJQUFBQlFEUkFBRXdBQUFGSURBQUFZQUFBQVVBMFFBQk1BQUFCU0F3QUFJUUFBQUZBTkVBQVRBQUFBWEFNQUFDRUFBQUJRRFJBQUV3QUFBSFVEQUFBWEFBQUFVQTBRQUJNQUFBQitBd0FBRndBQUFGQU5FQUFUQUFBQXdRTUFBQmdBQUFCUURSQUFFd0FBQU04REFBQVlBQUFBVkhKcFpXUWdkRzhnYzJoeWFXNXJJSFJ2SUdFZ2JHRnlaMlZ5SUdOaGNHRmphWFI1TkE0UUFDUUFBQUF2Y25WemRHTXZabVUxWWpFelpEWTRNV1l5TldWbE5qUTNOR0psTWpsa056UTRZelkxWVdSalpEa3haalk1WlM5c2FXSnlZWEo1TDJGc2JHOWpMM055WXk5eVlYZGZkbVZqTG5KellBNFFBRXdBQUFDcEFRQUFDUUFBQUFBQUFBQWlyaWpYbUMrS1FzMWw3eU9SUkRkeEx6dE43TS83d0xXODI0bUJwZHUxNlRpMVNQTmJ3bFk1R2RBRnR2RVI4Vm1iVHhtdnBJSS9raGlCYmRyVlhoeXJRZ0lEbzVpcUI5aStiM0JGQVZ1REVveXk1RTYraFRFazRyVC8xY045REZWdmlYdnlkRjIrY3JHV0ZqditzZDZBTlJMSEphY0czSnVVSm1uUGRQR2J3ZEpLOFo3QmFadms0eVZQT0laSHZ1KzExWXlMeHAzQkQyV2NySGZNb1F3a2RRSXJXVzhzNlMyRDVLWnVxb1IwU3RUN1FiM2NxYkJjdFZNUmc5cUkrWGFyMzJidVVsRSttQkF5dEMxdHhqR29QeUg3bU1nbkE3RGtEdSsreDM5WnY4S1BxRDN6QytER0phY0trMGVScDlWdmdnUGdVV1BLQm5CdURncG5LU2tVL0MvU1JvVUt0eWNteVNaY09DRWJMdTBxeEZyOGJTeE4zN09WblJNTk9GUGVZNitMVkhNS1phaXlkenk3Q21wMjVxN3RSeTdKd29FN05ZSVVoU3h5a21RRDhVeWg2TCtpQVRCQ3ZFdG1HcWlSbC9qUWNJdEx3akMrVkFhalVXekhHRkx2MWhub2t0RVFxV1ZWSkFhWjFpb2djVmVGTlE3MHVORzdNbkNnYWhESTBOSzRGc0drR1ZPclFWRUliRGNlbWV1TzMweDNTQ2VvU0p2aHRieXdOR05heWNXekRCdzV5NHBCNDBxcTJFNXo0Mk4zVDhxY1c2TzRzdGJ6Ynk1by9MTHZYZTZDajNSZ0x4ZERiMk9sZUhLcjhLRVVlTWlFN0Rsa0dnZ0N4NHdvSG1Nait2KytrT205Z3Q3cmJGQ2tGWG5Hc3ZlaitiNHJVM0xqOG5oeHhweGhKdXJPUGlmS0I4TEFJY2U0aHRFZTYrRE4xbjNhNm5qUmJ1NS9UMzMxdW04WGNxcG44QWFtbU1paXhYMWpDcTROK2I0RW1EOFJHMGNjRXpVTGNSdUVmUVFqOVhmYktKTWt4MEI3cThveXZMN0pGUXErbmp4TURSQ2N4R2NkUTdaQ1BzdSsxTVZNS241bC9Kd3BmMW5zK3RZNnEyL0xYeGRZUjBxTUdVUnNtQytLUXBGRU4zSFArOEMxcGR1MTZWdkNWam54RWZGWnBJSS9rdFZlSEt1WXFnZllBVnVERXI2Rk1TVERmUXhWZEYyK2N2Nngzb0NuQnR5YmRQR2J3Y0ZwbStTR1I3N3Z4cDNCRDh5aERDUnZMT2t0cW9SMFN0eXBzRnphaVBsMlVsRSttRzNHTWFqSUp3T3d4Mzladi9NTDRNWkhrYWZWVVdQS0JtY3BLUlNGQ3Jjbk9DRWJMdnh0TEUwVERUaFRWSE1LWmJzS2FuWXV5Y0tCaFN4eWtxSG92NkpMWmhxb2NJdEx3cU5SYk1jWjZKTFJKQWFaMW9VMUR2UndvR29RRnNHa0dRaHNOeDVNZDBnbnRieXdOTE1NSERsS3F0aE9UOHFjVy9OdkxtanVnbzkwYjJPbGVCUjR5SVFJQXNlTSt2KytrT3RzVUtUM28vbSs4bmh4eG5OeVl5OWliSE14TWpNNE1TOWliSE11Y25NQUFBQUFBS3VxLy8vLy8vNEI3di8vVkt6Ly93THFRV0lQYXc4cUFjT2MvVW9VemhNQ1MzZGsxNnhMUXdMdDZjYVNwdmxmQXFNZUVhQUJBQUFBUUJJUUFCTUFBQUJCQUFBQUV3QUFBRUFTRUFBVEFBQUFRUUFBQUEwQUFBQkFFaEFBRXdBQUFFTUFBQUFzQUFBQVFreFRYMU5KUjE5Q1RGTXhNak00TVVjeFgxaE5SRHBUU0VFdE1qVTJYMU5UVjFWZlVrOWZUbFZNWDNOeVl5OWliSE14TWpNNE1TOW1jREl1Y25NQUFPc1NFQUFUQUFBQW13QUFBQklBQUFEckVoQUFFd0FBQUo4QUFBQVNBQUFBYzNKakwySnNjekV5TXpneEwyVmpjREl1Y25NZ0V4QUFGQUFBQUpNQUFBQVZBQUFBSUJNUUFCUUFBQUNVQUFBQUZRQUFBQ0FURUFBVUFBQUFsUUFBQUJVQUFBQWdFeEFBRkFBQUFKWUFBQUFWQUFBQUlCTVFBQlFBQUFDWEFBQUFGUUFBQUNBVEVBQVVBQUFBbUFBQUFCVUFBQUFnRXhBQUZBQUFBSmtBQUFBVkFBQUFJQk1RQUJRQUFBQ2FBQUFBRlFBQUFDQVRFQUFVQUFBQUdRRUFBQkVBQUFBZ0V4QUFGQUFBQUNJQkFBQVdBQUFBSUJNUUFCUUFBQUFvQVFBQUdnQUFBQUFBQUFBRUFFR2dxTUFBQy9rRUlCTVFBQlFBQUFCWEFnQUFEUUFBQUNBVEVBQVVBQUFBWEFJQUFBa0FBQUM0dlNIQnlGYUFBUFg3YmdHcXlRQUR1bkFYUGE1SHRnQkUwUXJzQU9sVEEzcmt4bEVReFMwRFNRR0NTYVRDSXdBdks2b2tBQUFBQUg0ckJGMEZmYXdCK1ZVWDVZUkVQQU0wa3dUMXg3MGJBbW5YYXRpQ1pFSUQwR3RaWlU4bmlBRG9OR3NmMkdlY0FBVzJBajRCQUFBQUFTaTRDSVpVa3dGNG9panJEbk95QWlQSkVnMFdsYVlCQ3JXZFR2Y3lxZ0tiL2EwYU5TN2FBbkZ6TW1PRVc1OEFkMUpkemdBQUFBQytlVi93WHdlcEFtcG9CenZYU2NNQjg3T2E2WEsxS2dIU21ieU9uUmI2QVNnK3k1bUx3aXNBckRTckREUE5xUU1DU214Z0FBQUFBSE55WXk5b2JXRmpMbkp6QUNBVkVBQUxBQUFBZXdBQUFCUUFBQUFnRlJBQUN3QUFBSHNBQUFBTkFBQUFJQlVRQUFzQUFBQi9BQUFBSUFBQUFDQVZFQUFMQUFBQWZ3QUFBQTBBQUFBZ0ZSQUFDd0FBQUlJQUFBQU5BQUFBSUJVUUFBc0FBQUIzQUFBQUZBQUFBQ0FWRUFBTEFBQUFkd0FBQUEwQUFBQUFBQUFBWVhSMFpXMXdkQ0IwYnlCa2FYWnBaR1VnWW5rZ2VtVnlid0FBQUNBVkVBQUxBQUFBUkFFQUFBVUFBQUJJTWtNdFQxWkZVbE5KV2tVdFJGTlVMUUFBQUNBVkVBQUxBQUFBV3dFQUFEWUFBQUFnRlJBQUN3QUFBSEFCQUFBSkFBQUFJQlVRQUFzQUFBQnlBUUFBQlFBQUFDQVZFQUFMQUFBQWRBRUFBRUFBQUFBZ0ZSQUFDd0FBQUhrQkFBQVVBQUFBSUJVUUFBc0FBQUIvQVFBQURRQUFBQ0FWRUFBTEFBQUFnUUVBQUFrQUFBQWdGUkFBQ3dBQUFJTUJBQUF6QUFBQUlCVVFBQXNBQUFDREFRQUFTd0FBQUNBVkVBQUxBQUFBaFFFQUFCUUFBQUFnRlJBQUN3QUFBSVVCQUFBTkFBQUFBQUFCQUFBQUFRSTBBRUhJcmNBQUM1d0J1Rjhqa3UxMUJ3RmpUK0Q1V0UrcEEyZFBuS3RMZUQwQWtldzlmZlh5OUFNRDFnOGZEU3dnQUsxdmpQQ1p3YTRBOER0TmtBRUFBQUR6U3R4dEVvcjNBSXV3SDF0VHNGWURndkxGWXgrWDdBQXlzTC9OSHRzZUFrZWhWTGlmSHlNQ1FIbzZvZ3c0c1FHejRzTVBBQUFBQVA3Ly92Ly8vd0VDaXdDQWd0Z0U5Z0hoaldpSmI3NlRBczUycTk4OXFCMEF4bW02VWM1MjN3UExXY1lYQUVId3JzQUFDK0VFQVFBQUFBQUFBQUNDZ0FBQUFBQUFBSXFBQUFBQUFBQ0FBSUFBZ0FBQUFJQ0xnQUFBQUFBQUFBRUFBSUFBQUFBQWdZQUFnQUFBQUlBSmdBQUFBQUFBZ0lvQUFBQUFBQUFBaUFBQUFBQUFBQUFKZ0FDQUFBQUFBQW9BQUlBQUFBQUFpNEFBZ0FBQUFBQ0xBQUFBQUFBQWdJbUFBQUFBQUFDQUE0QUFBQUFBQUlBQ2dBQUFBQUFBZ0lBQUFBQUFBQUNBQ29BQUFBQUFBQUFLQUFDQUFBQUFnSUdBQUlBQUFBQ0FnSUFBQUFBQUFJQUJBQUNBQUFBQUFBaUFBSUFBQUFDQWMzSmpMM05vWVRNdWNuTUFNQmdRQUFzQUFBQy9BQUFBQ1FBQUFEQVlFQUFMQUFBQTJRQUFBQkFBQUFBQUFBQUFZWFIwWlcxd2RDQjBieUJrYVhacFpHVWdZbmtnZW1WeWJ3QUFBREFZRUFBTEFBQUEzUUFBQUJ3QUFBQXdHQkFBQ3dBQUFOOEFBQUFWQUFBQU1CZ1FBQXNBQUFEcEFBQUFHQUFBQURBWUVBQUxBQUFBNndBQUFCRUFBQUJ6Y21NdllteHpNVEl6T0RFdlpHSnBaeTV5Yzd3WUVBQVVBQUFBWEFBQUFBNEFBQUM4R0JBQUZBQUFBRndBQUFBeUFBQUF2QmdRQUJRQUFBQmZBQUFBT0FBQUFMd1lFQUFVQUFBQVlnQUFBQWtBQUFDOEdCQUFGQUFBQUc0QUFBQVNBQUFBdkJnUUFCUUFBQUJ0QUFBQURRQUFBTHdZRUFBVUFBQUFjQUFBQUFrQUFBQ3Jxdi8vLy8vK0FlNy8vMVNzLy84QzZrRmlEMnNQS2dIRG5QMUtGTTRUQWt0M1pOZXNTME1DN2VuR2txYjVYd0tqSGhHZ0FRQUFBSzczdnRXaE9RWUM2SlBkWW1STUpBSFNMRzVPdFFrdEF0dmxjREcyeEJFQm1XTTIrK2h0aWdPOG5CL3R6eFpQQUN0cXBwNEJBQUFBYzNKakwySnNjekV5TXpneEwyWndMbkp6QUFDd0dSQUFFZ0FBQUhvQkFBQU5BRUhnczhBQUM4RUhZWFIwWlcxd2RDQjBieUJrYVhacFpHVWdZbmtnZW1WeWJ3QUFBQUFBQUFCaGRIUmxiWEIwSUhSdklHUnBkbWxrWlNCM2FYUm9JRzkyWlhKbWJHOTNBTEFaRUFBU0FBQUFEQUlBQUEwQUFBQ3dHUkFBRWdBQUFCZ0NBQUFtQUFBQXNCa1FBQklBQUFBWUFnQUFJd0FBQUxBWkVBQVNBQUFBSGdJQUFCY0FBQUN3R1JBQUVnQUFBQjRDQUFBVUFBQUFxcXIvLy8vLy9nSHUvLzlVclAvL0F1cEJZZzlyRHlvQnc1ejlTaFRPRXdKTGQyVFhyRXREQXUzcHhwS20rVjhDb3g0Um9BRUFBQUFEQUFBQUJBQUFBQVFBQUFBRUFBQUFCUUFBQUFZQUFBQmpZV3hzWldRZ1lFOXdkR2x2YmpvNmRXNTNjbUZ3S0NsZ0lHOXVJR0VnWUU1dmJtVmdJSFpoYkhWbGJXVnRiM0o1SUdGc2JHOWpZWFJwYjI0Z2IyWWdJR0o1ZEdWeklHWmhhV3hsWkFvQUFPc2FFQUFWQUFBQUFCc1FBQTRBQUFCc2FXSnlZWEo1TDNOMFpDOXpjbU12WVd4c2IyTXVjbk1nR3hBQUdBQUFBRWtCQUFBSkFBQUFiR2xpY21GeWVTOXpkR1F2YzNKakwzQmhibWxqYTJsdVp5NXljMGdiRUFBY0FBQUFSZ0lBQUI4QUFBQklHeEFBSEFBQUFFY0NBQUFlQUFBQUJ3QUFBQXdBQUFBRUFBQUFDQUFBQUFNQUFBQUlBQUFBQkFBQUFBa0FBQUFLQUFBQUVBQUFBQVFBQUFBTEFBQUFEQUFBQUFNQUFBQUlBQUFBQkFBQUFBMEFBQUFPQUFBQWJHbGljbUZ5ZVM5aGJHeHZZeTl6Y21NdmNtRjNYM1psWXk1eWMyTmhjR0ZqYVhSNUlHOTJaWEptYkc5M0FBQUE2QnNRQUJFQUFBRE1HeEFBSEFBQUFBVUNBQUFGQUFBQUVBQUFBQUFBQUFBQkFBQUFFUUFBQUdsdVpHVjRJRzkxZENCdlppQmliM1Z1WkhNNklIUm9aU0JzWlc0Z2FYTWdJR0oxZENCMGFHVWdhVzVrWlhnZ2FYTWdBQUFrSEJBQUlBQUFBRVFjRUFBU0FBQUFNREF3TVRBeU1ETXdOREExTURZd056QTRNRGt4TURFeE1USXhNekUwTVRVeE5qRTNNVGd4T1RJd01qRXlNakl6TWpReU5USTJNamN5T0RJNU16QXpNVE15TXpNek5ETTFNell6TnpNNE16azBNRFF4TkRJME16UTBORFUwTmpRM05EZzBPVFV3TlRFMU1qVXpOVFExTlRVMk5UYzFPRFU1TmpBMk1UWXlOak0yTkRZMU5qWTJOelk0TmprM01EY3hOekkzTXpjME56VTNOamMzTnpnM09UZ3dPREU0TWpnek9EUTROVGcyT0RjNE9EZzVPVEE1TVRreU9UTTVORGsxT1RZNU56azRPVGtnYjNWMElHOW1JSEpoYm1kbElHWnZjaUJ6YkdsalpTQnZaaUJzWlc1bmRHZ2diR2xpY21GeWVTOWpiM0psTDNOeVl5OXpiR2xqWlM5cGJtUmxlQzV5YzNKaGJtZGxJR1Z1WkNCcGJtUmxlQ0FBQUFCeEhSQUFFQUFBQURBZEVBQWlBQUFBVWgwUUFCOEFBQUJKQUFBQUJRQjdDWEJ5YjJSMVkyVnljd0lJYkdGdVozVmhaMlVCQkZKMWMzUUFESEJ5YjJObGMzTmxaQzFpZVFNRmNuVnpkR01kTVM0Mk1TNHdJQ2htWlRWaU1UTmtOamdnTWpBeU1pMHdOUzB4T0NrR2QyRnNjblZ6QmpBdU1Ua3VNQXgzWVhOdExXSnBibVJuWlc0U01DNHlMamd4SUNnd05qSmhZVFZtTnpBcGA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YXNtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/lib/esm/vendor/bls/wasm.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/agent/node_modules/buffer/index.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@dfinity/agent/node_modules/buffer/index.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"../../../node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"../../../node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2FnZW50L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLDJEQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hZ2VudC9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzPzlhYmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG5jb25zdCBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICBsZXQgeSA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIGxldCBpbmRleFNpemUgPSAxXG4gIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpXG4gIGlmIChkaXIpIHtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgY29uc3QgcmVzID0gW11cblxuICBsZXQgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgbGV0IGNvZGVQb2ludCA9IG51bGxcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbmNvbnN0IE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICBsZXQgb3V0ID0gJydcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICBsZXQgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIGxldCBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjRcblxuICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdFxuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgaSA9IGJ5dGVMZW5ndGhcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gK1xuICAgIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggK1xuICAgIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICtcbiAgICAobGFzdCA8PCAyNCkgLy8gT3ZlcmZsb3dcblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQoZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0QkUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDddID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA2XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNV0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDRdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyAzXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMl0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDFdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXRdID0gaGlcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSAwXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIGxldCBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fVxuZnVuY3Rpb24gRSAoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7XG4gIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gXG4gICAgICAvLyBBY2Nlc3MgdGhlIHN0YWNrIHRvIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZVxuICAgICAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgICAgIHRoaXMuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIC8vIFJlc2V0IHRoZSBuYW1lIHRvIHRoZSBhY3R1YWwgbmFtZS5cbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgfVxuICB9XG59XG5cbkUoJ0VSUl9CVUZGRVJfT1VUX09GX0JPVU5EUycsXG4gIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgXG4gICAgfVxuXG4gICAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJ1xuICB9LCBSYW5nZUVycm9yKVxuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpXG5FKCdFUlJfT1VUX09GX1JBTkdFJyxcbiAgZnVuY3Rpb24gKHN0ciwgcmFuZ2UsIGlucHV0KSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYFxuICAgIGxldCByZWNlaXZlZCA9IGlucHV0XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9XG4gICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gICAgcmV0dXJuIG1zZ1xuICB9LCBSYW5nZUVycm9yKVxuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cblxuLy8gQ0hFQ0sgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMgKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGlmIChidWZbb2Zmc2V0XSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGggKyAxKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnXG4gICAgbGV0IHJhbmdlXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAzKSB7XG4gICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDh9JHtufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWBcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCd2YWx1ZScsIHJhbmdlLCB2YWx1ZSlcbiAgfVxuICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpXG4gIH1cblxuICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSlcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5jb25zdCBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgbGV0IGNvZGVQb2ludFxuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgbGV0IGMsIGhpLCBsb1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG5jb25zdCBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTZcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/agent/node_modules/buffer/index.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/auth-client/lib/esm/db.js":
/*!****************************************************************!*\
  !*** ../../../node_modules/@dfinity/auth-client/lib/esm/db.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IdbKeyVal: function() { return /* binding */ IdbKeyVal; }\n/* harmony export */ });\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! idb */ \"../../../node_modules/idb/build/index.js\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage */ \"../../../node_modules/@dfinity/auth-client/lib/esm/storage.js\");\n\n\nconst AUTH_DB_NAME = 'auth-client-db';\nconst OBJECT_STORE_NAME = 'ic-keyval';\nconst _openDbStore = async (dbName = AUTH_DB_NAME, storeName = OBJECT_STORE_NAME, version) => {\n    // Clear legacy stored delegations\n    if (_storage__WEBPACK_IMPORTED_MODULE_1__.isBrowser && (localStorage === null || localStorage === void 0 ? void 0 : localStorage.getItem(_storage__WEBPACK_IMPORTED_MODULE_1__.KEY_STORAGE_DELEGATION))) {\n        localStorage.removeItem(_storage__WEBPACK_IMPORTED_MODULE_1__.KEY_STORAGE_DELEGATION);\n        localStorage.removeItem(_storage__WEBPACK_IMPORTED_MODULE_1__.KEY_STORAGE_KEY);\n    }\n    return await (0,idb__WEBPACK_IMPORTED_MODULE_0__.openDB)(dbName, version, {\n        upgrade: database => {\n            database.objectStoreNames;\n            if (database.objectStoreNames.contains(storeName)) {\n                database.clear(storeName);\n            }\n            database.createObjectStore(storeName);\n        },\n    });\n};\nasync function _getValue(db, storeName, key) {\n    return await db.get(storeName, key);\n}\nasync function _setValue(db, storeName, key, value) {\n    return await db.put(storeName, value, key);\n}\nasync function _removeValue(db, storeName, key) {\n    return await db.delete(storeName, key);\n}\n/**\n * Simple Key Value store\n * Defaults to `'auth-client-db'` with an object store of `'ic-keyval'`\n */\nclass IdbKeyVal {\n    // Do not use - instead prefer create\n    constructor(_db, _storeName) {\n        this._db = _db;\n        this._storeName = _storeName;\n    }\n    /**\n     *\n     * @param {DBCreateOptions} options {@link DbCreateOptions}\n     * @param {DBCreateOptions['dbName']} options.dbName name for the indexeddb database\n     * @default\n     * @param {DBCreateOptions['storeName']} options.storeName name for the indexeddb Data Store\n     * @default\n     * @param {DBCreateOptions['version']} options.version version of the database. Increment to safely upgrade\n     * @constructs an {@link IdbKeyVal}\n     */\n    static async create(options) {\n        const { dbName = AUTH_DB_NAME, storeName = OBJECT_STORE_NAME, version = 1 } = options !== null && options !== void 0 ? options : {};\n        const db = await _openDbStore(dbName, storeName, version);\n        return new IdbKeyVal(db, storeName);\n    }\n    /**\n     * Basic setter\n     * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]\n     * @param value value to set\n     * @returns void\n     */\n    async set(key, value) {\n        return await _setValue(this._db, this._storeName, key, value);\n    }\n    /**\n     * Basic getter\n     * Pass in a type T for type safety if you know the type the value will have if it is found\n     * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]\n     * @returns `Promise<T | null>`\n     * @example\n     * await get<string>('exampleKey') -> 'exampleValue'\n     */\n    async get(key) {\n        var _a;\n        return (_a = (await _getValue(this._db, this._storeName, key))) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Remove a key\n     * @param key {@link IDBValidKey}\n     * @returns void\n     */\n    async remove(key) {\n        return await _removeValue(this._db, this._storeName, key);\n    }\n}\n//# sourceMappingURL=db.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2F1dGgtY2xpZW50L2xpYi9lc20vZGIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZCO0FBQ2tEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrQ0FBUyxzRkFBc0YsNERBQXNCO0FBQzdILGdDQUFnQyw0REFBc0I7QUFDdEQsZ0NBQWdDLHFEQUFlO0FBQy9DO0FBQ0EsaUJBQWlCLDJDQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQixTQUFTO0FBQ3pDLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQixvRUFBb0U7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hdXRoLWNsaWVudC9saWIvZXNtL2RiLmpzPzllMGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb3BlbkRCIH0gZnJvbSAnaWRiJztcbmltcG9ydCB7IGlzQnJvd3NlciwgS0VZX1NUT1JBR0VfREVMRUdBVElPTiwgS0VZX1NUT1JBR0VfS0VZIH0gZnJvbSAnLi9zdG9yYWdlJztcbmNvbnN0IEFVVEhfREJfTkFNRSA9ICdhdXRoLWNsaWVudC1kYic7XG5jb25zdCBPQkpFQ1RfU1RPUkVfTkFNRSA9ICdpYy1rZXl2YWwnO1xuY29uc3QgX29wZW5EYlN0b3JlID0gYXN5bmMgKGRiTmFtZSA9IEFVVEhfREJfTkFNRSwgc3RvcmVOYW1lID0gT0JKRUNUX1NUT1JFX05BTUUsIHZlcnNpb24pID0+IHtcbiAgICAvLyBDbGVhciBsZWdhY3kgc3RvcmVkIGRlbGVnYXRpb25zXG4gICAgaWYgKGlzQnJvd3NlciAmJiAobG9jYWxTdG9yYWdlID09PSBudWxsIHx8IGxvY2FsU3RvcmFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9jYWxTdG9yYWdlLmdldEl0ZW0oS0VZX1NUT1JBR0VfREVMRUdBVElPTikpKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKEtFWV9TVE9SQUdFX0RFTEVHQVRJT04pO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShLRVlfU1RPUkFHRV9LRVkpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgb3BlbkRCKGRiTmFtZSwgdmVyc2lvbiwge1xuICAgICAgICB1cGdyYWRlOiBkYXRhYmFzZSA9PiB7XG4gICAgICAgICAgICBkYXRhYmFzZS5vYmplY3RTdG9yZU5hbWVzO1xuICAgICAgICAgICAgaWYgKGRhdGFiYXNlLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoc3RvcmVOYW1lKSkge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlLmNsZWFyKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhYmFzZS5jcmVhdGVPYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xufTtcbmFzeW5jIGZ1bmN0aW9uIF9nZXRWYWx1ZShkYiwgc3RvcmVOYW1lLCBrZXkpIHtcbiAgICByZXR1cm4gYXdhaXQgZGIuZ2V0KHN0b3JlTmFtZSwga2V5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9zZXRWYWx1ZShkYiwgc3RvcmVOYW1lLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGF3YWl0IGRiLnB1dChzdG9yZU5hbWUsIHZhbHVlLCBrZXkpO1xufVxuYXN5bmMgZnVuY3Rpb24gX3JlbW92ZVZhbHVlKGRiLCBzdG9yZU5hbWUsIGtleSkge1xuICAgIHJldHVybiBhd2FpdCBkYi5kZWxldGUoc3RvcmVOYW1lLCBrZXkpO1xufVxuLyoqXG4gKiBTaW1wbGUgS2V5IFZhbHVlIHN0b3JlXG4gKiBEZWZhdWx0cyB0byBgJ2F1dGgtY2xpZW50LWRiJ2Agd2l0aCBhbiBvYmplY3Qgc3RvcmUgb2YgYCdpYy1rZXl2YWwnYFxuICovXG5leHBvcnQgY2xhc3MgSWRiS2V5VmFsIHtcbiAgICAvLyBEbyBub3QgdXNlIC0gaW5zdGVhZCBwcmVmZXIgY3JlYXRlXG4gICAgY29uc3RydWN0b3IoX2RiLCBfc3RvcmVOYW1lKSB7XG4gICAgICAgIHRoaXMuX2RiID0gX2RiO1xuICAgICAgICB0aGlzLl9zdG9yZU5hbWUgPSBfc3RvcmVOYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7REJDcmVhdGVPcHRpb25zfSBvcHRpb25zIHtAbGluayBEYkNyZWF0ZU9wdGlvbnN9XG4gICAgICogQHBhcmFtIHtEQkNyZWF0ZU9wdGlvbnNbJ2RiTmFtZSddfSBvcHRpb25zLmRiTmFtZSBuYW1lIGZvciB0aGUgaW5kZXhlZGRiIGRhdGFiYXNlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge0RCQ3JlYXRlT3B0aW9uc1snc3RvcmVOYW1lJ119IG9wdGlvbnMuc3RvcmVOYW1lIG5hbWUgZm9yIHRoZSBpbmRleGVkZGIgRGF0YSBTdG9yZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHBhcmFtIHtEQkNyZWF0ZU9wdGlvbnNbJ3ZlcnNpb24nXX0gb3B0aW9ucy52ZXJzaW9uIHZlcnNpb24gb2YgdGhlIGRhdGFiYXNlLiBJbmNyZW1lbnQgdG8gc2FmZWx5IHVwZ3JhZGVcbiAgICAgKiBAY29uc3RydWN0cyBhbiB7QGxpbmsgSWRiS2V5VmFsfVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGRiTmFtZSA9IEFVVEhfREJfTkFNRSwgc3RvcmVOYW1lID0gT0JKRUNUX1NUT1JFX05BTUUsIHZlcnNpb24gPSAxIH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCBfb3BlbkRiU3RvcmUoZGJOYW1lLCBzdG9yZU5hbWUsIHZlcnNpb24pO1xuICAgICAgICByZXR1cm4gbmV3IElkYktleVZhbChkYiwgc3RvcmVOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFzaWMgc2V0dGVyXG4gICAgICogQHBhcmFtIHtJREJWYWxpZEtleX0ga2V5IHN0cmluZyB8IG51bWJlciB8IERhdGUgfCBCdWZmZXJTb3VyY2UgfCBJREJWYWxpZEtleVtdXG4gICAgICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIHNldFxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBhc3luYyBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgX3NldFZhbHVlKHRoaXMuX2RiLCB0aGlzLl9zdG9yZU5hbWUsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNpYyBnZXR0ZXJcbiAgICAgKiBQYXNzIGluIGEgdHlwZSBUIGZvciB0eXBlIHNhZmV0eSBpZiB5b3Uga25vdyB0aGUgdHlwZSB0aGUgdmFsdWUgd2lsbCBoYXZlIGlmIGl0IGlzIGZvdW5kXG4gICAgICogQHBhcmFtIHtJREJWYWxpZEtleX0ga2V5IHN0cmluZyB8IG51bWJlciB8IERhdGUgfCBCdWZmZXJTb3VyY2UgfCBJREJWYWxpZEtleVtdXG4gICAgICogQHJldHVybnMgYFByb21pc2U8VCB8IG51bGw+YFxuICAgICAqIEBleGFtcGxlXG4gICAgICogYXdhaXQgZ2V0PHN0cmluZz4oJ2V4YW1wbGVLZXknKSAtPiAnZXhhbXBsZVZhbHVlJ1xuICAgICAqL1xuICAgIGFzeW5jIGdldChrZXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gKGF3YWl0IF9nZXRWYWx1ZSh0aGlzLl9kYiwgdGhpcy5fc3RvcmVOYW1lLCBrZXkpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEga2V5XG4gICAgICogQHBhcmFtIGtleSB7QGxpbmsgSURCVmFsaWRLZXl9XG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9yZW1vdmVWYWx1ZSh0aGlzLl9kYiwgdGhpcy5fc3RvcmVOYW1lLCBrZXkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRiLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/auth-client/lib/esm/db.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/auth-client/lib/esm/idleManager.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@dfinity/auth-client/lib/esm/idleManager.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IdleManager: function() { return /* binding */ IdleManager; }\n/* harmony export */ });\nconst events = ['mousedown', 'mousemove', 'keydown', 'touchstart', 'wheel'];\n/**\n * Detects if the user has been idle for a duration of `idleTimeout` ms, and calls `onIdle` and registered callbacks.\n * By default, the IdleManager will log a user out after 10 minutes of inactivity.\n * To override these defaults, you can pass an `onIdle` callback, or configure a custom `idleTimeout` in milliseconds\n */\nclass IdleManager {\n    /**\n     * @protected\n     * @param options {@link IdleManagerOptions}\n     */\n    constructor(options = {}) {\n        var _a;\n        this.callbacks = [];\n        this.idleTimeout = 10 * 60 * 1000;\n        this.timeoutID = undefined;\n        const { onIdle, idleTimeout = 10 * 60 * 1000 } = options || {};\n        this.callbacks = onIdle ? [onIdle] : [];\n        this.idleTimeout = idleTimeout;\n        const _resetTimer = this._resetTimer.bind(this);\n        window.addEventListener('load', _resetTimer, true);\n        events.forEach(function (name) {\n            document.addEventListener(name, _resetTimer, true);\n        });\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        const debounce = (func, wait) => {\n            let timeout;\n            return (...args) => {\n                // eslint-disable-next-line @typescript-eslint/no-this-alias\n                const context = this;\n                const later = function () {\n                    timeout = undefined;\n                    func.apply(context, args);\n                };\n                clearTimeout(timeout);\n                timeout = window.setTimeout(later, wait);\n            };\n        };\n        if (options === null || options === void 0 ? void 0 : options.captureScroll) {\n            // debounce scroll events\n            const scroll = debounce(_resetTimer, (_a = options === null || options === void 0 ? void 0 : options.scrollDebounce) !== null && _a !== void 0 ? _a : 100);\n            window.addEventListener('scroll', scroll, true);\n        }\n        _resetTimer();\n    }\n    /**\n     * Creates an {@link IdleManager}\n     * @param {IdleManagerOptions} options Optional configuration\n     * @see {@link IdleManagerOptions}\n     * @param options.onIdle Callback once user has been idle. Use to prompt for fresh login, and use `Actor.agentOf(your_actor).invalidateIdentity()` to protect the user\n     * @param options.idleTimeout timeout in ms\n     * @param options.captureScroll capture scroll events\n     * @param options.scrollDebounce scroll debounce time in ms\n     */\n    static create(options = {}) {\n        return new this(options);\n    }\n    /**\n     * @param {IdleCB} callback function to be called when user goes idle\n     */\n    registerCallback(callback) {\n        this.callbacks.push(callback);\n    }\n    /**\n     * Cleans up the idle manager and its listeners\n     */\n    exit() {\n        clearTimeout(this.timeoutID);\n        window.removeEventListener('load', this._resetTimer, true);\n        const _resetTimer = this._resetTimer.bind(this);\n        events.forEach(function (name) {\n            document.removeEventListener(name, _resetTimer, true);\n        });\n        this.callbacks.forEach(cb => cb());\n    }\n    /**\n     * Resets the timeouts during cleanup\n     */\n    _resetTimer() {\n        const exit = this.exit.bind(this);\n        window.clearTimeout(this.timeoutID);\n        this.timeoutID = window.setTimeout(exit, this.idleTimeout);\n    }\n}\n//# sourceMappingURL=idleManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2F1dGgtY2xpZW50L2xpYi9lc20vaWRsZU1hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGVBQWUsb0JBQW9CO0FBQ25DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hdXRoLWNsaWVudC9saWIvZXNtL2lkbGVNYW5hZ2VyLmpzP2NiYzEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZXZlbnRzID0gWydtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2tleWRvd24nLCAndG91Y2hzdGFydCcsICd3aGVlbCddO1xuLyoqXG4gKiBEZXRlY3RzIGlmIHRoZSB1c2VyIGhhcyBiZWVuIGlkbGUgZm9yIGEgZHVyYXRpb24gb2YgYGlkbGVUaW1lb3V0YCBtcywgYW5kIGNhbGxzIGBvbklkbGVgIGFuZCByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqIEJ5IGRlZmF1bHQsIHRoZSBJZGxlTWFuYWdlciB3aWxsIGxvZyBhIHVzZXIgb3V0IGFmdGVyIDEwIG1pbnV0ZXMgb2YgaW5hY3Rpdml0eS5cbiAqIFRvIG92ZXJyaWRlIHRoZXNlIGRlZmF1bHRzLCB5b3UgY2FuIHBhc3MgYW4gYG9uSWRsZWAgY2FsbGJhY2ssIG9yIGNvbmZpZ3VyZSBhIGN1c3RvbSBgaWRsZVRpbWVvdXRgIGluIG1pbGxpc2Vjb25kc1xuICovXG5leHBvcnQgY2xhc3MgSWRsZU1hbmFnZXIge1xuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7QGxpbmsgSWRsZU1hbmFnZXJPcHRpb25zfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXQgPSAxMCAqIDYwICogMTAwMDtcbiAgICAgICAgdGhpcy50aW1lb3V0SUQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHsgb25JZGxlLCBpZGxlVGltZW91dCA9IDEwICogNjAgKiAxMDAwIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IG9uSWRsZSA/IFtvbklkbGVdIDogW107XG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXQgPSBpZGxlVGltZW91dDtcbiAgICAgICAgY29uc3QgX3Jlc2V0VGltZXIgPSB0aGlzLl9yZXNldFRpbWVyLmJpbmQodGhpcyk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgX3Jlc2V0VGltZXIsIHRydWUpO1xuICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBfcmVzZXRUaW1lciwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgICAgICBjb25zdCBkZWJvdW5jZSA9IChmdW5jLCB3YWl0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdGltZW91dDtcbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHR1cmVTY3JvbGwpIHtcbiAgICAgICAgICAgIC8vIGRlYm91bmNlIHNjcm9sbCBldmVudHNcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbCA9IGRlYm91bmNlKF9yZXNldFRpbWVyLCAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2Nyb2xsRGVib3VuY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEwMCk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBfcmVzZXRUaW1lcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIHtAbGluayBJZGxlTWFuYWdlcn1cbiAgICAgKiBAcGFyYW0ge0lkbGVNYW5hZ2VyT3B0aW9uc30gb3B0aW9ucyBPcHRpb25hbCBjb25maWd1cmF0aW9uXG4gICAgICogQHNlZSB7QGxpbmsgSWRsZU1hbmFnZXJPcHRpb25zfVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uSWRsZSBDYWxsYmFjayBvbmNlIHVzZXIgaGFzIGJlZW4gaWRsZS4gVXNlIHRvIHByb21wdCBmb3IgZnJlc2ggbG9naW4sIGFuZCB1c2UgYEFjdG9yLmFnZW50T2YoeW91cl9hY3RvcikuaW52YWxpZGF0ZUlkZW50aXR5KClgIHRvIHByb3RlY3QgdGhlIHVzZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pZGxlVGltZW91dCB0aW1lb3V0IGluIG1zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2FwdHVyZVNjcm9sbCBjYXB0dXJlIHNjcm9sbCBldmVudHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zY3JvbGxEZWJvdW5jZSBzY3JvbGwgZGVib3VuY2UgdGltZSBpbiBtc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtJZGxlQ0J9IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHVzZXIgZ29lcyBpZGxlXG4gICAgICovXG4gICAgcmVnaXN0ZXJDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHRoZSBpZGxlIG1hbmFnZXIgYW5kIGl0cyBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBleGl0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SUQpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX3Jlc2V0VGltZXIsIHRydWUpO1xuICAgICAgICBjb25zdCBfcmVzZXRUaW1lciA9IHRoaXMuX3Jlc2V0VGltZXIuYmluZCh0aGlzKTtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgX3Jlc2V0VGltZXIsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuZm9yRWFjaChjYiA9PiBjYigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSB0aW1lb3V0cyBkdXJpbmcgY2xlYW51cFxuICAgICAqL1xuICAgIF9yZXNldFRpbWVyKCkge1xuICAgICAgICBjb25zdCBleGl0ID0gdGhpcy5leGl0LmJpbmQodGhpcyk7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SUQpO1xuICAgICAgICB0aGlzLnRpbWVvdXRJRCA9IHdpbmRvdy5zZXRUaW1lb3V0KGV4aXQsIHRoaXMuaWRsZVRpbWVvdXQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkbGVNYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/auth-client/lib/esm/idleManager.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/auth-client/lib/esm/index.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/@dfinity/auth-client/lib/esm/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthClient: function() { return /* binding */ AuthClient; },\n/* harmony export */   ERROR_USER_INTERRUPT: function() { return /* binding */ ERROR_USER_INTERRUPT; },\n/* harmony export */   IdbKeyVal: function() { return /* reexport safe */ _db__WEBPACK_IMPORTED_MODULE_4__.IdbKeyVal; },\n/* harmony export */   IdbStorage: function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_3__.IdbStorage; },\n/* harmony export */   IdleManager: function() { return /* reexport safe */ _idleManager__WEBPACK_IMPORTED_MODULE_2__.IdleManager; },\n/* harmony export */   KEY_STORAGE_DELEGATION: function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_DELEGATION; },\n/* harmony export */   KEY_STORAGE_KEY: function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_KEY; },\n/* harmony export */   LocalStorage: function() { return /* reexport safe */ _storage__WEBPACK_IMPORTED_MODULE_3__.LocalStorage; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"../../../node_modules/@dfinity/agent/lib/esm/index.js\");\n/* harmony import */ var _dfinity_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/identity */ \"../../../node_modules/@dfinity/identity/lib/esm/index.js\");\n/* harmony import */ var _idleManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./idleManager */ \"../../../node_modules/@dfinity/auth-client/lib/esm/idleManager.js\");\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage */ \"../../../node_modules/@dfinity/auth-client/lib/esm/storage.js\");\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./db */ \"../../../node_modules/@dfinity/auth-client/lib/esm/db.js\");\n/** @module AuthClient */\n\n\n\n\n\n\nconst IDENTITY_PROVIDER_DEFAULT = 'https://identity.ic0.app';\nconst IDENTITY_PROVIDER_ENDPOINT = '#authorize';\nconst ECDSA_KEY_LABEL = 'ECDSA';\nconst ED25519_KEY_LABEL = 'Ed25519';\nconst INTERRUPT_CHECK_INTERVAL = 500;\nconst ERROR_USER_INTERRUPT = 'UserInterrupt';\n\n/**\n * Tool to manage authentication and identity\n * @see {@link AuthClient}\n */\nclass AuthClient {\n    constructor(_identity, _key, _chain, _storage, idleManager, _createOptions, \n    // A handle on the IdP window.\n    _idpWindow, \n    // The event handler for processing events from the IdP.\n    _eventHandler) {\n        var _a;\n        this._identity = _identity;\n        this._key = _key;\n        this._chain = _chain;\n        this._storage = _storage;\n        this.idleManager = idleManager;\n        this._createOptions = _createOptions;\n        this._idpWindow = _idpWindow;\n        this._eventHandler = _eventHandler;\n        const logout = this.logout.bind(this);\n        const idleOptions = _createOptions === null || _createOptions === void 0 ? void 0 : _createOptions.idleOptions;\n        /**\n         * Default behavior is to clear stored identity and reload the page.\n         * By either setting the disableDefaultIdleCallback flag or passing in a custom idle callback, we will ignore this config\n         */\n        if (!(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.onIdle) && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableDefaultIdleCallback)) {\n            (_a = this.idleManager) === null || _a === void 0 ? void 0 : _a.registerCallback(() => {\n                logout();\n                location.reload();\n            });\n        }\n    }\n    /**\n     * Create an AuthClient to manage authentication and identity\n     * @constructs {@link AuthClient}\n     * @param {AuthClientCreateOptions} options\n     * @see {@link AuthClientCreateOptions}\n     * @param options.identity Optional Identity to use as the base\n     * @see {@link SignIdentity}\n     * @param options.storage Storage mechanism for delegration credentials\n     * @see {@link AuthClientStorage}\n     * @param options.keyType Type of key to use for the base key\n     * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}\n     * @see {@link IdleOptions}\n     * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.\n     * @example\n     * const authClient = await AuthClient.create({\n     *   idleOptions: {\n     *     disableIdle: true\n     *   }\n     * })\n     */\n    static async create(options = {}) {\n        var _a, _b, _c;\n        const storage = (_a = options.storage) !== null && _a !== void 0 ? _a : new _storage__WEBPACK_IMPORTED_MODULE_3__.IdbStorage();\n        const keyType = (_b = options.keyType) !== null && _b !== void 0 ? _b : ECDSA_KEY_LABEL;\n        let key = null;\n        if (options.identity) {\n            key = options.identity;\n        }\n        else {\n            let maybeIdentityStorage = await storage.get(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_KEY);\n            if (!maybeIdentityStorage && _storage__WEBPACK_IMPORTED_MODULE_3__.isBrowser) {\n                // Attempt to migrate from localstorage\n                try {\n                    const fallbackLocalStorage = new _storage__WEBPACK_IMPORTED_MODULE_3__.LocalStorage();\n                    const localChain = await fallbackLocalStorage.get(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_DELEGATION);\n                    const localKey = await fallbackLocalStorage.get(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_KEY);\n                    // not relevant for Ed25519\n                    if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {\n                        console.log('Discovered an identity stored in localstorage. Migrating to IndexedDB');\n                        await storage.set(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_DELEGATION, localChain);\n                        await storage.set(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_KEY, localKey);\n                        maybeIdentityStorage = localChain;\n                        // clean up\n                        await fallbackLocalStorage.remove(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_DELEGATION);\n                        await fallbackLocalStorage.remove(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_KEY);\n                    }\n                }\n                catch (error) {\n                    console.error('error while attempting to recover localstorage: ' + error);\n                }\n            }\n            if (maybeIdentityStorage) {\n                try {\n                    if (typeof maybeIdentityStorage === 'object') {\n                        if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === 'string') {\n                            key = await _dfinity_identity__WEBPACK_IMPORTED_MODULE_1__.Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n                        }\n                        else {\n                            key = await _dfinity_identity__WEBPACK_IMPORTED_MODULE_1__.ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);\n                        }\n                    }\n                    else if (typeof maybeIdentityStorage === 'string') {\n                        // This is a legacy identity, which is a serialized Ed25519KeyIdentity.\n                        key = _dfinity_identity__WEBPACK_IMPORTED_MODULE_1__.Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n                    }\n                }\n                catch (e) {\n                    // Ignore this, this means that the localStorage value isn't a valid Ed25519KeyIdentity or ECDSAKeyIdentity\n                    // serialization.\n                }\n            }\n        }\n        let identity = new _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.AnonymousIdentity();\n        let chain = null;\n        if (key) {\n            try {\n                const chainStorage = await storage.get(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_DELEGATION);\n                if (typeof chainStorage === 'object' && chainStorage !== null) {\n                    throw new Error('Delegation chain is incorrectly stored. A delegation chain should be stored as a string.');\n                }\n                if (options.identity) {\n                    identity = options.identity;\n                }\n                else if (chainStorage) {\n                    chain = _dfinity_identity__WEBPACK_IMPORTED_MODULE_1__.DelegationChain.fromJSON(chainStorage);\n                    // Verify that the delegation isn't expired.\n                    if (!(0,_dfinity_identity__WEBPACK_IMPORTED_MODULE_1__.isDelegationValid)(chain)) {\n                        await _deleteStorage(storage);\n                        key = null;\n                    }\n                    else {\n                        identity = _dfinity_identity__WEBPACK_IMPORTED_MODULE_1__.DelegationIdentity.fromDelegation(key, chain);\n                    }\n                }\n            }\n            catch (e) {\n                console.error(e);\n                // If there was a problem loading the chain, delete the key.\n                await _deleteStorage(storage);\n                key = null;\n            }\n        }\n        let idleManager = undefined;\n        if ((_c = options.idleOptions) === null || _c === void 0 ? void 0 : _c.disableIdle) {\n            idleManager = undefined;\n        }\n        // if there is a delegation chain or provided identity, setup idleManager\n        else if (chain || options.identity) {\n            idleManager = _idleManager__WEBPACK_IMPORTED_MODULE_2__.IdleManager.create(options.idleOptions);\n        }\n        if (!key) {\n            // Create a new key (whether or not one was in storage).\n            if (keyType === ED25519_KEY_LABEL) {\n                key = await _dfinity_identity__WEBPACK_IMPORTED_MODULE_1__.Ed25519KeyIdentity.generate();\n                await storage.set(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_KEY, JSON.stringify(key.toJSON()));\n            }\n            else {\n                if (options.storage && keyType === ECDSA_KEY_LABEL) {\n                    console.warn(`You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`);\n                }\n                key = await _dfinity_identity__WEBPACK_IMPORTED_MODULE_1__.ECDSAKeyIdentity.generate();\n                await storage.set(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_KEY, key.getKeyPair());\n            }\n        }\n        return new this(identity, key, chain, storage, idleManager, options);\n    }\n    async _handleSuccess(message, onSuccess) {\n        var _a, _b, _c;\n        const delegations = message.delegations.map(signedDelegation => {\n            return {\n                delegation: new _dfinity_identity__WEBPACK_IMPORTED_MODULE_1__.Delegation(signedDelegation.delegation.pubkey, signedDelegation.delegation.expiration, signedDelegation.delegation.targets),\n                signature: signedDelegation.signature.buffer,\n            };\n        });\n        const delegationChain = _dfinity_identity__WEBPACK_IMPORTED_MODULE_1__.DelegationChain.fromDelegations(delegations, message.userPublicKey.buffer);\n        const key = this._key;\n        if (!key) {\n            return;\n        }\n        this._chain = delegationChain;\n        this._identity = _dfinity_identity__WEBPACK_IMPORTED_MODULE_1__.DelegationIdentity.fromDelegation(key, this._chain);\n        (_a = this._idpWindow) === null || _a === void 0 ? void 0 : _a.close();\n        if (!this.idleManager) {\n            const idleOptions = (_b = this._createOptions) === null || _b === void 0 ? void 0 : _b.idleOptions;\n            this.idleManager = _idleManager__WEBPACK_IMPORTED_MODULE_2__.IdleManager.create(idleOptions);\n            if (!(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.onIdle) && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableDefaultIdleCallback)) {\n                (_c = this.idleManager) === null || _c === void 0 ? void 0 : _c.registerCallback(() => {\n                    this.logout();\n                    location.reload();\n                });\n            }\n        }\n        this._removeEventListener();\n        delete this._idpWindow;\n        if (this._chain) {\n            await this._storage.set(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));\n        }\n        // onSuccess should be the last thing to do to avoid consumers\n        // interfering by navigating or refreshing the page\n        onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess();\n    }\n    getIdentity() {\n        return this._identity;\n    }\n    async isAuthenticated() {\n        return !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null;\n    }\n    /**\n     * AuthClient Login -\n     * Opens up a new window to authenticate with Internet Identity\n     * @param {AuthClientLoginOptions} options\n     * @param options.identityProvider Identity provider\n     * @param options.maxTimeToLive Expiration of the authentication in nanoseconds\n     * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity\n     * @param options.windowOpenerFeatures Configures the opened authentication window\n     * @param options.onSuccess Callback once login has completed\n     * @param options.onError Callback in case authentication fails\n     * @example\n     * const authClient = await AuthClient.create();\n     * authClient.login({\n     *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',\n     *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week\n     *  windowOpenerFeatures: \"toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100\",\n     *  onSuccess: () => {\n     *    console.log('Login Successful!');\n     *  },\n     *  onError: (error) => {\n     *    console.error('Login Failed: ', error);\n     *  }\n     * });\n     */\n    async login(options) {\n        var _a, _b, _c, _d;\n        // Set default maxTimeToLive to 8 hours\n        const defaultTimeToLive = /* hours */ BigInt(8) * /* nanoseconds */ BigInt(3600000000000);\n        // Create the URL of the IDP. (e.g. https://XXXX/#authorize)\n        const identityProviderUrl = new URL(((_a = options === null || options === void 0 ? void 0 : options.identityProvider) === null || _a === void 0 ? void 0 : _a.toString()) || IDENTITY_PROVIDER_DEFAULT);\n        // Set the correct hash if it isn't already set.\n        identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;\n        // If `login` has been called previously, then close/remove any previous windows\n        // and event listeners.\n        (_b = this._idpWindow) === null || _b === void 0 ? void 0 : _b.close();\n        this._removeEventListener();\n        // Add an event listener to handle responses.\n        this._eventHandler = this._getEventHandler(identityProviderUrl, Object.assign({ maxTimeToLive: (_c = options === null || options === void 0 ? void 0 : options.maxTimeToLive) !== null && _c !== void 0 ? _c : defaultTimeToLive }, options));\n        window.addEventListener('message', this._eventHandler);\n        // Open a new window with the IDP provider.\n        this._idpWindow =\n            (_d = window.open(identityProviderUrl.toString(), 'idpWindow', options === null || options === void 0 ? void 0 : options.windowOpenerFeatures)) !== null && _d !== void 0 ? _d : undefined;\n        // Check if the _idpWindow is closed by user.\n        const checkInterruption = () => {\n            // The _idpWindow is opened and not yet closed by the client\n            if (this._idpWindow) {\n                if (this._idpWindow.closed) {\n                    this._handleFailure(ERROR_USER_INTERRUPT, options === null || options === void 0 ? void 0 : options.onError);\n                }\n                else {\n                    setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);\n                }\n            }\n        };\n        checkInterruption();\n    }\n    _getEventHandler(identityProviderUrl, options) {\n        return async (event) => {\n            var _a, _b, _c;\n            if (event.origin !== identityProviderUrl.origin) {\n                console.warn(`WARNING: expected origin '${identityProviderUrl.origin}', got '${event.origin}' (ignoring)`);\n                return;\n            }\n            const message = event.data;\n            switch (message.kind) {\n                case 'authorize-ready': {\n                    // IDP is ready. Send a message to request authorization.\n                    const request = {\n                        kind: 'authorize-client',\n                        sessionPublicKey: new Uint8Array((_a = this._key) === null || _a === void 0 ? void 0 : _a.getPublicKey().toDer()),\n                        maxTimeToLive: options === null || options === void 0 ? void 0 : options.maxTimeToLive,\n                        derivationOrigin: (_b = options === null || options === void 0 ? void 0 : options.derivationOrigin) === null || _b === void 0 ? void 0 : _b.toString(),\n                    };\n                    (_c = this._idpWindow) === null || _c === void 0 ? void 0 : _c.postMessage(request, identityProviderUrl.origin);\n                    break;\n                }\n                case 'authorize-client-success':\n                    // Create the delegation chain and store it.\n                    try {\n                        await this._handleSuccess(message, options === null || options === void 0 ? void 0 : options.onSuccess);\n                    }\n                    catch (err) {\n                        this._handleFailure(err.message, options === null || options === void 0 ? void 0 : options.onError);\n                    }\n                    break;\n                case 'authorize-client-failure':\n                    this._handleFailure(message.text, options === null || options === void 0 ? void 0 : options.onError);\n                    break;\n                default:\n                    break;\n            }\n        };\n    }\n    _handleFailure(errorMessage, onError) {\n        var _a;\n        (_a = this._idpWindow) === null || _a === void 0 ? void 0 : _a.close();\n        onError === null || onError === void 0 ? void 0 : onError(errorMessage);\n        this._removeEventListener();\n        delete this._idpWindow;\n    }\n    _removeEventListener() {\n        if (this._eventHandler) {\n            window.removeEventListener('message', this._eventHandler);\n        }\n        this._eventHandler = undefined;\n    }\n    async logout(options = {}) {\n        await _deleteStorage(this._storage);\n        // Reset this auth client to a non-authenticated state.\n        this._identity = new _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.AnonymousIdentity();\n        this._chain = null;\n        if (options.returnTo) {\n            try {\n                window.history.pushState({}, '', options.returnTo);\n            }\n            catch (e) {\n                window.location.href = options.returnTo;\n            }\n        }\n    }\n}\nasync function _deleteStorage(storage) {\n    await storage.remove(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_KEY);\n    await storage.remove(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_STORAGE_DELEGATION);\n    await storage.remove(_storage__WEBPACK_IMPORTED_MODULE_3__.KEY_VECTOR);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2F1dGgtY2xpZW50L2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ29EO0FBQzBGO0FBQ2xHO0FBQzBFO0FBQ3hCO0FBQzdEO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUN1QjtBQUM5QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsZUFBZSx5QkFBeUI7QUFDeEMsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZUFBZSxhQUFhLG1DQUFtQztBQUMvRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0ZBQW9GLGdEQUFVO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxREFBZTtBQUN4RSx5Q0FBeUMsK0NBQVM7QUFDbEQ7QUFDQTtBQUNBLHFEQUFxRCxrREFBWTtBQUNqRSxzRUFBc0UsNERBQXNCO0FBQzVGLG9FQUFvRSxxREFBZTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNERBQXNCO0FBQ2hFLDBDQUEwQyxxREFBZTtBQUN6RDtBQUNBO0FBQ0EsMERBQTBELDREQUFzQjtBQUNoRiwwREFBMEQscURBQWU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUVBQWtCO0FBQzFEO0FBQ0E7QUFDQSx3Q0FBd0MsK0RBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlFQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZEQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSx1REFBdUQsNERBQXNCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhEQUFlO0FBQzNDO0FBQ0EseUJBQXlCLG9FQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpRUFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscURBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUVBQWtCO0FBQzlDLGtDQUFrQyxxREFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSx3TkFBd04sa0JBQWtCO0FBQzFPO0FBQ0EsNEJBQTRCLCtEQUFnQjtBQUM1QyxrQ0FBa0MscURBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5REFBVTtBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNULGdDQUFnQyw4REFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscURBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw0REFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Ysa0pBQWtKO0FBQzFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDJCQUEyQixVQUFVLGFBQWE7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFlO0FBQ3hDLHlCQUF5Qiw0REFBc0I7QUFDL0MseUJBQXlCLGdEQUFVO0FBQ25DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9hdXRoLWNsaWVudC9saWIvZXNtL2luZGV4LmpzP2MwYTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBtb2R1bGUgQXV0aENsaWVudCAqL1xuaW1wb3J0IHsgQW5vbnltb3VzSWRlbnRpdHksIH0gZnJvbSAnQGRmaW5pdHkvYWdlbnQnO1xuaW1wb3J0IHsgRGVsZWdhdGlvbiwgRGVsZWdhdGlvbkNoYWluLCBpc0RlbGVnYXRpb25WYWxpZCwgRGVsZWdhdGlvbklkZW50aXR5LCBFZDI1NTE5S2V5SWRlbnRpdHksIEVDRFNBS2V5SWRlbnRpdHksIH0gZnJvbSAnQGRmaW5pdHkvaWRlbnRpdHknO1xuaW1wb3J0IHsgSWRsZU1hbmFnZXIgfSBmcm9tICcuL2lkbGVNYW5hZ2VyJztcbmltcG9ydCB7IElkYlN0b3JhZ2UsIGlzQnJvd3NlciwgS0VZX1NUT1JBR0VfREVMRUdBVElPTiwgS0VZX1NUT1JBR0VfS0VZLCBLRVlfVkVDVE9SLCBMb2NhbFN0b3JhZ2UsIH0gZnJvbSAnLi9zdG9yYWdlJztcbmV4cG9ydCB7IElkYlN0b3JhZ2UsIExvY2FsU3RvcmFnZSwgS0VZX1NUT1JBR0VfREVMRUdBVElPTiwgS0VZX1NUT1JBR0VfS0VZIH0gZnJvbSAnLi9zdG9yYWdlJztcbmV4cG9ydCB7IElkYktleVZhbCB9IGZyb20gJy4vZGInO1xuY29uc3QgSURFTlRJVFlfUFJPVklERVJfREVGQVVMVCA9ICdodHRwczovL2lkZW50aXR5LmljMC5hcHAnO1xuY29uc3QgSURFTlRJVFlfUFJPVklERVJfRU5EUE9JTlQgPSAnI2F1dGhvcml6ZSc7XG5jb25zdCBFQ0RTQV9LRVlfTEFCRUwgPSAnRUNEU0EnO1xuY29uc3QgRUQyNTUxOV9LRVlfTEFCRUwgPSAnRWQyNTUxOSc7XG5jb25zdCBJTlRFUlJVUFRfQ0hFQ0tfSU5URVJWQUwgPSA1MDA7XG5leHBvcnQgY29uc3QgRVJST1JfVVNFUl9JTlRFUlJVUFQgPSAnVXNlckludGVycnVwdCc7XG5leHBvcnQgKiBmcm9tICcuL2lkbGVNYW5hZ2VyJztcbi8qKlxuICogVG9vbCB0byBtYW5hZ2UgYXV0aGVudGljYXRpb24gYW5kIGlkZW50aXR5XG4gKiBAc2VlIHtAbGluayBBdXRoQ2xpZW50fVxuICovXG5leHBvcnQgY2xhc3MgQXV0aENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoX2lkZW50aXR5LCBfa2V5LCBfY2hhaW4sIF9zdG9yYWdlLCBpZGxlTWFuYWdlciwgX2NyZWF0ZU9wdGlvbnMsIFxuICAgIC8vIEEgaGFuZGxlIG9uIHRoZSBJZFAgd2luZG93LlxuICAgIF9pZHBXaW5kb3csIFxuICAgIC8vIFRoZSBldmVudCBoYW5kbGVyIGZvciBwcm9jZXNzaW5nIGV2ZW50cyBmcm9tIHRoZSBJZFAuXG4gICAgX2V2ZW50SGFuZGxlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuX2lkZW50aXR5ID0gX2lkZW50aXR5O1xuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xuICAgICAgICB0aGlzLl9jaGFpbiA9IF9jaGFpbjtcbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IF9zdG9yYWdlO1xuICAgICAgICB0aGlzLmlkbGVNYW5hZ2VyID0gaWRsZU1hbmFnZXI7XG4gICAgICAgIHRoaXMuX2NyZWF0ZU9wdGlvbnMgPSBfY3JlYXRlT3B0aW9ucztcbiAgICAgICAgdGhpcy5faWRwV2luZG93ID0gX2lkcFdpbmRvdztcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyID0gX2V2ZW50SGFuZGxlcjtcbiAgICAgICAgY29uc3QgbG9nb3V0ID0gdGhpcy5sb2dvdXQuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgaWRsZU9wdGlvbnMgPSBfY3JlYXRlT3B0aW9ucyA9PT0gbnVsbCB8fCBfY3JlYXRlT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NyZWF0ZU9wdGlvbnMuaWRsZU9wdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGNsZWFyIHN0b3JlZCBpZGVudGl0eSBhbmQgcmVsb2FkIHRoZSBwYWdlLlxuICAgICAgICAgKiBCeSBlaXRoZXIgc2V0dGluZyB0aGUgZGlzYWJsZURlZmF1bHRJZGxlQ2FsbGJhY2sgZmxhZyBvciBwYXNzaW5nIGluIGEgY3VzdG9tIGlkbGUgY2FsbGJhY2ssIHdlIHdpbGwgaWdub3JlIHRoaXMgY29uZmlnXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIShpZGxlT3B0aW9ucyA9PT0gbnVsbCB8fCBpZGxlT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWRsZU9wdGlvbnMub25JZGxlKSAmJiAhKGlkbGVPcHRpb25zID09PSBudWxsIHx8IGlkbGVPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZGxlT3B0aW9ucy5kaXNhYmxlRGVmYXVsdElkbGVDYWxsYmFjaykpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuaWRsZU1hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWdpc3RlckNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dvdXQoKTtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBBdXRoQ2xpZW50IHRvIG1hbmFnZSBhdXRoZW50aWNhdGlvbiBhbmQgaWRlbnRpdHlcbiAgICAgKiBAY29uc3RydWN0cyB7QGxpbmsgQXV0aENsaWVudH1cbiAgICAgKiBAcGFyYW0ge0F1dGhDbGllbnRDcmVhdGVPcHRpb25zfSBvcHRpb25zXG4gICAgICogQHNlZSB7QGxpbmsgQXV0aENsaWVudENyZWF0ZU9wdGlvbnN9XG4gICAgICogQHBhcmFtIG9wdGlvbnMuaWRlbnRpdHkgT3B0aW9uYWwgSWRlbnRpdHkgdG8gdXNlIGFzIHRoZSBiYXNlXG4gICAgICogQHNlZSB7QGxpbmsgU2lnbklkZW50aXR5fVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0b3JhZ2UgU3RvcmFnZSBtZWNoYW5pc20gZm9yIGRlbGVncmF0aW9uIGNyZWRlbnRpYWxzXG4gICAgICogQHNlZSB7QGxpbmsgQXV0aENsaWVudFN0b3JhZ2V9XG4gICAgICogQHBhcmFtIG9wdGlvbnMua2V5VHlwZSBUeXBlIG9mIGtleSB0byB1c2UgZm9yIHRoZSBiYXNlIGtleVxuICAgICAqIEBwYXJhbSB7SWRsZU9wdGlvbnN9IG9wdGlvbnMuaWRsZU9wdGlvbnMgQ29uZmlndXJlcyBhbiB7QGxpbmsgSWRsZU1hbmFnZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgSWRsZU9wdGlvbnN9XG4gICAgICogRGVmYXVsdCBiZWhhdmlvciBpcyB0byBjbGVhciBzdG9yZWQgaWRlbnRpdHkgYW5kIHJlbG9hZCB0aGUgcGFnZSB3aGVuIGEgdXNlciBnb2VzIGlkbGUsIHVubGVzcyB5b3Ugc2V0IHRoZSBkaXNhYmxlRGVmYXVsdElkbGVDYWxsYmFjayBmbGFnIG9yIHBhc3MgaW4gYSBjdXN0b20gaWRsZSBjYWxsYmFjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGF1dGhDbGllbnQgPSBhd2FpdCBBdXRoQ2xpZW50LmNyZWF0ZSh7XG4gICAgICogICBpZGxlT3B0aW9uczoge1xuICAgICAqICAgICBkaXNhYmxlSWRsZTogdHJ1ZVxuICAgICAqICAgfVxuICAgICAqIH0pXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSAoX2EgPSBvcHRpb25zLnN0b3JhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBJZGJTdG9yYWdlKCk7XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSAoX2IgPSBvcHRpb25zLmtleVR5cGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IEVDRFNBX0tFWV9MQUJFTDtcbiAgICAgICAgbGV0IGtleSA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLmlkZW50aXR5KSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmlkZW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1heWJlSWRlbnRpdHlTdG9yYWdlID0gYXdhaXQgc3RvcmFnZS5nZXQoS0VZX1NUT1JBR0VfS0VZKTtcbiAgICAgICAgICAgIGlmICghbWF5YmVJZGVudGl0eVN0b3JhZ2UgJiYgaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBtaWdyYXRlIGZyb20gbG9jYWxzdG9yYWdlXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmFsbGJhY2tMb2NhbFN0b3JhZ2UgPSBuZXcgTG9jYWxTdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsQ2hhaW4gPSBhd2FpdCBmYWxsYmFja0xvY2FsU3RvcmFnZS5nZXQoS0VZX1NUT1JBR0VfREVMRUdBVElPTik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsS2V5ID0gYXdhaXQgZmFsbGJhY2tMb2NhbFN0b3JhZ2UuZ2V0KEtFWV9TVE9SQUdFX0tFWSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCByZWxldmFudCBmb3IgRWQyNTUxOVxuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxDaGFpbiAmJiBsb2NhbEtleSAmJiBrZXlUeXBlID09PSBFQ0RTQV9LRVlfTEFCRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEaXNjb3ZlcmVkIGFuIGlkZW50aXR5IHN0b3JlZCBpbiBsb2NhbHN0b3JhZ2UuIE1pZ3JhdGluZyB0byBJbmRleGVkREInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KEtFWV9TVE9SQUdFX0RFTEVHQVRJT04sIGxvY2FsQ2hhaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RvcmFnZS5zZXQoS0VZX1NUT1JBR0VfS0VZLCBsb2NhbEtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZUlkZW50aXR5U3RvcmFnZSA9IGxvY2FsQ2hhaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGVhbiB1cFxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZmFsbGJhY2tMb2NhbFN0b3JhZ2UucmVtb3ZlKEtFWV9TVE9SQUdFX0RFTEVHQVRJT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgZmFsbGJhY2tMb2NhbFN0b3JhZ2UucmVtb3ZlKEtFWV9TVE9SQUdFX0tFWSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yIHdoaWxlIGF0dGVtcHRpbmcgdG8gcmVjb3ZlciBsb2NhbHN0b3JhZ2U6ICcgKyBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1heWJlSWRlbnRpdHlTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXliZUlkZW50aXR5U3RvcmFnZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlUeXBlID09PSBFRDI1NTE5X0tFWV9MQUJFTCAmJiB0eXBlb2YgbWF5YmVJZGVudGl0eVN0b3JhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gYXdhaXQgRWQyNTUxOUtleUlkZW50aXR5LmZyb21KU09OKG1heWJlSWRlbnRpdHlTdG9yYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGF3YWl0IEVDRFNBS2V5SWRlbnRpdHkuZnJvbUtleVBhaXIobWF5YmVJZGVudGl0eVN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtYXliZUlkZW50aXR5U3RvcmFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsZWdhY3kgaWRlbnRpdHksIHdoaWNoIGlzIGEgc2VyaWFsaXplZCBFZDI1NTE5S2V5SWRlbnRpdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBFZDI1NTE5S2V5SWRlbnRpdHkuZnJvbUpTT04obWF5YmVJZGVudGl0eVN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGlzLCB0aGlzIG1lYW5zIHRoYXQgdGhlIGxvY2FsU3RvcmFnZSB2YWx1ZSBpc24ndCBhIHZhbGlkIEVkMjU1MTlLZXlJZGVudGl0eSBvciBFQ0RTQUtleUlkZW50aXR5XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpZGVudGl0eSA9IG5ldyBBbm9ueW1vdXNJZGVudGl0eSgpO1xuICAgICAgICBsZXQgY2hhaW4gPSBudWxsO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluU3RvcmFnZSA9IGF3YWl0IHN0b3JhZ2UuZ2V0KEtFWV9TVE9SQUdFX0RFTEVHQVRJT04pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhaW5TdG9yYWdlID09PSAnb2JqZWN0JyAmJiBjaGFpblN0b3JhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxlZ2F0aW9uIGNoYWluIGlzIGluY29ycmVjdGx5IHN0b3JlZC4gQSBkZWxlZ2F0aW9uIGNoYWluIHNob3VsZCBiZSBzdG9yZWQgYXMgYSBzdHJpbmcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmlkZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aXR5ID0gb3B0aW9ucy5pZGVudGl0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhaW5TdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluID0gRGVsZWdhdGlvbkNoYWluLmZyb21KU09OKGNoYWluU3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBkZWxlZ2F0aW9uIGlzbid0IGV4cGlyZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNEZWxlZ2F0aW9uVmFsaWQoY2hhaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBfZGVsZXRlU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGl0eSA9IERlbGVnYXRpb25JZGVudGl0eS5mcm9tRGVsZWdhdGlvbihrZXksIGNoYWluKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcm9ibGVtIGxvYWRpbmcgdGhlIGNoYWluLCBkZWxldGUgdGhlIGtleS5cbiAgICAgICAgICAgICAgICBhd2FpdCBfZGVsZXRlU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpZGxlTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKChfYyA9IG9wdGlvbnMuaWRsZU9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNhYmxlSWRsZSkge1xuICAgICAgICAgICAgaWRsZU1hbmFnZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBkZWxlZ2F0aW9uIGNoYWluIG9yIHByb3ZpZGVkIGlkZW50aXR5LCBzZXR1cCBpZGxlTWFuYWdlclxuICAgICAgICBlbHNlIGlmIChjaGFpbiB8fCBvcHRpb25zLmlkZW50aXR5KSB7XG4gICAgICAgICAgICBpZGxlTWFuYWdlciA9IElkbGVNYW5hZ2VyLmNyZWF0ZShvcHRpb25zLmlkbGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGtleSAod2hldGhlciBvciBub3Qgb25lIHdhcyBpbiBzdG9yYWdlKS5cbiAgICAgICAgICAgIGlmIChrZXlUeXBlID09PSBFRDI1NTE5X0tFWV9MQUJFTCkge1xuICAgICAgICAgICAgICAgIGtleSA9IGF3YWl0IEVkMjU1MTlLZXlJZGVudGl0eS5nZW5lcmF0ZSgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KEtFWV9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoa2V5LnRvSlNPTigpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdG9yYWdlICYmIGtleVR5cGUgPT09IEVDRFNBX0tFWV9MQUJFTCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFlvdSBhcmUgdXNpbmcgYSBjdXN0b20gc3RvcmFnZSBwcm92aWRlciB0aGF0IG1heSBub3Qgc3VwcG9ydCBDcnlwdG9LZXkgc3RvcmFnZS4gSWYgeW91IGFyZSB1c2luZyBhIGN1c3RvbSBzdG9yYWdlIHByb3ZpZGVyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCBDcnlwdG9LZXkgc3RvcmFnZSwgeW91IHNob3VsZCB1c2UgJyR7RUQyNTUxOV9LRVlfTEFCRUx9JyBhcyB0aGUga2V5IHR5cGUsIGFzIGl0IGNhbiBzZXJpYWxpemUgdG8gYSBzdHJpbmdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ID0gYXdhaXQgRUNEU0FLZXlJZGVudGl0eS5nZW5lcmF0ZSgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHN0b3JhZ2Uuc2V0KEtFWV9TVE9SQUdFX0tFWSwga2V5LmdldEtleVBhaXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGlkZW50aXR5LCBrZXksIGNoYWluLCBzdG9yYWdlLCBpZGxlTWFuYWdlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIF9oYW5kbGVTdWNjZXNzKG1lc3NhZ2UsIG9uU3VjY2Vzcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgZGVsZWdhdGlvbnMgPSBtZXNzYWdlLmRlbGVnYXRpb25zLm1hcChzaWduZWREZWxlZ2F0aW9uID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVsZWdhdGlvbjogbmV3IERlbGVnYXRpb24oc2lnbmVkRGVsZWdhdGlvbi5kZWxlZ2F0aW9uLnB1YmtleSwgc2lnbmVkRGVsZWdhdGlvbi5kZWxlZ2F0aW9uLmV4cGlyYXRpb24sIHNpZ25lZERlbGVnYXRpb24uZGVsZWdhdGlvbi50YXJnZXRzKSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHNpZ25lZERlbGVnYXRpb24uc2lnbmF0dXJlLmJ1ZmZlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWxlZ2F0aW9uQ2hhaW4gPSBEZWxlZ2F0aW9uQ2hhaW4uZnJvbURlbGVnYXRpb25zKGRlbGVnYXRpb25zLCBtZXNzYWdlLnVzZXJQdWJsaWNLZXkuYnVmZmVyKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5fa2V5O1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYWluID0gZGVsZWdhdGlvbkNoYWluO1xuICAgICAgICB0aGlzLl9pZGVudGl0eSA9IERlbGVnYXRpb25JZGVudGl0eS5mcm9tRGVsZWdhdGlvbihrZXksIHRoaXMuX2NoYWluKTtcbiAgICAgICAgKF9hID0gdGhpcy5faWRwV2luZG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLmlkbGVNYW5hZ2VyKSB7XG4gICAgICAgICAgICBjb25zdCBpZGxlT3B0aW9ucyA9IChfYiA9IHRoaXMuX2NyZWF0ZU9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZGxlT3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuaWRsZU1hbmFnZXIgPSBJZGxlTWFuYWdlci5jcmVhdGUoaWRsZU9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCEoaWRsZU9wdGlvbnMgPT09IG51bGwgfHwgaWRsZU9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkbGVPcHRpb25zLm9uSWRsZSkgJiYgIShpZGxlT3B0aW9ucyA9PT0gbnVsbCB8fCBpZGxlT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWRsZU9wdGlvbnMuZGlzYWJsZURlZmF1bHRJZGxlQ2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgKF9jID0gdGhpcy5pZGxlTWFuYWdlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlZ2lzdGVyQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ291dCgpO1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVyKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pZHBXaW5kb3c7XG4gICAgICAgIGlmICh0aGlzLl9jaGFpbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc3RvcmFnZS5zZXQoS0VZX1NUT1JBR0VfREVMRUdBVElPTiwgSlNPTi5zdHJpbmdpZnkodGhpcy5fY2hhaW4udG9KU09OKCkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvblN1Y2Nlc3Mgc2hvdWxkIGJlIHRoZSBsYXN0IHRoaW5nIHRvIGRvIHRvIGF2b2lkIGNvbnN1bWVyc1xuICAgICAgICAvLyBpbnRlcmZlcmluZyBieSBuYXZpZ2F0aW5nIG9yIHJlZnJlc2hpbmcgdGhlIHBhZ2VcbiAgICAgICAgb25TdWNjZXNzID09PSBudWxsIHx8IG9uU3VjY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25TdWNjZXNzKCk7XG4gICAgfVxuICAgIGdldElkZW50aXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWRlbnRpdHk7XG4gICAgfVxuICAgIGFzeW5jIGlzQXV0aGVudGljYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmdldElkZW50aXR5KCkuZ2V0UHJpbmNpcGFsKCkuaXNBbm9ueW1vdXMoKSAmJiB0aGlzLl9jaGFpbiAhPT0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXV0aENsaWVudCBMb2dpbiAtXG4gICAgICogT3BlbnMgdXAgYSBuZXcgd2luZG93IHRvIGF1dGhlbnRpY2F0ZSB3aXRoIEludGVybmV0IElkZW50aXR5XG4gICAgICogQHBhcmFtIHtBdXRoQ2xpZW50TG9naW5PcHRpb25zfSBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaWRlbnRpdHlQcm92aWRlciBJZGVudGl0eSBwcm92aWRlclxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1heFRpbWVUb0xpdmUgRXhwaXJhdGlvbiBvZiB0aGUgYXV0aGVudGljYXRpb24gaW4gbmFub3NlY29uZHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZXJpdmF0aW9uT3JpZ2luIE9yaWdpbiBmb3IgSWRlbnRpdHkgUHJvdmlkZXIgdG8gdXNlIHdoaWxlIGdlbmVyYXRpbmcgdGhlIGRlbGVnYXRlZCBpZGVudGl0eVxuICAgICAqIEBwYXJhbSBvcHRpb25zLndpbmRvd09wZW5lckZlYXR1cmVzIENvbmZpZ3VyZXMgdGhlIG9wZW5lZCBhdXRoZW50aWNhdGlvbiB3aW5kb3dcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vblN1Y2Nlc3MgQ2FsbGJhY2sgb25jZSBsb2dpbiBoYXMgY29tcGxldGVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25FcnJvciBDYWxsYmFjayBpbiBjYXNlIGF1dGhlbnRpY2F0aW9uIGZhaWxzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBhdXRoQ2xpZW50ID0gYXdhaXQgQXV0aENsaWVudC5jcmVhdGUoKTtcbiAgICAgKiBhdXRoQ2xpZW50LmxvZ2luKHtcbiAgICAgKiAgaWRlbnRpdHlQcm92aWRlcjogJ2h0dHA6Ly88Y2FuaXN0ZXJJRD4uMTI3LjAuMC4xOjgwMDAnLFxuICAgICAqICBtYXhUaW1lVG9MaXZlOiBCaWdJbnQgKDcpICogQmlnSW50KDI0KSAqIEJpZ0ludCgzXzYwMF8wMDBfMDAwXzAwMCksIC8vIDEgd2Vla1xuICAgICAqICB3aW5kb3dPcGVuZXJGZWF0dXJlczogXCJ0b29sYmFyPTAsbG9jYXRpb249MCxtZW51YmFyPTAsd2lkdGg9NTAwLGhlaWdodD01MDAsbGVmdD0xMDAsdG9wPTEwMFwiLFxuICAgICAqICBvblN1Y2Nlc3M6ICgpID0+IHtcbiAgICAgKiAgICBjb25zb2xlLmxvZygnTG9naW4gU3VjY2Vzc2Z1bCEnKTtcbiAgICAgKiAgfSxcbiAgICAgKiAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICogICAgY29uc29sZS5lcnJvcignTG9naW4gRmFpbGVkOiAnLCBlcnJvcik7XG4gICAgICogIH1cbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBhc3luYyBsb2dpbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gU2V0IGRlZmF1bHQgbWF4VGltZVRvTGl2ZSB0byA4IGhvdXJzXG4gICAgICAgIGNvbnN0IGRlZmF1bHRUaW1lVG9MaXZlID0gLyogaG91cnMgKi8gQmlnSW50KDgpICogLyogbmFub3NlY29uZHMgKi8gQmlnSW50KDM2MDAwMDAwMDAwMDApO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIFVSTCBvZiB0aGUgSURQLiAoZS5nLiBodHRwczovL1hYWFgvI2F1dGhvcml6ZSlcbiAgICAgICAgY29uc3QgaWRlbnRpdHlQcm92aWRlclVybCA9IG5ldyBVUkwoKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZGVudGl0eVByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgfHwgSURFTlRJVFlfUFJPVklERVJfREVGQVVMVCk7XG4gICAgICAgIC8vIFNldCB0aGUgY29ycmVjdCBoYXNoIGlmIGl0IGlzbid0IGFscmVhZHkgc2V0LlxuICAgICAgICBpZGVudGl0eVByb3ZpZGVyVXJsLmhhc2ggPSBJREVOVElUWV9QUk9WSURFUl9FTkRQT0lOVDtcbiAgICAgICAgLy8gSWYgYGxvZ2luYCBoYXMgYmVlbiBjYWxsZWQgcHJldmlvdXNseSwgdGhlbiBjbG9zZS9yZW1vdmUgYW55IHByZXZpb3VzIHdpbmRvd3NcbiAgICAgICAgLy8gYW5kIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgKF9iID0gdGhpcy5faWRwV2luZG93KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAvLyBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gaGFuZGxlIHJlc3BvbnNlcy5cbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyID0gdGhpcy5fZ2V0RXZlbnRIYW5kbGVyKGlkZW50aXR5UHJvdmlkZXJVcmwsIE9iamVjdC5hc3NpZ24oeyBtYXhUaW1lVG9MaXZlOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4VGltZVRvTGl2ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdFRpbWVUb0xpdmUgfSwgb3B0aW9ucykpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX2V2ZW50SGFuZGxlcik7XG4gICAgICAgIC8vIE9wZW4gYSBuZXcgd2luZG93IHdpdGggdGhlIElEUCBwcm92aWRlci5cbiAgICAgICAgdGhpcy5faWRwV2luZG93ID1cbiAgICAgICAgICAgIChfZCA9IHdpbmRvdy5vcGVuKGlkZW50aXR5UHJvdmlkZXJVcmwudG9TdHJpbmcoKSwgJ2lkcFdpbmRvdycsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53aW5kb3dPcGVuZXJGZWF0dXJlcykpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIF9pZHBXaW5kb3cgaXMgY2xvc2VkIGJ5IHVzZXIuXG4gICAgICAgIGNvbnN0IGNoZWNrSW50ZXJydXB0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gVGhlIF9pZHBXaW5kb3cgaXMgb3BlbmVkIGFuZCBub3QgeWV0IGNsb3NlZCBieSB0aGUgY2xpZW50XG4gICAgICAgICAgICBpZiAodGhpcy5faWRwV2luZG93KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkcFdpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRmFpbHVyZShFUlJPUl9VU0VSX0lOVEVSUlVQVCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVja0ludGVycnVwdGlvbiwgSU5URVJSVVBUX0NIRUNLX0lOVEVSVkFMKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNoZWNrSW50ZXJydXB0aW9uKCk7XG4gICAgfVxuICAgIF9nZXRFdmVudEhhbmRsZXIoaWRlbnRpdHlQcm92aWRlclVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGlmIChldmVudC5vcmlnaW4gIT09IGlkZW50aXR5UHJvdmlkZXJVcmwub3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiBleHBlY3RlZCBvcmlnaW4gJyR7aWRlbnRpdHlQcm92aWRlclVybC5vcmlnaW59JywgZ290ICcke2V2ZW50Lm9yaWdpbn0nIChpZ25vcmluZylgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXV0aG9yaXplLXJlYWR5Jzoge1xuICAgICAgICAgICAgICAgICAgICAvLyBJRFAgaXMgcmVhZHkuIFNlbmQgYSBtZXNzYWdlIHRvIHJlcXVlc3QgYXV0aG9yaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdhdXRob3JpemUtY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25QdWJsaWNLZXk6IG5ldyBVaW50OEFycmF5KChfYSA9IHRoaXMuX2tleSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFB1YmxpY0tleSgpLnRvRGVyKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4VGltZVRvTGl2ZTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1heFRpbWVUb0xpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXJpdmF0aW9uT3JpZ2luOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVyaXZhdGlvbk9yaWdpbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMuX2lkcFdpbmRvdykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBvc3RNZXNzYWdlKHJlcXVlc3QsIGlkZW50aXR5UHJvdmlkZXJVcmwub3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2F1dGhvcml6ZS1jbGllbnQtc3VjY2Vzcyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZGVsZWdhdGlvbiBjaGFpbiBhbmQgc3RvcmUgaXQuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9oYW5kbGVTdWNjZXNzKG1lc3NhZ2UsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUZhaWx1cmUoZXJyLm1lc3NhZ2UsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhdXRob3JpemUtY2xpZW50LWZhaWx1cmUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVGYWlsdXJlKG1lc3NhZ2UudGV4dCwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2hhbmRsZUZhaWx1cmUoZXJyb3JNZXNzYWdlLCBvbkVycm9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5faWRwV2luZG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgICAgb25FcnJvciA9PT0gbnVsbCB8fCBvbkVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2lkcFdpbmRvdztcbiAgICB9XG4gICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIGxvZ291dChvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXdhaXQgX2RlbGV0ZVN0b3JhZ2UodGhpcy5fc3RvcmFnZSk7XG4gICAgICAgIC8vIFJlc2V0IHRoaXMgYXV0aCBjbGllbnQgdG8gYSBub24tYXV0aGVudGljYXRlZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5faWRlbnRpdHkgPSBuZXcgQW5vbnltb3VzSWRlbnRpdHkoKTtcbiAgICAgICAgdGhpcy5fY2hhaW4gPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXR1cm5Ubykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBvcHRpb25zLnJldHVyblRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBvcHRpb25zLnJldHVyblRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gX2RlbGV0ZVN0b3JhZ2Uoc3RvcmFnZSkge1xuICAgIGF3YWl0IHN0b3JhZ2UucmVtb3ZlKEtFWV9TVE9SQUdFX0tFWSk7XG4gICAgYXdhaXQgc3RvcmFnZS5yZW1vdmUoS0VZX1NUT1JBR0VfREVMRUdBVElPTik7XG4gICAgYXdhaXQgc3RvcmFnZS5yZW1vdmUoS0VZX1ZFQ1RPUik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/auth-client/lib/esm/index.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/auth-client/lib/esm/storage.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/@dfinity/auth-client/lib/esm/storage.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DB_VERSION: function() { return /* binding */ DB_VERSION; },\n/* harmony export */   IdbStorage: function() { return /* binding */ IdbStorage; },\n/* harmony export */   KEY_STORAGE_DELEGATION: function() { return /* binding */ KEY_STORAGE_DELEGATION; },\n/* harmony export */   KEY_STORAGE_KEY: function() { return /* binding */ KEY_STORAGE_KEY; },\n/* harmony export */   KEY_VECTOR: function() { return /* binding */ KEY_VECTOR; },\n/* harmony export */   LocalStorage: function() { return /* binding */ LocalStorage; },\n/* harmony export */   isBrowser: function() { return /* binding */ isBrowser; }\n/* harmony export */ });\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./db */ \"../../../node_modules/@dfinity/auth-client/lib/esm/db.js\");\n\nconst KEY_STORAGE_KEY = 'identity';\nconst KEY_STORAGE_DELEGATION = 'delegation';\nconst KEY_VECTOR = 'iv';\n// Increment if any fields are modified\nconst DB_VERSION = 1;\nconst isBrowser = typeof window !== 'undefined';\n/**\n * Legacy implementation of AuthClientStorage, for use where IndexedDb is not available\n */\nclass LocalStorage {\n    constructor(prefix = 'ic-', _localStorage) {\n        this.prefix = prefix;\n        this._localStorage = _localStorage;\n    }\n    get(key) {\n        return Promise.resolve(this._getLocalStorage().getItem(this.prefix + key));\n    }\n    set(key, value) {\n        this._getLocalStorage().setItem(this.prefix + key, value);\n        return Promise.resolve();\n    }\n    remove(key) {\n        this._getLocalStorage().removeItem(this.prefix + key);\n        return Promise.resolve();\n    }\n    _getLocalStorage() {\n        if (this._localStorage) {\n            return this._localStorage;\n        }\n        const ls = typeof window === 'undefined'\n            ? typeof __webpack_require__.g === 'undefined'\n                ? typeof self === 'undefined'\n                    ? undefined\n                    : self.localStorage\n                : __webpack_require__.g.localStorage\n            : window.localStorage;\n        if (!ls) {\n            throw new Error('Could not find local storage.');\n        }\n        return ls;\n    }\n}\n/**\n * IdbStorage is an interface for simple storage of string key-value pairs built on {@link IdbKeyVal}\n *\n * It replaces {@link LocalStorage}\n * @see implements {@link AuthClientStorage}\n */\nclass IdbStorage {\n    get _db() {\n        return new Promise(resolve => {\n            if (this.initializedDb) {\n                resolve(this.initializedDb);\n                return;\n            }\n            _db__WEBPACK_IMPORTED_MODULE_0__.IdbKeyVal.create({ version: DB_VERSION }).then(db => {\n                this.initializedDb = db;\n                resolve(db);\n            });\n        });\n    }\n    async get(key) {\n        const db = await this._db;\n        return await db.get(key);\n        // return (await db.get<string>(key)) ?? null;\n    }\n    async set(key, value) {\n        const db = await this._db;\n        await db.set(key, value);\n    }\n    async remove(key) {\n        const db = await this._db;\n        await db.remove(key);\n    }\n}\n//# sourceMappingURL=storage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2F1dGgtY2xpZW50L2xpYi9lc20vc3RvcmFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFpQztBQUMxQjtBQUNBO0FBQ0E7QUFDUDtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQSxnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBDQUFTLFVBQVUscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvYXV0aC1jbGllbnQvbGliL2VzbS9zdG9yYWdlLmpzPzU1NTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSWRiS2V5VmFsIH0gZnJvbSAnLi9kYic7XG5leHBvcnQgY29uc3QgS0VZX1NUT1JBR0VfS0VZID0gJ2lkZW50aXR5JztcbmV4cG9ydCBjb25zdCBLRVlfU1RPUkFHRV9ERUxFR0FUSU9OID0gJ2RlbGVnYXRpb24nO1xuZXhwb3J0IGNvbnN0IEtFWV9WRUNUT1IgPSAnaXYnO1xuLy8gSW5jcmVtZW50IGlmIGFueSBmaWVsZHMgYXJlIG1vZGlmaWVkXG5leHBvcnQgY29uc3QgREJfVkVSU0lPTiA9IDE7XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4vKipcbiAqIExlZ2FjeSBpbXBsZW1lbnRhdGlvbiBvZiBBdXRoQ2xpZW50U3RvcmFnZSwgZm9yIHVzZSB3aGVyZSBJbmRleGVkRGIgaXMgbm90IGF2YWlsYWJsZVxuICovXG5leHBvcnQgY2xhc3MgTG9jYWxTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXggPSAnaWMtJywgX2xvY2FsU3RvcmFnZSkge1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgdGhpcy5fbG9jYWxTdG9yYWdlID0gX2xvY2FsU3RvcmFnZTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2dldExvY2FsU3RvcmFnZSgpLmdldEl0ZW0odGhpcy5wcmVmaXggKyBrZXkpKTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKCkuc2V0SXRlbSh0aGlzLnByZWZpeCArIGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAgdGhpcy5fZ2V0TG9jYWxTdG9yYWdlKCkucmVtb3ZlSXRlbSh0aGlzLnByZWZpeCArIGtleSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgX2dldExvY2FsU3RvcmFnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsU3RvcmFnZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBscyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IHR5cGVvZiBnbG9iYWwgPT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmxvY2FsU3RvcmFnZVxuICAgICAgICAgICAgICAgIDogZ2xvYmFsLmxvY2FsU3RvcmFnZVxuICAgICAgICAgICAgOiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICBpZiAoIWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGxvY2FsIHN0b3JhZ2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxzO1xuICAgIH1cbn1cbi8qKlxuICogSWRiU3RvcmFnZSBpcyBhbiBpbnRlcmZhY2UgZm9yIHNpbXBsZSBzdG9yYWdlIG9mIHN0cmluZyBrZXktdmFsdWUgcGFpcnMgYnVpbHQgb24ge0BsaW5rIElkYktleVZhbH1cbiAqXG4gKiBJdCByZXBsYWNlcyB7QGxpbmsgTG9jYWxTdG9yYWdlfVxuICogQHNlZSBpbXBsZW1lbnRzIHtAbGluayBBdXRoQ2xpZW50U3RvcmFnZX1cbiAqL1xuZXhwb3J0IGNsYXNzIElkYlN0b3JhZ2Uge1xuICAgIGdldCBfZGIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkRGIpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuaW5pdGlhbGl6ZWREYik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSWRiS2V5VmFsLmNyZWF0ZSh7IHZlcnNpb246IERCX1ZFUlNJT04gfSkudGhlbihkYiA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZERiID0gZGI7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShkYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLl9kYjtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRiLmdldChrZXkpO1xuICAgICAgICAvLyByZXR1cm4gKGF3YWl0IGRiLmdldDxzdHJpbmc+KGtleSkpID8/IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5fZGI7XG4gICAgICAgIGF3YWl0IGRiLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlKGtleSkge1xuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuX2RiO1xuICAgICAgICBhd2FpdCBkYi5yZW1vdmUoa2V5KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdG9yYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/auth-client/lib/esm/storage.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/candid/lib/esm/candid-core.js":
/*!********************************************************************!*\
  !*** ../../../node_modules/@dfinity/candid/lib/esm/candid-core.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InputBox: function() { return /* binding */ InputBox; },\n/* harmony export */   InputForm: function() { return /* binding */ InputForm; },\n/* harmony export */   OptionForm: function() { return /* binding */ OptionForm; },\n/* harmony export */   RecordForm: function() { return /* binding */ RecordForm; },\n/* harmony export */   TupleForm: function() { return /* binding */ TupleForm; },\n/* harmony export */   VariantForm: function() { return /* binding */ VariantForm; },\n/* harmony export */   VecForm: function() { return /* binding */ VecForm; }\n/* harmony export */ });\nclass InputBox {\n    constructor(idl, ui) {\n        this.idl = idl;\n        this.ui = ui;\n        this.label = null;\n        this.value = undefined;\n        const status = document.createElement('span');\n        status.className = 'status';\n        this.status = status;\n        if (ui.input) {\n            ui.input.addEventListener('blur', () => {\n                if (ui.input.value === '') {\n                    return;\n                }\n                this.parse();\n            });\n            ui.input.addEventListener('input', () => {\n                status.style.display = 'none';\n                ui.input.classList.remove('reject');\n            });\n        }\n    }\n    isRejected() {\n        return this.value === undefined;\n    }\n    parse(config = {}) {\n        if (this.ui.form) {\n            const value = this.ui.form.parse(config);\n            this.value = value;\n            return value;\n        }\n        if (this.ui.input) {\n            const input = this.ui.input;\n            try {\n                const value = this.ui.parse(this.idl, config, input.value);\n                if (!this.idl.covariant(value)) {\n                    throw new Error(`${input.value} is not of type ${this.idl.display()}`);\n                }\n                this.status.style.display = 'none';\n                this.value = value;\n                return value;\n            }\n            catch (err) {\n                input.classList.add('reject');\n                this.status.style.display = 'block';\n                this.status.innerHTML = 'InputError: ' + err.message;\n                this.value = undefined;\n                return undefined;\n            }\n        }\n        return null;\n    }\n    render(dom) {\n        const container = document.createElement('span');\n        if (this.label) {\n            const label = document.createElement('label');\n            label.innerText = this.label;\n            container.appendChild(label);\n        }\n        if (this.ui.input) {\n            container.appendChild(this.ui.input);\n            container.appendChild(this.status);\n        }\n        if (this.ui.form) {\n            this.ui.form.render(container);\n        }\n        dom.appendChild(container);\n    }\n}\nclass InputForm {\n    constructor(ui) {\n        this.ui = ui;\n        this.form = [];\n    }\n    renderForm(dom) {\n        if (this.ui.container) {\n            this.form.forEach(e => e.render(this.ui.container));\n            dom.appendChild(this.ui.container);\n        }\n        else {\n            this.form.forEach(e => e.render(dom));\n        }\n    }\n    render(dom) {\n        if (this.ui.open && this.ui.event) {\n            dom.appendChild(this.ui.open);\n            const form = this;\n            // eslint-disable-next-line\n            form.ui.open.addEventListener(form.ui.event, () => {\n                // Remove old form\n                if (form.ui.container) {\n                    form.ui.container.innerHTML = '';\n                }\n                else {\n                    const oldContainer = form.ui.open.nextElementSibling;\n                    if (oldContainer) {\n                        oldContainer.parentNode.removeChild(oldContainer);\n                    }\n                }\n                // Render form\n                form.generateForm();\n                form.renderForm(dom);\n            });\n        }\n        else {\n            this.generateForm();\n            this.renderForm(dom);\n        }\n    }\n}\nclass RecordForm extends InputForm {\n    constructor(fields, ui) {\n        super(ui);\n        this.fields = fields;\n        this.ui = ui;\n    }\n    generateForm() {\n        this.form = this.fields.map(([key, type]) => {\n            const input = this.ui.render(type);\n            // eslint-disable-next-line\n            if (this.ui.labelMap && this.ui.labelMap.hasOwnProperty(key)) {\n                input.label = this.ui.labelMap[key] + ' ';\n            }\n            else {\n                input.label = key + ' ';\n            }\n            return input;\n        });\n    }\n    parse(config) {\n        const v = {};\n        this.fields.forEach(([key, _], i) => {\n            const value = this.form[i].parse(config);\n            v[key] = value;\n        });\n        if (this.form.some(input => input.isRejected())) {\n            return undefined;\n        }\n        return v;\n    }\n}\nclass TupleForm extends InputForm {\n    constructor(components, ui) {\n        super(ui);\n        this.components = components;\n        this.ui = ui;\n    }\n    generateForm() {\n        this.form = this.components.map(type => {\n            const input = this.ui.render(type);\n            return input;\n        });\n    }\n    parse(config) {\n        const v = [];\n        this.components.forEach((_, i) => {\n            const value = this.form[i].parse(config);\n            v.push(value);\n        });\n        if (this.form.some(input => input.isRejected())) {\n            return undefined;\n        }\n        return v;\n    }\n}\nclass VariantForm extends InputForm {\n    constructor(fields, ui) {\n        super(ui);\n        this.fields = fields;\n        this.ui = ui;\n    }\n    generateForm() {\n        const index = this.ui.open.selectedIndex;\n        const [_, type] = this.fields[index];\n        const variant = this.ui.render(type);\n        this.form = [variant];\n    }\n    parse(config) {\n        const select = this.ui.open;\n        const selected = select.options[select.selectedIndex].value;\n        const value = this.form[0].parse(config);\n        if (value === undefined) {\n            return undefined;\n        }\n        const v = {};\n        v[selected] = value;\n        return v;\n    }\n}\nclass OptionForm extends InputForm {\n    constructor(ty, ui) {\n        super(ui);\n        this.ty = ty;\n        this.ui = ui;\n    }\n    generateForm() {\n        if (this.ui.open.checked) {\n            const opt = this.ui.render(this.ty);\n            this.form = [opt];\n        }\n        else {\n            this.form = [];\n        }\n    }\n    parse(config) {\n        if (this.form.length === 0) {\n            return [];\n        }\n        else {\n            const value = this.form[0].parse(config);\n            if (value === undefined) {\n                return undefined;\n            }\n            return [value];\n        }\n    }\n}\nclass VecForm extends InputForm {\n    constructor(ty, ui) {\n        super(ui);\n        this.ty = ty;\n        this.ui = ui;\n    }\n    generateForm() {\n        const len = +this.ui.open.value;\n        this.form = [];\n        for (let i = 0; i < len; i++) {\n            const t = this.ui.render(this.ty);\n            this.form.push(t);\n        }\n    }\n    parse(config) {\n        const value = this.form.map(input => {\n            return input.parse(config);\n        });\n        if (this.form.some(input => input.isRejected())) {\n            return undefined;\n        }\n        return value;\n    }\n}\n//# sourceMappingURL=candid-core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL2NhbmRpZC1jb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYSxpQkFBaUIsbUJBQW1CO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL2NhbmRpZC1jb3JlLmpzPzQ0NDIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIElucHV0Qm94IHtcbiAgICBjb25zdHJ1Y3RvcihpZGwsIHVpKSB7XG4gICAgICAgIHRoaXMuaWRsID0gaWRsO1xuICAgICAgICB0aGlzLnVpID0gdWk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIHN0YXR1cy5jbGFzc05hbWUgPSAnc3RhdHVzJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIGlmICh1aS5pbnB1dCkge1xuICAgICAgICAgICAgdWkuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodWkuaW5wdXQudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1aS5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB1aS5pbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCdyZWplY3QnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzUmVqZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHBhcnNlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLnVpLmZvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy51aS5mb3JtLnBhcnNlKGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudWkuaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy51aS5pbnB1dDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnVpLnBhcnNlKHRoaXMuaWRsLCBjb25maWcsIGlucHV0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaWRsLmNvdmFyaWFudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2lucHV0LnZhbHVlfSBpcyBub3Qgb2YgdHlwZSAke3RoaXMuaWRsLmRpc3BsYXkoKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ3JlamVjdCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzLmlubmVySFRNTCA9ICdJbnB1dEVycm9yOiAnICsgZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZW5kZXIoZG9tKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgICAgIGxhYmVsLmlubmVyVGV4dCA9IHRoaXMubGFiZWw7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVpLmlucHV0KSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy51aS5pbnB1dCk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVpLmZvcm0pIHtcbiAgICAgICAgICAgIHRoaXMudWkuZm9ybS5yZW5kZXIoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBkb20uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSW5wdXRGb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcih1aSkge1xuICAgICAgICB0aGlzLnVpID0gdWk7XG4gICAgICAgIHRoaXMuZm9ybSA9IFtdO1xuICAgIH1cbiAgICByZW5kZXJGb3JtKGRvbSkge1xuICAgICAgICBpZiAodGhpcy51aS5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybS5mb3JFYWNoKGUgPT4gZS5yZW5kZXIodGhpcy51aS5jb250YWluZXIpKTtcbiAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZCh0aGlzLnVpLmNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvcm0uZm9yRWFjaChlID0+IGUucmVuZGVyKGRvbSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcihkb20pIHtcbiAgICAgICAgaWYgKHRoaXMudWkub3BlbiAmJiB0aGlzLnVpLmV2ZW50KSB7XG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQodGhpcy51aS5vcGVuKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm0gPSB0aGlzO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBmb3JtLnVpLm9wZW4uYWRkRXZlbnRMaXN0ZW5lcihmb3JtLnVpLmV2ZW50LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBmb3JtXG4gICAgICAgICAgICAgICAgaWYgKGZvcm0udWkuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0udWkuY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkQ29udGFpbmVyID0gZm9ybS51aS5vcGVuLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob2xkQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW5kZXIgZm9ybVxuICAgICAgICAgICAgICAgIGZvcm0uZ2VuZXJhdGVGb3JtKCk7XG4gICAgICAgICAgICAgICAgZm9ybS5yZW5kZXJGb3JtKGRvbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVGb3JtKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckZvcm0oZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSZWNvcmRGb3JtIGV4dGVuZHMgSW5wdXRGb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHVpKSB7XG4gICAgICAgIHN1cGVyKHVpKTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHRoaXMudWkgPSB1aTtcbiAgICB9XG4gICAgZ2VuZXJhdGVGb3JtKCkge1xuICAgICAgICB0aGlzLmZvcm0gPSB0aGlzLmZpZWxkcy5tYXAoKFtrZXksIHR5cGVdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMudWkucmVuZGVyKHR5cGUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBpZiAodGhpcy51aS5sYWJlbE1hcCAmJiB0aGlzLnVpLmxhYmVsTWFwLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5sYWJlbCA9IHRoaXMudWkubGFiZWxNYXBba2V5XSArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0LmxhYmVsID0ga2V5ICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2UoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHYgPSB7fTtcbiAgICAgICAgdGhpcy5maWVsZHMuZm9yRWFjaCgoW2tleSwgX10sIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5mb3JtW2ldLnBhcnNlKGNvbmZpZyk7XG4gICAgICAgICAgICB2W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmZvcm0uc29tZShpbnB1dCA9PiBpbnB1dC5pc1JlamVjdGVkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUdXBsZUZvcm0gZXh0ZW5kcyBJbnB1dEZvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudHMsIHVpKSB7XG4gICAgICAgIHN1cGVyKHVpKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgdGhpcy51aSA9IHVpO1xuICAgIH1cbiAgICBnZW5lcmF0ZUZvcm0oKSB7XG4gICAgICAgIHRoaXMuZm9ybSA9IHRoaXMuY29tcG9uZW50cy5tYXAodHlwZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMudWkucmVuZGVyKHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2UoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHYgPSBbXTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5mb3JtW2ldLnBhcnNlKGNvbmZpZyk7XG4gICAgICAgICAgICB2LnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZm9ybS5zb21lKGlucHV0ID0+IGlucHV0LmlzUmVqZWN0ZWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFZhcmlhbnRGb3JtIGV4dGVuZHMgSW5wdXRGb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHVpKSB7XG4gICAgICAgIHN1cGVyKHVpKTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHRoaXMudWkgPSB1aTtcbiAgICB9XG4gICAgZ2VuZXJhdGVGb3JtKCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudWkub3Blbi5zZWxlY3RlZEluZGV4O1xuICAgICAgICBjb25zdCBbXywgdHlwZV0gPSB0aGlzLmZpZWxkc1tpbmRleF07XG4gICAgICAgIGNvbnN0IHZhcmlhbnQgPSB0aGlzLnVpLnJlbmRlcih0eXBlKTtcbiAgICAgICAgdGhpcy5mb3JtID0gW3ZhcmlhbnRdO1xuICAgIH1cbiAgICBwYXJzZShjb25maWcpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ID0gdGhpcy51aS5vcGVuO1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHNlbGVjdC5vcHRpb25zW3NlbGVjdC5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmZvcm1bMF0ucGFyc2UoY29uZmlnKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdiA9IHt9O1xuICAgICAgICB2W3NlbGVjdGVkXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT3B0aW9uRm9ybSBleHRlbmRzIElucHV0Rm9ybSB7XG4gICAgY29uc3RydWN0b3IodHksIHVpKSB7XG4gICAgICAgIHN1cGVyKHVpKTtcbiAgICAgICAgdGhpcy50eSA9IHR5O1xuICAgICAgICB0aGlzLnVpID0gdWk7XG4gICAgfVxuICAgIGdlbmVyYXRlRm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMudWkub3Blbi5jaGVja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBvcHQgPSB0aGlzLnVpLnJlbmRlcih0aGlzLnR5KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybSA9IFtvcHRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3JtID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2UoY29uZmlnKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcm0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZm9ybVswXS5wYXJzZShjb25maWcpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVmVjRm9ybSBleHRlbmRzIElucHV0Rm9ybSB7XG4gICAgY29uc3RydWN0b3IodHksIHVpKSB7XG4gICAgICAgIHN1cGVyKHVpKTtcbiAgICAgICAgdGhpcy50eSA9IHR5O1xuICAgICAgICB0aGlzLnVpID0gdWk7XG4gICAgfVxuICAgIGdlbmVyYXRlRm9ybSgpIHtcbiAgICAgICAgY29uc3QgbGVuID0gK3RoaXMudWkub3Blbi52YWx1ZTtcbiAgICAgICAgdGhpcy5mb3JtID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLnVpLnJlbmRlcih0aGlzLnR5KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybS5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlKGNvbmZpZykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZm9ybS5tYXAoaW5wdXQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnBhcnNlKGNvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5mb3JtLnNvbWUoaW5wdXQgPT4gaW5wdXQuaXNSZWplY3RlZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuZGlkLWNvcmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/candid/lib/esm/candid-core.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/candid/lib/esm/candid-ui.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/@dfinity/candid/lib/esm/candid-ui.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Render: function() { return /* binding */ Render; },\n/* harmony export */   inputBox: function() { return /* binding */ inputBox; },\n/* harmony export */   optForm: function() { return /* binding */ optForm; },\n/* harmony export */   recordForm: function() { return /* binding */ recordForm; },\n/* harmony export */   renderInput: function() { return /* binding */ renderInput; },\n/* harmony export */   renderValue: function() { return /* binding */ renderValue; },\n/* harmony export */   tupleForm: function() { return /* binding */ tupleForm; },\n/* harmony export */   variantForm: function() { return /* binding */ variantForm; },\n/* harmony export */   vecForm: function() { return /* binding */ vecForm; }\n/* harmony export */ });\n/* harmony import */ var _idl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./idl */ \"../../../node_modules/@dfinity/candid/lib/esm/idl.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/principal */ \"../../../node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _candid_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./candid-core */ \"../../../node_modules/@dfinity/candid/lib/esm/candid-core.js\");\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n\n\nconst InputConfig = { parse: parsePrimitive };\nconst FormConfig = { render: renderInput };\nconst inputBox = (t, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.InputBox(t, Object.assign(Object.assign({}, InputConfig), config));\n};\nconst recordForm = (fields, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.RecordForm(fields, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst tupleForm = (components, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.TupleForm(components, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst variantForm = (fields, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.VariantForm(fields, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst optForm = (ty, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.OptionForm(ty, Object.assign(Object.assign({}, FormConfig), config));\n};\nconst vecForm = (ty, config) => {\n    return new _candid_core__WEBPACK_IMPORTED_MODULE_2__.VecForm(ty, Object.assign(Object.assign({}, FormConfig), config));\n};\nclass Render extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitType(t, d) {\n        const input = document.createElement('input');\n        input.classList.add('argument');\n        input.placeholder = t.display();\n        return inputBox(t, { input });\n    }\n    visitNull(t, d) {\n        return inputBox(t, {});\n    }\n    visitRecord(t, fields, d) {\n        let config = {};\n        if (fields.length > 1) {\n            const container = document.createElement('div');\n            container.classList.add('popup-form');\n            config = { container };\n        }\n        const form = recordForm(fields, config);\n        return inputBox(t, { form });\n    }\n    visitTuple(t, components, d) {\n        let config = {};\n        if (components.length > 1) {\n            const container = document.createElement('div');\n            container.classList.add('popup-form');\n            config = { container };\n        }\n        const form = tupleForm(components, config);\n        return inputBox(t, { form });\n    }\n    visitVariant(t, fields, d) {\n        const select = document.createElement('select');\n        for (const [key, type] of fields) {\n            const option = new Option(key);\n            select.add(option);\n        }\n        select.selectedIndex = -1;\n        select.classList.add('open');\n        const config = { open: select, event: 'change' };\n        const form = variantForm(fields, config);\n        return inputBox(t, { form });\n    }\n    visitOpt(t, ty, d) {\n        const checkbox = document.createElement('input');\n        checkbox.type = 'checkbox';\n        checkbox.classList.add('open');\n        const form = optForm(ty, { open: checkbox, event: 'change' });\n        return inputBox(t, { form });\n    }\n    visitVec(t, ty, d) {\n        const len = document.createElement('input');\n        len.type = 'number';\n        len.min = '0';\n        len.max = '100';\n        len.style.width = '8rem';\n        len.placeholder = 'len';\n        len.classList.add('open');\n        const container = document.createElement('div');\n        container.classList.add('popup-form');\n        const form = vecForm(ty, { open: len, event: 'change', container });\n        return inputBox(t, { form });\n    }\n    visitRec(t, ty, d) {\n        return renderInput(ty);\n    }\n}\nclass Parse extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitNull(t, v) {\n        return null;\n    }\n    visitBool(t, v) {\n        if (v === 'true') {\n            return true;\n        }\n        if (v === 'false') {\n            return false;\n        }\n        throw new Error(`Cannot parse ${v} as boolean`);\n    }\n    visitText(t, v) {\n        return v;\n    }\n    visitFloat(t, v) {\n        return parseFloat(v);\n    }\n    visitFixedInt(t, v) {\n        if (t._bits <= 32) {\n            return parseInt(v, 10);\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    visitFixedNat(t, v) {\n        if (t._bits <= 32) {\n            return parseInt(v, 10);\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    visitNumber(t, v) {\n        return BigInt(v);\n    }\n    visitPrincipal(t, v) {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(v);\n    }\n    visitService(t, v) {\n        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(v);\n    }\n    visitFunc(t, v) {\n        const x = v.split('.', 2);\n        return [_dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(x[0]), x[1]];\n    }\n}\nclass Random extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitNull(t, v) {\n        return null;\n    }\n    visitBool(t, v) {\n        return Math.random() < 0.5;\n    }\n    visitText(t, v) {\n        return Math.random().toString(36).substring(6);\n    }\n    visitFloat(t, v) {\n        return Math.random();\n    }\n    visitInt(t, v) {\n        return BigInt(this.generateNumber(true));\n    }\n    visitNat(t, v) {\n        return BigInt(this.generateNumber(false));\n    }\n    visitFixedInt(t, v) {\n        const x = this.generateNumber(true);\n        if (t._bits <= 32) {\n            return x;\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    visitFixedNat(t, v) {\n        const x = this.generateNumber(false);\n        if (t._bits <= 32) {\n            return x;\n        }\n        else {\n            return BigInt(v);\n        }\n    }\n    generateNumber(signed) {\n        const num = Math.floor(Math.random() * 100);\n        if (signed && Math.random() < 0.5) {\n            return -num;\n        }\n        else {\n            return num;\n        }\n    }\n}\nfunction parsePrimitive(t, config, d) {\n    if (config.random && d === '') {\n        return t.accept(new Random(), d);\n    }\n    else {\n        return t.accept(new Parse(), d);\n    }\n}\n/**\n *\n * @param t an IDL type\n * @returns an input for that type\n */\nfunction renderInput(t) {\n    return t.accept(new Render(), null);\n}\n/**\n *\n * @param t an IDL Type\n * @param input an InputBox\n * @param value any\n * @returns rendering that value to the provided input\n */\nfunction renderValue(t, input, value) {\n    return t.accept(new RenderValue(), { input, value });\n}\nclass RenderValue extends _idl__WEBPACK_IMPORTED_MODULE_0__.Visitor {\n    visitType(t, d) {\n        d.input.ui.input.value = t.valueToString(d.value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    visitNull(t, d) { }\n    visitText(t, d) {\n        d.input.ui.input.value = d.value;\n    }\n    visitRec(t, ty, d) {\n        renderValue(ty, d.input, d.value);\n    }\n    visitOpt(t, ty, d) {\n        if (d.value.length === 0) {\n            return;\n        }\n        else {\n            const form = d.input.ui.form;\n            const open = form.ui.open;\n            open.checked = true;\n            open.dispatchEvent(new Event(form.ui.event));\n            renderValue(ty, form.form[0], d.value[0]);\n        }\n    }\n    visitRecord(t, fields, d) {\n        const form = d.input.ui.form;\n        fields.forEach(([key, type], i) => {\n            renderValue(type, form.form[i], d.value[key]);\n        });\n    }\n    visitTuple(t, components, d) {\n        const form = d.input.ui.form;\n        components.forEach((type, i) => {\n            renderValue(type, form.form[i], d.value[i]);\n        });\n    }\n    visitVariant(t, fields, d) {\n        const form = d.input.ui.form;\n        const selected = Object.entries(d.value)[0];\n        fields.forEach(([key, type], i) => {\n            if (key === selected[0]) {\n                const open = form.ui.open;\n                open.selectedIndex = i;\n                open.dispatchEvent(new Event(form.ui.event));\n                renderValue(type, form.form[0], selected[1]);\n            }\n        });\n    }\n    visitVec(t, ty, d) {\n        const form = d.input.ui.form;\n        const len = d.value.length;\n        const open = form.ui.open;\n        open.value = len;\n        open.dispatchEvent(new Event(form.ui.event));\n        d.value.forEach((v, i) => {\n            renderValue(ty, form.form[i], v);\n        });\n    }\n}\n//# sourceMappingURL=candid-ui.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL2NhbmRpZC11aS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQzZCO0FBQ2tCO0FBQ1g7QUFDcEMsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNkO0FBQ1AsZUFBZSxrREFBVyxrQ0FBa0M7QUFDNUQ7QUFDTztBQUNQLGVBQWUsb0RBQWEsdUNBQXVDO0FBQ25FO0FBQ087QUFDUCxlQUFlLG1EQUFZLDJDQUEyQztBQUN0RTtBQUNPO0FBQ1AsZUFBZSxxREFBYyx1Q0FBdUM7QUFDcEU7QUFDTztBQUNQLGVBQWUsb0RBQWEsbUNBQW1DO0FBQy9EO0FBQ087QUFDUCxlQUFlLGlEQUFVLG1DQUFtQztBQUM1RDtBQUNPLHFCQUFxQix5Q0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUNBQWlDO0FBQ3BFLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUNBQXVDO0FBQzFFLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFTO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlLHlEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBUztBQUN6QjtBQUNBO0FBQ0EscUJBQXFCLHlDQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQSwwQkFBMEIseUNBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vY2FuZGlkLXVpLmpzPzljMjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5pbXBvcnQgKiBhcyBJREwgZnJvbSAnLi9pZGwnO1xuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSAnQGRmaW5pdHkvcHJpbmNpcGFsJztcbmltcG9ydCAqIGFzIFVJIGZyb20gJy4vY2FuZGlkLWNvcmUnO1xuY29uc3QgSW5wdXRDb25maWcgPSB7IHBhcnNlOiBwYXJzZVByaW1pdGl2ZSB9O1xuY29uc3QgRm9ybUNvbmZpZyA9IHsgcmVuZGVyOiByZW5kZXJJbnB1dCB9O1xuZXhwb3J0IGNvbnN0IGlucHV0Qm94ID0gKHQsIGNvbmZpZykgPT4ge1xuICAgIHJldHVybiBuZXcgVUkuSW5wdXRCb3godCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBJbnB1dENvbmZpZyksIGNvbmZpZykpO1xufTtcbmV4cG9ydCBjb25zdCByZWNvcmRGb3JtID0gKGZpZWxkcywgY29uZmlnKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBVSS5SZWNvcmRGb3JtKGZpZWxkcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBGb3JtQ29uZmlnKSwgY29uZmlnKSk7XG59O1xuZXhwb3J0IGNvbnN0IHR1cGxlRm9ybSA9IChjb21wb25lbnRzLCBjb25maWcpID0+IHtcbiAgICByZXR1cm4gbmV3IFVJLlR1cGxlRm9ybShjb21wb25lbnRzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEZvcm1Db25maWcpLCBjb25maWcpKTtcbn07XG5leHBvcnQgY29uc3QgdmFyaWFudEZvcm0gPSAoZmllbGRzLCBjb25maWcpID0+IHtcbiAgICByZXR1cm4gbmV3IFVJLlZhcmlhbnRGb3JtKGZpZWxkcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBGb3JtQ29uZmlnKSwgY29uZmlnKSk7XG59O1xuZXhwb3J0IGNvbnN0IG9wdEZvcm0gPSAodHksIGNvbmZpZykgPT4ge1xuICAgIHJldHVybiBuZXcgVUkuT3B0aW9uRm9ybSh0eSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBGb3JtQ29uZmlnKSwgY29uZmlnKSk7XG59O1xuZXhwb3J0IGNvbnN0IHZlY0Zvcm0gPSAodHksIGNvbmZpZykgPT4ge1xuICAgIHJldHVybiBuZXcgVUkuVmVjRm9ybSh0eSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBGb3JtQ29uZmlnKSwgY29uZmlnKSk7XG59O1xuZXhwb3J0IGNsYXNzIFJlbmRlciBleHRlbmRzIElETC5WaXNpdG9yIHtcbiAgICB2aXNpdFR5cGUodCwgZCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2FyZ3VtZW50Jyk7XG4gICAgICAgIGlucHV0LnBsYWNlaG9sZGVyID0gdC5kaXNwbGF5KCk7XG4gICAgICAgIHJldHVybiBpbnB1dEJveCh0LCB7IGlucHV0IH0pO1xuICAgIH1cbiAgICB2aXNpdE51bGwodCwgZCkge1xuICAgICAgICByZXR1cm4gaW5wdXRCb3godCwge30pO1xuICAgIH1cbiAgICB2aXNpdFJlY29yZCh0LCBmaWVsZHMsIGQpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHt9O1xuICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3BvcHVwLWZvcm0nKTtcbiAgICAgICAgICAgIGNvbmZpZyA9IHsgY29udGFpbmVyIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybSA9IHJlY29yZEZvcm0oZmllbGRzLCBjb25maWcpO1xuICAgICAgICByZXR1cm4gaW5wdXRCb3godCwgeyBmb3JtIH0pO1xuICAgIH1cbiAgICB2aXNpdFR1cGxlKHQsIGNvbXBvbmVudHMsIGQpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHt9O1xuICAgICAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdwb3B1cC1mb3JtJyk7XG4gICAgICAgICAgICBjb25maWcgPSB7IGNvbnRhaW5lciB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm0gPSB0dXBsZUZvcm0oY29tcG9uZW50cywgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGlucHV0Qm94KHQsIHsgZm9ybSB9KTtcbiAgICB9XG4gICAgdmlzaXRWYXJpYW50KHQsIGZpZWxkcywgZCkge1xuICAgICAgICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB0eXBlXSBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IG5ldyBPcHRpb24oa2V5KTtcbiAgICAgICAgICAgIHNlbGVjdC5hZGQob3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICBzZWxlY3QuY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7IG9wZW46IHNlbGVjdCwgZXZlbnQ6ICdjaGFuZ2UnIH07XG4gICAgICAgIGNvbnN0IGZvcm0gPSB2YXJpYW50Rm9ybShmaWVsZHMsIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiBpbnB1dEJveCh0LCB7IGZvcm0gfSk7XG4gICAgfVxuICAgIHZpc2l0T3B0KHQsIHR5LCBkKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgY2hlY2tib3gudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgIGNoZWNrYm94LmNsYXNzTGlzdC5hZGQoJ29wZW4nKTtcbiAgICAgICAgY29uc3QgZm9ybSA9IG9wdEZvcm0odHksIHsgb3BlbjogY2hlY2tib3gsIGV2ZW50OiAnY2hhbmdlJyB9KTtcbiAgICAgICAgcmV0dXJuIGlucHV0Qm94KHQsIHsgZm9ybSB9KTtcbiAgICB9XG4gICAgdmlzaXRWZWModCwgdHksIGQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgbGVuLnR5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgbGVuLm1pbiA9ICcwJztcbiAgICAgICAgbGVuLm1heCA9ICcxMDAnO1xuICAgICAgICBsZW4uc3R5bGUud2lkdGggPSAnOHJlbSc7XG4gICAgICAgIGxlbi5wbGFjZWhvbGRlciA9ICdsZW4nO1xuICAgICAgICBsZW4uY2xhc3NMaXN0LmFkZCgnb3BlbicpO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3BvcHVwLWZvcm0nKTtcbiAgICAgICAgY29uc3QgZm9ybSA9IHZlY0Zvcm0odHksIHsgb3BlbjogbGVuLCBldmVudDogJ2NoYW5nZScsIGNvbnRhaW5lciB9KTtcbiAgICAgICAgcmV0dXJuIGlucHV0Qm94KHQsIHsgZm9ybSB9KTtcbiAgICB9XG4gICAgdmlzaXRSZWModCwgdHksIGQpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcklucHV0KHR5KTtcbiAgICB9XG59XG5jbGFzcyBQYXJzZSBleHRlbmRzIElETC5WaXNpdG9yIHtcbiAgICB2aXNpdE51bGwodCwgdikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRCb29sKHQsIHYpIHtcbiAgICAgICAgaWYgKHYgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSAke3Z9IGFzIGJvb2xlYW5gKTtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHZpc2l0RmxvYXQodCwgdikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgICB9XG4gICAgdmlzaXRGaXhlZEludCh0LCB2KSB7XG4gICAgICAgIGlmICh0Ll9iaXRzIDw9IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEZpeGVkTmF0KHQsIHYpIHtcbiAgICAgICAgaWYgKHQuX2JpdHMgPD0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh2LCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0TnVtYmVyKHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh2KTtcbiAgICB9XG4gICAgdmlzaXRQcmluY2lwYWwodCwgdikge1xuICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmZyb21UZXh0KHYpO1xuICAgIH1cbiAgICB2aXNpdFNlcnZpY2UodCwgdikge1xuICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmZyb21UZXh0KHYpO1xuICAgIH1cbiAgICB2aXNpdEZ1bmModCwgdikge1xuICAgICAgICBjb25zdCB4ID0gdi5zcGxpdCgnLicsIDIpO1xuICAgICAgICByZXR1cm4gW1ByaW5jaXBhbC5mcm9tVGV4dCh4WzBdKSwgeFsxXV07XG4gICAgfVxufVxuY2xhc3MgUmFuZG9tIGV4dGVuZHMgSURMLlZpc2l0b3Ige1xuICAgIHZpc2l0TnVsbCh0LCB2KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEJvb2wodCwgdikge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSA8IDAuNTtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg2KTtcbiAgICB9XG4gICAgdmlzaXRGbG9hdCh0LCB2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuICAgIH1cbiAgICB2aXNpdEludCh0LCB2KSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy5nZW5lcmF0ZU51bWJlcih0cnVlKSk7XG4gICAgfVxuICAgIHZpc2l0TmF0KHQsIHYpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLmdlbmVyYXRlTnVtYmVyKGZhbHNlKSk7XG4gICAgfVxuICAgIHZpc2l0Rml4ZWRJbnQodCwgdikge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5nZW5lcmF0ZU51bWJlcih0cnVlKTtcbiAgICAgICAgaWYgKHQuX2JpdHMgPD0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEZpeGVkTmF0KHQsIHYpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2VuZXJhdGVOdW1iZXIoZmFsc2UpO1xuICAgICAgICBpZiAodC5fYml0cyA8PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdlbmVyYXRlTnVtYmVyKHNpZ25lZCkge1xuICAgICAgICBjb25zdCBudW0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApO1xuICAgICAgICBpZiAoc2lnbmVkICYmIE1hdGgucmFuZG9tKCkgPCAwLjUpIHtcbiAgICAgICAgICAgIHJldHVybiAtbnVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUHJpbWl0aXZlKHQsIGNvbmZpZywgZCkge1xuICAgIGlmIChjb25maWcucmFuZG9tICYmIGQgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0LmFjY2VwdChuZXcgUmFuZG9tKCksIGQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHQuYWNjZXB0KG5ldyBQYXJzZSgpLCBkKTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdCBhbiBJREwgdHlwZVxuICogQHJldHVybnMgYW4gaW5wdXQgZm9yIHRoYXQgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVySW5wdXQodCkge1xuICAgIHJldHVybiB0LmFjY2VwdChuZXcgUmVuZGVyKCksIG51bGwpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHQgYW4gSURMIFR5cGVcbiAqIEBwYXJhbSBpbnB1dCBhbiBJbnB1dEJveFxuICogQHBhcmFtIHZhbHVlIGFueVxuICogQHJldHVybnMgcmVuZGVyaW5nIHRoYXQgdmFsdWUgdG8gdGhlIHByb3ZpZGVkIGlucHV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJWYWx1ZSh0LCBpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdC5hY2NlcHQobmV3IFJlbmRlclZhbHVlKCksIHsgaW5wdXQsIHZhbHVlIH0pO1xufVxuY2xhc3MgUmVuZGVyVmFsdWUgZXh0ZW5kcyBJREwuVmlzaXRvciB7XG4gICAgdmlzaXRUeXBlKHQsIGQpIHtcbiAgICAgICAgZC5pbnB1dC51aS5pbnB1dC52YWx1ZSA9IHQudmFsdWVUb1N0cmluZyhkLnZhbHVlKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIHZpc2l0TnVsbCh0LCBkKSB7IH1cbiAgICB2aXNpdFRleHQodCwgZCkge1xuICAgICAgICBkLmlucHV0LnVpLmlucHV0LnZhbHVlID0gZC52YWx1ZTtcbiAgICB9XG4gICAgdmlzaXRSZWModCwgdHksIGQpIHtcbiAgICAgICAgcmVuZGVyVmFsdWUodHksIGQuaW5wdXQsIGQudmFsdWUpO1xuICAgIH1cbiAgICB2aXNpdE9wdCh0LCB0eSwgZCkge1xuICAgICAgICBpZiAoZC52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm0gPSBkLmlucHV0LnVpLmZvcm07XG4gICAgICAgICAgICBjb25zdCBvcGVuID0gZm9ybS51aS5vcGVuO1xuICAgICAgICAgICAgb3Blbi5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wZW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoZm9ybS51aS5ldmVudCkpO1xuICAgICAgICAgICAgcmVuZGVyVmFsdWUodHksIGZvcm0uZm9ybVswXSwgZC52YWx1ZVswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRSZWNvcmQodCwgZmllbGRzLCBkKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBkLmlucHV0LnVpLmZvcm07XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKChba2V5LCB0eXBlXSwgaSkgPT4ge1xuICAgICAgICAgICAgcmVuZGVyVmFsdWUodHlwZSwgZm9ybS5mb3JtW2ldLCBkLnZhbHVlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlzaXRUdXBsZSh0LCBjb21wb25lbnRzLCBkKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBkLmlucHV0LnVpLmZvcm07XG4gICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaCgodHlwZSwgaSkgPT4ge1xuICAgICAgICAgICAgcmVuZGVyVmFsdWUodHlwZSwgZm9ybS5mb3JtW2ldLCBkLnZhbHVlW2ldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0VmFyaWFudCh0LCBmaWVsZHMsIGQpIHtcbiAgICAgICAgY29uc3QgZm9ybSA9IGQuaW5wdXQudWkuZm9ybTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBPYmplY3QuZW50cmllcyhkLnZhbHVlKVswXTtcbiAgICAgICAgZmllbGRzLmZvckVhY2goKFtrZXksIHR5cGVdLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBzZWxlY3RlZFswXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZW4gPSBmb3JtLnVpLm9wZW47XG4gICAgICAgICAgICAgICAgb3Blbi5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBvcGVuLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KGZvcm0udWkuZXZlbnQpKTtcbiAgICAgICAgICAgICAgICByZW5kZXJWYWx1ZSh0eXBlLCBmb3JtLmZvcm1bMF0sIHNlbGVjdGVkWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0VmVjKHQsIHR5LCBkKSB7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBkLmlucHV0LnVpLmZvcm07XG4gICAgICAgIGNvbnN0IGxlbiA9IGQudmFsdWUubGVuZ3RoO1xuICAgICAgICBjb25zdCBvcGVuID0gZm9ybS51aS5vcGVuO1xuICAgICAgICBvcGVuLnZhbHVlID0gbGVuO1xuICAgICAgICBvcGVuLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KGZvcm0udWkuZXZlbnQpKTtcbiAgICAgICAgZC52YWx1ZS5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgICAgICByZW5kZXJWYWx1ZSh0eSwgZm9ybS5mb3JtW2ldLCB2KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FuZGlkLXVpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/candid/lib/esm/candid-ui.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/candid/lib/esm/idl.js":
/*!************************************************************!*\
  !*** ../../../node_modules/@dfinity/candid/lib/esm/idl.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bool: function() { return /* binding */ Bool; },\n/* harmony export */   BoolClass: function() { return /* binding */ BoolClass; },\n/* harmony export */   ConstructType: function() { return /* binding */ ConstructType; },\n/* harmony export */   Empty: function() { return /* binding */ Empty; },\n/* harmony export */   EmptyClass: function() { return /* binding */ EmptyClass; },\n/* harmony export */   FixedIntClass: function() { return /* binding */ FixedIntClass; },\n/* harmony export */   FixedNatClass: function() { return /* binding */ FixedNatClass; },\n/* harmony export */   Float32: function() { return /* binding */ Float32; },\n/* harmony export */   Float64: function() { return /* binding */ Float64; },\n/* harmony export */   FloatClass: function() { return /* binding */ FloatClass; },\n/* harmony export */   Func: function() { return /* binding */ Func; },\n/* harmony export */   FuncClass: function() { return /* binding */ FuncClass; },\n/* harmony export */   Int: function() { return /* binding */ Int; },\n/* harmony export */   Int16: function() { return /* binding */ Int16; },\n/* harmony export */   Int32: function() { return /* binding */ Int32; },\n/* harmony export */   Int64: function() { return /* binding */ Int64; },\n/* harmony export */   Int8: function() { return /* binding */ Int8; },\n/* harmony export */   IntClass: function() { return /* binding */ IntClass; },\n/* harmony export */   Nat: function() { return /* binding */ Nat; },\n/* harmony export */   Nat16: function() { return /* binding */ Nat16; },\n/* harmony export */   Nat32: function() { return /* binding */ Nat32; },\n/* harmony export */   Nat64: function() { return /* binding */ Nat64; },\n/* harmony export */   Nat8: function() { return /* binding */ Nat8; },\n/* harmony export */   NatClass: function() { return /* binding */ NatClass; },\n/* harmony export */   Null: function() { return /* binding */ Null; },\n/* harmony export */   NullClass: function() { return /* binding */ NullClass; },\n/* harmony export */   Opt: function() { return /* binding */ Opt; },\n/* harmony export */   OptClass: function() { return /* binding */ OptClass; },\n/* harmony export */   PrimitiveType: function() { return /* binding */ PrimitiveType; },\n/* harmony export */   Principal: function() { return /* binding */ Principal; },\n/* harmony export */   PrincipalClass: function() { return /* binding */ PrincipalClass; },\n/* harmony export */   Rec: function() { return /* binding */ Rec; },\n/* harmony export */   RecClass: function() { return /* binding */ RecClass; },\n/* harmony export */   Record: function() { return /* binding */ Record; },\n/* harmony export */   RecordClass: function() { return /* binding */ RecordClass; },\n/* harmony export */   Reserved: function() { return /* binding */ Reserved; },\n/* harmony export */   ReservedClass: function() { return /* binding */ ReservedClass; },\n/* harmony export */   Service: function() { return /* binding */ Service; },\n/* harmony export */   ServiceClass: function() { return /* binding */ ServiceClass; },\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   TextClass: function() { return /* binding */ TextClass; },\n/* harmony export */   Tuple: function() { return /* binding */ Tuple; },\n/* harmony export */   TupleClass: function() { return /* binding */ TupleClass; },\n/* harmony export */   Type: function() { return /* binding */ Type; },\n/* harmony export */   Unknown: function() { return /* binding */ Unknown; },\n/* harmony export */   UnknownClass: function() { return /* binding */ UnknownClass; },\n/* harmony export */   Variant: function() { return /* binding */ Variant; },\n/* harmony export */   VariantClass: function() { return /* binding */ VariantClass; },\n/* harmony export */   Vec: function() { return /* binding */ Vec; },\n/* harmony export */   VecClass: function() { return /* binding */ VecClass; },\n/* harmony export */   Visitor: function() { return /* binding */ Visitor; },\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/principal */ \"../../../node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/buffer */ \"../../../node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* harmony import */ var _utils_hash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hash */ \"../../../node_modules/@dfinity/candid/lib/esm/utils/hash.js\");\n/* harmony import */ var _utils_leb128__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/leb128 */ \"../../../node_modules/@dfinity/candid/lib/esm/utils/leb128.js\");\n/* harmony import */ var _utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/bigint-math */ \"../../../node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js\");\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\n\n\n\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\nfunction zipWith(xs, ys, f) {\n    return xs.map((x, i) => f(x, ys[i]));\n}\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n    constructor() {\n        // List of types. Needs to be an array as the index needs to be stable.\n        this._typs = [];\n        this._idx = new Map();\n    }\n    has(obj) {\n        return this._idx.has(obj.name);\n    }\n    add(type, buf) {\n        const idx = this._typs.length;\n        this._idx.set(type.name, idx);\n        this._typs.push(buf);\n    }\n    merge(obj, knot) {\n        const idx = this._idx.get(obj.name);\n        const knotIdx = this._idx.get(knot);\n        if (idx === undefined) {\n            throw new Error('Missing type index for ' + obj);\n        }\n        if (knotIdx === undefined) {\n            throw new Error('Missing type index for ' + knot);\n        }\n        this._typs[idx] = this._typs[knotIdx];\n        // Delete the type.\n        this._typs.splice(knotIdx, 1);\n        this._idx.delete(knot);\n    }\n    encode() {\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._typs.length);\n        const buf = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this._typs);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, buf);\n    }\n    indexOf(typeName) {\n        if (!this._idx.has(typeName)) {\n            throw new Error('Missing type index for ' + typeName);\n        }\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(this._idx.get(typeName) || 0);\n    }\n}\nclass Visitor {\n    visitType(t, data) {\n        throw new Error('Not implemented');\n    }\n    visitPrimitive(t, data) {\n        return this.visitType(t, data);\n    }\n    visitEmpty(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitBool(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNull(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitReserved(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitText(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitNumber(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFloat(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitFixedInt(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitFixedNat(t, data) {\n        return this.visitNumber(t, data);\n    }\n    visitPrincipal(t, data) {\n        return this.visitPrimitive(t, data);\n    }\n    visitConstruct(t, data) {\n        return this.visitType(t, data);\n    }\n    visitVec(t, ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitOpt(t, ty, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRecord(t, fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitTuple(t, components, data) {\n        const fields = components.map((ty, i) => [`_${i}_`, ty]);\n        return this.visitRecord(t, fields, data);\n    }\n    visitVariant(t, fields, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitRec(t, ty, data) {\n        return this.visitConstruct(ty, data);\n    }\n    visitFunc(t, data) {\n        return this.visitConstruct(t, data);\n    }\n    visitService(t, data) {\n        return this.visitConstruct(t, data);\n    }\n}\n/**\n * Represents an IDL type.\n */\nclass Type {\n    /* Display type name */\n    display() {\n        return this.name;\n    }\n    valueToString(x) {\n        return toReadableString(x);\n    }\n    /* Implement `T` in the IDL spec, only needed for non-primitive types */\n    buildTypeTable(typeTable) {\n        if (!typeTable.has(this)) {\n            this._buildTypeTableImpl(typeTable);\n        }\n    }\n}\nclass PrimitiveType extends Type {\n    checkType(t) {\n        if (this.name !== t.name) {\n            throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n        }\n        return t;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _buildTypeTableImpl(typeTable) {\n        // No type table encoding for Primitive types.\n        return;\n    }\n}\nclass ConstructType extends Type {\n    checkType(t) {\n        if (t instanceof RecClass) {\n            const ty = t.getType();\n            if (typeof ty === 'undefined') {\n                throw new Error('type mismatch with uninitialized type');\n            }\n            return ty;\n        }\n        throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    encodeType(typeTable) {\n        return typeTable.indexOf(this.name);\n    }\n}\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nclass EmptyClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitEmpty(this, d);\n    }\n    covariant(x) {\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        throw new Error('Empty cannot appear as a function argument');\n    }\n    valueToString() {\n        throw new Error('Empty cannot appear as a value');\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-17 /* IDLTypeIds.Empty */);\n    }\n    decodeValue() {\n        throw new Error('Empty cannot appear as an output');\n    }\n    get name() {\n        return 'empty';\n    }\n}\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nclass UnknownClass extends Type {\n    checkType(t) {\n        throw new Error('Method not implemented for unknown.');\n    }\n    accept(v, d) {\n        throw v.visitType(this, d);\n    }\n    covariant(x) {\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        throw new Error('Unknown cannot appear as a function argument');\n    }\n    valueToString() {\n        throw new Error('Unknown cannot appear as a value');\n    }\n    encodeType() {\n        throw new Error('Unknown cannot be serialized');\n    }\n    decodeValue(b, t) {\n        let decodedValue = t.decodeValue(b, t);\n        if (Object(decodedValue) !== decodedValue) {\n            // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n            // The type() function is important for primitives because otherwise we cannot tell apart the\n            // different number types.\n            decodedValue = Object(decodedValue);\n        }\n        let typeFunc;\n        if (t instanceof RecClass) {\n            typeFunc = () => t.getType();\n        }\n        else {\n            typeFunc = () => t;\n        }\n        // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n        // 'type' which means it would be serialized if the value would be candid encoded again.\n        // This in turn leads to problems if the decoded value is a variant because these values are\n        // only allowed to have a single property.\n        Object.defineProperty(decodedValue, 'type', {\n            value: typeFunc,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        });\n        return decodedValue;\n    }\n    _buildTypeTableImpl() {\n        throw new Error('Unknown cannot be serialized');\n    }\n    get name() {\n        return 'Unknown';\n    }\n}\n/**\n * Represents an IDL Bool\n */\nclass BoolClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitBool(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'boolean')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return new Uint8Array([x ? 1 : 0]);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-2 /* IDLTypeIds.Bool */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        switch ((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b)) {\n            case 0:\n                return false;\n            case 1:\n                return true;\n            default:\n                throw new Error('Boolean value out of range');\n        }\n    }\n    get name() {\n        return 'bool';\n    }\n}\n/**\n * Represents an IDL Null\n */\nclass NullClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitNull(this, d);\n    }\n    covariant(x) {\n        if (x === null)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue() {\n        return new ArrayBuffer(0);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-1 /* IDLTypeIds.Null */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return null;\n    }\n    get name() {\n        return 'null';\n    }\n}\n/**\n * Represents an IDL Reserved\n */\nclass ReservedClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitReserved(this, d);\n    }\n    covariant(x) {\n        return true;\n    }\n    encodeValue() {\n        return new ArrayBuffer(0);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-16 /* IDLTypeIds.Reserved */);\n    }\n    decodeValue(b, t) {\n        if (t.name !== this.name) {\n            t.decodeValue(b, t);\n        }\n        return null;\n    }\n    get name() {\n        return 'reserved';\n    }\n}\n/**\n * Represents an IDL Text\n */\nclass TextClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitText(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'string')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = new TextEncoder().encode(x);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, buf);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-15 /* IDLTypeIds.Text */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b);\n        const buf = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, Number(len));\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        return decoder.decode(buf);\n    }\n    get name() {\n        return 'text';\n    }\n    valueToString(x) {\n        return '\"' + x + '\"';\n    }\n}\n/**\n * Represents an IDL Int\n */\nclass IntClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitInt(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        if (typeof x === 'bigint' || Number.isInteger(x))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(x);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-4 /* IDLTypeIds.Int */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(b);\n    }\n    get name() {\n        return 'int';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Nat\n */\nclass NatClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitNat(this, d);\n    }\n    covariant(x) {\n        // We allow encoding of JavaScript plain numbers.\n        // But we will always decode to bigint.\n        if ((typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(x);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-3 /* IDLTypeIds.Nat */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b);\n    }\n    get name() {\n        return 'nat';\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Float\n */\nclass FloatClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n        if (_bits !== 32 && _bits !== 64) {\n            throw new Error('not a valid float type');\n        }\n    }\n    accept(v, d) {\n        return v.visitFloat(this, d);\n    }\n    covariant(x) {\n        if (typeof x === 'number' || x instanceof Number)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = new ArrayBuffer(this._bits / 8);\n        const view = new DataView(buf);\n        if (this._bits === 32) {\n            view.setFloat32(0, x, true);\n        }\n        else {\n            view.setFloat64(0, x, true);\n        }\n        return buf;\n    }\n    encodeType() {\n        const opcode = this._bits === 32 ? -13 /* IDLTypeIds.Float32 */ : -14 /* IDLTypeIds.Float64 */;\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(opcode);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const bytes = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, this._bits / 8);\n        const view = new DataView(bytes);\n        if (this._bits === 32) {\n            return view.getFloat32(0, true);\n        }\n        else {\n            return view.getFloat64(0, true);\n        }\n    }\n    get name() {\n        return 'float' + this._bits;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Int(n)\n */\nclass FixedIntClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n    }\n    accept(v, d) {\n        return v.visitFixedInt(this, d);\n    }\n    covariant(x) {\n        const min = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits - 1) * BigInt(-1);\n        const max = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits - 1) - BigInt(1);\n        let ok = false;\n        if (typeof x === 'bigint') {\n            ok = x >= min && x <= max;\n        }\n        else if (Number.isInteger(x)) {\n            const v = BigInt(x);\n            ok = v >= min && v <= max;\n        }\n        else {\n            ok = false;\n        }\n        if (ok)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.writeIntLE)(x, this._bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this._bits) - 3;\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-9 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.readIntLE)(b, this._bits / 8);\n        if (this._bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `int${this._bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nclass FixedNatClass extends PrimitiveType {\n    constructor(_bits) {\n        super();\n        this._bits = _bits;\n    }\n    accept(v, d) {\n        return v.visitFixedNat(this, d);\n    }\n    covariant(x) {\n        const max = (0,_utils_bigint_math__WEBPACK_IMPORTED_MODULE_4__.iexp2)(this._bits);\n        let ok = false;\n        if (typeof x === 'bigint' && x >= BigInt(0)) {\n            ok = x < max;\n        }\n        else if (Number.isInteger(x) && x >= 0) {\n            const v = BigInt(x);\n            ok = v < max;\n        }\n        else {\n            ok = false;\n        }\n        if (ok)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.writeUIntLE)(x, this._bits / 8);\n    }\n    encodeType() {\n        const offset = Math.log2(this._bits) - 3;\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-5 - offset);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        const num = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.readUIntLE)(b, this._bits / 8);\n        if (this._bits <= 32) {\n            return Number(num);\n        }\n        else {\n            return num;\n        }\n    }\n    get name() {\n        return `nat${this._bits}`;\n    }\n    valueToString(x) {\n        return x.toString();\n    }\n}\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nclass VecClass extends ConstructType {\n    constructor(_type) {\n        super();\n        this._type = _type;\n        // If true, this vector is really a blob and we can just use memcpy.\n        //\n        // NOTE:\n        // With support of encoding/dencoding of TypedArrays, this optimization is\n        // only used when plain array of bytes are passed as encoding input in order\n        // to be backward compatible.\n        this._blobOptimization = false;\n        if (_type instanceof FixedNatClass && _type._bits === 8) {\n            this._blobOptimization = true;\n        }\n    }\n    accept(v, d) {\n        return v.visitVec(this, this._type, d);\n    }\n    covariant(x) {\n        // Special case for ArrayBuffer\n        const bits = this._type instanceof FixedNatClass\n            ? this._type._bits\n            : this._type instanceof FixedIntClass\n                ? this._type._bits\n                : 0;\n        if ((ArrayBuffer.isView(x) && bits == x.BYTES_PER_ELEMENT * 8) ||\n            (Array.isArray(x) &&\n                x.every((v, idx) => {\n                    try {\n                        return this._type.covariant(v);\n                    }\n                    catch (e) {\n                        throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n                    }\n                })))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(x.length);\n        if (this._blobOptimization) {\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(x));\n        }\n        if (ArrayBuffer.isView(x)) {\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(len, new Uint8Array(x.buffer));\n        }\n        const buf = new _utils_buffer__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(new ArrayBuffer(len.byteLength + x.length), 0);\n        buf.write(len);\n        for (const d of x) {\n            const encoded = this._type.encodeValue(d);\n            buf.write(new Uint8Array(encoded));\n        }\n        return buf.buffer;\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-19 /* IDLTypeIds.Vector */);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        const vec = this.checkType(t);\n        if (!(vec instanceof VecClass)) {\n            throw new Error('Not a vector type');\n        }\n        const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n        if (this._type instanceof FixedNatClass) {\n            if (this._type._bits == 8) {\n                return new Uint8Array(b.read(len));\n            }\n            if (this._type._bits == 16) {\n                return new Uint16Array(b.read(len * 2));\n            }\n            if (this._type._bits == 32) {\n                return new Uint32Array(b.read(len * 4));\n            }\n            if (this._type._bits == 64) {\n                return new BigUint64Array(b.read(len * 8));\n            }\n        }\n        if (this._type instanceof FixedIntClass) {\n            if (this._type._bits == 8) {\n                return new Int8Array(b.read(len));\n            }\n            if (this._type._bits == 16) {\n                return new Int16Array(b.read(len * 2));\n            }\n            if (this._type._bits == 32) {\n                return new Int32Array(b.read(len * 4));\n            }\n            if (this._type._bits == 64) {\n                return new BigInt64Array(b.read(len * 8));\n            }\n        }\n        const rets = [];\n        for (let i = 0; i < len; i++) {\n            rets.push(this._type.decodeValue(b, vec._type));\n        }\n        return rets;\n    }\n    get name() {\n        return `vec ${this._type.name}`;\n    }\n    display() {\n        return `vec ${this._type.display()}`;\n    }\n    valueToString(x) {\n        const elements = x.map(e => this._type.valueToString(e));\n        return 'vec {' + elements.join('; ') + '}';\n    }\n}\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nclass OptClass extends ConstructType {\n    constructor(_type) {\n        super();\n        this._type = _type;\n    }\n    accept(v, d) {\n        return v.visitOpt(this, this._type, d);\n    }\n    covariant(x) {\n        try {\n            if (Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0]))))\n                return true;\n        }\n        catch (e) {\n            throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`);\n        }\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        if (x.length === 0) {\n            return new Uint8Array([0]);\n        }\n        else {\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), this._type.encodeValue(x[0]));\n        }\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._type.buildTypeTable(typeTable);\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-18 /* IDLTypeIds.Opt */);\n        const buffer = this._type.encodeType(typeTable);\n        typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, buffer));\n    }\n    decodeValue(b, t) {\n        const opt = this.checkType(t);\n        if (!(opt instanceof OptClass)) {\n            throw new Error('Not an option type');\n        }\n        switch ((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b)) {\n            case 0:\n                return [];\n            case 1:\n                return [this._type.decodeValue(b, opt._type)];\n            default:\n                throw new Error('Not an option value');\n        }\n    }\n    get name() {\n        return `opt ${this._type.name}`;\n    }\n    display() {\n        return `opt ${this._type.display()}`;\n    }\n    valueToString(x) {\n        if (x.length === 0) {\n            return 'null';\n        }\n        else {\n            return `opt ${this._type.valueToString(x[0])}`;\n        }\n    }\n}\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nclass RecordClass extends ConstructType {\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(a[0]) - (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(b[0]));\n    }\n    accept(v, d) {\n        return v.visitRecord(this, this._fields, d);\n    }\n    tryAsTuple() {\n        const res = [];\n        for (let i = 0; i < this._fields.length; i++) {\n            const [key, type] = this._fields[i];\n            if (key !== `_${i}_`) {\n                return null;\n            }\n            res.push(type);\n        }\n        return res;\n    }\n    covariant(x) {\n        if (typeof x === 'object' &&\n            this._fields.every(([k, t]) => {\n                // eslint-disable-next-line\n                if (!x.hasOwnProperty(k)) {\n                    throw new Error(`Record is missing key \"${k}\".`);\n                }\n                try {\n                    return t.covariant(x[k]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...bufs);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-20 /* IDLTypeIds.Record */);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);\n        const fields = this._fields.map(([key, value]) => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)), value.encodeType(T)));\n        T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...fields)));\n    }\n    decodeValue(b, t) {\n        const record = this.checkType(t);\n        if (!(record instanceof RecordClass)) {\n            throw new Error('Not a record type');\n        }\n        const x = {};\n        let expectedRecordIdx = 0;\n        let actualRecordIdx = 0;\n        while (actualRecordIdx < record._fields.length) {\n            const [hash, type] = record._fields[actualRecordIdx];\n            if (expectedRecordIdx >= this._fields.length) {\n                // skip unexpected left over fields present on the wire\n                type.decodeValue(b, type);\n                actualRecordIdx++;\n                continue;\n            }\n            const [expectKey, expectType] = this._fields[expectedRecordIdx];\n            const expectedId = (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(this._fields[expectedRecordIdx][0]);\n            const actualId = (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(hash);\n            if (expectedId === actualId) {\n                // the current field on the wire matches the expected field\n                x[expectKey] = expectType.decodeValue(b, type);\n                expectedRecordIdx++;\n                actualRecordIdx++;\n            }\n            else if (actualId > expectedId) {\n                // The expected field does not exist on the wire\n                if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n                    x[expectKey] = [];\n                    expectedRecordIdx++;\n                }\n                else {\n                    throw new Error('Cannot find required field ' + expectKey);\n                }\n            }\n            else {\n                // The field on the wire does not exist in the output type, so we can skip it\n                type.decodeValue(b, type);\n                actualRecordIdx++;\n            }\n        }\n        // initialize left over expected optional fields\n        for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n            if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n                // TODO this assumes null value in opt is represented as []\n                x[expectKey] = [];\n            }\n            else {\n                throw new Error('Cannot find required field ' + expectKey);\n            }\n        }\n        return x;\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `record {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        const values = this._fields.map(([key]) => x[key]);\n        const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nclass TupleClass extends RecordClass {\n    constructor(_components) {\n        const x = {};\n        _components.forEach((e, i) => (x['_' + i + '_'] = e));\n        super(x);\n        this._components = _components;\n    }\n    accept(v, d) {\n        return v.visitTuple(this, this._components, d);\n    }\n    covariant(x) {\n        // `>=` because tuples can be covariant when encoded.\n        if (Array.isArray(x) &&\n            x.length >= this._fields.length &&\n            this._components.every((t, i) => {\n                try {\n                    return t.covariant(x[i]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...bufs);\n    }\n    decodeValue(b, t) {\n        const tuple = this.checkType(t);\n        if (!(tuple instanceof TupleClass)) {\n            throw new Error('not a tuple type');\n        }\n        if (tuple._components.length < this._components.length) {\n            throw new Error('tuple mismatch');\n        }\n        const res = [];\n        for (const [i, wireType] of tuple._components.entries()) {\n            if (i >= this._components.length) {\n                // skip value\n                wireType.decodeValue(b, wireType);\n            }\n            else {\n                res.push(this._components[i].decodeValue(b, wireType));\n            }\n        }\n        return res;\n    }\n    display() {\n        const fields = this._components.map(value => value.display());\n        return `record {${fields.join('; ')}}`;\n    }\n    valueToString(values) {\n        const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n        return `record {${fields.join('; ')}}`;\n    }\n}\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nclass VariantClass extends ConstructType {\n    constructor(fields = {}) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(a[0]) - (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(b[0]));\n    }\n    accept(v, d) {\n        return v.visitVariant(this, this._fields, d);\n    }\n    covariant(x) {\n        if (typeof x === 'object' &&\n            Object.entries(x).length === 1 &&\n            this._fields.every(([k, v]) => {\n                try {\n                    // eslint-disable-next-line\n                    return !x.hasOwnProperty(k) || v.covariant(x[k]);\n                }\n                catch (e) {\n                    throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n                }\n            }))\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        for (let i = 0; i < this._fields.length; i++) {\n            const [name, type] = this._fields[i];\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const idx = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(i);\n                const buf = type.encodeValue(x[name]);\n                return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(idx, buf);\n            }\n        }\n        throw Error('Variant has no data: ' + x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        this._fields.forEach(([, type]) => {\n            type.buildTypeTable(typeTable);\n        });\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-21 /* IDLTypeIds.Variant */);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);\n        const fields = this._fields.map(([key, value]) => (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)), value.encodeType(typeTable)));\n        typeTable.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, ...fields));\n    }\n    decodeValue(b, t) {\n        const variant = this.checkType(t);\n        if (!(variant instanceof VariantClass)) {\n            throw new Error('Not a variant type');\n        }\n        const idx = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n        if (idx >= variant._fields.length) {\n            throw Error('Invalid variant index: ' + idx);\n        }\n        const [wireHash, wireType] = variant._fields[idx];\n        for (const [key, expectType] of this._fields) {\n            if ((0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(wireHash) === (0,_utils_hash__WEBPACK_IMPORTED_MODULE_2__.idlLabelToId)(key)) {\n                const value = expectType.decodeValue(b, wireType);\n                return { [key]: value };\n            }\n        }\n        throw new Error('Cannot find field hash ' + wireHash);\n    }\n    get name() {\n        const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n        return `variant {${fields.join('; ')}}`;\n    }\n    display() {\n        const fields = this._fields.map(([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`));\n        return `variant {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        for (const [name, type] of this._fields) {\n            // eslint-disable-next-line\n            if (x.hasOwnProperty(name)) {\n                const value = type.valueToString(x[name]);\n                if (value === 'null') {\n                    return `variant {${name}}`;\n                }\n                else {\n                    return `variant {${name}=${value}}`;\n                }\n            }\n        }\n        throw new Error('Variant has no data: ' + x);\n    }\n}\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nclass RecClass extends ConstructType {\n    constructor() {\n        super(...arguments);\n        this._id = RecClass._counter++;\n        this._type = undefined;\n    }\n    accept(v, d) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return v.visitRec(this, this._type, d);\n    }\n    fill(t) {\n        this._type = t;\n    }\n    getType() {\n        return this._type;\n    }\n    covariant(x) {\n        if (this._type ? this._type.covariant(x) : false)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.encodeValue(x);\n    }\n    _buildTypeTableImpl(typeTable) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        typeTable.add(this, new Uint8Array([]));\n        this._type.buildTypeTable(typeTable);\n        typeTable.merge(this, this._type.name);\n    }\n    decodeValue(b, t) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.decodeValue(b, t);\n    }\n    get name() {\n        return `rec_${this._id}`;\n    }\n    display() {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return `${this.name}.${this._type.name}`;\n    }\n    valueToString(x) {\n        if (!this._type) {\n            throw Error('Recursive type uninitialized.');\n        }\n        return this._type.valueToString(x);\n    }\n}\nRecClass._counter = 0;\nfunction decodePrincipalId(b) {\n    const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b);\n    if (x !== 1) {\n        throw new Error('Cannot decode principal');\n    }\n    const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n    return _dfinity_principal__WEBPACK_IMPORTED_MODULE_0__.Principal.fromUint8Array(new Uint8Array((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, len)));\n}\n/**\n * Represents an IDL principal reference\n */\nclass PrincipalClass extends PrimitiveType {\n    accept(v, d) {\n        return v.visitPrincipal(this, d);\n    }\n    covariant(x) {\n        if (x && x._isPrincipal)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n    }\n    encodeType() {\n        return (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-24 /* IDLTypeIds.Principal */);\n    }\n    decodeValue(b, t) {\n        this.checkType(t);\n        return decodePrincipalId(b);\n    }\n    get name() {\n        return 'principal';\n    }\n    valueToString(x) {\n        return `${this.name} \"${x.toText()}\"`;\n    }\n}\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nclass FuncClass extends ConstructType {\n    constructor(argTypes, retTypes, annotations = []) {\n        super();\n        this.argTypes = argTypes;\n        this.retTypes = retTypes;\n        this.annotations = annotations;\n    }\n    static argsToString(types, v) {\n        if (types.length !== v.length) {\n            throw new Error('arity mismatch');\n        }\n        return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n    }\n    accept(v, d) {\n        return v.visitFunc(this, d);\n    }\n    covariant(x) {\n        if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string')\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue([principal, methodName]) {\n        const buf = principal.toUint8Array();\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.byteLength);\n        const canister = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n        const method = new TextEncoder().encode(methodName);\n        const methodLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(method.byteLength);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), canister, methodLen, method);\n    }\n    _buildTypeTableImpl(T) {\n        this.argTypes.forEach(arg => arg.buildTypeTable(T));\n        this.retTypes.forEach(arg => arg.buildTypeTable(T));\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-22 /* IDLTypeIds.Func */);\n        const argLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.argTypes.length);\n        const args = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.argTypes.map(arg => arg.encodeType(T)));\n        const retLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.retTypes.length);\n        const rets = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.retTypes.map(arg => arg.encodeType(T)));\n        const annLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this.annotations.length);\n        const anns = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...this.annotations.map(a => this.encodeAnnotation(a)));\n        T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, argLen, args, retLen, rets, annLen, anns));\n    }\n    decodeValue(b) {\n        const x = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeReadUint8)(b);\n        if (x !== 1) {\n            throw new Error('Cannot decode function reference');\n        }\n        const canister = decodePrincipalId(b);\n        const mLen = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(b));\n        const buf = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, mLen);\n        const decoder = new TextDecoder('utf8', { fatal: true });\n        const method = decoder.decode(buf);\n        return [canister, method];\n    }\n    get name() {\n        const args = this.argTypes.map(arg => arg.name).join(', ');\n        const rets = this.retTypes.map(arg => arg.name).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args}) -> (${rets})${annon}`;\n    }\n    valueToString([principal, str]) {\n        return `func \"${principal.toText()}\".${str}`;\n    }\n    display() {\n        const args = this.argTypes.map(arg => arg.display()).join(', ');\n        const rets = this.retTypes.map(arg => arg.display()).join(', ');\n        const annon = ' ' + this.annotations.join(' ');\n        return `(${args})  (${rets})${annon}`;\n    }\n    encodeAnnotation(ann) {\n        if (ann === 'query') {\n            return new Uint8Array([1]);\n        }\n        else if (ann === 'oneway') {\n            return new Uint8Array([2]);\n        }\n        else if (ann === 'composite_query') {\n            return new Uint8Array([3]);\n        }\n        else {\n            throw new Error('Illegal function annotation');\n        }\n    }\n}\nclass ServiceClass extends ConstructType {\n    constructor(fields) {\n        super();\n        this._fields = Object.entries(fields).sort((a, b) => {\n            if (a[0] < b[0]) {\n                return -1;\n            }\n            if (a[0] > b[0]) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    accept(v, d) {\n        return v.visitService(this, d);\n    }\n    covariant(x) {\n        if (x && x._isPrincipal)\n            return true;\n        throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n    }\n    encodeValue(x) {\n        const buf = x.toUint8Array();\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(buf.length);\n        return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(new Uint8Array([1]), len, buf);\n    }\n    _buildTypeTableImpl(T) {\n        this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n        const opCode = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebEncode)(-23 /* IDLTypeIds.Service */);\n        const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(this._fields.length);\n        const meths = this._fields.map(([label, func]) => {\n            const labelBuf = new TextEncoder().encode(label);\n            const labelLen = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(labelBuf.length);\n            return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(labelLen, labelBuf, func.encodeType(T));\n        });\n        T.add(this, (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(opCode, len, ...meths));\n    }\n    decodeValue(b) {\n        return decodePrincipalId(b);\n    }\n    get name() {\n        const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n        return `service {${fields.join('; ')}}`;\n    }\n    valueToString(x) {\n        return `service \"${x.toText()}\"`;\n    }\n}\n/**\n *\n * @param x\n * @returns {string}\n */\nfunction toReadableString(x) {\n    const str = JSON.stringify(x, (_key, value) => typeof value === 'bigint' ? `BigInt(${value})` : value);\n    return str && str.length > toReadableString_max\n        ? str.substring(0, toReadableString_max - 3) + '...'\n        : str;\n}\n/**\n * Encode a array of values\n * @param argTypes\n * @param args\n * @returns {Buffer} serialised value\n */\nfunction encode(argTypes, args) {\n    if (args.length < argTypes.length) {\n        throw Error('Wrong number of message arguments');\n    }\n    const typeTable = new TypeTable();\n    argTypes.forEach(t => t.buildTypeTable(typeTable));\n    const magic = new TextEncoder().encode(magicNumber);\n    const table = typeTable.encode();\n    const len = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebEncode)(args.length);\n    const typs = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...argTypes.map(t => t.encodeType(typeTable)));\n    const vals = (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(...zipWith(argTypes, args, (t, x) => {\n        try {\n            t.covariant(x);\n        }\n        catch (e) {\n            const err = new Error(e.message + '\\n\\n');\n            throw err;\n        }\n        return t.encodeValue(x);\n    }));\n    return (0,_utils_buffer__WEBPACK_IMPORTED_MODULE_1__.concat)(magic, table, len, typs, vals);\n}\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nfunction decode(retTypes, bytes) {\n    const b = new _utils_buffer__WEBPACK_IMPORTED_MODULE_1__.PipeArrayBuffer(bytes);\n    if (bytes.byteLength < magicNumber.length) {\n        throw new Error('Message length smaller than magic number');\n    }\n    const magicBuffer = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(b, magicNumber.length);\n    const magic = new TextDecoder().decode(magicBuffer);\n    if (magic !== magicNumber) {\n        throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n    }\n    function readTypeTable(pipe) {\n        const typeTable = [];\n        const len = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n        for (let i = 0; i < len; i++) {\n            const ty = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));\n            switch (ty) {\n                case -18 /* IDLTypeIds.Opt */:\n                case -19 /* IDLTypeIds.Vector */: {\n                    const t = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));\n                    typeTable.push([ty, t]);\n                    break;\n                }\n                case -20 /* IDLTypeIds.Record */:\n                case -21 /* IDLTypeIds.Variant */: {\n                    const fields = [];\n                    let objectLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    let prevHash;\n                    while (objectLength--) {\n                        const hash = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                        if (hash >= Math.pow(2, 32)) {\n                            throw new Error('field id out of 32-bit range');\n                        }\n                        if (typeof prevHash === 'number' && prevHash >= hash) {\n                            throw new Error('field id collision or not sorted');\n                        }\n                        prevHash = hash;\n                        const t = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe));\n                        fields.push([hash, t]);\n                    }\n                    typeTable.push([ty, fields]);\n                    break;\n                }\n                case -22 /* IDLTypeIds.Func */: {\n                    const args = [];\n                    let argLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    while (argLength--) {\n                        args.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));\n                    }\n                    const returnValues = [];\n                    let returnValuesLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    while (returnValuesLength--) {\n                        returnValues.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));\n                    }\n                    const annotations = [];\n                    let annotationLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    while (annotationLength--) {\n                        const annotation = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                        switch (annotation) {\n                            case 1: {\n                                annotations.push('query');\n                                break;\n                            }\n                            case 2: {\n                                annotations.push('oneway');\n                                break;\n                            }\n                            case 3: {\n                                annotations.push('composite_query');\n                                break;\n                            }\n                            default:\n                                throw new Error('unknown annotation');\n                        }\n                    }\n                    typeTable.push([ty, [args, returnValues, annotations]]);\n                    break;\n                }\n                case -23 /* IDLTypeIds.Service */: {\n                    let servLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                    const methods = [];\n                    while (servLength--) {\n                        const nameLength = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n                        const funcName = new TextDecoder().decode((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.safeRead)(pipe, nameLength));\n                        const funcType = (0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe);\n                        methods.push([funcName, funcType]);\n                    }\n                    typeTable.push([ty, methods]);\n                    break;\n                }\n                default:\n                    throw new Error('Illegal op_code: ' + ty);\n            }\n        }\n        const rawList = [];\n        const length = Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.lebDecode)(pipe));\n        for (let i = 0; i < length; i++) {\n            rawList.push(Number((0,_utils_leb128__WEBPACK_IMPORTED_MODULE_3__.slebDecode)(pipe)));\n        }\n        return [typeTable, rawList];\n    }\n    const [rawTable, rawTypes] = readTypeTable(b);\n    if (rawTypes.length < retTypes.length) {\n        throw new Error('Wrong number of return values');\n    }\n    const table = rawTable.map(_ => Rec());\n    function getType(t) {\n        if (t < -24) {\n            throw new Error('future value not supported');\n        }\n        if (t < 0) {\n            switch (t) {\n                case -1:\n                    return Null;\n                case -2:\n                    return Bool;\n                case -3:\n                    return Nat;\n                case -4:\n                    return Int;\n                case -5:\n                    return Nat8;\n                case -6:\n                    return Nat16;\n                case -7:\n                    return Nat32;\n                case -8:\n                    return Nat64;\n                case -9:\n                    return Int8;\n                case -10:\n                    return Int16;\n                case -11:\n                    return Int32;\n                case -12:\n                    return Int64;\n                case -13:\n                    return Float32;\n                case -14:\n                    return Float64;\n                case -15:\n                    return Text;\n                case -16:\n                    return Reserved;\n                case -17:\n                    return Empty;\n                case -24:\n                    return Principal;\n                default:\n                    throw new Error('Illegal op_code: ' + t);\n            }\n        }\n        if (t >= rawTable.length) {\n            throw new Error('type index out of range');\n        }\n        return table[t];\n    }\n    function buildType(entry) {\n        switch (entry[0]) {\n            case -19 /* IDLTypeIds.Vector */: {\n                const ty = getType(entry[1]);\n                return Vec(ty);\n            }\n            case -18 /* IDLTypeIds.Opt */: {\n                const ty = getType(entry[1]);\n                return Opt(ty);\n            }\n            case -20 /* IDLTypeIds.Record */: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                const record = Record(fields);\n                const tuple = record.tryAsTuple();\n                if (Array.isArray(tuple)) {\n                    return Tuple(...tuple);\n                }\n                else {\n                    return record;\n                }\n            }\n            case -21 /* IDLTypeIds.Variant */: {\n                const fields = {};\n                for (const [hash, ty] of entry[1]) {\n                    const name = `_${hash}_`;\n                    fields[name] = getType(ty);\n                }\n                return Variant(fields);\n            }\n            case -22 /* IDLTypeIds.Func */: {\n                const [args, returnValues, annotations] = entry[1];\n                return Func(args.map((t) => getType(t)), returnValues.map((t) => getType(t)), annotations);\n            }\n            case -23 /* IDLTypeIds.Service */: {\n                const rec = {};\n                const methods = entry[1];\n                for (const [name, typeRef] of methods) {\n                    let type = getType(typeRef);\n                    if (type instanceof RecClass) {\n                        // unpack reference type\n                        type = type.getType();\n                    }\n                    if (!(type instanceof FuncClass)) {\n                        throw new Error('Illegal service definition: services can only contain functions');\n                    }\n                    rec[name] = type;\n                }\n                return Service(rec);\n            }\n            default:\n                throw new Error('Illegal op_code: ' + entry[0]);\n        }\n    }\n    rawTable.forEach((entry, i) => {\n        // Process function type first, so that we can construct the correct service type\n        if (entry[0] === -22 /* IDLTypeIds.Func */) {\n            const t = buildType(entry);\n            table[i].fill(t);\n        }\n    });\n    rawTable.forEach((entry, i) => {\n        if (entry[0] !== -22 /* IDLTypeIds.Func */) {\n            const t = buildType(entry);\n            table[i].fill(t);\n        }\n    });\n    const types = rawTypes.map(t => getType(t));\n    const output = retTypes.map((t, i) => {\n        return t.decodeValue(b, types[i]);\n    });\n    // skip unused values\n    for (let ind = retTypes.length; ind < types.length; ind++) {\n        types[ind].decodeValue(b, types[ind]);\n    }\n    if (b.byteLength > 0) {\n        throw new Error('decode: Left-over bytes');\n    }\n    return output;\n}\n// Export Types instances.\nconst Empty = new EmptyClass();\nconst Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nconst Unknown = new UnknownClass();\nconst Bool = new BoolClass();\nconst Null = new NullClass();\nconst Text = new TextClass();\nconst Int = new IntClass();\nconst Nat = new NatClass();\nconst Float32 = new FloatClass(32);\nconst Float64 = new FloatClass(64);\nconst Int8 = new FixedIntClass(8);\nconst Int16 = new FixedIntClass(16);\nconst Int32 = new FixedIntClass(32);\nconst Int64 = new FixedIntClass(64);\nconst Nat8 = new FixedNatClass(8);\nconst Nat16 = new FixedNatClass(16);\nconst Nat32 = new FixedNatClass(32);\nconst Nat64 = new FixedNatClass(64);\nconst Principal = new PrincipalClass();\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nfunction Tuple(...types) {\n    return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nfunction Vec(t) {\n    return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nfunction Opt(t) {\n    return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nfunction Record(t) {\n    return new RecordClass(t);\n}\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nfunction Variant(fields) {\n    return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nfunction Rec() {\n    return new RecClass();\n}\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nfunction Func(args, ret, annotations = []) {\n    return new FuncClass(args, ret, annotations);\n}\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nfunction Service(t) {\n    return new ServiceClass(t);\n}\n//# sourceMappingURL=idl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL2lkbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUM4RDtBQUNHO0FBQ3JCO0FBQzRHO0FBQzVHO0FBQzVDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQVM7QUFDN0Isb0JBQW9CLHFEQUFNO0FBQzFCLGVBQWUscURBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVU7QUFDekI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsRUFBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS9pZGwuanM/YjM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCB7IFByaW5jaXBhbCBhcyBQcmluY2lwYWxJZCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgeyBjb25jYXQsIFBpcGVBcnJheUJ1ZmZlciBhcyBQaXBlIH0gZnJvbSAnLi91dGlscy9idWZmZXInO1xuaW1wb3J0IHsgaWRsTGFiZWxUb0lkIH0gZnJvbSAnLi91dGlscy9oYXNoJztcbmltcG9ydCB7IGxlYkRlY29kZSwgbGViRW5jb2RlLCByZWFkSW50TEUsIHJlYWRVSW50TEUsIHNhZmVSZWFkLCBzYWZlUmVhZFVpbnQ4LCBzbGViRGVjb2RlLCBzbGViRW5jb2RlLCB3cml0ZUludExFLCB3cml0ZVVJbnRMRSwgfSBmcm9tICcuL3V0aWxzL2xlYjEyOCc7XG5pbXBvcnQgeyBpZXhwMiB9IGZyb20gJy4vdXRpbHMvYmlnaW50LW1hdGgnO1xuY29uc3QgbWFnaWNOdW1iZXIgPSAnRElETCc7XG5jb25zdCB0b1JlYWRhYmxlU3RyaW5nX21heCA9IDQwMDsgLy8gd2lsbCBub3QgZGlzcGxheSBhcmd1bWVudHMgYWZ0ZXIgNDAwY2hhcnMuIE1ha2VzIHN1cmUgMm1iIGJsb2JzIGRvbid0IGdldCBpbnNpZGUgdGhlIGVycm9yXG5mdW5jdGlvbiB6aXBXaXRoKHhzLCB5cywgZikge1xuICAgIHJldHVybiB4cy5tYXAoKHgsIGkpID0+IGYoeCwgeXNbaV0pKTtcbn1cbi8qKlxuICogQW4gSURMIFR5cGUgVGFibGUsIHdoaWNoIHByZWNlZGVzIHRoZSBkYXRhIGluIHRoZSBzdHJlYW0uXG4gKi9cbmNsYXNzIFR5cGVUYWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIExpc3Qgb2YgdHlwZXMuIE5lZWRzIHRvIGJlIGFuIGFycmF5IGFzIHRoZSBpbmRleCBuZWVkcyB0byBiZSBzdGFibGUuXG4gICAgICAgIHRoaXMuX3R5cHMgPSBbXTtcbiAgICAgICAgdGhpcy5faWR4ID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBoYXMob2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZHguaGFzKG9iai5uYW1lKTtcbiAgICB9XG4gICAgYWRkKHR5cGUsIGJ1Zikge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl90eXBzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5faWR4LnNldCh0eXBlLm5hbWUsIGlkeCk7XG4gICAgICAgIHRoaXMuX3R5cHMucHVzaChidWYpO1xuICAgIH1cbiAgICBtZXJnZShvYmosIGtub3QpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5faWR4LmdldChvYmoubmFtZSk7XG4gICAgICAgIGNvbnN0IGtub3RJZHggPSB0aGlzLl9pZHguZ2V0KGtub3QpO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB0eXBlIGluZGV4IGZvciAnICsgb2JqKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa25vdElkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHlwZSBpbmRleCBmb3IgJyArIGtub3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3R5cHNbaWR4XSA9IHRoaXMuX3R5cHNba25vdElkeF07XG4gICAgICAgIC8vIERlbGV0ZSB0aGUgdHlwZS5cbiAgICAgICAgdGhpcy5fdHlwcy5zcGxpY2Uoa25vdElkeCwgMSk7XG4gICAgICAgIHRoaXMuX2lkeC5kZWxldGUoa25vdCk7XG4gICAgfVxuICAgIGVuY29kZSgpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKHRoaXMuX3R5cHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYnVmID0gY29uY2F0KC4uLnRoaXMuX3R5cHMpO1xuICAgICAgICByZXR1cm4gY29uY2F0KGxlbiwgYnVmKTtcbiAgICB9XG4gICAgaW5kZXhPZih0eXBlTmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2lkeC5oYXModHlwZU5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdHlwZSBpbmRleCBmb3IgJyArIHR5cGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSh0aGlzLl9pZHguZ2V0KHR5cGVOYW1lKSB8fCAwKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVmlzaXRvciB7XG4gICAgdmlzaXRUeXBlKHQsIGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgdmlzaXRQcmltaXRpdmUodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFR5cGUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0RW1wdHkodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFByaW1pdGl2ZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRCb29sKHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRQcmltaXRpdmUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0TnVsbCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFJlc2VydmVkKHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRQcmltaXRpdmUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdE51bWJlcih0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdEludCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0TnVtYmVyKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdE5hdCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0TnVtYmVyKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdEZsb2F0KHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRQcmltaXRpdmUodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0Rml4ZWRJbnQodCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdE51bWJlcih0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRGaXhlZE5hdCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0TnVtYmVyKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFByaW5jaXBhbCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0UHJpbWl0aXZlKHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdENvbnN0cnVjdCh0LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0VHlwZSh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRWZWModCwgdHksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0T3B0KHQsIHR5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Q29uc3RydWN0KHQsIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdFJlY29yZCh0LCBmaWVsZHMsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodCwgZGF0YSk7XG4gICAgfVxuICAgIHZpc2l0VHVwbGUodCwgY29tcG9uZW50cywgZGF0YSkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBjb21wb25lbnRzLm1hcCgodHksIGkpID0+IFtgXyR7aX1fYCwgdHldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRSZWNvcmQodCwgZmllbGRzLCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRWYXJpYW50KHQsIGZpZWxkcywgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENvbnN0cnVjdCh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRSZWModCwgdHksIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodHksIGRhdGEpO1xuICAgIH1cbiAgICB2aXNpdEZ1bmModCwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENvbnN0cnVjdCh0LCBkYXRhKTtcbiAgICB9XG4gICAgdmlzaXRTZXJ2aWNlKHQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDb25zdHJ1Y3QodCwgZGF0YSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgVHlwZSB7XG4gICAgLyogRGlzcGxheSB0eXBlIG5hbWUgKi9cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgcmV0dXJuIHRvUmVhZGFibGVTdHJpbmcoeCk7XG4gICAgfVxuICAgIC8qIEltcGxlbWVudCBgVGAgaW4gdGhlIElETCBzcGVjLCBvbmx5IG5lZWRlZCBmb3Igbm9uLXByaW1pdGl2ZSB0eXBlcyAqL1xuICAgIGJ1aWxkVHlwZVRhYmxlKHR5cGVUYWJsZSkge1xuICAgICAgICBpZiAoIXR5cGVUYWJsZS5oYXModGhpcykpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkVHlwZVRhYmxlSW1wbCh0eXBlVGFibGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFByaW1pdGl2ZVR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgICBjaGVja1R5cGUodCkge1xuICAgICAgICBpZiAodGhpcy5uYW1lICE9PSB0Lm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdHlwZSBtaXNtYXRjaDogdHlwZSBvbiB0aGUgd2lyZSAke3QubmFtZX0sIGV4cGVjdCB0eXBlICR7dGhpcy5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbCh0eXBlVGFibGUpIHtcbiAgICAgICAgLy8gTm8gdHlwZSB0YWJsZSBlbmNvZGluZyBmb3IgUHJpbWl0aXZlIHR5cGVzLlxuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnN0cnVjdFR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgICBjaGVja1R5cGUodCkge1xuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIFJlY0NsYXNzKSB7XG4gICAgICAgICAgICBjb25zdCB0eSA9IHQuZ2V0VHlwZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgbWlzbWF0Y2ggd2l0aCB1bmluaXRpYWxpemVkIHR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR5cGUgbWlzbWF0Y2g6IHR5cGUgb24gdGhlIHdpcmUgJHt0Lm5hbWV9LCBleHBlY3QgdHlwZSAke3RoaXMubmFtZX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSh0eXBlVGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVUYWJsZS5pbmRleE9mKHRoaXMubmFtZSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBFbXB0eSwgYSB0eXBlIHdoaWNoIGhhcyBubyBpbmhhYml0YW50cy5cbiAqIFNpbmNlIG5vIHZhbHVlcyBleGlzdCBmb3IgdGhpcyB0eXBlLCBpdCBjYW5ub3QgYmUgc2VyaWFsaXNlZCBvciBkZXNlcmlhbGlzZWQuXG4gKiBSZXN1bHQgdHlwZXMgbGlrZSBgUmVzdWx0PFRleHQsIEVtcHR5PmAgc2hvdWxkIGFsd2F5cyBzdWNjZWVkLlxuICovXG5leHBvcnQgY2xhc3MgRW1wdHlDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0RW1wdHkodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBjYW5ub3QgYXBwZWFyIGFzIGEgZnVuY3Rpb24gYXJndW1lbnQnKTtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBjYW5ub3QgYXBwZWFyIGFzIGEgdmFsdWUnKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTE3IC8qIElETFR5cGVJZHMuRW1wdHkgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBjYW5ub3QgYXBwZWFyIGFzIGFuIG91dHB1dCcpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdlbXB0eSc7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBVbmtub3duLCBhIHBsYWNlaG9sZGVyIHR5cGUgZm9yIGRlc2VyaWFsaXphdGlvbiBvbmx5LlxuICogV2hlbiBkZWNvZGluZyBhIHZhbHVlIGFzIFVua25vd24sIGFsbCBmaWVsZHMgd2lsbCBiZSByZXRhaW5lZCBidXQgdGhlIG5hbWVzIGFyZSBvbmx5IGF2YWlsYWJsZSBpblxuICogaGFzaGVkIGZvcm0uXG4gKiBBIGRlc2VyaWFsaXplZCB1bmtub3duIHdpbGwgb2ZmZXIgaXQncyBhY3R1YWwgdHlwZSBieSBjYWxsaW5nIHRoZSBgdHlwZSgpYCBmdW5jdGlvbi5cbiAqIFVua25vd24gY2Fubm90IGJlIHNlcmlhbGl6ZWQgYW5kIGF0dGVtcHRpbmcgdG8gZG8gc28gd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFVua25vd25DbGFzcyBleHRlbmRzIFR5cGUge1xuICAgIGNoZWNrVHlwZSh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCBmb3IgdW5rbm93bi4nKTtcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgdGhyb3cgdi52aXNpdFR5cGUodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbm5vdCBhcHBlYXIgYXMgYSBmdW5jdGlvbiBhcmd1bWVudCcpO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2Fubm90IGFwcGVhciBhcyBhIHZhbHVlJyk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjYW5ub3QgYmUgc2VyaWFsaXplZCcpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGxldCBkZWNvZGVkVmFsdWUgPSB0LmRlY29kZVZhbHVlKGIsIHQpO1xuICAgICAgICBpZiAoT2JqZWN0KGRlY29kZWRWYWx1ZSkgIT09IGRlY29kZWRWYWx1ZSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlZFZhbHVlIGlzIHByaW1pdGl2ZS4gQm94IGl0LCBvdGhlcndpc2Ugd2UgY2Fubm90IGFkZCB0aGUgdHlwZSgpIGZ1bmN0aW9uLlxuICAgICAgICAgICAgLy8gVGhlIHR5cGUoKSBmdW5jdGlvbiBpcyBpbXBvcnRhbnQgZm9yIHByaW1pdGl2ZXMgYmVjYXVzZSBvdGhlcndpc2Ugd2UgY2Fubm90IHRlbGwgYXBhcnQgdGhlXG4gICAgICAgICAgICAvLyBkaWZmZXJlbnQgbnVtYmVyIHR5cGVzLlxuICAgICAgICAgICAgZGVjb2RlZFZhbHVlID0gT2JqZWN0KGRlY29kZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGVGdW5jO1xuICAgICAgICBpZiAodCBpbnN0YW5jZW9mIFJlY0NsYXNzKSB7XG4gICAgICAgICAgICB0eXBlRnVuYyA9ICgpID0+IHQuZ2V0VHlwZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZUZ1bmMgPSAoKSA9PiB0O1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIG5vdCB1c2UgJ2RlY29kZWRWYWx1ZS50eXBlID0gdHlwZUZ1bmMnIGJlY2F1c2UgdGhpcyB3b3VsZCBsZWFkIHRvIGFuIGVudW1lcmFibGUgcHJvcGVydHlcbiAgICAgICAgLy8gJ3R5cGUnIHdoaWNoIG1lYW5zIGl0IHdvdWxkIGJlIHNlcmlhbGl6ZWQgaWYgdGhlIHZhbHVlIHdvdWxkIGJlIGNhbmRpZCBlbmNvZGVkIGFnYWluLlxuICAgICAgICAvLyBUaGlzIGluIHR1cm4gbGVhZHMgdG8gcHJvYmxlbXMgaWYgdGhlIGRlY29kZWQgdmFsdWUgaXMgYSB2YXJpYW50IGJlY2F1c2UgdGhlc2UgdmFsdWVzIGFyZVxuICAgICAgICAvLyBvbmx5IGFsbG93ZWQgdG8gaGF2ZSBhIHNpbmdsZSBwcm9wZXJ0eS5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlY29kZWRWYWx1ZSwgJ3R5cGUnLCB7XG4gICAgICAgICAgICB2YWx1ZTogdHlwZUZ1bmMsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlY29kZWRWYWx1ZTtcbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNhbm5vdCBiZSBzZXJpYWxpemVkJyk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ1Vua25vd24nO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgQm9vbFxuICovXG5leHBvcnQgY2xhc3MgQm9vbENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRCb29sKHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW3ggPyAxIDogMF0pO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSgtMiAvKiBJRExUeXBlSWRzLkJvb2wgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBzd2l0Y2ggKHNhZmVSZWFkVWludDgoYikpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm9vbGVhbiB2YWx1ZSBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdib29sJztcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIE51bGxcbiAqL1xuZXhwb3J0IGNsYXNzIE51bGxDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0TnVsbCh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgaWYgKHggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSgtMSAvKiBJRExUeXBlSWRzLk51bGwgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBSZXNlcnZlZFxuICovXG5leHBvcnQgY2xhc3MgUmVzZXJ2ZWRDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0UmVzZXJ2ZWQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTE2IC8qIElETFR5cGVJZHMuUmVzZXJ2ZWQgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGlmICh0Lm5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgdC5kZWNvZGVWYWx1ZShiLCB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAncmVzZXJ2ZWQnO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgVGV4dFxuICovXG5leHBvcnQgY2xhc3MgVGV4dENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRUZXh0KHRoaXMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh4KTtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChsZW4sIGJ1Zik7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKC0xNSAvKiBJRExUeXBlSWRzLlRleHQgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJEZWNvZGUoYik7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHNhZmVSZWFkKGIsIE51bWJlcihsZW4pKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcsIHsgZmF0YWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShidWYpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICd0ZXh0JztcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiAnXCInICsgeCArICdcIic7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBJbnRcbiAqL1xuZXhwb3J0IGNsYXNzIEludENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRJbnQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGVuY29kaW5nIG9mIEphdmFTY3JpcHQgcGxhaW4gbnVtYmVycy5cbiAgICAgICAgLy8gQnV0IHdlIHdpbGwgYWx3YXlzIGRlY29kZSB0byBiaWdpbnQuXG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih4KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSh4KTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTQgLyogSURMVHlwZUlkcy5JbnQgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICByZXR1cm4gc2xlYkRlY29kZShiKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnaW50JztcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiB4LnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBOYXRcbiAqL1xuZXhwb3J0IGNsYXNzIE5hdENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXROYXQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGVuY29kaW5nIG9mIEphdmFTY3JpcHQgcGxhaW4gbnVtYmVycy5cbiAgICAgICAgLy8gQnV0IHdlIHdpbGwgYWx3YXlzIGRlY29kZSB0byBiaWdpbnQuXG4gICAgICAgIGlmICgodHlwZW9mIHggPT09ICdiaWdpbnQnICYmIHggPj0gQmlnSW50KDApKSB8fCAoTnVtYmVyLmlzSW50ZWdlcih4KSAmJiB4ID49IDApKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIHJldHVybiBsZWJFbmNvZGUoeCk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKC0zIC8qIElETFR5cGVJZHMuTmF0ICovKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgcmV0dXJuIGxlYkRlY29kZShiKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnbmF0JztcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiB4LnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBGbG9hdFxuICovXG5leHBvcnQgY2xhc3MgRmxvYXRDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKF9iaXRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2JpdHMgPSBfYml0cztcbiAgICAgICAgaWYgKF9iaXRzICE9PSAzMiAmJiBfYml0cyAhPT0gNjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGEgdmFsaWQgZmxvYXQgdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0RmxvYXQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicgfHwgeCBpbnN0YW5jZW9mIE51bWJlcilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5fYml0cyAvIDgpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zik7XG4gICAgICAgIGlmICh0aGlzLl9iaXRzID09PSAzMikge1xuICAgICAgICAgICAgdmlldy5zZXRGbG9hdDMyKDAsIHgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlldy5zZXRGbG9hdDY0KDAsIHgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGVuY29kZVR5cGUoKSB7XG4gICAgICAgIGNvbnN0IG9wY29kZSA9IHRoaXMuX2JpdHMgPT09IDMyID8gLTEzIC8qIElETFR5cGVJZHMuRmxvYXQzMiAqLyA6IC0xNCAvKiBJRExUeXBlSWRzLkZsb2F0NjQgKi87XG4gICAgICAgIHJldHVybiBzbGViRW5jb2RlKG9wY29kZSk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgdGhpcy5jaGVja1R5cGUodCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gc2FmZVJlYWQoYiwgdGhpcy5fYml0cyAvIDgpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzKTtcbiAgICAgICAgaWYgKHRoaXMuX2JpdHMgPT09IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5nZXRGbG9hdDMyKDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQ2NCgwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdmbG9hdCcgKyB0aGlzLl9iaXRzO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIGZpeGVkLXdpZHRoIEludChuKVxuICovXG5leHBvcnQgY2xhc3MgRml4ZWRJbnRDbGFzcyBleHRlbmRzIFByaW1pdGl2ZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKF9iaXRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2JpdHMgPSBfYml0cztcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRGaXhlZEludCh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgY29uc3QgbWluID0gaWV4cDIodGhpcy5fYml0cyAtIDEpICogQmlnSW50KC0xKTtcbiAgICAgICAgY29uc3QgbWF4ID0gaWV4cDIodGhpcy5fYml0cyAtIDEpIC0gQmlnSW50KDEpO1xuICAgICAgICBsZXQgb2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgb2sgPSB4ID49IG1pbiAmJiB4IDw9IG1heDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHgpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gQmlnSW50KHgpO1xuICAgICAgICAgICAgb2sgPSB2ID49IG1pbiAmJiB2IDw9IG1heDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9rKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIHJldHVybiB3cml0ZUludExFKHgsIHRoaXMuX2JpdHMgLyA4KTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5sb2cyKHRoaXMuX2JpdHMpIC0gMztcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTkgLSBvZmZzZXQpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBjb25zdCBudW0gPSByZWFkSW50TEUoYiwgdGhpcy5fYml0cyAvIDgpO1xuICAgICAgICBpZiAodGhpcy5fYml0cyA8PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihudW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIGBpbnQke3RoaXMuX2JpdHN9YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiB4LnRvU3RyaW5nKCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBmaXhlZC13aWR0aCBOYXQobilcbiAqL1xuZXhwb3J0IGNsYXNzIEZpeGVkTmF0Q2xhc3MgZXh0ZW5kcyBQcmltaXRpdmVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihfYml0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9iaXRzID0gX2JpdHM7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0Rml4ZWROYXQodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGNvbnN0IG1heCA9IGlleHAyKHRoaXMuX2JpdHMpO1xuICAgICAgICBsZXQgb2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB4ID49IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgb2sgPSB4IDwgbWF4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoeCkgJiYgeCA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gQmlnSW50KHgpO1xuICAgICAgICAgICAgb2sgPSB2IDwgbWF4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlVUludExFKHgsIHRoaXMuX2JpdHMgLyA4KTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5sb2cyKHRoaXMuX2JpdHMpIC0gMztcbiAgICAgICAgcmV0dXJuIHNsZWJFbmNvZGUoLTUgLSBvZmZzZXQpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBjb25zdCBudW0gPSByZWFkVUludExFKGIsIHRoaXMuX2JpdHMgLyA4KTtcbiAgICAgICAgaWYgKHRoaXMuX2JpdHMgPD0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIobnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgbmF0JHt0aGlzLl9iaXRzfWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4geC50b1N0cmluZygpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgQXJyYXlcbiAqXG4gKiBBcnJheXMgb2YgZml4ZWQtc2l6ZWQgbmF0L2ludCB0eXBlIChlLmcuIG5hdDgpLCBhcmUgZW5jb2RlZCBmcm9tIGFuZCBkZWNvZGVkIHRvIFR5cGVkQXJyYXlzIChlLmcuIFVpbnQ4QXJyYXkpLlxuICogQXJyYXlzIG9mIGZsb2F0IG9yIG90aGVyIG5vbi1wcmltaXRpdmUgdHlwZXMgYXJlIGVuY29kZWQvZGVjb2RlZCBhcyB1bnR5cGVkIGFycmF5IGluIEphdmFzY3JpcHQuXG4gKiBAcGFyYW0ge1R5cGV9IHRcbiAqL1xuZXhwb3J0IGNsYXNzIFZlY0NsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoX3R5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9IF90eXBlO1xuICAgICAgICAvLyBJZiB0cnVlLCB0aGlzIHZlY3RvciBpcyByZWFsbHkgYSBibG9iIGFuZCB3ZSBjYW4ganVzdCB1c2UgbWVtY3B5LlxuICAgICAgICAvL1xuICAgICAgICAvLyBOT1RFOlxuICAgICAgICAvLyBXaXRoIHN1cHBvcnQgb2YgZW5jb2RpbmcvZGVuY29kaW5nIG9mIFR5cGVkQXJyYXlzLCB0aGlzIG9wdGltaXphdGlvbiBpc1xuICAgICAgICAvLyBvbmx5IHVzZWQgd2hlbiBwbGFpbiBhcnJheSBvZiBieXRlcyBhcmUgcGFzc2VkIGFzIGVuY29kaW5nIGlucHV0IGluIG9yZGVyXG4gICAgICAgIC8vIHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUuXG4gICAgICAgIHRoaXMuX2Jsb2JPcHRpbWl6YXRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKF90eXBlIGluc3RhbmNlb2YgRml4ZWROYXRDbGFzcyAmJiBfdHlwZS5fYml0cyA9PT0gOCkge1xuICAgICAgICAgICAgdGhpcy5fYmxvYk9wdGltaXphdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRWZWModGhpcywgdGhpcy5fdHlwZSwgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgQXJyYXlCdWZmZXJcbiAgICAgICAgY29uc3QgYml0cyA9IHRoaXMuX3R5cGUgaW5zdGFuY2VvZiBGaXhlZE5hdENsYXNzXG4gICAgICAgICAgICA/IHRoaXMuX3R5cGUuX2JpdHNcbiAgICAgICAgICAgIDogdGhpcy5fdHlwZSBpbnN0YW5jZW9mIEZpeGVkSW50Q2xhc3NcbiAgICAgICAgICAgICAgICA/IHRoaXMuX3R5cGUuX2JpdHNcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgIGlmICgoQXJyYXlCdWZmZXIuaXNWaWV3KHgpICYmIGJpdHMgPT0geC5CWVRFU19QRVJfRUxFTUVOVCAqIDgpIHx8XG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh4KSAmJlxuICAgICAgICAgICAgICAgIHguZXZlcnkoKHYsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUuY292YXJpYW50KHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6IFxcblxcbmluZGV4ICR7aWR4fSAtPiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJFbmNvZGUoeC5sZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5fYmxvYk9wdGltaXphdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdChsZW4sIG5ldyBVaW50OEFycmF5KHgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0KGxlbiwgbmV3IFVpbnQ4QXJyYXkoeC5idWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBuZXcgUGlwZShuZXcgQXJyYXlCdWZmZXIobGVuLmJ5dGVMZW5ndGggKyB4Lmxlbmd0aCksIDApO1xuICAgICAgICBidWYud3JpdGUobGVuKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSB0aGlzLl90eXBlLmVuY29kZVZhbHVlKGQpO1xuICAgICAgICAgICAgYnVmLndyaXRlKG5ldyBVaW50OEFycmF5KGVuY29kZWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbCh0eXBlVGFibGUpIHtcbiAgICAgICAgdGhpcy5fdHlwZS5idWlsZFR5cGVUYWJsZSh0eXBlVGFibGUpO1xuICAgICAgICBjb25zdCBvcENvZGUgPSBzbGViRW5jb2RlKC0xOSAvKiBJRExUeXBlSWRzLlZlY3RvciAqLyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3R5cGUuZW5jb2RlVHlwZSh0eXBlVGFibGUpO1xuICAgICAgICB0eXBlVGFibGUuYWRkKHRoaXMsIGNvbmNhdChvcENvZGUsIGJ1ZmZlcikpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGNvbnN0IHZlYyA9IHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBpZiAoISh2ZWMgaW5zdGFuY2VvZiBWZWNDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmVjdG9yIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBOdW1iZXIobGViRGVjb2RlKGIpKTtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgaW5zdGFuY2VvZiBGaXhlZE5hdENsYXNzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSA4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGIucmVhZChsZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90eXBlLl9iaXRzID09IDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShiLnJlYWQobGVuICogMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUuX2JpdHMgPT0gMzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGIucmVhZChsZW4gKiA0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSA2NCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnVWludDY0QXJyYXkoYi5yZWFkKGxlbiAqIDgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdHlwZSBpbnN0YW5jZW9mIEZpeGVkSW50Q2xhc3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90eXBlLl9iaXRzID09IDgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShiLnJlYWQobGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdHlwZS5fYml0cyA9PSAxNikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MTZBcnJheShiLnJlYWQobGVuICogMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGUuX2JpdHMgPT0gMzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYi5yZWFkKGxlbiAqIDQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90eXBlLl9iaXRzID09IDY0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnQ2NEFycmF5KGIucmVhZChsZW4gKiA4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXRzLnB1c2godGhpcy5fdHlwZS5kZWNvZGVWYWx1ZShiLCB2ZWMuX3R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0cztcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgdmVjICR7dGhpcy5fdHlwZS5uYW1lfWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIHJldHVybiBgdmVjICR7dGhpcy5fdHlwZS5kaXNwbGF5KCl9YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0geC5tYXAoZSA9PiB0aGlzLl90eXBlLnZhbHVlVG9TdHJpbmcoZSkpO1xuICAgICAgICByZXR1cm4gJ3ZlYyB7JyArIGVsZW1lbnRzLmpvaW4oJzsgJykgKyAnfSc7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBPcHRpb25cbiAqIEBwYXJhbSB7VHlwZX0gdFxuICovXG5leHBvcnQgY2xhc3MgT3B0Q2xhc3MgZXh0ZW5kcyBDb25zdHJ1Y3RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihfdHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90eXBlID0gX3R5cGU7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0T3B0KHRoaXMsIHRoaXMuX3R5cGUsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoeCkgJiYgKHgubGVuZ3RoID09PSAwIHx8ICh4Lmxlbmd0aCA9PT0gMSAmJiB0aGlzLl90eXBlLmNvdmFyaWFudCh4WzBdKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX0gXFxuXFxuLT4gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQobmV3IFVpbnQ4QXJyYXkoWzFdKSwgdGhpcy5fdHlwZS5lbmNvZGVWYWx1ZSh4WzBdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbCh0eXBlVGFibGUpIHtcbiAgICAgICAgdGhpcy5fdHlwZS5idWlsZFR5cGVUYWJsZSh0eXBlVGFibGUpO1xuICAgICAgICBjb25zdCBvcENvZGUgPSBzbGViRW5jb2RlKC0xOCAvKiBJRExUeXBlSWRzLk9wdCAqLyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3R5cGUuZW5jb2RlVHlwZSh0eXBlVGFibGUpO1xuICAgICAgICB0eXBlVGFibGUuYWRkKHRoaXMsIGNvbmNhdChvcENvZGUsIGJ1ZmZlcikpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBpZiAoIShvcHQgaW5zdGFuY2VvZiBPcHRDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGFuIG9wdGlvbiB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzYWZlUmVhZFVpbnQ4KGIpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBbdGhpcy5fdHlwZS5kZWNvZGVWYWx1ZShiLCBvcHQuX3R5cGUpXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYW4gb3B0aW9uIHZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgb3B0ICR7dGhpcy5fdHlwZS5uYW1lfWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIHJldHVybiBgb3B0ICR7dGhpcy5fdHlwZS5kaXNwbGF5KCl9YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIGlmICh4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgb3B0ICR7dGhpcy5fdHlwZS52YWx1ZVRvU3RyaW5nKHhbMF0pfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIFJlY29yZFxuICogQHBhcmFtIHtvYmplY3R9IFtmaWVsZHNdIC0gbWFwcGluZyBvZiBmdW5jdGlvbiBuYW1lIHRvIFR5cGVcbiAqL1xuZXhwb3J0IGNsYXNzIFJlY29yZENsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZmllbGRzID0gT2JqZWN0LmVudHJpZXMoZmllbGRzKS5zb3J0KChhLCBiKSA9PiBpZGxMYWJlbFRvSWQoYVswXSkgLSBpZGxMYWJlbFRvSWQoYlswXSkpO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdFJlY29yZCh0aGlzLCB0aGlzLl9maWVsZHMsIGQpO1xuICAgIH1cbiAgICB0cnlBc1R1cGxlKCkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHR5cGVdID0gdGhpcy5fZmllbGRzW2ldO1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gYF8ke2l9X2ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkcy5ldmVyeSgoW2ssIHRdKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgaWYgKCF4Lmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjb3JkIGlzIG1pc3Npbmcga2V5IFwiJHtrfVwiLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC5jb3ZhcmlhbnQoeFtrXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogXFxuXFxuZmllbGQgJHtrfSAtPiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5XSkgPT4geFtrZXldKTtcbiAgICAgICAgY29uc3QgYnVmcyA9IHppcFdpdGgodGhpcy5fZmllbGRzLCB2YWx1ZXMsIChbLCBjXSwgZCkgPT4gYy5lbmNvZGVWYWx1ZShkKSk7XG4gICAgICAgIHJldHVybiBjb25jYXQoLi4uYnVmcyk7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwoVCkge1xuICAgICAgICB0aGlzLl9maWVsZHMuZm9yRWFjaCgoW18sIHZhbHVlXSkgPT4gdmFsdWUuYnVpbGRUeXBlVGFibGUoVCkpO1xuICAgICAgICBjb25zdCBvcENvZGUgPSBzbGViRW5jb2RlKC0yMCAvKiBJRExUeXBlSWRzLlJlY29yZCAqLyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZSh0aGlzLl9maWVsZHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBjb25jYXQobGViRW5jb2RlKGlkbExhYmVsVG9JZChrZXkpKSwgdmFsdWUuZW5jb2RlVHlwZShUKSkpO1xuICAgICAgICBULmFkZCh0aGlzLCBjb25jYXQob3BDb2RlLCBsZW4sIGNvbmNhdCguLi5maWVsZHMpKSk7XG4gICAgfVxuICAgIGRlY29kZVZhbHVlKGIsIHQpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5jaGVja1R5cGUodCk7XG4gICAgICAgIGlmICghKHJlY29yZCBpbnN0YW5jZW9mIFJlY29yZENsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSByZWNvcmQgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHggPSB7fTtcbiAgICAgICAgbGV0IGV4cGVjdGVkUmVjb3JkSWR4ID0gMDtcbiAgICAgICAgbGV0IGFjdHVhbFJlY29yZElkeCA9IDA7XG4gICAgICAgIHdoaWxlIChhY3R1YWxSZWNvcmRJZHggPCByZWNvcmQuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtoYXNoLCB0eXBlXSA9IHJlY29yZC5fZmllbGRzW2FjdHVhbFJlY29yZElkeF07XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRSZWNvcmRJZHggPj0gdGhpcy5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdW5leHBlY3RlZCBsZWZ0IG92ZXIgZmllbGRzIHByZXNlbnQgb24gdGhlIHdpcmVcbiAgICAgICAgICAgICAgICB0eXBlLmRlY29kZVZhbHVlKGIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGFjdHVhbFJlY29yZElkeCsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2V4cGVjdEtleSwgZXhwZWN0VHlwZV0gPSB0aGlzLl9maWVsZHNbZXhwZWN0ZWRSZWNvcmRJZHhdO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRJZCA9IGlkbExhYmVsVG9JZCh0aGlzLl9maWVsZHNbZXhwZWN0ZWRSZWNvcmRJZHhdWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbElkID0gaWRsTGFiZWxUb0lkKGhhc2gpO1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkSWQgPT09IGFjdHVhbElkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgZmllbGQgb24gdGhlIHdpcmUgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgZmllbGRcbiAgICAgICAgICAgICAgICB4W2V4cGVjdEtleV0gPSBleHBlY3RUeXBlLmRlY29kZVZhbHVlKGIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkUmVjb3JkSWR4Kys7XG4gICAgICAgICAgICAgICAgYWN0dWFsUmVjb3JkSWR4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY3R1YWxJZCA+IGV4cGVjdGVkSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZXhwZWN0ZWQgZmllbGQgZG9lcyBub3QgZXhpc3Qgb24gdGhlIHdpcmVcbiAgICAgICAgICAgICAgICBpZiAoZXhwZWN0VHlwZSBpbnN0YW5jZW9mIE9wdENsYXNzIHx8IGV4cGVjdFR5cGUgaW5zdGFuY2VvZiBSZXNlcnZlZENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHhbZXhwZWN0S2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZFJlY29yZElkeCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCByZXF1aXJlZCBmaWVsZCAnICsgZXhwZWN0S2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZmllbGQgb24gdGhlIHdpcmUgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG91dHB1dCB0eXBlLCBzbyB3ZSBjYW4gc2tpcCBpdFxuICAgICAgICAgICAgICAgIHR5cGUuZGVjb2RlVmFsdWUoYiwgdHlwZSk7XG4gICAgICAgICAgICAgICAgYWN0dWFsUmVjb3JkSWR4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBsZWZ0IG92ZXIgZXhwZWN0ZWQgb3B0aW9uYWwgZmllbGRzXG4gICAgICAgIGZvciAoY29uc3QgW2V4cGVjdEtleSwgZXhwZWN0VHlwZV0gb2YgdGhpcy5fZmllbGRzLnNsaWNlKGV4cGVjdGVkUmVjb3JkSWR4KSkge1xuICAgICAgICAgICAgaWYgKGV4cGVjdFR5cGUgaW5zdGFuY2VvZiBPcHRDbGFzcyB8fCBleHBlY3RUeXBlIGluc3RhbmNlb2YgUmVzZXJ2ZWRDbGFzcykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBhc3N1bWVzIG51bGwgdmFsdWUgaW4gb3B0IGlzIHJlcHJlc2VudGVkIGFzIFtdXG4gICAgICAgICAgICAgICAgeFtleHBlY3RLZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHJlcXVpcmVkIGZpZWxkICcgKyBleHBlY3RLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBrZXkgKyAnOicgKyB2YWx1ZS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGByZWNvcmQgeyR7ZmllbGRzLmpvaW4oJzsgJyl9fWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4ga2V5ICsgJzonICsgdmFsdWUuZGlzcGxheSgpKTtcbiAgICAgICAgcmV0dXJuIGByZWNvcmQgeyR7ZmllbGRzLmpvaW4oJzsgJyl9fWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5XSkgPT4geFtrZXldKTtcbiAgICAgICAgY29uc3QgZmllbGRzID0gemlwV2l0aCh0aGlzLl9maWVsZHMsIHZhbHVlcywgKFtrLCBjXSwgZCkgPT4gayArICc9JyArIGMudmFsdWVUb1N0cmluZyhkKSk7XG4gICAgICAgIHJldHVybiBgcmVjb3JkIHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBUdXBsZSwgYSBzeW50YWN0aWMgc3VnYXIgZm9yIFJlY29yZC5cbiAqIEBwYXJhbSB7VHlwZX0gY29tcG9uZW50c1xuICovXG5leHBvcnQgY2xhc3MgVHVwbGVDbGFzcyBleHRlbmRzIFJlY29yZENsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihfY29tcG9uZW50cykge1xuICAgICAgICBjb25zdCB4ID0ge307XG4gICAgICAgIF9jb21wb25lbnRzLmZvckVhY2goKGUsIGkpID0+ICh4WydfJyArIGkgKyAnXyddID0gZSkpO1xuICAgICAgICBzdXBlcih4KTtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IF9jb21wb25lbnRzO1xuICAgIH1cbiAgICBhY2NlcHQodiwgZCkge1xuICAgICAgICByZXR1cm4gdi52aXNpdFR1cGxlKHRoaXMsIHRoaXMuX2NvbXBvbmVudHMsIGQpO1xuICAgIH1cbiAgICBjb3ZhcmlhbnQoeCkge1xuICAgICAgICAvLyBgPj1gIGJlY2F1c2UgdHVwbGVzIGNhbiBiZSBjb3ZhcmlhbnQgd2hlbiBlbmNvZGVkLlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSAmJlxuICAgICAgICAgICAgeC5sZW5ndGggPj0gdGhpcy5fZmllbGRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cy5ldmVyeSgodCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0LmNvdmFyaWFudCh4W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiBcXG5cXG5pbmRleCAke2l9IC0+ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGNvbnN0IGJ1ZnMgPSB6aXBXaXRoKHRoaXMuX2NvbXBvbmVudHMsIHgsIChjLCBkKSA9PiBjLmVuY29kZVZhbHVlKGQpKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCguLi5idWZzKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYiwgdCkge1xuICAgICAgICBjb25zdCB0dXBsZSA9IHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICBpZiAoISh0dXBsZSBpbnN0YW5jZW9mIFR1cGxlQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBhIHR1cGxlIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHVwbGUuX2NvbXBvbmVudHMubGVuZ3RoIDwgdGhpcy5fY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHVwbGUgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbaSwgd2lyZVR5cGVdIG9mIHR1cGxlLl9jb21wb25lbnRzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5fY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHZhbHVlXG4gICAgICAgICAgICAgICAgd2lyZVR5cGUuZGVjb2RlVmFsdWUoYiwgd2lyZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2godGhpcy5fY29tcG9uZW50c1tpXS5kZWNvZGVWYWx1ZShiLCB3aXJlVHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2NvbXBvbmVudHMubWFwKHZhbHVlID0+IHZhbHVlLmRpc3BsYXkoKSk7XG4gICAgICAgIHJldHVybiBgcmVjb3JkIHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHZhbHVlcykge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB6aXBXaXRoKHRoaXMuX2NvbXBvbmVudHMsIHZhbHVlcywgKGMsIGQpID0+IGMudmFsdWVUb1N0cmluZyhkKSk7XG4gICAgICAgIHJldHVybiBgcmVjb3JkIHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBJREwgVmFyaWFudFxuICogQHBhcmFtIHtvYmplY3R9IFtmaWVsZHNdIC0gbWFwcGluZyBvZiBmdW5jdGlvbiBuYW1lIHRvIFR5cGVcbiAqL1xuZXhwb3J0IGNsYXNzIFZhcmlhbnRDbGFzcyBleHRlbmRzIENvbnN0cnVjdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpZWxkcyA9IE9iamVjdC5lbnRyaWVzKGZpZWxkcykuc29ydCgoYSwgYikgPT4gaWRsTGFiZWxUb0lkKGFbMF0pIC0gaWRsTGFiZWxUb0lkKGJbMF0pKTtcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRWYXJpYW50KHRoaXMsIHRoaXMuX2ZpZWxkcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHgpLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgdGhpcy5fZmllbGRzLmV2ZXJ5KChbaywgdl0pID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF4Lmhhc093blByb3BlcnR5KGspIHx8IHYuY292YXJpYW50KHhba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6IFxcblxcbnZhcmlhbnQgJHtrfSAtPiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0aGlzLmRpc3BsYXkoKX0gYXJndW1lbnQ6ICR7dG9SZWFkYWJsZVN0cmluZyh4KX1gKTtcbiAgICB9XG4gICAgZW5jb2RlVmFsdWUoeCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2ZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgW25hbWUsIHR5cGVdID0gdGhpcy5fZmllbGRzW2ldO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBpZiAoeC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGxlYkVuY29kZShpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWYgPSB0eXBlLmVuY29kZVZhbHVlKHhbbmFtZV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jYXQoaWR4LCBidWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IEVycm9yKCdWYXJpYW50IGhhcyBubyBkYXRhOiAnICsgeCk7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwodHlwZVRhYmxlKSB7XG4gICAgICAgIHRoaXMuX2ZpZWxkcy5mb3JFYWNoKChbLCB0eXBlXSkgPT4ge1xuICAgICAgICAgICAgdHlwZS5idWlsZFR5cGVUYWJsZSh0eXBlVGFibGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb3BDb2RlID0gc2xlYkVuY29kZSgtMjEgLyogSURMVHlwZUlkcy5WYXJpYW50ICovKTtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKHRoaXMuX2ZpZWxkcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5LCB2YWx1ZV0pID0+IGNvbmNhdChsZWJFbmNvZGUoaWRsTGFiZWxUb0lkKGtleSkpLCB2YWx1ZS5lbmNvZGVUeXBlKHR5cGVUYWJsZSkpKTtcbiAgICAgICAgdHlwZVRhYmxlLmFkZCh0aGlzLCBjb25jYXQob3BDb2RlLCBsZW4sIC4uLmZpZWxkcykpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGNvbnN0IHZhcmlhbnQgPSB0aGlzLmNoZWNrVHlwZSh0KTtcbiAgICAgICAgaWYgKCEodmFyaWFudCBpbnN0YW5jZW9mIFZhcmlhbnRDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFyaWFudCB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWR4ID0gTnVtYmVyKGxlYkRlY29kZShiKSk7XG4gICAgICAgIGlmIChpZHggPj0gdmFyaWFudC5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgdmFyaWFudCBpbmRleDogJyArIGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3dpcmVIYXNoLCB3aXJlVHlwZV0gPSB2YXJpYW50Ll9maWVsZHNbaWR4XTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBleHBlY3RUeXBlXSBvZiB0aGlzLl9maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChpZGxMYWJlbFRvSWQod2lyZUhhc2gpID09PSBpZGxMYWJlbFRvSWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXhwZWN0VHlwZS5kZWNvZGVWYWx1ZShiLCB3aXJlVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgW2tleV06IHZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBmaWVsZCBoYXNoICcgKyB3aXJlSGFzaCk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5LCB0eXBlXSkgPT4ga2V5ICsgJzonICsgdHlwZS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGB2YXJpYW50IHske2ZpZWxkcy5qb2luKCc7ICcpfX1gO1xuICAgIH1cbiAgICBkaXNwbGF5KCkge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLl9maWVsZHMubWFwKChba2V5LCB0eXBlXSkgPT4ga2V5ICsgKHR5cGUubmFtZSA9PT0gJ251bGwnID8gJycgOiBgOiR7dHlwZS5kaXNwbGF5KCl9YCkpO1xuICAgICAgICByZXR1cm4gYHZhcmlhbnQgeyR7ZmllbGRzLmpvaW4oJzsgJyl9fWA7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB0eXBlXSBvZiB0aGlzLl9maWVsZHMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKHguaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGUudmFsdWVUb1N0cmluZyh4W25hbWVdKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHZhcmlhbnQgeyR7bmFtZX19YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdmFyaWFudCB7JHtuYW1lfT0ke3ZhbHVlfX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhcmlhbnQgaGFzIG5vIGRhdGE6ICcgKyB4KTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSByZWZlcmVuY2UgdG8gYW4gSURMIHR5cGUsIHVzZWQgZm9yIGRlZmluaW5nIHJlY3Vyc2l2ZSBkYXRhXG4gKiB0eXBlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlY0NsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2lkID0gUmVjQ2xhc3MuX2NvdW50ZXIrKztcbiAgICAgICAgdGhpcy5fdHlwZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjdXJzaXZlIHR5cGUgdW5pbml0aWFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdi52aXNpdFJlYyh0aGlzLCB0aGlzLl90eXBlLCBkKTtcbiAgICB9XG4gICAgZmlsbCh0KSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0O1xuICAgIH1cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPyB0aGlzLl90eXBlLmNvdmFyaWFudCh4KSA6IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGlmICghdGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY3Vyc2l2ZSB0eXBlIHVuaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUuZW5jb2RlVmFsdWUoeCk7XG4gICAgfVxuICAgIF9idWlsZFR5cGVUYWJsZUltcGwodHlwZVRhYmxlKSB7XG4gICAgICAgIGlmICghdGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY3Vyc2l2ZSB0eXBlIHVuaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZVRhYmxlLmFkZCh0aGlzLCBuZXcgVWludDhBcnJheShbXSkpO1xuICAgICAgICB0aGlzLl90eXBlLmJ1aWxkVHlwZVRhYmxlKHR5cGVUYWJsZSk7XG4gICAgICAgIHR5cGVUYWJsZS5tZXJnZSh0aGlzLCB0aGlzLl90eXBlLm5hbWUpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIGlmICghdGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY3Vyc2l2ZSB0eXBlIHVuaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGUuZGVjb2RlVmFsdWUoYiwgdCk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gYHJlY18ke3RoaXMuX2lkfWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1JlY3Vyc2l2ZSB0eXBlIHVuaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGDOvCR7dGhpcy5uYW1lfS4ke3RoaXMuX3R5cGUubmFtZX1gO1xuICAgIH1cbiAgICB2YWx1ZVRvU3RyaW5nKHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUmVjdXJzaXZlIHR5cGUgdW5pbml0aWFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZS52YWx1ZVRvU3RyaW5nKHgpO1xuICAgIH1cbn1cblJlY0NsYXNzLl9jb3VudGVyID0gMDtcbmZ1bmN0aW9uIGRlY29kZVByaW5jaXBhbElkKGIpIHtcbiAgICBjb25zdCB4ID0gc2FmZVJlYWRVaW50OChiKTtcbiAgICBpZiAoeCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZWNvZGUgcHJpbmNpcGFsJyk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IE51bWJlcihsZWJEZWNvZGUoYikpO1xuICAgIHJldHVybiBQcmluY2lwYWxJZC5mcm9tVWludDhBcnJheShuZXcgVWludDhBcnJheShzYWZlUmVhZChiLCBsZW4pKSk7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gSURMIHByaW5jaXBhbCByZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGNsYXNzIFByaW5jaXBhbENsYXNzIGV4dGVuZHMgUHJpbWl0aXZlVHlwZSB7XG4gICAgYWNjZXB0KHYsIGQpIHtcbiAgICAgICAgcmV0dXJuIHYudmlzaXRQcmluY2lwYWwodGhpcywgZCk7XG4gICAgfVxuICAgIGNvdmFyaWFudCh4KSB7XG4gICAgICAgIGlmICh4ICYmIHguX2lzUHJpbmNpcGFsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3RoaXMuZGlzcGxheSgpfSBhcmd1bWVudDogJHt0b1JlYWRhYmxlU3RyaW5nKHgpfWApO1xuICAgIH1cbiAgICBlbmNvZGVWYWx1ZSh4KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHgudG9VaW50OEFycmF5KCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlYkVuY29kZShidWYuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjb25jYXQobmV3IFVpbnQ4QXJyYXkoWzFdKSwgbGVuLCBidWYpO1xuICAgIH1cbiAgICBlbmNvZGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gc2xlYkVuY29kZSgtMjQgLyogSURMVHlwZUlkcy5QcmluY2lwYWwgKi8pO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiLCB0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUeXBlKHQpO1xuICAgICAgICByZXR1cm4gZGVjb2RlUHJpbmNpcGFsSWQoYik7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3ByaW5jaXBhbCc7XG4gICAgfVxuICAgIHZhbHVlVG9TdHJpbmcoeCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBcIiR7eC50b1RleHQoKX1cImA7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIElETCBmdW5jdGlvbiByZWZlcmVuY2UuXG4gKiBAcGFyYW0gYXJnVHlwZXMgQXJndW1lbnQgdHlwZXMuXG4gKiBAcGFyYW0gcmV0VHlwZXMgUmV0dXJuIHR5cGVzLlxuICogQHBhcmFtIGFubm90YXRpb25zIEZ1bmN0aW9uIGFubm90YXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY0NsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXJnVHlwZXMsIHJldFR5cGVzLCBhbm5vdGF0aW9ucyA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXJnVHlwZXMgPSBhcmdUeXBlcztcbiAgICAgICAgdGhpcy5yZXRUeXBlcyA9IHJldFR5cGVzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIHN0YXRpYyBhcmdzVG9TdHJpbmcodHlwZXMsIHYpIHtcbiAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJpdHkgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJygnICsgdHlwZXMubWFwKCh0LCBpKSA9PiB0LnZhbHVlVG9TdHJpbmcodltpXSkpLmpvaW4oJywgJykgKyAnKSc7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0RnVuYyh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoeCkgJiYgeC5sZW5ndGggPT09IDIgJiYgeFswXSAmJiB4WzBdLl9pc1ByaW5jaXBhbCAmJiB0eXBlb2YgeFsxXSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKFtwcmluY2lwYWwsIG1ldGhvZE5hbWVdKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHByaW5jaXBhbC50b1VpbnQ4QXJyYXkoKTtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FuaXN0ZXIgPSBjb25jYXQobmV3IFVpbnQ4QXJyYXkoWzFdKSwgbGVuLCBidWYpO1xuICAgICAgICBjb25zdCBtZXRob2QgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWV0aG9kTmFtZSk7XG4gICAgICAgIGNvbnN0IG1ldGhvZExlbiA9IGxlYkVuY29kZShtZXRob2QuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBjb25jYXQobmV3IFVpbnQ4QXJyYXkoWzFdKSwgY2FuaXN0ZXIsIG1ldGhvZExlbiwgbWV0aG9kKTtcbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbChUKSB7XG4gICAgICAgIHRoaXMuYXJnVHlwZXMuZm9yRWFjaChhcmcgPT4gYXJnLmJ1aWxkVHlwZVRhYmxlKFQpKTtcbiAgICAgICAgdGhpcy5yZXRUeXBlcy5mb3JFYWNoKGFyZyA9PiBhcmcuYnVpbGRUeXBlVGFibGUoVCkpO1xuICAgICAgICBjb25zdCBvcENvZGUgPSBzbGViRW5jb2RlKC0yMiAvKiBJRExUeXBlSWRzLkZ1bmMgKi8pO1xuICAgICAgICBjb25zdCBhcmdMZW4gPSBsZWJFbmNvZGUodGhpcy5hcmdUeXBlcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBhcmdzID0gY29uY2F0KC4uLnRoaXMuYXJnVHlwZXMubWFwKGFyZyA9PiBhcmcuZW5jb2RlVHlwZShUKSkpO1xuICAgICAgICBjb25zdCByZXRMZW4gPSBsZWJFbmNvZGUodGhpcy5yZXRUeXBlcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCByZXRzID0gY29uY2F0KC4uLnRoaXMucmV0VHlwZXMubWFwKGFyZyA9PiBhcmcuZW5jb2RlVHlwZShUKSkpO1xuICAgICAgICBjb25zdCBhbm5MZW4gPSBsZWJFbmNvZGUodGhpcy5hbm5vdGF0aW9ucy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBhbm5zID0gY29uY2F0KC4uLnRoaXMuYW5ub3RhdGlvbnMubWFwKGEgPT4gdGhpcy5lbmNvZGVBbm5vdGF0aW9uKGEpKSk7XG4gICAgICAgIFQuYWRkKHRoaXMsIGNvbmNhdChvcENvZGUsIGFyZ0xlbiwgYXJncywgcmV0TGVuLCByZXRzLCBhbm5MZW4sIGFubnMpKTtcbiAgICB9XG4gICAgZGVjb2RlVmFsdWUoYikge1xuICAgICAgICBjb25zdCB4ID0gc2FmZVJlYWRVaW50OChiKTtcbiAgICAgICAgaWYgKHggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY29kZSBmdW5jdGlvbiByZWZlcmVuY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW5pc3RlciA9IGRlY29kZVByaW5jaXBhbElkKGIpO1xuICAgICAgICBjb25zdCBtTGVuID0gTnVtYmVyKGxlYkRlY29kZShiKSk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHNhZmVSZWFkKGIsIG1MZW4pO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGY4JywgeyBmYXRhbDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gZGVjb2Rlci5kZWNvZGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIFtjYW5pc3RlciwgbWV0aG9kXTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ1R5cGVzLm1hcChhcmcgPT4gYXJnLm5hbWUpLmpvaW4oJywgJyk7XG4gICAgICAgIGNvbnN0IHJldHMgPSB0aGlzLnJldFR5cGVzLm1hcChhcmcgPT4gYXJnLm5hbWUpLmpvaW4oJywgJyk7XG4gICAgICAgIGNvbnN0IGFubm9uID0gJyAnICsgdGhpcy5hbm5vdGF0aW9ucy5qb2luKCcgJyk7XG4gICAgICAgIHJldHVybiBgKCR7YXJnc30pIC0+ICgke3JldHN9KSR7YW5ub259YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyhbcHJpbmNpcGFsLCBzdHJdKSB7XG4gICAgICAgIHJldHVybiBgZnVuYyBcIiR7cHJpbmNpcGFsLnRvVGV4dCgpfVwiLiR7c3RyfWA7XG4gICAgfVxuICAgIGRpc3BsYXkoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ1R5cGVzLm1hcChhcmcgPT4gYXJnLmRpc3BsYXkoKSkuam9pbignLCAnKTtcbiAgICAgICAgY29uc3QgcmV0cyA9IHRoaXMucmV0VHlwZXMubWFwKGFyZyA9PiBhcmcuZGlzcGxheSgpKS5qb2luKCcsICcpO1xuICAgICAgICBjb25zdCBhbm5vbiA9ICcgJyArIHRoaXMuYW5ub3RhdGlvbnMuam9pbignICcpO1xuICAgICAgICByZXR1cm4gYCgke2FyZ3N9KSDihpIgKCR7cmV0c30pJHthbm5vbn1gO1xuICAgIH1cbiAgICBlbmNvZGVBbm5vdGF0aW9uKGFubikge1xuICAgICAgICBpZiAoYW5uID09PSAncXVlcnknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbm4gPT09ICdvbmV3YXknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbm4gPT09ICdjb21wb3NpdGVfcXVlcnknKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzNdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBmdW5jdGlvbiBhbm5vdGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU2VydmljZUNsYXNzIGV4dGVuZHMgQ29uc3RydWN0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZpZWxkcyA9IE9iamVjdC5lbnRyaWVzKGZpZWxkcykuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGFbMF0gPCBiWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFbMF0gPiBiWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFjY2VwdCh2LCBkKSB7XG4gICAgICAgIHJldHVybiB2LnZpc2l0U2VydmljZSh0aGlzLCBkKTtcbiAgICB9XG4gICAgY292YXJpYW50KHgpIHtcbiAgICAgICAgaWYgKHggJiYgeC5faXNQcmluY2lwYWwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkICR7dGhpcy5kaXNwbGF5KCl9IGFyZ3VtZW50OiAke3RvUmVhZGFibGVTdHJpbmcoeCl9YCk7XG4gICAgfVxuICAgIGVuY29kZVZhbHVlKHgpIHtcbiAgICAgICAgY29uc3QgYnVmID0geC50b1VpbnQ4QXJyYXkoKTtcbiAgICAgICAgY29uc3QgbGVuID0gbGViRW5jb2RlKGJ1Zi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gY29uY2F0KG5ldyBVaW50OEFycmF5KFsxXSksIGxlbiwgYnVmKTtcbiAgICB9XG4gICAgX2J1aWxkVHlwZVRhYmxlSW1wbChUKSB7XG4gICAgICAgIHRoaXMuX2ZpZWxkcy5mb3JFYWNoKChbXywgZnVuY10pID0+IGZ1bmMuYnVpbGRUeXBlVGFibGUoVCkpO1xuICAgICAgICBjb25zdCBvcENvZGUgPSBzbGViRW5jb2RlKC0yMyAvKiBJRExUeXBlSWRzLlNlcnZpY2UgKi8pO1xuICAgICAgICBjb25zdCBsZW4gPSBsZWJFbmNvZGUodGhpcy5fZmllbGRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1ldGhzID0gdGhpcy5fZmllbGRzLm1hcCgoW2xhYmVsLCBmdW5jXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFiZWxCdWYgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobGFiZWwpO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxMZW4gPSBsZWJFbmNvZGUobGFiZWxCdWYubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQobGFiZWxMZW4sIGxhYmVsQnVmLCBmdW5jLmVuY29kZVR5cGUoVCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgVC5hZGQodGhpcywgY29uY2F0KG9wQ29kZSwgbGVuLCAuLi5tZXRocykpO1xuICAgIH1cbiAgICBkZWNvZGVWYWx1ZShiKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVQcmluY2lwYWxJZChiKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4ga2V5ICsgJzonICsgdmFsdWUubmFtZSk7XG4gICAgICAgIHJldHVybiBgc2VydmljZSB7JHtmaWVsZHMuam9pbignOyAnKX19YDtcbiAgICB9XG4gICAgdmFsdWVUb1N0cmluZyh4KSB7XG4gICAgICAgIHJldHVybiBgc2VydmljZSBcIiR7eC50b1RleHQoKX1cImA7XG4gICAgfVxufVxuLyoqXG4gKlxuICogQHBhcmFtIHhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvUmVhZGFibGVTdHJpbmcoeCkge1xuICAgIGNvbnN0IHN0ciA9IEpTT04uc3RyaW5naWZ5KHgsIChfa2V5LCB2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyA/IGBCaWdJbnQoJHt2YWx1ZX0pYCA6IHZhbHVlKTtcbiAgICByZXR1cm4gc3RyICYmIHN0ci5sZW5ndGggPiB0b1JlYWRhYmxlU3RyaW5nX21heFxuICAgICAgICA/IHN0ci5zdWJzdHJpbmcoMCwgdG9SZWFkYWJsZVN0cmluZ19tYXggLSAzKSArICcuLi4nXG4gICAgICAgIDogc3RyO1xufVxuLyoqXG4gKiBFbmNvZGUgYSBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSBhcmdUeXBlc1xuICogQHBhcmFtIGFyZ3NcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IHNlcmlhbGlzZWQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShhcmdUeXBlcywgYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA8IGFyZ1R5cGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBFcnJvcignV3JvbmcgbnVtYmVyIG9mIG1lc3NhZ2UgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGVUYWJsZSA9IG5ldyBUeXBlVGFibGUoKTtcbiAgICBhcmdUeXBlcy5mb3JFYWNoKHQgPT4gdC5idWlsZFR5cGVUYWJsZSh0eXBlVGFibGUpKTtcbiAgICBjb25zdCBtYWdpYyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShtYWdpY051bWJlcik7XG4gICAgY29uc3QgdGFibGUgPSB0eXBlVGFibGUuZW5jb2RlKCk7XG4gICAgY29uc3QgbGVuID0gbGViRW5jb2RlKGFyZ3MubGVuZ3RoKTtcbiAgICBjb25zdCB0eXBzID0gY29uY2F0KC4uLmFyZ1R5cGVzLm1hcCh0ID0+IHQuZW5jb2RlVHlwZSh0eXBlVGFibGUpKSk7XG4gICAgY29uc3QgdmFscyA9IGNvbmNhdCguLi56aXBXaXRoKGFyZ1R5cGVzLCBhcmdzLCAodCwgeCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdC5jb3ZhcmlhbnQoeCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihlLm1lc3NhZ2UgKyAnXFxuXFxuJyk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQuZW5jb2RlVmFsdWUoeCk7XG4gICAgfSkpO1xuICAgIHJldHVybiBjb25jYXQobWFnaWMsIHRhYmxlLCBsZW4sIHR5cHMsIHZhbHMpO1xufVxuLyoqXG4gKiBEZWNvZGUgYSBiaW5hcnkgdmFsdWVcbiAqIEBwYXJhbSByZXRUeXBlcyAtIFR5cGVzIGV4cGVjdGVkIGluIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0gYnl0ZXMgLSBoZXgtZW5jb2RlZCBzdHJpbmcsIG9yIGJ1ZmZlci5cbiAqIEByZXR1cm5zIFZhbHVlIGRlc2VyaWFsaXNlZCB0byBKUyB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUocmV0VHlwZXMsIGJ5dGVzKSB7XG4gICAgY29uc3QgYiA9IG5ldyBQaXBlKGJ5dGVzKTtcbiAgICBpZiAoYnl0ZXMuYnl0ZUxlbmd0aCA8IG1hZ2ljTnVtYmVyLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgbGVuZ3RoIHNtYWxsZXIgdGhhbiBtYWdpYyBudW1iZXInKTtcbiAgICB9XG4gICAgY29uc3QgbWFnaWNCdWZmZXIgPSBzYWZlUmVhZChiLCBtYWdpY051bWJlci5sZW5ndGgpO1xuICAgIGNvbnN0IG1hZ2ljID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG1hZ2ljQnVmZmVyKTtcbiAgICBpZiAobWFnaWMgIT09IG1hZ2ljTnVtYmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbWFnaWMgbnVtYmVyOiAnICsgSlNPTi5zdHJpbmdpZnkobWFnaWMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZFR5cGVUYWJsZShwaXBlKSB7XG4gICAgICAgIGNvbnN0IHR5cGVUYWJsZSA9IFtdO1xuICAgICAgICBjb25zdCBsZW4gPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdHkgPSBOdW1iZXIoc2xlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTggLyogSURMVHlwZUlkcy5PcHQgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAtMTkgLyogSURMVHlwZUlkcy5WZWN0b3IgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IE51bWJlcihzbGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZVRhYmxlLnB1c2goW3R5LCB0XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIC0yMCAvKiBJRExUeXBlSWRzLlJlY29yZCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIC0yMSAvKiBJRExUeXBlSWRzLlZhcmlhbnQgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBvYmplY3RMZW5ndGggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZIYXNoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAob2JqZWN0TGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNoID49IE1hdGgucG93KDIsIDMyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgaWQgb3V0IG9mIDMyLWJpdCByYW5nZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2SGFzaCA9PT0gJ251bWJlcicgJiYgcHJldkhhc2ggPj0gaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgaWQgY29sbGlzaW9uIG9yIG5vdCBzb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZIYXNoID0gaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBOdW1iZXIoc2xlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChbaGFzaCwgdF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVUYWJsZS5wdXNoKFt0eSwgZmllbGRzXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIC0yMiAvKiBJRExUeXBlSWRzLkZ1bmMgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXJnTGVuZ3RoID0gTnVtYmVyKGxlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhcmdMZW5ndGgtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKE51bWJlcihzbGViRGVjb2RlKHBpcGUpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXR1cm5WYWx1ZXNMZW5ndGggPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJldHVyblZhbHVlc0xlbmd0aC0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZXMucHVzaChOdW1iZXIoc2xlYkRlY29kZShwaXBlKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbm5vdGF0aW9uTGVuZ3RoID0gTnVtYmVyKGxlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhbm5vdGF0aW9uTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb24gPSBOdW1iZXIobGViRGVjb2RlKHBpcGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKCdxdWVyeScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2goJ29uZXdheScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2goJ2NvbXBvc2l0ZV9xdWVyeScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGFubm90YXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eXBlVGFibGUucHVzaChbdHksIFthcmdzLCByZXR1cm5WYWx1ZXMsIGFubm90YXRpb25zXV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAtMjMgLyogSURMVHlwZUlkcy5TZXJ2aWNlICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZXJ2TGVuZ3RoID0gTnVtYmVyKGxlYkRlY29kZShwaXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGhvZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNlcnZMZW5ndGgtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZUxlbmd0aCA9IE51bWJlcihsZWJEZWNvZGUocGlwZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVuY05hbWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoc2FmZVJlYWQocGlwZSwgbmFtZUxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVuY1R5cGUgPSBzbGViRGVjb2RlKHBpcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kcy5wdXNoKFtmdW5jTmFtZSwgZnVuY1R5cGVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eXBlVGFibGUucHVzaChbdHksIG1ldGhvZHNdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBvcF9jb2RlOiAnICsgdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd0xpc3QgPSBbXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gTnVtYmVyKGxlYkRlY29kZShwaXBlKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJhd0xpc3QucHVzaChOdW1iZXIoc2xlYkRlY29kZShwaXBlKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdHlwZVRhYmxlLCByYXdMaXN0XTtcbiAgICB9XG4gICAgY29uc3QgW3Jhd1RhYmxlLCByYXdUeXBlc10gPSByZWFkVHlwZVRhYmxlKGIpO1xuICAgIGlmIChyYXdUeXBlcy5sZW5ndGggPCByZXRUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBudW1iZXIgb2YgcmV0dXJuIHZhbHVlcycpO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZSA9IHJhd1RhYmxlLm1hcChfID0+IFJlYygpKTtcbiAgICBmdW5jdGlvbiBnZXRUeXBlKHQpIHtcbiAgICAgICAgaWYgKHQgPCAtMjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnV0dXJlIHZhbHVlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCA8IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsO1xuICAgICAgICAgICAgICAgIGNhc2UgLTI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCb29sO1xuICAgICAgICAgICAgICAgIGNhc2UgLTM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYXQ7XG4gICAgICAgICAgICAgICAgY2FzZSAtNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEludDtcbiAgICAgICAgICAgICAgICBjYXNlIC01OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmF0ODtcbiAgICAgICAgICAgICAgICBjYXNlIC02OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmF0MTY7XG4gICAgICAgICAgICAgICAgY2FzZSAtNzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hdDMyO1xuICAgICAgICAgICAgICAgIGNhc2UgLTg6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYXQ2NDtcbiAgICAgICAgICAgICAgICBjYXNlIC05OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW50ODtcbiAgICAgICAgICAgICAgICBjYXNlIC0xMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEludDE2O1xuICAgICAgICAgICAgICAgIGNhc2UgLTExOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW50MzI7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJbnQ2NDtcbiAgICAgICAgICAgICAgICBjYXNlIC0xMzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZsb2F0MzI7XG4gICAgICAgICAgICAgICAgY2FzZSAtMTQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGbG9hdDY0O1xuICAgICAgICAgICAgICAgIGNhc2UgLTE1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGV4dDtcbiAgICAgICAgICAgICAgICBjYXNlIC0xNjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlc2VydmVkO1xuICAgICAgICAgICAgICAgIGNhc2UgLTE3OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRW1wdHk7XG4gICAgICAgICAgICAgICAgY2FzZSAtMjQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcmluY2lwYWw7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIG9wX2NvZGU6ICcgKyB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodCA+PSByYXdUYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBpbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFibGVbdF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1aWxkVHlwZShlbnRyeSkge1xuICAgICAgICBzd2l0Y2ggKGVudHJ5WzBdKSB7XG4gICAgICAgICAgICBjYXNlIC0xOSAvKiBJRExUeXBlSWRzLlZlY3RvciAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5ID0gZ2V0VHlwZShlbnRyeVsxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlYyh0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIC0xOCAvKiBJRExUeXBlSWRzLk9wdCAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5ID0gZ2V0VHlwZShlbnRyeVsxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9wdCh0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIC0yMCAvKiBJRExUeXBlSWRzLlJlY29yZCAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2hhc2gsIHR5XSBvZiBlbnRyeVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYF8ke2hhc2h9X2A7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkc1tuYW1lXSA9IGdldFR5cGUodHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmQgPSBSZWNvcmQoZmllbGRzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0dXBsZSA9IHJlY29yZC50cnlBc1R1cGxlKCk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHVwbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUdXBsZSguLi50dXBsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgLTIxIC8qIElETFR5cGVJZHMuVmFyaWFudCAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2hhc2gsIHR5XSBvZiBlbnRyeVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYF8ke2hhc2h9X2A7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkc1tuYW1lXSA9IGdldFR5cGUodHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gVmFyaWFudChmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAtMjIgLyogSURMVHlwZUlkcy5GdW5jICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2FyZ3MsIHJldHVyblZhbHVlcywgYW5ub3RhdGlvbnNdID0gZW50cnlbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmMoYXJncy5tYXAoKHQpID0+IGdldFR5cGUodCkpLCByZXR1cm5WYWx1ZXMubWFwKCh0KSA9PiBnZXRUeXBlKHQpKSwgYW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAtMjMgLyogSURMVHlwZUlkcy5TZXJ2aWNlICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0aG9kcyA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIHR5cGVSZWZdIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBnZXRUeXBlKHR5cGVSZWYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFJlY0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1bnBhY2sgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlLmdldFR5cGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgRnVuY0NsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIHNlcnZpY2UgZGVmaW5pdGlvbjogc2VydmljZXMgY2FuIG9ubHkgY29udGFpbiBmdW5jdGlvbnMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWNbbmFtZV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gU2VydmljZShyZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgb3BfY29kZTogJyArIGVudHJ5WzBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByYXdUYWJsZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xuICAgICAgICAvLyBQcm9jZXNzIGZ1bmN0aW9uIHR5cGUgZmlyc3QsIHNvIHRoYXQgd2UgY2FuIGNvbnN0cnVjdCB0aGUgY29ycmVjdCBzZXJ2aWNlIHR5cGVcbiAgICAgICAgaWYgKGVudHJ5WzBdID09PSAtMjIgLyogSURMVHlwZUlkcy5GdW5jICovKSB7XG4gICAgICAgICAgICBjb25zdCB0ID0gYnVpbGRUeXBlKGVudHJ5KTtcbiAgICAgICAgICAgIHRhYmxlW2ldLmZpbGwodCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByYXdUYWJsZS5mb3JFYWNoKChlbnRyeSwgaSkgPT4ge1xuICAgICAgICBpZiAoZW50cnlbMF0gIT09IC0yMiAvKiBJRExUeXBlSWRzLkZ1bmMgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBidWlsZFR5cGUoZW50cnkpO1xuICAgICAgICAgICAgdGFibGVbaV0uZmlsbCh0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHR5cGVzID0gcmF3VHlwZXMubWFwKHQgPT4gZ2V0VHlwZSh0KSk7XG4gICAgY29uc3Qgb3V0cHV0ID0gcmV0VHlwZXMubWFwKCh0LCBpKSA9PiB7XG4gICAgICAgIHJldHVybiB0LmRlY29kZVZhbHVlKGIsIHR5cGVzW2ldKTtcbiAgICB9KTtcbiAgICAvLyBza2lwIHVudXNlZCB2YWx1ZXNcbiAgICBmb3IgKGxldCBpbmQgPSByZXRUeXBlcy5sZW5ndGg7IGluZCA8IHR5cGVzLmxlbmd0aDsgaW5kKyspIHtcbiAgICAgICAgdHlwZXNbaW5kXS5kZWNvZGVWYWx1ZShiLCB0eXBlc1tpbmRdKTtcbiAgICB9XG4gICAgaWYgKGIuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZWNvZGU6IExlZnQtb3ZlciBieXRlcycpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuLy8gRXhwb3J0IFR5cGVzIGluc3RhbmNlcy5cbmV4cG9ydCBjb25zdCBFbXB0eSA9IG5ldyBFbXB0eUNsYXNzKCk7XG5leHBvcnQgY29uc3QgUmVzZXJ2ZWQgPSBuZXcgUmVzZXJ2ZWRDbGFzcygpO1xuLyoqXG4gKiBDbGllbnQtb25seSB0eXBlIGZvciBkZXNlcmlhbGl6aW5nIHVua25vd24gZGF0YS4gTm90IHN1cHBvcnRlZCBieSBDYW5kaWQsIGFuZCBpdHMgdXNlIGlzIGRpc2NvdXJhZ2VkLlxuICovXG5leHBvcnQgY29uc3QgVW5rbm93biA9IG5ldyBVbmtub3duQ2xhc3MoKTtcbmV4cG9ydCBjb25zdCBCb29sID0gbmV3IEJvb2xDbGFzcygpO1xuZXhwb3J0IGNvbnN0IE51bGwgPSBuZXcgTnVsbENsYXNzKCk7XG5leHBvcnQgY29uc3QgVGV4dCA9IG5ldyBUZXh0Q2xhc3MoKTtcbmV4cG9ydCBjb25zdCBJbnQgPSBuZXcgSW50Q2xhc3MoKTtcbmV4cG9ydCBjb25zdCBOYXQgPSBuZXcgTmF0Q2xhc3MoKTtcbmV4cG9ydCBjb25zdCBGbG9hdDMyID0gbmV3IEZsb2F0Q2xhc3MoMzIpO1xuZXhwb3J0IGNvbnN0IEZsb2F0NjQgPSBuZXcgRmxvYXRDbGFzcyg2NCk7XG5leHBvcnQgY29uc3QgSW50OCA9IG5ldyBGaXhlZEludENsYXNzKDgpO1xuZXhwb3J0IGNvbnN0IEludDE2ID0gbmV3IEZpeGVkSW50Q2xhc3MoMTYpO1xuZXhwb3J0IGNvbnN0IEludDMyID0gbmV3IEZpeGVkSW50Q2xhc3MoMzIpO1xuZXhwb3J0IGNvbnN0IEludDY0ID0gbmV3IEZpeGVkSW50Q2xhc3MoNjQpO1xuZXhwb3J0IGNvbnN0IE5hdDggPSBuZXcgRml4ZWROYXRDbGFzcyg4KTtcbmV4cG9ydCBjb25zdCBOYXQxNiA9IG5ldyBGaXhlZE5hdENsYXNzKDE2KTtcbmV4cG9ydCBjb25zdCBOYXQzMiA9IG5ldyBGaXhlZE5hdENsYXNzKDMyKTtcbmV4cG9ydCBjb25zdCBOYXQ2NCA9IG5ldyBGaXhlZE5hdENsYXNzKDY0KTtcbmV4cG9ydCBjb25zdCBQcmluY2lwYWwgPSBuZXcgUHJpbmNpcGFsQ2xhc3MoKTtcbi8qKlxuICpcbiAqIEBwYXJhbSB0eXBlcyBhcnJheSBvZiBhbnkgdHlwZXNcbiAqIEByZXR1cm5zIFR1cGxlQ2xhc3MgZnJvbSB0aG9zZSB0eXBlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gVHVwbGUoLi4udHlwZXMpIHtcbiAgICByZXR1cm4gbmV3IFR1cGxlQ2xhc3ModHlwZXMpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHQgSURMIFR5cGVcbiAqIEByZXR1cm5zIFZlY0NsYXNzIGZyb20gdGhhdCB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBWZWModCkge1xuICAgIHJldHVybiBuZXcgVmVjQ2xhc3ModCk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdCBJREwgVHlwZVxuICogQHJldHVybnMgT3B0Q2xhc3Mgb2YgVHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gT3B0KHQpIHtcbiAgICByZXR1cm4gbmV3IE9wdENsYXNzKHQpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHQgUmVjb3JkIG9mIHN0cmluZyBhbmQgSURMIFR5cGVcbiAqIEByZXR1cm5zIFJlY29yZENsYXNzIG9mIHN0cmluZyBhbmQgVHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gUmVjb3JkKHQpIHtcbiAgICByZXR1cm4gbmV3IFJlY29yZENsYXNzKHQpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIGZpZWxkcyBSZWNvcmQgb2Ygc3RyaW5nIGFuZCBJREwgVHlwZVxuICogQHJldHVybnMgVmFyaWFudENsYXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBWYXJpYW50KGZpZWxkcykge1xuICAgIHJldHVybiBuZXcgVmFyaWFudENsYXNzKGZpZWxkcyk7XG59XG4vKipcbiAqXG4gKiBAcmV0dXJucyBuZXcgUmVjQ2xhc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlYygpIHtcbiAgICByZXR1cm4gbmV3IFJlY0NsYXNzKCk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gYXJncyBhcnJheSBvZiBJREwgVHlwZXNcbiAqIEBwYXJhbSByZXQgYXJyYXkgb2YgSURMIFR5cGVzXG4gKiBAcGFyYW0gYW5ub3RhdGlvbnMgYXJyYXkgb2Ygc3RyaW5ncywgW10gYnkgZGVmYXVsdFxuICogQHJldHVybnMgbmV3IEZ1bmNDbGFzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRnVuYyhhcmdzLCByZXQsIGFubm90YXRpb25zID0gW10pIHtcbiAgICByZXR1cm4gbmV3IEZ1bmNDbGFzcyhhcmdzLCByZXQsIGFubm90YXRpb25zKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB0IFJlY29yZCBvZiBzdHJpbmcgYW5kIEZ1bmNDbGFzc1xuICogQHJldHVybnMgU2VydmljZUNsYXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTZXJ2aWNlKHQpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZpY2VDbGFzcyh0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/candid/lib/esm/idl.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/candid/lib/esm/index.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/@dfinity/candid/lib/esm/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IDL: function() { return /* reexport module object */ _idl__WEBPACK_IMPORTED_MODULE_2__; },\n/* harmony export */   InputBox: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.InputBox; },\n/* harmony export */   InputForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.InputForm; },\n/* harmony export */   OptionForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.OptionForm; },\n/* harmony export */   PipeArrayBuffer: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.PipeArrayBuffer; },\n/* harmony export */   RecordForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.RecordForm; },\n/* harmony export */   Render: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.Render; },\n/* harmony export */   TupleForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.TupleForm; },\n/* harmony export */   VariantForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.VariantForm; },\n/* harmony export */   VecForm: function() { return /* reexport safe */ _candid_core__WEBPACK_IMPORTED_MODULE_1__.VecForm; },\n/* harmony export */   concat: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.concat; },\n/* harmony export */   fromHexString: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.fromHexString; },\n/* harmony export */   idlLabelToId: function() { return /* reexport safe */ _utils_hash__WEBPACK_IMPORTED_MODULE_3__.idlLabelToId; },\n/* harmony export */   inputBox: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.inputBox; },\n/* harmony export */   lebDecode: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.lebDecode; },\n/* harmony export */   lebEncode: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.lebEncode; },\n/* harmony export */   optForm: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.optForm; },\n/* harmony export */   readIntLE: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.readIntLE; },\n/* harmony export */   readUIntLE: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.readUIntLE; },\n/* harmony export */   recordForm: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.recordForm; },\n/* harmony export */   renderInput: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.renderInput; },\n/* harmony export */   renderValue: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.renderValue; },\n/* harmony export */   safeRead: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.safeRead; },\n/* harmony export */   safeReadUint8: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.safeReadUint8; },\n/* harmony export */   slebDecode: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.slebDecode; },\n/* harmony export */   slebEncode: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.slebEncode; },\n/* harmony export */   toHexString: function() { return /* reexport safe */ _utils_buffer__WEBPACK_IMPORTED_MODULE_5__.toHexString; },\n/* harmony export */   tupleForm: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.tupleForm; },\n/* harmony export */   variantForm: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.variantForm; },\n/* harmony export */   vecForm: function() { return /* reexport safe */ _candid_ui__WEBPACK_IMPORTED_MODULE_0__.vecForm; },\n/* harmony export */   writeIntLE: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.writeIntLE; },\n/* harmony export */   writeUIntLE: function() { return /* reexport safe */ _utils_leb128__WEBPACK_IMPORTED_MODULE_4__.writeUIntLE; }\n/* harmony export */ });\n/* harmony import */ var _candid_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./candid-ui */ \"../../../node_modules/@dfinity/candid/lib/esm/candid-ui.js\");\n/* harmony import */ var _candid_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./candid-core */ \"../../../node_modules/@dfinity/candid/lib/esm/candid-core.js\");\n/* harmony import */ var _idl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./idl */ \"../../../node_modules/@dfinity/candid/lib/esm/idl.js\");\n/* harmony import */ var _utils_hash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/hash */ \"../../../node_modules/@dfinity/candid/lib/esm/utils/hash.js\");\n/* harmony import */ var _utils_leb128__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/leb128 */ \"../../../node_modules/@dfinity/candid/lib/esm/utils/leb128.js\");\n/* harmony import */ var _utils_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/buffer */ \"../../../node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types */ \"../../../node_modules/@dfinity/candid/lib/esm/types.js\");\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0QjtBQUNFO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDUDtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL2luZGV4LmpzPzViODUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9jYW5kaWQtdWknO1xuZXhwb3J0ICogZnJvbSAnLi9jYW5kaWQtY29yZSc7XG5leHBvcnQgKiBhcyBJREwgZnJvbSAnLi9pZGwnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlscy9oYXNoJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvbGViMTI4JztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvYnVmZmVyJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/candid/lib/esm/index.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/candid/lib/esm/types.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/@dfinity/candid/lib/esm/types.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7QUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvY2FuZGlkL2xpYi9lc20vdHlwZXMuanM/ODNlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/candid/lib/esm/types.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   iexp2: function() { return /* binding */ iexp2; },\n/* harmony export */   ilog2: function() { return /* binding */ ilog2; }\n/* harmony export */ });\n/**\n * Equivalent to `Math.log2(n)` with support for `BigInt` values\n * @param n bigint or integer\n * @returns integer\n */\nfunction ilog2(n) {\n    const nBig = BigInt(n);\n    if (n <= 0) {\n        throw new RangeError('Input must be positive');\n    }\n    return nBig.toString(2).length - 1;\n}\n/**\n * Equivalent to `2 ** n` with support for `BigInt` values\n * (necessary for browser preprocessors which replace the `**` operator with `Math.pow`)\n * @param n bigint or integer\n * @returns bigint\n */\nfunction iexp2(n) {\n    const nBig = BigInt(n);\n    if (n < 0) {\n        throw new RangeError('Input must be non-negative');\n    }\n    return BigInt(1) << nBig;\n}\n//# sourceMappingURL=bigint-math.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2JpZ2ludC1tYXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2JpZ2ludC1tYXRoLmpzP2U3MmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFcXVpdmFsZW50IHRvIGBNYXRoLmxvZzIobilgIHdpdGggc3VwcG9ydCBmb3IgYEJpZ0ludGAgdmFsdWVzXG4gKiBAcGFyYW0gbiBiaWdpbnQgb3IgaW50ZWdlclxuICogQHJldHVybnMgaW50ZWdlclxuICovXG5leHBvcnQgZnVuY3Rpb24gaWxvZzIobikge1xuICAgIGNvbnN0IG5CaWcgPSBCaWdJbnQobik7XG4gICAgaWYgKG4gPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5wdXQgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICAgIH1cbiAgICByZXR1cm4gbkJpZy50b1N0cmluZygyKS5sZW5ndGggLSAxO1xufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIGAyICoqIG5gIHdpdGggc3VwcG9ydCBmb3IgYEJpZ0ludGAgdmFsdWVzXG4gKiAobmVjZXNzYXJ5IGZvciBicm93c2VyIHByZXByb2Nlc3NvcnMgd2hpY2ggcmVwbGFjZSB0aGUgYCoqYCBvcGVyYXRvciB3aXRoIGBNYXRoLnBvd2ApXG4gKiBAcGFyYW0gbiBiaWdpbnQgb3IgaW50ZWdlclxuICogQHJldHVybnMgYmlnaW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZXhwMihuKSB7XG4gICAgY29uc3QgbkJpZyA9IEJpZ0ludChuKTtcbiAgICBpZiAobiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0lucHV0IG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoMSkgPDwgbkJpZztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZ2ludC1tYXRoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/candid/lib/esm/utils/bigint-math.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/candid/lib/esm/utils/buffer.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/@dfinity/candid/lib/esm/utils/buffer.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PipeArrayBuffer: function() { return /* binding */ PipeArrayBuffer; },\n/* harmony export */   concat: function() { return /* binding */ concat; },\n/* harmony export */   fromHexString: function() { return /* binding */ fromHexString; },\n/* harmony export */   toHexString: function() { return /* binding */ toHexString; }\n/* harmony export */ });\n/**\n * Concatenate multiple array buffers.\n * @param buffers The buffers to concatenate.\n */\nfunction concat(...buffers) {\n    const result = new Uint8Array(buffers.reduce((acc, curr) => acc + curr.byteLength, 0));\n    let index = 0;\n    for (const b of buffers) {\n        result.set(new Uint8Array(b), index);\n        index += b.byteLength;\n    }\n    return result;\n}\n/**\n * Returns an hexadecimal representation of an array buffer.\n * @param bytes The array buffer.\n */\nfunction toHexString(bytes) {\n    return new Uint8Array(bytes).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n/**\n * Return an array buffer from its hexadecimal representation.\n * @param hexString The hexadecimal string.\n */\nfunction fromHexString(hexString) {\n    var _a;\n    return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16)));\n}\n/**\n * A class that abstracts a pipe-like ArrayBuffer.\n */\nclass PipeArrayBuffer {\n    /**\n     * Creates a new instance of a pipe\n     * @param buffer an optional buffer to start with\n     * @param length an optional amount of bytes to use for the length.\n     */\n    constructor(buffer, length = (buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) || 0) {\n        this._buffer = buffer || new ArrayBuffer(0);\n        this._view = new Uint8Array(this._buffer, 0, length);\n    }\n    get buffer() {\n        // Return a copy of the buffer.\n        return this._view.slice();\n    }\n    get byteLength() {\n        return this._view.byteLength;\n    }\n    /**\n     * Read `num` number of bytes from the front of the pipe.\n     * @param num The number of bytes to read.\n     */\n    read(num) {\n        const result = this._view.subarray(0, num);\n        this._view = this._view.subarray(num);\n        return result.slice().buffer;\n    }\n    readUint8() {\n        const result = this._view[0];\n        this._view = this._view.subarray(1);\n        return result;\n    }\n    /**\n     * Write a buffer to the end of the pipe.\n     * @param buf The bytes to write.\n     */\n    write(buf) {\n        const b = new Uint8Array(buf);\n        const offset = this._view.byteLength;\n        if (this._view.byteOffset + this._view.byteLength + b.byteLength >= this._buffer.byteLength) {\n            // Alloc grow the view to include the new bytes.\n            this.alloc(b.byteLength);\n        }\n        else {\n            // Update the view to include the new bytes.\n            this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + b.byteLength);\n        }\n        this._view.set(b, offset);\n    }\n    /**\n     * Whether or not there is more data to read from the buffer\n     */\n    get end() {\n        return this._view.byteLength === 0;\n    }\n    /**\n     * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n     * @param amount A number of bytes to add to the buffer.\n     */\n    alloc(amount) {\n        // Add a little bit of exponential growth.\n        const b = new ArrayBuffer(((this._buffer.byteLength + amount) * 1.2) | 0);\n        const v = new Uint8Array(b, 0, this._view.byteLength + amount);\n        v.set(this._view);\n        this._buffer = b;\n        this._view = v;\n    }\n}\n//# sourceMappingURL=buffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9EQUFvRCxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2J1ZmZlci5qcz8yMDQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgYXJyYXkgYnVmZmVycy5cbiAqIEBwYXJhbSBidWZmZXJzIFRoZSBidWZmZXJzIHRvIGNvbmNhdGVuYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLmJ1ZmZlcnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShidWZmZXJzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyLmJ5dGVMZW5ndGgsIDApKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgYiBvZiBidWZmZXJzKSB7XG4gICAgICAgIHJlc3VsdC5zZXQobmV3IFVpbnQ4QXJyYXkoYiksIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYi5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGFuIGFycmF5IGJ1ZmZlci5cbiAqIEBwYXJhbSBieXRlcyBUaGUgYXJyYXkgYnVmZmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXhTdHJpbmcoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpLCAnJyk7XG59XG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBidWZmZXIgZnJvbSBpdHMgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0gaGV4U3RyaW5nIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4U3RyaW5nKGhleFN0cmluZykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKChfYSA9IGhleFN0cmluZy5tYXRjaCgvLnsxLDJ9L2cpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkubWFwKGJ5dGUgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSk7XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBhYnN0cmFjdHMgYSBwaXBlLWxpa2UgQXJyYXlCdWZmZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBQaXBlQXJyYXlCdWZmZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBwaXBlXG4gICAgICogQHBhcmFtIGJ1ZmZlciBhbiBvcHRpb25hbCBidWZmZXIgdG8gc3RhcnQgd2l0aFxuICAgICAqIEBwYXJhbSBsZW5ndGggYW4gb3B0aW9uYWwgYW1vdW50IG9mIGJ5dGVzIHRvIHVzZSBmb3IgdGhlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGxlbmd0aCA9IChidWZmZXIgPT09IG51bGwgfHwgYnVmZmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBidWZmZXIuYnl0ZUxlbmd0aCkgfHwgMCkge1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBidWZmZXIgfHwgbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLl92aWV3ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmZmVyLCAwLCBsZW5ndGgpO1xuICAgIH1cbiAgICBnZXQgYnVmZmVyKCkge1xuICAgICAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBidWZmZXIuXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3LnNsaWNlKCk7XG4gICAgfVxuICAgIGdldCBieXRlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGBudW1gIG51bWJlciBvZiBieXRlcyBmcm9tIHRoZSBmcm9udCBvZiB0aGUgcGlwZS5cbiAgICAgKiBAcGFyYW0gbnVtIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKi9cbiAgICByZWFkKG51bSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl92aWV3LnN1YmFycmF5KDAsIG51bSk7XG4gICAgICAgIHRoaXMuX3ZpZXcgPSB0aGlzLl92aWV3LnN1YmFycmF5KG51bSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuc2xpY2UoKS5idWZmZXI7XG4gICAgfVxuICAgIHJlYWRVaW50OCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fdmlld1swXTtcbiAgICAgICAgdGhpcy5fdmlldyA9IHRoaXMuX3ZpZXcuc3ViYXJyYXkoMSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgYnVmZmVyIHRvIHRoZSBlbmQgb2YgdGhlIHBpcGUuXG4gICAgICogQHBhcmFtIGJ1ZiBUaGUgYnl0ZXMgdG8gd3JpdGUuXG4gICAgICovXG4gICAgd3JpdGUoYnVmKSB7XG4gICAgICAgIGNvbnN0IGIgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl92aWV3LmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl92aWV3LmJ5dGVPZmZzZXQgKyB0aGlzLl92aWV3LmJ5dGVMZW5ndGggKyBiLmJ5dGVMZW5ndGggPj0gdGhpcy5fYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEFsbG9jIGdyb3cgdGhlIHZpZXcgdG8gaW5jbHVkZSB0aGUgbmV3IGJ5dGVzLlxuICAgICAgICAgICAgdGhpcy5hbGxvYyhiLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB2aWV3IHRvIGluY2x1ZGUgdGhlIG5ldyBieXRlcy5cbiAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLl9idWZmZXIsIHRoaXMuX3ZpZXcuYnl0ZU9mZnNldCwgdGhpcy5fdmlldy5ieXRlTGVuZ3RoICsgYi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aWV3LnNldChiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBtb3JlIGRhdGEgdG8gcmVhZCBmcm9tIHRoZSBidWZmZXJcbiAgICAgKi9cbiAgICBnZXQgZW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5ieXRlTGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZSBhIGZpeGVkIGFtb3VudCBvZiBtZW1vcnkgaW4gdGhlIGJ1ZmZlci4gVGhpcyBkb2VzIG5vdCBhZmZlY3QgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIGFtb3VudCBBIG51bWJlciBvZiBieXRlcyB0byBhZGQgdG8gdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBhbGxvYyhhbW91bnQpIHtcbiAgICAgICAgLy8gQWRkIGEgbGl0dGxlIGJpdCBvZiBleHBvbmVudGlhbCBncm93dGguXG4gICAgICAgIGNvbnN0IGIgPSBuZXcgQXJyYXlCdWZmZXIoKCh0aGlzLl9idWZmZXIuYnl0ZUxlbmd0aCArIGFtb3VudCkgKiAxLjIpIHwgMCk7XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgVWludDhBcnJheShiLCAwLCB0aGlzLl92aWV3LmJ5dGVMZW5ndGggKyBhbW91bnQpO1xuICAgICAgICB2LnNldCh0aGlzLl92aWV3KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gYjtcbiAgICAgICAgdGhpcy5fdmlldyA9IHY7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/candid/lib/esm/utils/buffer.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/candid/lib/esm/utils/hash.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/@dfinity/candid/lib/esm/utils/hash.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   idlLabelToId: function() { return /* binding */ idlLabelToId; }\n/* harmony export */ });\n/**\n * Hashes a string to a number. Algorithm can be found here:\n * https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf\n * @param s\n */\nfunction idlHash(s) {\n    const utf8encoder = new TextEncoder();\n    const array = utf8encoder.encode(s);\n    let h = 0;\n    for (const c of array) {\n        h = (h * 223 + c) % 2 ** 32;\n    }\n    return h;\n}\n/**\n *\n * @param label string\n * @returns number representing hashed label\n */\nfunction idlLabelToId(label) {\n    if (/^_\\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {\n        const num = +label.slice(1, -1);\n        if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {\n            return num;\n        }\n    }\n    return idlHash(label);\n}\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2hhc2guanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9oYXNoLmpzPzcwNTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIYXNoZXMgYSBzdHJpbmcgdG8gYSBudW1iZXIuIEFsZ29yaXRobSBjYW4gYmUgZm91bmQgaGVyZTpcbiAqIGh0dHBzOi8vY2FtbC5pbnJpYS5mci9wdWIvcGFwZXJzL2dhcnJpZ3VlLXBvbHltb3JwaGljX3ZhcmlhbnRzLW1sOTgucGRmXG4gKiBAcGFyYW0gc1xuICovXG5mdW5jdGlvbiBpZGxIYXNoKHMpIHtcbiAgICBjb25zdCB1dGY4ZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGFycmF5ID0gdXRmOGVuY29kZXIuZW5jb2RlKHMpO1xuICAgIGxldCBoID0gMDtcbiAgICBmb3IgKGNvbnN0IGMgb2YgYXJyYXkpIHtcbiAgICAgICAgaCA9IChoICogMjIzICsgYykgJSAyICoqIDMyO1xuICAgIH1cbiAgICByZXR1cm4gaDtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBsYWJlbCBzdHJpbmdcbiAqIEByZXR1cm5zIG51bWJlciByZXByZXNlbnRpbmcgaGFzaGVkIGxhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGxMYWJlbFRvSWQobGFiZWwpIHtcbiAgICBpZiAoL15fXFxkK18kLy50ZXN0KGxhYmVsKSB8fCAvXl8weFswLTlhLWZBLUZdK18kLy50ZXN0KGxhYmVsKSkge1xuICAgICAgICBjb25zdCBudW0gPSArbGFiZWwuc2xpY2UoMSwgLTEpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSAmJiBudW0gPj0gMCAmJiBudW0gPCAyICoqIDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZGxIYXNoKGxhYmVsKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/candid/lib/esm/utils/hash.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/candid/lib/esm/utils/leb128.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/@dfinity/candid/lib/esm/utils/leb128.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lebDecode: function() { return /* binding */ lebDecode; },\n/* harmony export */   lebEncode: function() { return /* binding */ lebEncode; },\n/* harmony export */   readIntLE: function() { return /* binding */ readIntLE; },\n/* harmony export */   readUIntLE: function() { return /* binding */ readUIntLE; },\n/* harmony export */   safeRead: function() { return /* binding */ safeRead; },\n/* harmony export */   safeReadUint8: function() { return /* binding */ safeReadUint8; },\n/* harmony export */   slebDecode: function() { return /* binding */ slebDecode; },\n/* harmony export */   slebEncode: function() { return /* binding */ slebEncode; },\n/* harmony export */   writeIntLE: function() { return /* binding */ writeIntLE; },\n/* harmony export */   writeUIntLE: function() { return /* binding */ writeUIntLE; }\n/* harmony export */ });\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ \"../../../node_modules/@dfinity/candid/lib/esm/utils/buffer.js\");\n/* eslint-disable no-constant-condition */\n// Note: this file uses buffer-pipe, which on Node only, uses the Node Buffer\n//       implementation, which isn't compatible with the NPM buffer package\n//       which we use everywhere else. This means that we have to transform\n//       one into the other, hence why every function that returns a Buffer\n//       actually return `new Buffer(pipe.buffer)`.\n// TODO: The best solution would be to have our own buffer type around\n//       Uint8Array which is standard.\n\nfunction eob() {\n    throw new Error('unexpected end of buffer');\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param num number\n * @returns Buffer\n */\nfunction safeRead(pipe, num) {\n    if (pipe.byteLength < num) {\n        eob();\n    }\n    return pipe.read(num);\n}\n/**\n * @param pipe\n */\nfunction safeReadUint8(pipe) {\n    const byte = pipe.readUint8();\n    if (byte === undefined) {\n        eob();\n    }\n    return byte;\n}\n/**\n * Encode a positive number (or bigint) into a Buffer. The number will be floored to the\n * nearest integer.\n * @param value The number to encode.\n */\nfunction lebEncode(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    if (value < BigInt(0)) {\n        throw new Error('Cannot leb encode negative values.');\n    }\n    const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n    const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);\n    while (true) {\n        const i = Number(value & BigInt(0x7f));\n        value /= BigInt(0x80);\n        if (value === BigInt(0)) {\n            pipe.write(new Uint8Array([i]));\n            break;\n        }\n        else {\n            pipe.write(new Uint8Array([i | 0x80]));\n        }\n    }\n    return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number will always be positive (does not\n * support signed leb encoding).\n * @param pipe A Buffer containing the leb encoded bits.\n */\nfunction lebDecode(pipe) {\n    let weight = BigInt(1);\n    let value = BigInt(0);\n    let byte;\n    do {\n        byte = safeReadUint8(pipe);\n        value += BigInt(byte & 0x7f).valueOf() * weight;\n        weight *= BigInt(128);\n    } while (byte >= 0x80);\n    return value;\n}\n/**\n * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number\n * will be floored to the nearest integer.\n * @param value The number to encode.\n */\nfunction slebEncode(value) {\n    if (typeof value === 'number') {\n        value = BigInt(value);\n    }\n    const isNeg = value < BigInt(0);\n    if (isNeg) {\n        value = -value - BigInt(1);\n    }\n    const byteLength = (value === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(value)))) + 1;\n    const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(byteLength), 0);\n    while (true) {\n        const i = getLowerBytes(value);\n        value /= BigInt(0x80);\n        // prettier-ignore\n        if ((isNeg && value === BigInt(0) && (i & 0x40) !== 0)\n            || (!isNeg && value === BigInt(0) && (i & 0x40) === 0)) {\n            pipe.write(new Uint8Array([i]));\n            break;\n        }\n        else {\n            pipe.write(new Uint8Array([i | 0x80]));\n        }\n    }\n    function getLowerBytes(num) {\n        const bytes = num % BigInt(0x80);\n        if (isNeg) {\n            // We swap the bits here again, and remove 1 to do two's complement.\n            return Number(BigInt(0x80) - bytes - BigInt(1));\n        }\n        else {\n            return Number(bytes);\n        }\n    }\n    return pipe.buffer;\n}\n/**\n * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative\n * signed-leb encoding.\n * @param pipe A Buffer containing the signed leb encoded bits.\n */\nfunction slebDecode(pipe) {\n    // Get the size of the buffer, then cut a buffer of that size.\n    const pipeView = new Uint8Array(pipe.buffer);\n    let len = 0;\n    for (; len < pipeView.byteLength; len++) {\n        if (pipeView[len] < 0x80) {\n            // If it's a positive number, we reuse lebDecode.\n            if ((pipeView[len] & 0x40) === 0) {\n                return lebDecode(pipe);\n            }\n            break;\n        }\n    }\n    const bytes = new Uint8Array(safeRead(pipe, len + 1));\n    let value = BigInt(0);\n    for (let i = bytes.byteLength - 1; i >= 0; i--) {\n        value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);\n    }\n    return -value - BigInt(1);\n}\n/**\n *\n * @param value bigint or number\n * @param byteLength number\n * @returns Buffer\n */\nfunction writeUIntLE(value, byteLength) {\n    if (BigInt(value) < BigInt(0)) {\n        throw new Error('Cannot write negative values.');\n    }\n    return writeIntLE(value, byteLength);\n}\n/**\n *\n * @param value\n * @param byteLength\n */\nfunction writeIntLE(value, byteLength) {\n    value = BigInt(value);\n    const pipe = new _buffer__WEBPACK_IMPORTED_MODULE_0__.PipeArrayBuffer(new ArrayBuffer(Math.min(1, byteLength)), 0);\n    let i = 0;\n    let mul = BigInt(256);\n    let sub = BigInt(0);\n    let byte = Number(value % mul);\n    pipe.write(new Uint8Array([byte]));\n    while (++i < byteLength) {\n        if (value < 0 && sub === BigInt(0) && byte !== 0) {\n            sub = BigInt(1);\n        }\n        byte = Number((value / mul - sub) % BigInt(256));\n        pipe.write(new Uint8Array([byte]));\n        mul *= BigInt(256);\n    }\n    return pipe.buffer;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nfunction readUIntLE(pipe, byteLength) {\n    let val = BigInt(safeReadUint8(pipe));\n    let mul = BigInt(1);\n    let i = 0;\n    while (++i < byteLength) {\n        mul *= BigInt(256);\n        const byte = BigInt(safeReadUint8(pipe));\n        val = val + mul * byte;\n    }\n    return val;\n}\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nfunction readIntLE(pipe, byteLength) {\n    let val = readUIntLE(pipe, byteLength);\n    const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));\n    if (val >= mul) {\n        val -= mul * BigInt(2);\n    }\n    return val;\n}\n//# sourceMappingURL=leb128.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2NhbmRpZC9saWIvZXNtL3V0aWxzL2xlYjEyOC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9EQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUJBQXFCLG9EQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9jYW5kaWQvbGliL2VzbS91dGlscy9sZWIxMjguanM/YjQ1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zdGFudC1jb25kaXRpb24gKi9cbi8vIE5vdGU6IHRoaXMgZmlsZSB1c2VzIGJ1ZmZlci1waXBlLCB3aGljaCBvbiBOb2RlIG9ubHksIHVzZXMgdGhlIE5vZGUgQnVmZmVyXG4vLyAgICAgICBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXNuJ3QgY29tcGF0aWJsZSB3aXRoIHRoZSBOUE0gYnVmZmVyIHBhY2thZ2Vcbi8vICAgICAgIHdoaWNoIHdlIHVzZSBldmVyeXdoZXJlIGVsc2UuIFRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIHRvIHRyYW5zZm9ybVxuLy8gICAgICAgb25lIGludG8gdGhlIG90aGVyLCBoZW5jZSB3aHkgZXZlcnkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgQnVmZmVyXG4vLyAgICAgICBhY3R1YWxseSByZXR1cm4gYG5ldyBCdWZmZXIocGlwZS5idWZmZXIpYC5cbi8vIFRPRE86IFRoZSBiZXN0IHNvbHV0aW9uIHdvdWxkIGJlIHRvIGhhdmUgb3VyIG93biBidWZmZXIgdHlwZSBhcm91bmRcbi8vICAgICAgIFVpbnQ4QXJyYXkgd2hpY2ggaXMgc3RhbmRhcmQuXG5pbXBvcnQgeyBQaXBlQXJyYXlCdWZmZXIgYXMgUGlwZSB9IGZyb20gJy4vYnVmZmVyJztcbmZ1bmN0aW9uIGVvYigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGJ1ZmZlcicpO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHBpcGUgUGlwZSBmcm9tIGJ1ZmZlci1waXBlXG4gKiBAcGFyYW0gbnVtIG51bWJlclxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlUmVhZChwaXBlLCBudW0pIHtcbiAgICBpZiAocGlwZS5ieXRlTGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgIGVvYigpO1xuICAgIH1cbiAgICByZXR1cm4gcGlwZS5yZWFkKG51bSk7XG59XG4vKipcbiAqIEBwYXJhbSBwaXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlUmVhZFVpbnQ4KHBpcGUpIHtcbiAgICBjb25zdCBieXRlID0gcGlwZS5yZWFkVWludDgoKTtcbiAgICBpZiAoYnl0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVvYigpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZTtcbn1cbi8qKlxuICogRW5jb2RlIGEgcG9zaXRpdmUgbnVtYmVyIChvciBiaWdpbnQpIGludG8gYSBCdWZmZXIuIFRoZSBudW1iZXIgd2lsbCBiZSBmbG9vcmVkIHRvIHRoZVxuICogbmVhcmVzdCBpbnRlZ2VyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBudW1iZXIgdG8gZW5jb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGViRW5jb2RlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBCaWdJbnQoMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbGViIGVuY29kZSBuZWdhdGl2ZSB2YWx1ZXMuJyk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSAodmFsdWUgPT09IEJpZ0ludCgwKSA/IDAgOiBNYXRoLmNlaWwoTWF0aC5sb2cyKE51bWJlcih2YWx1ZSkpKSkgKyAxO1xuICAgIGNvbnN0IHBpcGUgPSBuZXcgUGlwZShuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCksIDApO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGkgPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHg3ZikpO1xuICAgICAgICB2YWx1ZSAvPSBCaWdJbnQoMHg4MCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICBwaXBlLndyaXRlKG5ldyBVaW50OEFycmF5KFtpXSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwaXBlLndyaXRlKG5ldyBVaW50OEFycmF5KFtpIHwgMHg4MF0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGlwZS5idWZmZXI7XG59XG4vKipcbiAqIERlY29kZSBhIGxlYiBlbmNvZGVkIGJ1ZmZlciBpbnRvIGEgYmlnaW50LiBUaGUgbnVtYmVyIHdpbGwgYWx3YXlzIGJlIHBvc2l0aXZlIChkb2VzIG5vdFxuICogc3VwcG9ydCBzaWduZWQgbGViIGVuY29kaW5nKS5cbiAqIEBwYXJhbSBwaXBlIEEgQnVmZmVyIGNvbnRhaW5pbmcgdGhlIGxlYiBlbmNvZGVkIGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWJEZWNvZGUocGlwZSkge1xuICAgIGxldCB3ZWlnaHQgPSBCaWdJbnQoMSk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGxldCBieXRlO1xuICAgIGRvIHtcbiAgICAgICAgYnl0ZSA9IHNhZmVSZWFkVWludDgocGlwZSk7XG4gICAgICAgIHZhbHVlICs9IEJpZ0ludChieXRlICYgMHg3ZikudmFsdWVPZigpICogd2VpZ2h0O1xuICAgICAgICB3ZWlnaHQgKj0gQmlnSW50KDEyOCk7XG4gICAgfSB3aGlsZSAoYnl0ZSA+PSAweDgwKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZSBhIG51bWJlciAob3IgYmlnaW50KSBpbnRvIGEgQnVmZmVyLCB3aXRoIHN1cHBvcnQgZm9yIG5lZ2F0aXZlIG51bWJlcnMuIFRoZSBudW1iZXJcbiAqIHdpbGwgYmUgZmxvb3JlZCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBudW1iZXIgdG8gZW5jb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xlYkVuY29kZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgaXNOZWcgPSB2YWx1ZSA8IEJpZ0ludCgwKTtcbiAgICBpZiAoaXNOZWcpIHtcbiAgICAgICAgdmFsdWUgPSAtdmFsdWUgLSBCaWdJbnQoMSk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSAodmFsdWUgPT09IEJpZ0ludCgwKSA/IDAgOiBNYXRoLmNlaWwoTWF0aC5sb2cyKE51bWJlcih2YWx1ZSkpKSkgKyAxO1xuICAgIGNvbnN0IHBpcGUgPSBuZXcgUGlwZShuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCksIDApO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGkgPSBnZXRMb3dlckJ5dGVzKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgLz0gQmlnSW50KDB4ODApO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKChpc05lZyAmJiB2YWx1ZSA9PT0gQmlnSW50KDApICYmIChpICYgMHg0MCkgIT09IDApXG4gICAgICAgICAgICB8fCAoIWlzTmVnICYmIHZhbHVlID09PSBCaWdJbnQoMCkgJiYgKGkgJiAweDQwKSA9PT0gMCkpIHtcbiAgICAgICAgICAgIHBpcGUud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2ldKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBpcGUud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2kgfCAweDgwXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExvd2VyQnl0ZXMobnVtKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbnVtICUgQmlnSW50KDB4ODApO1xuICAgICAgICBpZiAoaXNOZWcpIHtcbiAgICAgICAgICAgIC8vIFdlIHN3YXAgdGhlIGJpdHMgaGVyZSBhZ2FpbiwgYW5kIHJlbW92ZSAxIHRvIGRvIHR3bydzIGNvbXBsZW1lbnQuXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKEJpZ0ludCgweDgwKSAtIGJ5dGVzIC0gQmlnSW50KDEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwaXBlLmJ1ZmZlcjtcbn1cbi8qKlxuICogRGVjb2RlIGEgbGViIGVuY29kZWQgYnVmZmVyIGludG8gYSBiaWdpbnQuIFRoZSBudW1iZXIgaXMgZGVjb2RlZCB3aXRoIHN1cHBvcnQgZm9yIG5lZ2F0aXZlXG4gKiBzaWduZWQtbGViIGVuY29kaW5nLlxuICogQHBhcmFtIHBpcGUgQSBCdWZmZXIgY29udGFpbmluZyB0aGUgc2lnbmVkIGxlYiBlbmNvZGVkIGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGViRGVjb2RlKHBpcGUpIHtcbiAgICAvLyBHZXQgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlciwgdGhlbiBjdXQgYSBidWZmZXIgb2YgdGhhdCBzaXplLlxuICAgIGNvbnN0IHBpcGVWaWV3ID0gbmV3IFVpbnQ4QXJyYXkocGlwZS5idWZmZXIpO1xuICAgIGxldCBsZW4gPSAwO1xuICAgIGZvciAoOyBsZW4gPCBwaXBlVmlldy5ieXRlTGVuZ3RoOyBsZW4rKykge1xuICAgICAgICBpZiAocGlwZVZpZXdbbGVuXSA8IDB4ODApIHtcbiAgICAgICAgICAgIC8vIElmIGl0J3MgYSBwb3NpdGl2ZSBudW1iZXIsIHdlIHJldXNlIGxlYkRlY29kZS5cbiAgICAgICAgICAgIGlmICgocGlwZVZpZXdbbGVuXSAmIDB4NDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlYkRlY29kZShwaXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2FmZVJlYWQocGlwZSwgbGVuICsgMSkpO1xuICAgIGxldCB2YWx1ZSA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gYnl0ZXMuYnl0ZUxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgKiBCaWdJbnQoMHg4MCkgKyBCaWdJbnQoMHg4MCAtIChieXRlc1tpXSAmIDB4N2YpIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiAtdmFsdWUgLSBCaWdJbnQoMSk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdmFsdWUgYmlnaW50IG9yIG51bWJlclxuICogQHBhcmFtIGJ5dGVMZW5ndGggbnVtYmVyXG4gKiBAcmV0dXJucyBCdWZmZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlVUludExFKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gICAgaWYgKEJpZ0ludCh2YWx1ZSkgPCBCaWdJbnQoMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgd3JpdGUgbmVnYXRpdmUgdmFsdWVzLicpO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVJbnRMRSh2YWx1ZSwgYnl0ZUxlbmd0aCk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBieXRlTGVuZ3RoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUludExFKHZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIGNvbnN0IHBpcGUgPSBuZXcgUGlwZShuZXcgQXJyYXlCdWZmZXIoTWF0aC5taW4oMSwgYnl0ZUxlbmd0aCkpLCAwKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IG11bCA9IEJpZ0ludCgyNTYpO1xuICAgIGxldCBzdWIgPSBCaWdJbnQoMCk7XG4gICAgbGV0IGJ5dGUgPSBOdW1iZXIodmFsdWUgJSBtdWwpO1xuICAgIHBpcGUud3JpdGUobmV3IFVpbnQ4QXJyYXkoW2J5dGVdKSk7XG4gICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IEJpZ0ludCgwKSAmJiBieXRlICE9PSAwKSB7XG4gICAgICAgICAgICBzdWIgPSBCaWdJbnQoMSk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZSA9IE51bWJlcigodmFsdWUgLyBtdWwgLSBzdWIpICUgQmlnSW50KDI1NikpO1xuICAgICAgICBwaXBlLndyaXRlKG5ldyBVaW50OEFycmF5KFtieXRlXSkpO1xuICAgICAgICBtdWwgKj0gQmlnSW50KDI1Nik7XG4gICAgfVxuICAgIHJldHVybiBwaXBlLmJ1ZmZlcjtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBwaXBlIFBpcGUgZnJvbSBidWZmZXItcGlwZVxuICogQHBhcmFtIGJ5dGVMZW5ndGggbnVtYmVyXG4gKiBAcmV0dXJucyBiaWdpbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVSW50TEUocGlwZSwgYnl0ZUxlbmd0aCkge1xuICAgIGxldCB2YWwgPSBCaWdJbnQoc2FmZVJlYWRVaW50OChwaXBlKSk7XG4gICAgbGV0IG11bCA9IEJpZ0ludCgxKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGgpIHtcbiAgICAgICAgbXVsICo9IEJpZ0ludCgyNTYpO1xuICAgICAgICBjb25zdCBieXRlID0gQmlnSW50KHNhZmVSZWFkVWludDgocGlwZSkpO1xuICAgICAgICB2YWwgPSB2YWwgKyBtdWwgKiBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIHBpcGUgUGlwZSBmcm9tIGJ1ZmZlci1waXBlXG4gKiBAcGFyYW0gYnl0ZUxlbmd0aCBudW1iZXJcbiAqIEByZXR1cm5zIGJpZ2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZEludExFKHBpcGUsIGJ5dGVMZW5ndGgpIHtcbiAgICBsZXQgdmFsID0gcmVhZFVJbnRMRShwaXBlLCBieXRlTGVuZ3RoKTtcbiAgICBjb25zdCBtdWwgPSBCaWdJbnQoMikgKiogKEJpZ0ludCg4KSAqIEJpZ0ludChieXRlTGVuZ3RoIC0gMSkgKyBCaWdJbnQoNykpO1xuICAgIGlmICh2YWwgPj0gbXVsKSB7XG4gICAgICAgIHZhbCAtPSBtdWwgKiBCaWdJbnQoMik7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWIxMjguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/candid/lib/esm/utils/leb128.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/identity/lib/esm/identity/delegation.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/@dfinity/identity/lib/esm/identity/delegation.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Delegation: function() { return /* binding */ Delegation; },\n/* harmony export */   DelegationChain: function() { return /* binding */ DelegationChain; },\n/* harmony export */   DelegationIdentity: function() { return /* binding */ DelegationIdentity; },\n/* harmony export */   isDelegationValid: function() { return /* binding */ isDelegationValid; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"../../../node_modules/@dfinity/agent/lib/esm/index.js\");\n/* harmony import */ var _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dfinity/principal */ \"../../../node_modules/@dfinity/principal/lib/esm/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! simple-cbor */ \"../../../node_modules/simple-cbor/src/index.js\");\n/* harmony import */ var simple_cbor__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(simple_cbor__WEBPACK_IMPORTED_MODULE_2__);\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n\n\n\nconst domainSeparator = new TextEncoder().encode('\\x1Aic-request-auth-delegation');\nconst requestDomainSeparator = new TextEncoder().encode('\\x0Aic-request');\nfunction _parseBlob(value) {\n    if (typeof value !== 'string' || value.length < 64) {\n        throw new Error('Invalid public key.');\n    }\n    return (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.fromHex)(value);\n}\n/**\n * A single delegation object that is signed by a private key. This is constructed by\n * `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nclass Delegation {\n    constructor(pubkey, expiration, targets) {\n        this.pubkey = pubkey;\n        this.expiration = expiration;\n        this.targets = targets;\n    }\n    toCBOR() {\n        // Expiration field needs to be encoded as a u64 specifically.\n        return simple_cbor__WEBPACK_IMPORTED_MODULE_2__.value.map(Object.assign({ pubkey: simple_cbor__WEBPACK_IMPORTED_MODULE_2__.value.bytes(this.pubkey), expiration: simple_cbor__WEBPACK_IMPORTED_MODULE_2__.value.u64(this.expiration.toString(16), 16) }, (this.targets && {\n            targets: simple_cbor__WEBPACK_IMPORTED_MODULE_2__.value.array(this.targets.map(t => simple_cbor__WEBPACK_IMPORTED_MODULE_2__.value.bytes(t.toUint8Array()))),\n        })));\n    }\n    toJSON() {\n        // every string should be hex and once-de-hexed,\n        // discoverable what it is (e.g. de-hex to get JSON with a 'type' property, or de-hex to DER\n        // with an OID). After de-hex, if it's not obvious what it is, it's an ArrayBuffer.\n        return Object.assign({ expiration: this.expiration.toString(16), pubkey: (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.toHex)(this.pubkey) }, (this.targets && { targets: this.targets.map(p => p.toHex()) }));\n    }\n}\n/**\n * Sign a single delegation object for a period of time.\n * @param from The identity that lends its delegation.\n * @param to The identity that receives the delegation.\n * @param expiration An expiration date for this delegation.\n * @param targets Limit this delegation to the target principals.\n */\nasync function _createSingleDelegation(from, to, expiration, targets) {\n    const delegation = new Delegation(to.toDer(), BigInt(+expiration) * BigInt(1000000), // In nanoseconds.\n    targets);\n    // The signature is calculated by signing the concatenation of the domain separator\n    // and the message.\n    // Note: To ensure Safari treats this as a user gesture, ensure to not use async methods\n    // besides the actualy webauthn functionality (such as `sign`). Safari will de-register\n    // a user gesture if you await an async call thats not fetch, xhr, or setTimeout.\n    const challenge = new Uint8Array([\n        ...domainSeparator,\n        ...new Uint8Array((0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.requestIdOf)(delegation)),\n    ]);\n    const signature = await from.sign(challenge);\n    return {\n        delegation,\n        signature,\n    };\n}\n/**\n * A chain of delegations. This is JSON Serializable.\n * This is the object to serialize and pass to a DelegationIdentity. It does not keep any\n * private keys.\n */\nclass DelegationChain {\n    constructor(delegations, publicKey) {\n        this.delegations = delegations;\n        this.publicKey = publicKey;\n    }\n    /**\n     * Create a delegation chain between two (or more) keys. By default, the expiration time\n     * will be very short (15 minutes).\n     *\n     * To build a chain of more than 2 identities, this function needs to be called multiple times,\n     * passing the previous delegation chain into the options argument. For example:\n     * @example\n     * const rootKey = createKey();\n     * const middleKey = createKey();\n     * const bottomeKey = createKey();\n     *\n     * const rootToMiddle = await DelegationChain.create(\n     *   root, middle.getPublicKey(), Date.parse('2100-01-01'),\n     * );\n     * const middleToBottom = await DelegationChain.create(\n     *   middle, bottom.getPublicKey(), Date.parse('2100-01-01'), { previous: rootToMiddle },\n     * );\n     *\n     * // We can now use a delegation identity that uses the delegation above:\n     * const identity = DelegationIdentity.fromDelegation(bottomKey, middleToBottom);\n     * @param from The identity that will delegate.\n     * @param to The identity that gets delegated. It can now sign messages as if it was the\n     *           identity above.\n     * @param expiration The length the delegation is valid. By default, 15 minutes from calling\n     *                   this function.\n     * @param options A set of options for this delegation. expiration and previous\n     * @param options.previous - Another DelegationChain that this chain should start with.\n     * @param options.targets - targets that scope the delegation (e.g. Canister Principals)\n     */\n    static async create(from, to, expiration = new Date(Date.now() + 15 * 60 * 1000), options = {}) {\n        var _a, _b;\n        const delegation = await _createSingleDelegation(from, to, expiration, options.targets);\n        return new DelegationChain([...(((_a = options.previous) === null || _a === void 0 ? void 0 : _a.delegations) || []), delegation], ((_b = options.previous) === null || _b === void 0 ? void 0 : _b.publicKey) || from.getPublicKey().toDer());\n    }\n    /**\n     * Creates a DelegationChain object from a JSON string.\n     * @param json The JSON string to parse.\n     */\n    static fromJSON(json) {\n        const { publicKey, delegations } = typeof json === 'string' ? JSON.parse(json) : json;\n        if (!Array.isArray(delegations)) {\n            throw new Error('Invalid delegations.');\n        }\n        const parsedDelegations = delegations.map(signedDelegation => {\n            const { delegation, signature } = signedDelegation;\n            const { pubkey, expiration, targets } = delegation;\n            if (targets !== undefined && !Array.isArray(targets)) {\n                throw new Error('Invalid targets.');\n            }\n            return {\n                delegation: new Delegation(_parseBlob(pubkey), BigInt('0x' + expiration), // expiration in JSON is an hexa string (See toJSON() below).\n                targets &&\n                    targets.map((t) => {\n                        if (typeof t !== 'string') {\n                            throw new Error('Invalid target.');\n                        }\n                        return _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromHex(t);\n                    })),\n                signature: _parseBlob(signature),\n            };\n        });\n        return new this(parsedDelegations, _parseBlob(publicKey));\n    }\n    /**\n     * Creates a DelegationChain object from a list of delegations and a DER-encoded public key.\n     * @param delegations The list of delegations.\n     * @param publicKey The DER-encoded public key of the key-pair signing the first delegation.\n     */\n    static fromDelegations(delegations, publicKey) {\n        return new this(delegations, publicKey);\n    }\n    toJSON() {\n        return {\n            delegations: this.delegations.map(signedDelegation => {\n                const { delegation, signature } = signedDelegation;\n                const { targets } = delegation;\n                return {\n                    delegation: Object.assign({ expiration: delegation.expiration.toString(16), pubkey: (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.toHex)(delegation.pubkey) }, (targets && {\n                        targets: targets.map(t => t.toHex()),\n                    })),\n                    signature: (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.toHex)(signature),\n                };\n            }),\n            publicKey: (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.toHex)(this.publicKey),\n        };\n    }\n}\n/**\n * An Identity that adds delegation to a request. Everywhere in this class, the name\n * innerKey refers to the SignIdentity that is being used to sign the requests, while\n * originalKey is the identity that is being borrowed. More identities can be used\n * in the middle to delegate.\n */\nclass DelegationIdentity extends _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.SignIdentity {\n    constructor(_inner, _delegation) {\n        super();\n        this._inner = _inner;\n        this._delegation = _delegation;\n    }\n    /**\n     * Create a delegation without having access to delegateKey.\n     * @param key The key used to sign the reqyests.\n     * @param delegation A delegation object created using `createDelegation`.\n     */\n    static fromDelegation(key, delegation) {\n        return new this(key, delegation);\n    }\n    getDelegation() {\n        return this._delegation;\n    }\n    getPublicKey() {\n        return {\n            derKey: this._delegation.publicKey,\n            toDer: () => this._delegation.publicKey,\n        };\n    }\n    sign(blob) {\n        return this._inner.sign(blob);\n    }\n    async transformRequest(request) {\n        const { body } = request, fields = __rest(request, [\"body\"]);\n        const requestId = await (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.requestIdOf)(body);\n        return Object.assign(Object.assign({}, fields), { body: {\n                content: body,\n                sender_sig: await this.sign(new Uint8Array([...requestDomainSeparator, ...new Uint8Array(requestId)])),\n                sender_delegation: this._delegation.delegations,\n                sender_pubkey: this._delegation.publicKey,\n            } });\n    }\n}\n/**\n * Analyze a DelegationChain and validate that it's valid, ie. not expired and apply to the\n * scope.\n * @param chain The chain to validate.\n * @param checks Various checks to validate on the chain.\n */\nfunction isDelegationValid(chain, checks) {\n    // Verify that the no delegation is expired. If any are in the chain, returns false.\n    for (const { delegation } of chain.delegations) {\n        // prettier-ignore\n        if (+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now()) {\n            return false;\n        }\n    }\n    // Check the scopes.\n    const scopes = [];\n    const maybeScope = checks === null || checks === void 0 ? void 0 : checks.scope;\n    if (maybeScope) {\n        if (Array.isArray(maybeScope)) {\n            scopes.push(...maybeScope.map(s => (typeof s === 'string' ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(s) : s)));\n        }\n        else {\n            scopes.push(typeof maybeScope === 'string' ? _dfinity_principal__WEBPACK_IMPORTED_MODULE_1__.Principal.fromText(maybeScope) : maybeScope);\n        }\n    }\n    for (const s of scopes) {\n        const scope = s.toText();\n        for (const { delegation } of chain.delegations) {\n            if (delegation.targets === undefined) {\n                continue;\n            }\n            let none = true;\n            for (const target of delegation.targets) {\n                if (target.toText() === scope) {\n                    none = false;\n                    break;\n                }\n            }\n            if (none) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=delegation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2lkZW50aXR5L2xpYi9lc20vaWRlbnRpdHkvZGVsZWdhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLGNBQWMsU0FBSSxJQUFJLFNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRFO0FBQzdCO0FBQ1g7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQVUscUJBQXFCLFFBQVEsOENBQVUsaUNBQWlDLDhDQUFVLHdDQUF3QztBQUNuSixxQkFBcUIsOENBQVUsNkJBQTZCLDhDQUFVO0FBQ3RFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtEQUFrRCxxREFBSyxlQUFlLHFCQUFxQiwyQ0FBMkM7QUFDcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSx3QkFBd0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5REFBUztBQUN4QyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQSxnREFBZ0Qsd0RBQXdELHFEQUFLLHFCQUFxQjtBQUNsSTtBQUNBLHFCQUFxQjtBQUNyQiwrQkFBK0IscURBQUs7QUFDcEM7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCLHFEQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyx3REFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0NBQWdDLDJEQUFXO0FBQzNDLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UseURBQVM7QUFDakY7QUFDQTtBQUNBLHlEQUF5RCx5REFBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2lkZW50aXR5L2xpYi9lc20vaWRlbnRpdHkvZGVsZWdhdGlvbi5qcz9jYWFlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbmltcG9ydCB7IGZyb21IZXgsIHJlcXVlc3RJZE9mLCBTaWduSWRlbnRpdHksIHRvSGV4LCB9IGZyb20gJ0BkZmluaXR5L2FnZW50JztcbmltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gJ0BkZmluaXR5L3ByaW5jaXBhbCc7XG5pbXBvcnQgKiBhcyBjYm9yIGZyb20gJ3NpbXBsZS1jYm9yJztcbmNvbnN0IGRvbWFpblNlcGFyYXRvciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnXFx4MUFpYy1yZXF1ZXN0LWF1dGgtZGVsZWdhdGlvbicpO1xuY29uc3QgcmVxdWVzdERvbWFpblNlcGFyYXRvciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnXFx4MEFpYy1yZXF1ZXN0Jyk7XG5mdW5jdGlvbiBfcGFyc2VCbG9iKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgdmFsdWUubGVuZ3RoIDwgNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHB1YmxpYyBrZXkuJyk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tSGV4KHZhbHVlKTtcbn1cbi8qKlxuICogQSBzaW5nbGUgZGVsZWdhdGlvbiBvYmplY3QgdGhhdCBpcyBzaWduZWQgYnkgYSBwcml2YXRlIGtleS4gVGhpcyBpcyBjb25zdHJ1Y3RlZCBieVxuICogYERlbGVnYXRpb25DaGFpbi5jcmVhdGUoKWAuXG4gKlxuICoge0BzZWUgRGVsZWdhdGlvbkNoYWlufVxuICovXG5leHBvcnQgY2xhc3MgRGVsZWdhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocHVia2V5LCBleHBpcmF0aW9uLCB0YXJnZXRzKSB7XG4gICAgICAgIHRoaXMucHVia2V5ID0gcHVia2V5O1xuICAgICAgICB0aGlzLmV4cGlyYXRpb24gPSBleHBpcmF0aW9uO1xuICAgICAgICB0aGlzLnRhcmdldHMgPSB0YXJnZXRzO1xuICAgIH1cbiAgICB0b0NCT1IoKSB7XG4gICAgICAgIC8vIEV4cGlyYXRpb24gZmllbGQgbmVlZHMgdG8gYmUgZW5jb2RlZCBhcyBhIHU2NCBzcGVjaWZpY2FsbHkuXG4gICAgICAgIHJldHVybiBjYm9yLnZhbHVlLm1hcChPYmplY3QuYXNzaWduKHsgcHVia2V5OiBjYm9yLnZhbHVlLmJ5dGVzKHRoaXMucHVia2V5KSwgZXhwaXJhdGlvbjogY2Jvci52YWx1ZS51NjQodGhpcy5leHBpcmF0aW9uLnRvU3RyaW5nKDE2KSwgMTYpIH0sICh0aGlzLnRhcmdldHMgJiYge1xuICAgICAgICAgICAgdGFyZ2V0czogY2Jvci52YWx1ZS5hcnJheSh0aGlzLnRhcmdldHMubWFwKHQgPT4gY2Jvci52YWx1ZS5ieXRlcyh0LnRvVWludDhBcnJheSgpKSkpLFxuICAgICAgICB9KSkpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIC8vIGV2ZXJ5IHN0cmluZyBzaG91bGQgYmUgaGV4IGFuZCBvbmNlLWRlLWhleGVkLFxuICAgICAgICAvLyBkaXNjb3ZlcmFibGUgd2hhdCBpdCBpcyAoZS5nLiBkZS1oZXggdG8gZ2V0IEpTT04gd2l0aCBhICd0eXBlJyBwcm9wZXJ0eSwgb3IgZGUtaGV4IHRvIERFUlxuICAgICAgICAvLyB3aXRoIGFuIE9JRCkuIEFmdGVyIGRlLWhleCwgaWYgaXQncyBub3Qgb2J2aW91cyB3aGF0IGl0IGlzLCBpdCdzIGFuIEFycmF5QnVmZmVyLlxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGV4cGlyYXRpb246IHRoaXMuZXhwaXJhdGlvbi50b1N0cmluZygxNiksIHB1YmtleTogdG9IZXgodGhpcy5wdWJrZXkpIH0sICh0aGlzLnRhcmdldHMgJiYgeyB0YXJnZXRzOiB0aGlzLnRhcmdldHMubWFwKHAgPT4gcC50b0hleCgpKSB9KSk7XG4gICAgfVxufVxuLyoqXG4gKiBTaWduIGEgc2luZ2xlIGRlbGVnYXRpb24gb2JqZWN0IGZvciBhIHBlcmlvZCBvZiB0aW1lLlxuICogQHBhcmFtIGZyb20gVGhlIGlkZW50aXR5IHRoYXQgbGVuZHMgaXRzIGRlbGVnYXRpb24uXG4gKiBAcGFyYW0gdG8gVGhlIGlkZW50aXR5IHRoYXQgcmVjZWl2ZXMgdGhlIGRlbGVnYXRpb24uXG4gKiBAcGFyYW0gZXhwaXJhdGlvbiBBbiBleHBpcmF0aW9uIGRhdGUgZm9yIHRoaXMgZGVsZWdhdGlvbi5cbiAqIEBwYXJhbSB0YXJnZXRzIExpbWl0IHRoaXMgZGVsZWdhdGlvbiB0byB0aGUgdGFyZ2V0IHByaW5jaXBhbHMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9jcmVhdGVTaW5nbGVEZWxlZ2F0aW9uKGZyb20sIHRvLCBleHBpcmF0aW9uLCB0YXJnZXRzKSB7XG4gICAgY29uc3QgZGVsZWdhdGlvbiA9IG5ldyBEZWxlZ2F0aW9uKHRvLnRvRGVyKCksIEJpZ0ludCgrZXhwaXJhdGlvbikgKiBCaWdJbnQoMTAwMDAwMCksIC8vIEluIG5hbm9zZWNvbmRzLlxuICAgIHRhcmdldHMpO1xuICAgIC8vIFRoZSBzaWduYXR1cmUgaXMgY2FsY3VsYXRlZCBieSBzaWduaW5nIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSBkb21haW4gc2VwYXJhdG9yXG4gICAgLy8gYW5kIHRoZSBtZXNzYWdlLlxuICAgIC8vIE5vdGU6IFRvIGVuc3VyZSBTYWZhcmkgdHJlYXRzIHRoaXMgYXMgYSB1c2VyIGdlc3R1cmUsIGVuc3VyZSB0byBub3QgdXNlIGFzeW5jIG1ldGhvZHNcbiAgICAvLyBiZXNpZGVzIHRoZSBhY3R1YWx5IHdlYmF1dGhuIGZ1bmN0aW9uYWxpdHkgKHN1Y2ggYXMgYHNpZ25gKS4gU2FmYXJpIHdpbGwgZGUtcmVnaXN0ZXJcbiAgICAvLyBhIHVzZXIgZ2VzdHVyZSBpZiB5b3UgYXdhaXQgYW4gYXN5bmMgY2FsbCB0aGF0cyBub3QgZmV0Y2gsIHhociwgb3Igc2V0VGltZW91dC5cbiAgICBjb25zdCBjaGFsbGVuZ2UgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAgIC4uLmRvbWFpblNlcGFyYXRvcixcbiAgICAgICAgLi4ubmV3IFVpbnQ4QXJyYXkocmVxdWVzdElkT2YoZGVsZWdhdGlvbikpLFxuICAgIF0pO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGZyb20uc2lnbihjaGFsbGVuZ2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGVnYXRpb24sXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICB9O1xufVxuLyoqXG4gKiBBIGNoYWluIG9mIGRlbGVnYXRpb25zLiBUaGlzIGlzIEpTT04gU2VyaWFsaXphYmxlLlxuICogVGhpcyBpcyB0aGUgb2JqZWN0IHRvIHNlcmlhbGl6ZSBhbmQgcGFzcyB0byBhIERlbGVnYXRpb25JZGVudGl0eS4gSXQgZG9lcyBub3Qga2VlcCBhbnlcbiAqIHByaXZhdGUga2V5cy5cbiAqL1xuZXhwb3J0IGNsYXNzIERlbGVnYXRpb25DaGFpbiB7XG4gICAgY29uc3RydWN0b3IoZGVsZWdhdGlvbnMsIHB1YmxpY0tleSkge1xuICAgICAgICB0aGlzLmRlbGVnYXRpb25zID0gZGVsZWdhdGlvbnM7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gcHVibGljS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkZWxlZ2F0aW9uIGNoYWluIGJldHdlZW4gdHdvIChvciBtb3JlKSBrZXlzLiBCeSBkZWZhdWx0LCB0aGUgZXhwaXJhdGlvbiB0aW1lXG4gICAgICogd2lsbCBiZSB2ZXJ5IHNob3J0ICgxNSBtaW51dGVzKS5cbiAgICAgKlxuICAgICAqIFRvIGJ1aWxkIGEgY2hhaW4gb2YgbW9yZSB0aGFuIDIgaWRlbnRpdGllcywgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsXG4gICAgICogcGFzc2luZyB0aGUgcHJldmlvdXMgZGVsZWdhdGlvbiBjaGFpbiBpbnRvIHRoZSBvcHRpb25zIGFyZ3VtZW50LiBGb3IgZXhhbXBsZTpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHJvb3RLZXkgPSBjcmVhdGVLZXkoKTtcbiAgICAgKiBjb25zdCBtaWRkbGVLZXkgPSBjcmVhdGVLZXkoKTtcbiAgICAgKiBjb25zdCBib3R0b21lS2V5ID0gY3JlYXRlS2V5KCk7XG4gICAgICpcbiAgICAgKiBjb25zdCByb290VG9NaWRkbGUgPSBhd2FpdCBEZWxlZ2F0aW9uQ2hhaW4uY3JlYXRlKFxuICAgICAqICAgcm9vdCwgbWlkZGxlLmdldFB1YmxpY0tleSgpLCBEYXRlLnBhcnNlKCcyMTAwLTAxLTAxJyksXG4gICAgICogKTtcbiAgICAgKiBjb25zdCBtaWRkbGVUb0JvdHRvbSA9IGF3YWl0IERlbGVnYXRpb25DaGFpbi5jcmVhdGUoXG4gICAgICogICBtaWRkbGUsIGJvdHRvbS5nZXRQdWJsaWNLZXkoKSwgRGF0ZS5wYXJzZSgnMjEwMC0wMS0wMScpLCB7IHByZXZpb3VzOiByb290VG9NaWRkbGUgfSxcbiAgICAgKiApO1xuICAgICAqXG4gICAgICogLy8gV2UgY2FuIG5vdyB1c2UgYSBkZWxlZ2F0aW9uIGlkZW50aXR5IHRoYXQgdXNlcyB0aGUgZGVsZWdhdGlvbiBhYm92ZTpcbiAgICAgKiBjb25zdCBpZGVudGl0eSA9IERlbGVnYXRpb25JZGVudGl0eS5mcm9tRGVsZWdhdGlvbihib3R0b21LZXksIG1pZGRsZVRvQm90dG9tKTtcbiAgICAgKiBAcGFyYW0gZnJvbSBUaGUgaWRlbnRpdHkgdGhhdCB3aWxsIGRlbGVnYXRlLlxuICAgICAqIEBwYXJhbSB0byBUaGUgaWRlbnRpdHkgdGhhdCBnZXRzIGRlbGVnYXRlZC4gSXQgY2FuIG5vdyBzaWduIG1lc3NhZ2VzIGFzIGlmIGl0IHdhcyB0aGVcbiAgICAgKiAgICAgICAgICAgaWRlbnRpdHkgYWJvdmUuXG4gICAgICogQHBhcmFtIGV4cGlyYXRpb24gVGhlIGxlbmd0aCB0aGUgZGVsZWdhdGlvbiBpcyB2YWxpZC4gQnkgZGVmYXVsdCwgMTUgbWludXRlcyBmcm9tIGNhbGxpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICB0aGlzIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEEgc2V0IG9mIG9wdGlvbnMgZm9yIHRoaXMgZGVsZWdhdGlvbi4gZXhwaXJhdGlvbiBhbmQgcHJldmlvdXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wcmV2aW91cyAtIEFub3RoZXIgRGVsZWdhdGlvbkNoYWluIHRoYXQgdGhpcyBjaGFpbiBzaG91bGQgc3RhcnQgd2l0aC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50YXJnZXRzIC0gdGFyZ2V0cyB0aGF0IHNjb3BlIHRoZSBkZWxlZ2F0aW9uIChlLmcuIENhbmlzdGVyIFByaW5jaXBhbHMpXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShmcm9tLCB0bywgZXhwaXJhdGlvbiA9IG5ldyBEYXRlKERhdGUubm93KCkgKyAxNSAqIDYwICogMTAwMCksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBkZWxlZ2F0aW9uID0gYXdhaXQgX2NyZWF0ZVNpbmdsZURlbGVnYXRpb24oZnJvbSwgdG8sIGV4cGlyYXRpb24sIG9wdGlvbnMudGFyZ2V0cyk7XG4gICAgICAgIHJldHVybiBuZXcgRGVsZWdhdGlvbkNoYWluKFsuLi4oKChfYSA9IG9wdGlvbnMucHJldmlvdXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWxlZ2F0aW9ucykgfHwgW10pLCBkZWxlZ2F0aW9uXSwgKChfYiA9IG9wdGlvbnMucHJldmlvdXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wdWJsaWNLZXkpIHx8IGZyb20uZ2V0UHVibGljS2V5KCkudG9EZXIoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBEZWxlZ2F0aW9uQ2hhaW4gb2JqZWN0IGZyb20gYSBKU09OIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ganNvbiBUaGUgSlNPTiBzdHJpbmcgdG8gcGFyc2UuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNLZXksIGRlbGVnYXRpb25zIH0gPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRlbGVnYXRpb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRlbGVnYXRpb25zLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZERlbGVnYXRpb25zID0gZGVsZWdhdGlvbnMubWFwKHNpZ25lZERlbGVnYXRpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkZWxlZ2F0aW9uLCBzaWduYXR1cmUgfSA9IHNpZ25lZERlbGVnYXRpb247XG4gICAgICAgICAgICBjb25zdCB7IHB1YmtleSwgZXhwaXJhdGlvbiwgdGFyZ2V0cyB9ID0gZGVsZWdhdGlvbjtcbiAgICAgICAgICAgIGlmICh0YXJnZXRzICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0cykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyZ2V0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVsZWdhdGlvbjogbmV3IERlbGVnYXRpb24oX3BhcnNlQmxvYihwdWJrZXkpLCBCaWdJbnQoJzB4JyArIGV4cGlyYXRpb24pLCAvLyBleHBpcmF0aW9uIGluIEpTT04gaXMgYW4gaGV4YSBzdHJpbmcgKFNlZSB0b0pTT04oKSBiZWxvdykuXG4gICAgICAgICAgICAgICAgdGFyZ2V0cyAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YXJnZXQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJpbmNpcGFsLmZyb21IZXgodCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IF9wYXJzZUJsb2Ioc2lnbmF0dXJlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMocGFyc2VkRGVsZWdhdGlvbnMsIF9wYXJzZUJsb2IocHVibGljS2V5KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBEZWxlZ2F0aW9uQ2hhaW4gb2JqZWN0IGZyb20gYSBsaXN0IG9mIGRlbGVnYXRpb25zIGFuZCBhIERFUi1lbmNvZGVkIHB1YmxpYyBrZXkuXG4gICAgICogQHBhcmFtIGRlbGVnYXRpb25zIFRoZSBsaXN0IG9mIGRlbGVnYXRpb25zLlxuICAgICAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIERFUi1lbmNvZGVkIHB1YmxpYyBrZXkgb2YgdGhlIGtleS1wYWlyIHNpZ25pbmcgdGhlIGZpcnN0IGRlbGVnYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGZyb21EZWxlZ2F0aW9ucyhkZWxlZ2F0aW9ucywgcHVibGljS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhkZWxlZ2F0aW9ucywgcHVibGljS2V5KTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsZWdhdGlvbnM6IHRoaXMuZGVsZWdhdGlvbnMubWFwKHNpZ25lZERlbGVnYXRpb24gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsZWdhdGlvbiwgc2lnbmF0dXJlIH0gPSBzaWduZWREZWxlZ2F0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGFyZ2V0cyB9ID0gZGVsZWdhdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0aW9uOiBPYmplY3QuYXNzaWduKHsgZXhwaXJhdGlvbjogZGVsZWdhdGlvbi5leHBpcmF0aW9uLnRvU3RyaW5nKDE2KSwgcHVia2V5OiB0b0hleChkZWxlZ2F0aW9uLnB1YmtleSkgfSwgKHRhcmdldHMgJiYge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0czogdGFyZ2V0cy5tYXAodCA9PiB0LnRvSGV4KCkpLFxuICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogdG9IZXgoc2lnbmF0dXJlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHRvSGV4KHRoaXMucHVibGljS2V5KSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIEFuIElkZW50aXR5IHRoYXQgYWRkcyBkZWxlZ2F0aW9uIHRvIGEgcmVxdWVzdC4gRXZlcnl3aGVyZSBpbiB0aGlzIGNsYXNzLCB0aGUgbmFtZVxuICogaW5uZXJLZXkgcmVmZXJzIHRvIHRoZSBTaWduSWRlbnRpdHkgdGhhdCBpcyBiZWluZyB1c2VkIHRvIHNpZ24gdGhlIHJlcXVlc3RzLCB3aGlsZVxuICogb3JpZ2luYWxLZXkgaXMgdGhlIGlkZW50aXR5IHRoYXQgaXMgYmVpbmcgYm9ycm93ZWQuIE1vcmUgaWRlbnRpdGllcyBjYW4gYmUgdXNlZFxuICogaW4gdGhlIG1pZGRsZSB0byBkZWxlZ2F0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIERlbGVnYXRpb25JZGVudGl0eSBleHRlbmRzIFNpZ25JZGVudGl0eSB7XG4gICAgY29uc3RydWN0b3IoX2lubmVyLCBfZGVsZWdhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9pbm5lciA9IF9pbm5lcjtcbiAgICAgICAgdGhpcy5fZGVsZWdhdGlvbiA9IF9kZWxlZ2F0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkZWxlZ2F0aW9uIHdpdGhvdXQgaGF2aW5nIGFjY2VzcyB0byBkZWxlZ2F0ZUtleS5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdXNlZCB0byBzaWduIHRoZSByZXF5ZXN0cy5cbiAgICAgKiBAcGFyYW0gZGVsZWdhdGlvbiBBIGRlbGVnYXRpb24gb2JqZWN0IGNyZWF0ZWQgdXNpbmcgYGNyZWF0ZURlbGVnYXRpb25gLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRGVsZWdhdGlvbihrZXksIGRlbGVnYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGtleSwgZGVsZWdhdGlvbik7XG4gICAgfVxuICAgIGdldERlbGVnYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0aW9uO1xuICAgIH1cbiAgICBnZXRQdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZXJLZXk6IHRoaXMuX2RlbGVnYXRpb24ucHVibGljS2V5LFxuICAgICAgICAgICAgdG9EZXI6ICgpID0+IHRoaXMuX2RlbGVnYXRpb24ucHVibGljS2V5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzaWduKGJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyLnNpZ24oYmxvYik7XG4gICAgfVxuICAgIGFzeW5jIHRyYW5zZm9ybVJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBjb25zdCB7IGJvZHkgfSA9IHJlcXVlc3QsIGZpZWxkcyA9IF9fcmVzdChyZXF1ZXN0LCBbXCJib2R5XCJdKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gYXdhaXQgcmVxdWVzdElkT2YoYm9keSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpZWxkcyksIHsgYm9keToge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGJvZHksXG4gICAgICAgICAgICAgICAgc2VuZGVyX3NpZzogYXdhaXQgdGhpcy5zaWduKG5ldyBVaW50OEFycmF5KFsuLi5yZXF1ZXN0RG9tYWluU2VwYXJhdG9yLCAuLi5uZXcgVWludDhBcnJheShyZXF1ZXN0SWQpXSkpLFxuICAgICAgICAgICAgICAgIHNlbmRlcl9kZWxlZ2F0aW9uOiB0aGlzLl9kZWxlZ2F0aW9uLmRlbGVnYXRpb25zLFxuICAgICAgICAgICAgICAgIHNlbmRlcl9wdWJrZXk6IHRoaXMuX2RlbGVnYXRpb24ucHVibGljS2V5LFxuICAgICAgICAgICAgfSB9KTtcbiAgICB9XG59XG4vKipcbiAqIEFuYWx5emUgYSBEZWxlZ2F0aW9uQ2hhaW4gYW5kIHZhbGlkYXRlIHRoYXQgaXQncyB2YWxpZCwgaWUuIG5vdCBleHBpcmVkIGFuZCBhcHBseSB0byB0aGVcbiAqIHNjb3BlLlxuICogQHBhcmFtIGNoYWluIFRoZSBjaGFpbiB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBjaGVja3MgVmFyaW91cyBjaGVja3MgdG8gdmFsaWRhdGUgb24gdGhlIGNoYWluLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEZWxlZ2F0aW9uVmFsaWQoY2hhaW4sIGNoZWNrcykge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBubyBkZWxlZ2F0aW9uIGlzIGV4cGlyZWQuIElmIGFueSBhcmUgaW4gdGhlIGNoYWluLCByZXR1cm5zIGZhbHNlLlxuICAgIGZvciAoY29uc3QgeyBkZWxlZ2F0aW9uIH0gb2YgY2hhaW4uZGVsZWdhdGlvbnMpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICgrbmV3IERhdGUoTnVtYmVyKGRlbGVnYXRpb24uZXhwaXJhdGlvbiAvIEJpZ0ludCgxMDAwMDAwKSkpIDw9ICtEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgdGhlIHNjb3Blcy5cbiAgICBjb25zdCBzY29wZXMgPSBbXTtcbiAgICBjb25zdCBtYXliZVNjb3BlID0gY2hlY2tzID09PSBudWxsIHx8IGNoZWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hlY2tzLnNjb3BlO1xuICAgIGlmIChtYXliZVNjb3BlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1heWJlU2NvcGUpKSB7XG4gICAgICAgICAgICBzY29wZXMucHVzaCguLi5tYXliZVNjb3BlLm1hcChzID0+ICh0eXBlb2YgcyA9PT0gJ3N0cmluZycgPyBQcmluY2lwYWwuZnJvbVRleHQocykgOiBzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NvcGVzLnB1c2godHlwZW9mIG1heWJlU2NvcGUgPT09ICdzdHJpbmcnID8gUHJpbmNpcGFsLmZyb21UZXh0KG1heWJlU2NvcGUpIDogbWF5YmVTY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBzIG9mIHNjb3Blcykge1xuICAgICAgICBjb25zdCBzY29wZSA9IHMudG9UZXh0KCk7XG4gICAgICAgIGZvciAoY29uc3QgeyBkZWxlZ2F0aW9uIH0gb2YgY2hhaW4uZGVsZWdhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0aW9uLnRhcmdldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5vbmUgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgZGVsZWdhdGlvbi50YXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC50b1RleHQoKSA9PT0gc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGVnYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/identity/lib/esm/identity/delegation.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/identity/lib/esm/identity/ecdsa.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@dfinity/identity/lib/esm/identity/ecdsa.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CryptoError: function() { return /* binding */ CryptoError; },\n/* harmony export */   ECDSAKeyIdentity: function() { return /* binding */ ECDSAKeyIdentity; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"../../../node_modules/@dfinity/agent/lib/esm/index.js\");\n\nclass CryptoError extends Error {\n    constructor(message) {\n        super(message);\n        this.message = message;\n        Object.setPrototypeOf(this, CryptoError.prototype);\n    }\n}\n/**\n * Utility method to ensure that a subtleCrypto implementation is provided or is available in the global context\n * @param subtleCrypto SubtleCrypto implementation\n * @returns subleCrypto\n */\nfunction _getEffectiveCrypto(subtleCrypto) {\n    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g['crypto'] && __webpack_require__.g['crypto']['subtle']) {\n        return __webpack_require__.g['crypto']['subtle'];\n    }\n    if (subtleCrypto) {\n        return subtleCrypto;\n    }\n    else if (typeof crypto !== 'undefined' && crypto['subtle']) {\n        return crypto.subtle;\n    }\n    else {\n        throw new CryptoError('Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto');\n    }\n}\n/**\n * An identity interface that wraps an ECDSA keypair using the P-256 named curve. Supports DER-encoding and decoding for agent calls\n */\nclass ECDSAKeyIdentity extends _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.SignIdentity {\n    // `fromKeyPair` and `generate` should be used for instantiation, not this constructor.\n    constructor(keyPair, derKey, subtleCrypto) {\n        super();\n        this._keyPair = keyPair;\n        this._derKey = derKey;\n        this._subtleCrypto = subtleCrypto;\n    }\n    /**\n     * Generates a randomly generated identity for use in calls to the Internet Computer.\n     * @param {CryptoKeyOptions} options optional settings\n     * @param {CryptoKeyOptions['extractable']} options.extractable - whether the key should allow itself to be used. Set to false for maximum security.\n     * @param {CryptoKeyOptions['keyUsages']} options.keyUsages - a list of key usages that the key can be used for\n     * @param {CryptoKeyOptions['subtleCrypto']} options.subtleCrypto interface\n     * @constructs ECDSAKeyIdentity\n     * @returns a {@link ECDSAKeyIdentity}\n     */\n    static async generate(options) {\n        const { extractable = false, keyUsages = ['sign', 'verify'], subtleCrypto } = options !== null && options !== void 0 ? options : {};\n        const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n        const keyPair = await effectiveCrypto.generateKey({\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n        }, extractable, keyUsages);\n        const derKey = (await effectiveCrypto.exportKey('spki', keyPair.publicKey));\n        return new this(keyPair, derKey, effectiveCrypto);\n    }\n    /**\n     * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key\n     * @param keyPair a {@link CryptoKeyPair}\n     * @param subtleCrypto a {@link SubtleCrypto} interface in case one is not available globally\n     * @returns an {@link ECDSAKeyIdentity}\n     */\n    static async fromKeyPair(keyPair, subtleCrypto) {\n        const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n        const derKey = (await effectiveCrypto.exportKey('spki', keyPair.publicKey));\n        return new ECDSAKeyIdentity(keyPair, derKey, effectiveCrypto);\n    }\n    /**\n     * Return the internally-used key pair.\n     * @returns a {@link CryptoKeyPair}\n     */\n    getKeyPair() {\n        return this._keyPair;\n    }\n    /**\n     * Return the public key.\n     * @returns an {@link DerCryptoKey}\n     */\n    getPublicKey() {\n        const derKey = this._derKey;\n        const key = Object.create(this._keyPair.publicKey);\n        key.toDer = function () {\n            return derKey;\n        };\n        return key;\n    }\n    /**\n     * Signs a blob of data, with this identity's private key.\n     * @param {ArrayBuffer} challenge - challenge to sign with this identity's secretKey, producing a signature\n     * @returns {Promise<Signature>} signature\n     */\n    async sign(challenge) {\n        const params = {\n            name: 'ECDSA',\n            hash: { name: 'SHA-256' },\n        };\n        this._keyPair.privateKey;\n        const signature = await this._subtleCrypto.sign(params, this._keyPair.privateKey, challenge);\n        return signature;\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (ECDSAKeyIdentity);\n//# sourceMappingURL=ecdsa.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2lkZW50aXR5L2xpYi9lc20vaWRlbnRpdHkvZWNkc2EuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ3ZDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBTSxvQkFBb0IscUJBQU0sY0FBYyxxQkFBTTtBQUNuRSxlQUFlLHFCQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0Isd0RBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakMsZUFBZSxpQ0FBaUM7QUFDaEQsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGdCQUFnQixvRUFBb0U7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qiw4QkFBOEIsb0JBQW9CO0FBQ2xELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUFlLGdCQUFnQixFQUFDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvaWRlbnRpdHkvbGliL2VzbS9pZGVudGl0eS9lY2RzYS5qcz9jMDllIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNpZ25JZGVudGl0eSB9IGZyb20gJ0BkZmluaXR5L2FnZW50JztcbmV4cG9ydCBjbGFzcyBDcnlwdG9FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ3J5cHRvRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGVuc3VyZSB0aGF0IGEgc3VidGxlQ3J5cHRvIGltcGxlbWVudGF0aW9uIGlzIHByb3ZpZGVkIG9yIGlzIGF2YWlsYWJsZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAqIEBwYXJhbSBzdWJ0bGVDcnlwdG8gU3VidGxlQ3J5cHRvIGltcGxlbWVudGF0aW9uXG4gKiBAcmV0dXJucyBzdWJsZUNyeXB0b1xuICovXG5mdW5jdGlvbiBfZ2V0RWZmZWN0aXZlQ3J5cHRvKHN1YnRsZUNyeXB0bykge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxbJ2NyeXB0byddICYmIGdsb2JhbFsnY3J5cHRvJ11bJ3N1YnRsZSddKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxbJ2NyeXB0byddWydzdWJ0bGUnXTtcbiAgICB9XG4gICAgaWYgKHN1YnRsZUNyeXB0bykge1xuICAgICAgICByZXR1cm4gc3VidGxlQ3J5cHRvO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG9bJ3N1YnRsZSddKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IENyeXB0b0Vycm9yKCdHbG9iYWwgY3J5cHRvIHdhcyBub3QgYXZhaWxhYmxlIGFuZCBub25lIHdhcyBwcm92aWRlZC4gUGxlYXNlIGlubGN1ZGUgYSBTdWJ0bGVDcnlwdG8gaW1wbGVtZW50YXRpb24uIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvJyk7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBpZGVudGl0eSBpbnRlcmZhY2UgdGhhdCB3cmFwcyBhbiBFQ0RTQSBrZXlwYWlyIHVzaW5nIHRoZSBQLTI1NiBuYW1lZCBjdXJ2ZS4gU3VwcG9ydHMgREVSLWVuY29kaW5nIGFuZCBkZWNvZGluZyBmb3IgYWdlbnQgY2FsbHNcbiAqL1xuZXhwb3J0IGNsYXNzIEVDRFNBS2V5SWRlbnRpdHkgZXh0ZW5kcyBTaWduSWRlbnRpdHkge1xuICAgIC8vIGBmcm9tS2V5UGFpcmAgYW5kIGBnZW5lcmF0ZWAgc2hvdWxkIGJlIHVzZWQgZm9yIGluc3RhbnRpYXRpb24sIG5vdCB0aGlzIGNvbnN0cnVjdG9yLlxuICAgIGNvbnN0cnVjdG9yKGtleVBhaXIsIGRlcktleSwgc3VidGxlQ3J5cHRvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2tleVBhaXIgPSBrZXlQYWlyO1xuICAgICAgICB0aGlzLl9kZXJLZXkgPSBkZXJLZXk7XG4gICAgICAgIHRoaXMuX3N1YnRsZUNyeXB0byA9IHN1YnRsZUNyeXB0bztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgcmFuZG9tbHkgZ2VuZXJhdGVkIGlkZW50aXR5IGZvciB1c2UgaW4gY2FsbHMgdG8gdGhlIEludGVybmV0IENvbXB1dGVyLlxuICAgICAqIEBwYXJhbSB7Q3J5cHRvS2V5T3B0aW9uc30gb3B0aW9ucyBvcHRpb25hbCBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Q3J5cHRvS2V5T3B0aW9uc1snZXh0cmFjdGFibGUnXX0gb3B0aW9ucy5leHRyYWN0YWJsZSAtIHdoZXRoZXIgdGhlIGtleSBzaG91bGQgYWxsb3cgaXRzZWxmIHRvIGJlIHVzZWQuIFNldCB0byBmYWxzZSBmb3IgbWF4aW11bSBzZWN1cml0eS5cbiAgICAgKiBAcGFyYW0ge0NyeXB0b0tleU9wdGlvbnNbJ2tleVVzYWdlcyddfSBvcHRpb25zLmtleVVzYWdlcyAtIGEgbGlzdCBvZiBrZXkgdXNhZ2VzIHRoYXQgdGhlIGtleSBjYW4gYmUgdXNlZCBmb3JcbiAgICAgKiBAcGFyYW0ge0NyeXB0b0tleU9wdGlvbnNbJ3N1YnRsZUNyeXB0byddfSBvcHRpb25zLnN1YnRsZUNyeXB0byBpbnRlcmZhY2VcbiAgICAgKiBAY29uc3RydWN0cyBFQ0RTQUtleUlkZW50aXR5XG4gICAgICogQHJldHVybnMgYSB7QGxpbmsgRUNEU0FLZXlJZGVudGl0eX1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGV4dHJhY3RhYmxlID0gZmFsc2UsIGtleVVzYWdlcyA9IFsnc2lnbicsICd2ZXJpZnknXSwgc3VidGxlQ3J5cHRvIH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlQ3J5cHRvID0gX2dldEVmZmVjdGl2ZUNyeXB0byhzdWJ0bGVDcnlwdG8pO1xuICAgICAgICBjb25zdCBrZXlQYWlyID0gYXdhaXQgZWZmZWN0aXZlQ3J5cHRvLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiAnUC0yNTYnLFxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcbiAgICAgICAgY29uc3QgZGVyS2V5ID0gKGF3YWl0IGVmZmVjdGl2ZUNyeXB0by5leHBvcnRLZXkoJ3Nwa2knLCBrZXlQYWlyLnB1YmxpY0tleSkpO1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoa2V5UGFpciwgZGVyS2V5LCBlZmZlY3RpdmVDcnlwdG8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZXMgYW4gaWRlbnRpdHkgZnJvbSBhIHB1YmxpYyBhbmQgcHJpdmF0ZSBrZXkuIFBsZWFzZSBlbnN1cmUgdGhhdCB5b3UgYXJlIGdlbmVyYXRpbmcgdGhlc2Uga2V5cyBzZWN1cmVseSBhbmQgcHJvdGVjdCB0aGUgdXNlcidzIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGtleVBhaXIgYSB7QGxpbmsgQ3J5cHRvS2V5UGFpcn1cbiAgICAgKiBAcGFyYW0gc3VidGxlQ3J5cHRvIGEge0BsaW5rIFN1YnRsZUNyeXB0b30gaW50ZXJmYWNlIGluIGNhc2Ugb25lIGlzIG5vdCBhdmFpbGFibGUgZ2xvYmFsbHlcbiAgICAgKiBAcmV0dXJucyBhbiB7QGxpbmsgRUNEU0FLZXlJZGVudGl0eX1cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUtleVBhaXIoa2V5UGFpciwgc3VidGxlQ3J5cHRvKSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZUNyeXB0byA9IF9nZXRFZmZlY3RpdmVDcnlwdG8oc3VidGxlQ3J5cHRvKTtcbiAgICAgICAgY29uc3QgZGVyS2V5ID0gKGF3YWl0IGVmZmVjdGl2ZUNyeXB0by5leHBvcnRLZXkoJ3Nwa2knLCBrZXlQYWlyLnB1YmxpY0tleSkpO1xuICAgICAgICByZXR1cm4gbmV3IEVDRFNBS2V5SWRlbnRpdHkoa2V5UGFpciwgZGVyS2V5LCBlZmZlY3RpdmVDcnlwdG8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGludGVybmFsbHktdXNlZCBrZXkgcGFpci5cbiAgICAgKiBAcmV0dXJucyBhIHtAbGluayBDcnlwdG9LZXlQYWlyfVxuICAgICAqL1xuICAgIGdldEtleVBhaXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlQYWlyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHB1YmxpYyBrZXkuXG4gICAgICogQHJldHVybnMgYW4ge0BsaW5rIERlckNyeXB0b0tleX1cbiAgICAgKi9cbiAgICBnZXRQdWJsaWNLZXkoKSB7XG4gICAgICAgIGNvbnN0IGRlcktleSA9IHRoaXMuX2RlcktleTtcbiAgICAgICAgY29uc3Qga2V5ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLl9rZXlQYWlyLnB1YmxpY0tleSk7XG4gICAgICAgIGtleS50b0RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXJLZXk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIGEgYmxvYiBvZiBkYXRhLCB3aXRoIHRoaXMgaWRlbnRpdHkncyBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBjaGFsbGVuZ2UgLSBjaGFsbGVuZ2UgdG8gc2lnbiB3aXRoIHRoaXMgaWRlbnRpdHkncyBzZWNyZXRLZXksIHByb2R1Y2luZyBhIHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25hdHVyZT59IHNpZ25hdHVyZVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ24oY2hhbGxlbmdlKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgICAgICBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9rZXlQYWlyLnByaXZhdGVLZXk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuX3N1YnRsZUNyeXB0by5zaWduKHBhcmFtcywgdGhpcy5fa2V5UGFpci5wcml2YXRlS2V5LCBjaGFsbGVuZ2UpO1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEVDRFNBS2V5SWRlbnRpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lY2RzYS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/identity/lib/esm/identity/ecdsa.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/identity/lib/esm/identity/ed25519.js":
/*!***************************************************************************!*\
  !*** ../../../node_modules/@dfinity/identity/lib/esm/identity/ed25519.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ed25519KeyIdentity: function() { return /* binding */ Ed25519KeyIdentity; },\n/* harmony export */   Ed25519PublicKey: function() { return /* binding */ Ed25519PublicKey; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"../../../node_modules/@dfinity/agent/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"../../../node_modules/@noble/curves/esm/ed25519.js\");\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Ed25519PublicKey_rawKey, _Ed25519PublicKey_derKey, _Ed25519KeyIdentity_publicKey, _Ed25519KeyIdentity_privateKey;\n\n\nclass Ed25519PublicKey {\n    // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n    constructor(key) {\n        _Ed25519PublicKey_rawKey.set(this, void 0);\n        _Ed25519PublicKey_derKey.set(this, void 0);\n        if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n            throw new Error('An Ed25519 public key must be exactly 32bytes long');\n        }\n        __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, key, \"f\");\n        __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, Ed25519PublicKey.derEncode(key), \"f\");\n    }\n    static from(key) {\n        return this.fromDer(key.toDer());\n    }\n    static fromRaw(rawKey) {\n        return new Ed25519PublicKey(rawKey);\n    }\n    static fromDer(derKey) {\n        return new Ed25519PublicKey(this.derDecode(derKey));\n    }\n    static derEncode(publicKey) {\n        return (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.wrapDER)(publicKey, _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID).buffer;\n    }\n    static derDecode(key) {\n        const unwrapped = (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.unwrapDER)(key, _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.ED25519_OID);\n        if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n            throw new Error('An Ed25519 public key must be exactly 32bytes long');\n        }\n        return unwrapped;\n    }\n    get rawKey() {\n        return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, \"f\");\n    }\n    get derKey() {\n        return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, \"f\");\n    }\n    toDer() {\n        return this.derKey;\n    }\n    toRaw() {\n        return this.rawKey;\n    }\n}\n_Ed25519PublicKey_rawKey = new WeakMap(), _Ed25519PublicKey_derKey = new WeakMap();\n// The length of Ed25519 public keys is always 32 bytes.\nEd25519PublicKey.RAW_KEY_LENGTH = 32;\nclass Ed25519KeyIdentity extends _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.SignIdentity {\n    // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n    constructor(publicKey, privateKey) {\n        super();\n        _Ed25519KeyIdentity_publicKey.set(this, void 0);\n        _Ed25519KeyIdentity_privateKey.set(this, void 0);\n        __classPrivateFieldSet(this, _Ed25519KeyIdentity_publicKey, Ed25519PublicKey.from(publicKey), \"f\");\n        __classPrivateFieldSet(this, _Ed25519KeyIdentity_privateKey, new Uint8Array(privateKey), \"f\");\n    }\n    static generate(seed = new Uint8Array(32)) {\n        if (seed && seed.length !== 32) {\n            throw new Error('Ed25519 Seed needs to be 32 bytes long.');\n        }\n        if (!seed)\n            seed = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__.ed25519.utils.randomPrivateKey();\n        const sk = new Uint8Array(32);\n        for (let i = 0; i < 32; i++)\n            sk[i] = new Uint8Array(seed)[i];\n        const pk = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__.ed25519.getPublicKey(sk);\n        return Ed25519KeyIdentity.fromKeyPair(pk, sk);\n    }\n    static fromParsedJson(obj) {\n        const [publicKeyDer, privateKeyRaw] = obj;\n        return new Ed25519KeyIdentity(Ed25519PublicKey.fromDer((0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.fromHex)(publicKeyDer)), (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.fromHex)(privateKeyRaw));\n    }\n    static fromJSON(json) {\n        const parsed = JSON.parse(json);\n        if (Array.isArray(parsed)) {\n            if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n                return this.fromParsedJson([parsed[0], parsed[1]]);\n            }\n            else {\n                throw new Error('Deserialization error: JSON must have at least 2 items.');\n            }\n        }\n        throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n    }\n    static fromKeyPair(publicKey, privateKey) {\n        return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);\n    }\n    static fromSecretKey(secretKey) {\n        const publicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__.ed25519.getPublicKey(new Uint8Array(secretKey));\n        return Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);\n    }\n    /**\n     * Serialize this key to JSON.\n     */\n    toJSON() {\n        return [(0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.toHex)(__classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, \"f\").toDer()), (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.toHex)(__classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, \"f\"))];\n    }\n    /**\n     * Return a copy of the key pair.\n     */\n    getKeyPair() {\n        return {\n            secretKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, \"f\"),\n            publicKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, \"f\"),\n        };\n    }\n    /**\n     * Return the public key.\n     */\n    getPublicKey() {\n        return __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, \"f\");\n    }\n    /**\n     * Signs a blob of data, with this identity's private key.\n     * @param challenge - challenge to sign with this identity's secretKey, producing a signature\n     */\n    async sign(challenge) {\n        const blob = new Uint8Array(challenge);\n        // Some implementations of Ed25519 private keys append a public key to the end of the private key. We only want the private key.\n        const signature = (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.uint8ToBuf)(_noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__.ed25519.sign(blob, __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, \"f\").slice(0, 32)));\n        // add { __signature__: void; } to the signature to make it compatible with the agent\n        Object.defineProperty(signature, '__signature__', {\n            enumerable: false,\n            value: undefined,\n        });\n        return signature;\n    }\n    /**\n     * Verify\n     * @param sig - signature to verify\n     * @param msg - message to verify\n     * @param pk - public key\n     * @returns - true if the signature is valid, false otherwise\n     */\n    static verify(sig, msg, pk) {\n        const [signature, message, publicKey] = [sig, msg, pk].map(x => {\n            if (typeof x === 'string') {\n                x = (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.fromHex)(x);\n            }\n            if (x instanceof Uint8Array) {\n                x = x.buffer;\n            }\n            return new Uint8Array(x);\n        });\n        return _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__.ed25519.verify(message, signature, publicKey);\n    }\n}\n_Ed25519KeyIdentity_publicKey = new WeakMap(), _Ed25519KeyIdentity_privateKey = new WeakMap();\n//# sourceMappingURL=ed25519.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2lkZW50aXR5L2xpYi9lc20vaWRlbnRpdHkvZWQyNTUxOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0RztBQUM1RDtBQUN6QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFPLFlBQVksdURBQVc7QUFDN0M7QUFDQTtBQUNBLDBCQUEwQix5REFBUyxNQUFNLHVEQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyx3REFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBTztBQUMxQjtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EsbUJBQW1CLDBEQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHVEQUFPLGlCQUFpQix1REFBTztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLHFCQUFxQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBSyw0RUFBNEUscURBQUs7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwREFBVSxDQUFDLDBEQUFPO0FBQzVDLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1REFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsMERBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9pZGVudGl0eS9saWIvZXNtL2lkZW50aXR5L2VkMjU1MTkuanM/YmRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0VkMjU1MTlQdWJsaWNLZXlfcmF3S2V5LCBfRWQyNTUxOVB1YmxpY0tleV9kZXJLZXksIF9FZDI1NTE5S2V5SWRlbnRpdHlfcHVibGljS2V5LCBfRWQyNTUxOUtleUlkZW50aXR5X3ByaXZhdGVLZXk7XG5pbXBvcnQgeyBTaWduSWRlbnRpdHksIHVpbnQ4VG9CdWYsIEVEMjU1MTlfT0lELCB1bndyYXBERVIsIHdyYXBERVIsIGZyb21IZXgsIHRvSGV4LCB9IGZyb20gJ0BkZmluaXR5L2FnZW50JztcbmltcG9ydCB7IGVkMjU1MTkgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTknO1xuZXhwb3J0IGNsYXNzIEVkMjU1MTlQdWJsaWNLZXkge1xuICAgIC8vIGBmcm9tUmF3YCBhbmQgYGZyb21EZXJgIHNob3VsZCBiZSB1c2VkIGZvciBpbnN0YW50aWF0aW9uLCBub3QgdGhpcyBjb25zdHJ1Y3Rvci5cbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgX0VkMjU1MTlQdWJsaWNLZXlfcmF3S2V5LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfRWQyNTUxOVB1YmxpY0tleV9kZXJLZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIGlmIChrZXkuYnl0ZUxlbmd0aCAhPT0gRWQyNTUxOVB1YmxpY0tleS5SQVdfS0VZX0xFTkdUSCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBFZDI1NTE5IHB1YmxpYyBrZXkgbXVzdCBiZSBleGFjdGx5IDMyYnl0ZXMgbG9uZycpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0VkMjU1MTlQdWJsaWNLZXlfcmF3S2V5LCBrZXksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRWQyNTUxOVB1YmxpY0tleV9kZXJLZXksIEVkMjU1MTlQdWJsaWNLZXkuZGVyRW5jb2RlKGtleSksIFwiZlwiKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21EZXIoa2V5LnRvRGVyKCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJhdyhyYXdLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZDI1NTE5UHVibGljS2V5KHJhd0tleSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRGVyKGRlcktleSkge1xuICAgICAgICByZXR1cm4gbmV3IEVkMjU1MTlQdWJsaWNLZXkodGhpcy5kZXJEZWNvZGUoZGVyS2V5KSk7XG4gICAgfVxuICAgIHN0YXRpYyBkZXJFbmNvZGUocHVibGljS2V5KSB7XG4gICAgICAgIHJldHVybiB3cmFwREVSKHB1YmxpY0tleSwgRUQyNTUxOV9PSUQpLmJ1ZmZlcjtcbiAgICB9XG4gICAgc3RhdGljIGRlckRlY29kZShrZXkpIHtcbiAgICAgICAgY29uc3QgdW53cmFwcGVkID0gdW53cmFwREVSKGtleSwgRUQyNTUxOV9PSUQpO1xuICAgICAgICBpZiAodW53cmFwcGVkLmxlbmd0aCAhPT0gdGhpcy5SQVdfS0VZX0xFTkdUSCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBFZDI1NTE5IHB1YmxpYyBrZXkgbXVzdCBiZSBleGFjdGx5IDMyYnl0ZXMgbG9uZycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bndyYXBwZWQ7XG4gICAgfVxuICAgIGdldCByYXdLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FZDI1NTE5UHVibGljS2V5X3Jhd0tleSwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgZGVyS2V5KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRWQyNTUxOVB1YmxpY0tleV9kZXJLZXksIFwiZlwiKTtcbiAgICB9XG4gICAgdG9EZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcktleTtcbiAgICB9XG4gICAgdG9SYXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhd0tleTtcbiAgICB9XG59XG5fRWQyNTUxOVB1YmxpY0tleV9yYXdLZXkgPSBuZXcgV2Vha01hcCgpLCBfRWQyNTUxOVB1YmxpY0tleV9kZXJLZXkgPSBuZXcgV2Vha01hcCgpO1xuLy8gVGhlIGxlbmd0aCBvZiBFZDI1NTE5IHB1YmxpYyBrZXlzIGlzIGFsd2F5cyAzMiBieXRlcy5cbkVkMjU1MTlQdWJsaWNLZXkuUkFXX0tFWV9MRU5HVEggPSAzMjtcbmV4cG9ydCBjbGFzcyBFZDI1NTE5S2V5SWRlbnRpdHkgZXh0ZW5kcyBTaWduSWRlbnRpdHkge1xuICAgIC8vIGBmcm9tUmF3YCBhbmQgYGZyb21EZXJgIHNob3VsZCBiZSB1c2VkIGZvciBpbnN0YW50aWF0aW9uLCBub3QgdGhpcyBjb25zdHJ1Y3Rvci5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgX0VkMjU1MTlLZXlJZGVudGl0eV9wdWJsaWNLZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9FZDI1NTE5S2V5SWRlbnRpdHlfcHJpdmF0ZUtleS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRWQyNTUxOUtleUlkZW50aXR5X3B1YmxpY0tleSwgRWQyNTUxOVB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRWQyNTUxOUtleUlkZW50aXR5X3ByaXZhdGVLZXksIG5ldyBVaW50OEFycmF5KHByaXZhdGVLZXkpLCBcImZcIik7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZShzZWVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpKSB7XG4gICAgICAgIGlmIChzZWVkICYmIHNlZWQubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFZDI1NTE5IFNlZWQgbmVlZHMgdG8gYmUgMzIgYnl0ZXMgbG9uZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlZWQpXG4gICAgICAgICAgICBzZWVkID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gICAgICAgIGNvbnN0IHNrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspXG4gICAgICAgICAgICBza1tpXSA9IG5ldyBVaW50OEFycmF5KHNlZWQpW2ldO1xuICAgICAgICBjb25zdCBwayA9IGVkMjU1MTkuZ2V0UHVibGljS2V5KHNrKTtcbiAgICAgICAgcmV0dXJuIEVkMjU1MTlLZXlJZGVudGl0eS5mcm9tS2V5UGFpcihwaywgc2spO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVBhcnNlZEpzb24ob2JqKSB7XG4gICAgICAgIGNvbnN0IFtwdWJsaWNLZXlEZXIsIHByaXZhdGVLZXlSYXddID0gb2JqO1xuICAgICAgICByZXR1cm4gbmV3IEVkMjU1MTlLZXlJZGVudGl0eShFZDI1NTE5UHVibGljS2V5LmZyb21EZXIoZnJvbUhleChwdWJsaWNLZXlEZXIpKSwgZnJvbUhleChwcml2YXRlS2V5UmF3KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2VkWzBdID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgcGFyc2VkWzFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21QYXJzZWRKc29uKFtwYXJzZWRbMF0sIHBhcnNlZFsxXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZXNlcmlhbGl6YXRpb24gZXJyb3I6IEpTT04gbXVzdCBoYXZlIGF0IGxlYXN0IDIgaXRlbXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZXNlcmlhbGl6YXRpb24gZXJyb3I6IEludmFsaWQgSlNPTiB0eXBlIGZvciBzdHJpbmc6ICR7SlNPTi5zdHJpbmdpZnkoanNvbil9YCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tS2V5UGFpcihwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZDI1NTE5S2V5SWRlbnRpdHkoRWQyNTUxOVB1YmxpY0tleS5mcm9tUmF3KHB1YmxpY0tleSksIHByaXZhdGVLZXkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVNlY3JldEtleShzZWNyZXRLZXkpIHtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gZWQyNTUxOS5nZXRQdWJsaWNLZXkobmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KSk7XG4gICAgICAgIHJldHVybiBFZDI1NTE5S2V5SWRlbnRpdHkuZnJvbUtleVBhaXIocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhpcyBrZXkgdG8gSlNPTi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBbdG9IZXgoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRWQyNTUxOUtleUlkZW50aXR5X3B1YmxpY0tleSwgXCJmXCIpLnRvRGVyKCkpLCB0b0hleChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FZDI1NTE5S2V5SWRlbnRpdHlfcHJpdmF0ZUtleSwgXCJmXCIpKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvcHkgb2YgdGhlIGtleSBwYWlyLlxuICAgICAqL1xuICAgIGdldEtleVBhaXIoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWNyZXRLZXk6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0VkMjU1MTlLZXlJZGVudGl0eV9wcml2YXRlS2V5LCBcImZcIiksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0VkMjU1MTlLZXlJZGVudGl0eV9wdWJsaWNLZXksIFwiZlwiKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwdWJsaWMga2V5LlxuICAgICAqL1xuICAgIGdldFB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0VkMjU1MTlLZXlJZGVudGl0eV9wdWJsaWNLZXksIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgYSBibG9iIG9mIGRhdGEsIHdpdGggdGhpcyBpZGVudGl0eSdzIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBjaGFsbGVuZ2UgLSBjaGFsbGVuZ2UgdG8gc2lnbiB3aXRoIHRoaXMgaWRlbnRpdHkncyBzZWNyZXRLZXksIHByb2R1Y2luZyBhIHNpZ25hdHVyZVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ24oY2hhbGxlbmdlKSB7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgVWludDhBcnJheShjaGFsbGVuZ2UpO1xuICAgICAgICAvLyBTb21lIGltcGxlbWVudGF0aW9ucyBvZiBFZDI1NTE5IHByaXZhdGUga2V5cyBhcHBlbmQgYSBwdWJsaWMga2V5IHRvIHRoZSBlbmQgb2YgdGhlIHByaXZhdGUga2V5LiBXZSBvbmx5IHdhbnQgdGhlIHByaXZhdGUga2V5LlxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB1aW50OFRvQnVmKGVkMjU1MTkuc2lnbihibG9iLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9FZDI1NTE5S2V5SWRlbnRpdHlfcHJpdmF0ZUtleSwgXCJmXCIpLnNsaWNlKDAsIDMyKSkpO1xuICAgICAgICAvLyBhZGQgeyBfX3NpZ25hdHVyZV9fOiB2b2lkOyB9IHRvIHRoZSBzaWduYXR1cmUgdG8gbWFrZSBpdCBjb21wYXRpYmxlIHdpdGggdGhlIGFnZW50XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYXR1cmUsICdfX3NpZ25hdHVyZV9fJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5XG4gICAgICogQHBhcmFtIHNpZyAtIHNpZ25hdHVyZSB0byB2ZXJpZnlcbiAgICAgKiBAcGFyYW0gbXNnIC0gbWVzc2FnZSB0byB2ZXJpZnlcbiAgICAgKiBAcGFyYW0gcGsgLSBwdWJsaWMga2V5XG4gICAgICogQHJldHVybnMgLSB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN0YXRpYyB2ZXJpZnkoc2lnLCBtc2csIHBrKSB7XG4gICAgICAgIGNvbnN0IFtzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleV0gPSBbc2lnLCBtc2csIHBrXS5tYXAoeCA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgeCA9IGZyb21IZXgoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICB4ID0geC5idWZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWQyNTUxOS52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpO1xuICAgIH1cbn1cbl9FZDI1NTE5S2V5SWRlbnRpdHlfcHVibGljS2V5ID0gbmV3IFdlYWtNYXAoKSwgX0VkMjU1MTlLZXlJZGVudGl0eV9wcml2YXRlS2V5ID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkMjU1MTkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/identity/lib/esm/identity/ed25519.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/identity/lib/esm/identity/webauthn.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/@dfinity/identity/lib/esm/identity/webauthn.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CosePublicKey: function() { return /* binding */ CosePublicKey; },\n/* harmony export */   WebAuthnIdentity: function() { return /* binding */ WebAuthnIdentity; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"../../../node_modules/@dfinity/agent/lib/esm/index.js\");\n/* harmony import */ var borc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! borc */ \"../../../node_modules/borc/src/index.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ \"../../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\nfunction _coseToDerEncodedBlob(cose) {\n    return (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.wrapDER)(cose, _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.DER_COSE_OID).buffer;\n}\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData) {\n    const dataView = new DataView(new ArrayBuffer(2));\n    const idLenBytes = authData.slice(53, 55);\n    [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n    const credentialIdLength = dataView.getUint16(0);\n    // Get the public key object.\n    return authData.slice(55 + credentialIdLength);\n}\nclass CosePublicKey {\n    constructor(_cose) {\n        this._cose = _cose;\n        this._encodedKey = _coseToDerEncodedBlob(_cose);\n    }\n    toDer() {\n        return this._encodedKey;\n    }\n    getCose() {\n        return this._cose;\n    }\n}\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer(challenge = '<ic0.app>') {\n    if (typeof challenge === 'string') {\n        return Uint8Array.from(challenge, c => c.charCodeAt(0));\n    }\n    else {\n        return challenge;\n    }\n}\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(credentialCreationOptions) {\n    const creds = (await navigator.credentials.create(credentialCreationOptions !== null && credentialCreationOptions !== void 0 ? credentialCreationOptions : {\n        publicKey: {\n            authenticatorSelection: {\n                userVerification: 'preferred',\n            },\n            attestation: 'direct',\n            challenge: _createChallengeBuffer(),\n            pubKeyCredParams: [{ type: 'public-key', alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256 }],\n            rp: {\n                name: 'Internet Identity Service',\n            },\n            user: {\n                id: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes)(16),\n                name: 'Internet Identity',\n                displayName: 'Internet Identity',\n            },\n        },\n    }));\n    // Validate that it's the correct type at runtime, since WebAuthn does not HAVE to\n    // reply with a PublicKeyCredential.\n    if (creds.response === undefined || !(creds.rawId instanceof ArrayBuffer)) {\n        return null;\n    }\n    else {\n        return creds;\n    }\n}\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nvar PubKeyCoseAlgo;\n(function (PubKeyCoseAlgo) {\n    PubKeyCoseAlgo[PubKeyCoseAlgo[\"ECDSA_WITH_SHA256\"] = -7] = \"ECDSA_WITH_SHA256\";\n})(PubKeyCoseAlgo || (PubKeyCoseAlgo = {}));\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nclass WebAuthnIdentity extends _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.SignIdentity {\n    constructor(rawId, cose, authenticatorAttachment) {\n        super();\n        this.rawId = rawId;\n        this.authenticatorAttachment = authenticatorAttachment;\n        this._publicKey = new CosePublicKey(cose);\n    }\n    /**\n     * Create an identity from a JSON serialization.\n     * @param json - json to parse\n     */\n    static fromJSON(json) {\n        const { publicKey, rawId } = JSON.parse(json);\n        if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n            throw new Error('Invalid JSON string.');\n        }\n        return new this((0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.fromHex)(rawId), (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.fromHex)(publicKey), undefined);\n    }\n    /**\n     * Create an identity.\n     * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n     */\n    static async create(credentialCreationOptions) {\n        var _a;\n        const creds = await _createCredential(credentialCreationOptions);\n        if (!creds || creds.type !== 'public-key') {\n            throw new Error('Could not create credentials.');\n        }\n        const response = creds.response;\n        if (!(response.attestationObject instanceof ArrayBuffer)) {\n            throw new Error('Was expecting an attestation response.');\n        }\n        // Parse the attestationObject as CBOR.\n        const attObject = borc__WEBPACK_IMPORTED_MODULE_1__.decodeFirst(new Uint8Array(response.attestationObject));\n        return new this(creds.rawId, _authDataToCose(attObject.authData), (_a = creds.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined);\n    }\n    getPublicKey() {\n        return this._publicKey;\n    }\n    /**\n     * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n     * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n     * This attribute is already implemented for Chrome, Safari and Edge.\n     *\n     * Given the attribute is only available after a successful interaction, the information is\n     * provided opportunistically and might also be `undefined`.\n     */\n    getAuthenticatorAttachment() {\n        return this.authenticatorAttachment;\n    }\n    async sign(blob) {\n        const result = (await navigator.credentials.get({\n            publicKey: {\n                allowCredentials: [\n                    {\n                        type: 'public-key',\n                        id: this.rawId,\n                    },\n                ],\n                challenge: blob,\n                userVerification: 'preferred',\n            },\n        }));\n        if (result.authenticatorAttachment !== null) {\n            this.authenticatorAttachment = result.authenticatorAttachment;\n        }\n        const response = result.response;\n        if (response.signature instanceof ArrayBuffer &&\n            response.authenticatorData instanceof ArrayBuffer) {\n            const cbor = borc__WEBPACK_IMPORTED_MODULE_1__.encode(new borc__WEBPACK_IMPORTED_MODULE_1__.Tagged(55799, {\n                authenticator_data: new Uint8Array(response.authenticatorData),\n                client_data_json: new TextDecoder().decode(response.clientDataJSON),\n                signature: new Uint8Array(response.signature),\n            }));\n            if (!cbor) {\n                throw new Error('failed to encode cbor');\n            }\n            return cbor.buffer;\n        }\n        else {\n            throw new Error('Invalid response from WebAuthn.');\n        }\n    }\n    /**\n     * Allow for JSON serialization of all information needed to reuse this identity.\n     */\n    toJSON() {\n        return {\n            publicKey: (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.toHex)(this._publicKey.getCose()),\n            rawId: (0,_dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.toHex)(this.rawId),\n        };\n    }\n}\n//# sourceMappingURL=webauthn.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2lkZW50aXR5L2xpYi9lc20vaWRlbnRpdHkvd2ViYXV0aG4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0Y7QUFDOUQ7QUFDMEI7QUFDbEQ7QUFDQSxXQUFXLHVEQUFPLE9BQU8sd0RBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlDQUFpQywyREFBMkQ7QUFDNUY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQixnRUFBVztBQUMvQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLHdEQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBTyxTQUFTLHVEQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdDQUFXLEtBQUssd0NBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscURBQUs7QUFDNUIsbUJBQW1CLHFEQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvaWRlbnRpdHkvbGliL2VzbS9pZGVudGl0eS93ZWJhdXRobi5qcz9iZjM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNpZ25JZGVudGl0eSwgd3JhcERFUiwgREVSX0NPU0VfT0lELCBmcm9tSGV4LCB0b0hleCwgfSBmcm9tICdAZGZpbml0eS9hZ2VudCc7XG5pbXBvcnQgYm9yYyBmcm9tICdib3JjJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5mdW5jdGlvbiBfY29zZVRvRGVyRW5jb2RlZEJsb2IoY29zZSkge1xuICAgIHJldHVybiB3cmFwREVSKGNvc2UsIERFUl9DT1NFX09JRCkuYnVmZmVyO1xufVxuLyoqXG4gKiBGcm9tIHRoZSBkb2N1bWVudGF0aW9uO1xuICogVGhlIGF1dGhEYXRhIGlzIGEgYnl0ZSBhcnJheSBkZXNjcmliZWQgaW4gdGhlIHNwZWMuIFBhcnNpbmcgaXQgd2lsbCBpbnZvbHZlIHNsaWNpbmcgYnl0ZXMgZnJvbVxuICogdGhlIGFycmF5IGFuZCBjb252ZXJ0aW5nIHRoZW0gaW50byB1c2FibGUgb2JqZWN0cy5cbiAqXG4gKiBTZWUgaHR0cHM6Ly93ZWJhdXRobi5ndWlkZS8jcmVnaXN0cmF0aW9uIChzdWJzZWN0aW9uIFwiRXhhbXBsZTogUGFyc2luZyB0aGUgYXV0aGVudGljYXRvciBkYXRhXCIpLlxuICogQHBhcmFtIGF1dGhEYXRhIFRoZSBhdXRoRGF0YSBmaWVsZCBvZiB0aGUgYXR0ZXN0YXRpb24gcmVzcG9uc2UuXG4gKiBAcmV0dXJucyBUaGUgQ09TRSBrZXkgb2YgdGhlIGF1dGhEYXRhLlxuICovXG5mdW5jdGlvbiBfYXV0aERhdGFUb0Nvc2UoYXV0aERhdGEpIHtcbiAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMikpO1xuICAgIGNvbnN0IGlkTGVuQnl0ZXMgPSBhdXRoRGF0YS5zbGljZSg1MywgNTUpO1xuICAgIFsuLi5uZXcgVWludDhBcnJheShpZExlbkJ5dGVzKV0uZm9yRWFjaCgodiwgaSkgPT4gZGF0YVZpZXcuc2V0VWludDgoaSwgdikpO1xuICAgIGNvbnN0IGNyZWRlbnRpYWxJZExlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQxNigwKTtcbiAgICAvLyBHZXQgdGhlIHB1YmxpYyBrZXkgb2JqZWN0LlxuICAgIHJldHVybiBhdXRoRGF0YS5zbGljZSg1NSArIGNyZWRlbnRpYWxJZExlbmd0aCk7XG59XG5leHBvcnQgY2xhc3MgQ29zZVB1YmxpY0tleSB7XG4gICAgY29uc3RydWN0b3IoX2Nvc2UpIHtcbiAgICAgICAgdGhpcy5fY29zZSA9IF9jb3NlO1xuICAgICAgICB0aGlzLl9lbmNvZGVkS2V5ID0gX2Nvc2VUb0RlckVuY29kZWRCbG9iKF9jb3NlKTtcbiAgICB9XG4gICAgdG9EZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVkS2V5O1xuICAgIH1cbiAgICBnZXRDb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29zZTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIGNoYWxsZW5nZSBmcm9tIGEgc3RyaW5nIG9yIGFycmF5LiBUaGUgZGVmYXVsdCBjaGFsbGVuZ2UgaXMgYWx3YXlzIHRoZSBzYW1lXG4gKiBiZWNhdXNlIHdlIGRvbid0IG5lZWQgdG8gdmVyaWZ5IHRoZSBhdXRoZW50aWNpdHkgb2YgdGhlIGtleSBvbiB0aGUgc2VydmVyICh3ZSBkb24ndFxuICogcmVnaXN0ZXIgb3VyIGtleXMgd2l0aCB0aGUgSUMpLiBBbnkgY2hhbGxlbmdlIHdvdWxkIGRvLCBldmVuIG9uZSBwZXIga2V5LCByYW5kb21seVxuICogZ2VuZXJhdGVkLlxuICogQHBhcmFtIGNoYWxsZW5nZSBUaGUgY2hhbGxlbmdlIHRvIHRyYW5zZm9ybSBpbnRvIGEgYnl0ZSBhcnJheS4gQnkgZGVmYXVsdCBhIGhhcmRcbiAqICAgICAgICBjb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIF9jcmVhdGVDaGFsbGVuZ2VCdWZmZXIoY2hhbGxlbmdlID0gJzxpYzAuYXBwPicpIHtcbiAgICBpZiAodHlwZW9mIGNoYWxsZW5nZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjaGFsbGVuZ2UsIGMgPT4gYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGFsbGVuZ2U7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBjcmVkZW50aWFscyB0byBhdXRoZW50aWNhdGUgd2l0aCBhIHNlcnZlci4gVGhpcyBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgaW5cbiAqIFdlYkF1dGhuIHRvIGdldCBjcmVkZW50aWFscyBJRHMgKHdoaWNoIGdpdmUgdXMgdGhlIHB1YmxpYyBrZXkgYW5kIGFsbG93IHVzIHRvXG4gKiBzaWduKSwgYnV0IGluIHRoZSBjYXNlIG9mIHRoZSBJbnRlcm5ldCBDb21wdXRlciwgd2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0byByZWdpc3RlclxuICogaXQsIHNvIHdlIGRvbid0LlxuICogQHBhcmFtIGNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgYW4gb3B0aW9uYWwgQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyBvYmplY3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2NyZWF0ZUNyZWRlbnRpYWwoY3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucykge1xuICAgIGNvbnN0IGNyZWRzID0gKGF3YWl0IG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoY3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyAhPT0gbnVsbCAmJiBjcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zICE9PSB2b2lkIDAgPyBjcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zIDoge1xuICAgICAgICBwdWJsaWNLZXk6IHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JTZWxlY3Rpb246IHtcbiAgICAgICAgICAgICAgICB1c2VyVmVyaWZpY2F0aW9uOiAncHJlZmVycmVkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdHRlc3RhdGlvbjogJ2RpcmVjdCcsXG4gICAgICAgICAgICBjaGFsbGVuZ2U6IF9jcmVhdGVDaGFsbGVuZ2VCdWZmZXIoKSxcbiAgICAgICAgICAgIHB1YktleUNyZWRQYXJhbXM6IFt7IHR5cGU6ICdwdWJsaWMta2V5JywgYWxnOiBQdWJLZXlDb3NlQWxnby5FQ0RTQV9XSVRIX1NIQTI1NiB9XSxcbiAgICAgICAgICAgIHJwOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0ludGVybmV0IElkZW50aXR5IFNlcnZpY2UnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVzZXI6IHtcbiAgICAgICAgICAgICAgICBpZDogcmFuZG9tQnl0ZXMoMTYpLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdJbnRlcm5ldCBJZGVudGl0eScsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdJbnRlcm5ldCBJZGVudGl0eScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pKTtcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IGl0J3MgdGhlIGNvcnJlY3QgdHlwZSBhdCBydW50aW1lLCBzaW5jZSBXZWJBdXRobiBkb2VzIG5vdCBIQVZFIHRvXG4gICAgLy8gcmVwbHkgd2l0aCBhIFB1YmxpY0tleUNyZWRlbnRpYWwuXG4gICAgaWYgKGNyZWRzLnJlc3BvbnNlID09PSB1bmRlZmluZWQgfHwgIShjcmVkcy5yYXdJZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVkcztcbiAgICB9XG59XG4vLyBTZWUgaHR0cHM6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvY29zZS9jb3NlLnhodG1sI2FsZ29yaXRobXMgZm9yIGEgY29tcGxldGVcbi8vIGxpc3Qgb2YgdGhlc2UgYWxnb3JpdGhtcy4gV2Ugb25seSBsaXN0IHRoZSBvbmVzIHdlIHN1cHBvcnQgaGVyZS5cbnZhciBQdWJLZXlDb3NlQWxnbztcbihmdW5jdGlvbiAoUHViS2V5Q29zZUFsZ28pIHtcbiAgICBQdWJLZXlDb3NlQWxnb1tQdWJLZXlDb3NlQWxnb1tcIkVDRFNBX1dJVEhfU0hBMjU2XCJdID0gLTddID0gXCJFQ0RTQV9XSVRIX1NIQTI1NlwiO1xufSkoUHViS2V5Q29zZUFsZ28gfHwgKFB1YktleUNvc2VBbGdvID0ge30pKTtcbi8qKlxuICogQSBTaWduSWRlbnRpdHkgdGhhdCB1c2VzIGBuYXZpZ2F0b3IuY3JlZGVudGlhbHNgLiBTZWUgaHR0cHM6Ly93ZWJhdXRobi5ndWlkZS8gZm9yXG4gKiBtb3JlIGluZm9ybWF0aW9uIGFib3V0IFdlYkF1dGhlbnRpY2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgV2ViQXV0aG5JZGVudGl0eSBleHRlbmRzIFNpZ25JZGVudGl0eSB7XG4gICAgY29uc3RydWN0b3IocmF3SWQsIGNvc2UsIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmF3SWQgPSByYXdJZDtcbiAgICAgICAgdGhpcy5hdXRoZW50aWNhdG9yQXR0YWNobWVudCA9IGF1dGhlbnRpY2F0b3JBdHRhY2htZW50O1xuICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBuZXcgQ29zZVB1YmxpY0tleShjb3NlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGlkZW50aXR5IGZyb20gYSBKU09OIHNlcmlhbGl6YXRpb24uXG4gICAgICogQHBhcmFtIGpzb24gLSBqc29uIHRvIHBhcnNlXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNLZXksIHJhd0lkIH0gPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICBpZiAodHlwZW9mIHB1YmxpY0tleSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHJhd0lkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gc3RyaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhmcm9tSGV4KHJhd0lkKSwgZnJvbUhleChwdWJsaWNLZXkpLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaWRlbnRpdHkuXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgYW4gb3B0aW9uYWwgQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyBDaGFsbGVuZ2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjcmVkcyA9IGF3YWl0IF9jcmVhdGVDcmVkZW50aWFsKGNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMpO1xuICAgICAgICBpZiAoIWNyZWRzIHx8IGNyZWRzLnR5cGUgIT09ICdwdWJsaWMta2V5Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgY3JlYXRlIGNyZWRlbnRpYWxzLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gY3JlZHMucmVzcG9uc2U7XG4gICAgICAgIGlmICghKHJlc3BvbnNlLmF0dGVzdGF0aW9uT2JqZWN0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhcyBleHBlY3RpbmcgYW4gYXR0ZXN0YXRpb24gcmVzcG9uc2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgdGhlIGF0dGVzdGF0aW9uT2JqZWN0IGFzIENCT1IuXG4gICAgICAgIGNvbnN0IGF0dE9iamVjdCA9IGJvcmMuZGVjb2RlRmlyc3QobmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UuYXR0ZXN0YXRpb25PYmplY3QpKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGNyZWRzLnJhd0lkLCBfYXV0aERhdGFUb0Nvc2UoYXR0T2JqZWN0LmF1dGhEYXRhKSwgKF9hID0gY3JlZHMuYXV0aGVudGljYXRvckF0dGFjaG1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGdldFB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2ViQXV0aG4gbGV2ZWwgMyBzcGVjIGludHJvZHVjZXMgYSBuZXcgYXR0cmlidXRlIG9uIHN1Y2Nlc3NmdWwgV2ViQXV0aG4gaW50ZXJhY3Rpb25zLFxuICAgICAqIHNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI2RvbS1wdWJsaWNrZXljcmVkZW50aWFsLWF1dGhlbnRpY2F0b3JhdHRhY2htZW50LlxuICAgICAqIFRoaXMgYXR0cmlidXRlIGlzIGFscmVhZHkgaW1wbGVtZW50ZWQgZm9yIENocm9tZSwgU2FmYXJpIGFuZCBFZGdlLlxuICAgICAqXG4gICAgICogR2l2ZW4gdGhlIGF0dHJpYnV0ZSBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciBhIHN1Y2Nlc3NmdWwgaW50ZXJhY3Rpb24sIHRoZSBpbmZvcm1hdGlvbiBpc1xuICAgICAqIHByb3ZpZGVkIG9wcG9ydHVuaXN0aWNhbGx5IGFuZCBtaWdodCBhbHNvIGJlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGdldEF1dGhlbnRpY2F0b3JBdHRhY2htZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoZW50aWNhdG9yQXR0YWNobWVudDtcbiAgICB9XG4gICAgYXN5bmMgc2lnbihibG9iKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChhd2FpdCBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KHtcbiAgICAgICAgICAgIHB1YmxpY0tleToge1xuICAgICAgICAgICAgICAgIGFsbG93Q3JlZGVudGlhbHM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMucmF3SWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2U6IGJsb2IsXG4gICAgICAgICAgICAgICAgdXNlclZlcmlmaWNhdGlvbjogJ3ByZWZlcnJlZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChyZXN1bHQuYXV0aGVudGljYXRvckF0dGFjaG1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRvckF0dGFjaG1lbnQgPSByZXN1bHQuYXV0aGVudGljYXRvckF0dGFjaG1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXN1bHQucmVzcG9uc2U7XG4gICAgICAgIGlmIChyZXNwb25zZS5zaWduYXR1cmUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciAmJlxuICAgICAgICAgICAgcmVzcG9uc2UuYXV0aGVudGljYXRvckRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgY29uc3QgY2JvciA9IGJvcmMuZW5jb2RlKG5ldyBib3JjLlRhZ2dlZCg1NTc5OSwge1xuICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JfZGF0YTogbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UuYXV0aGVudGljYXRvckRhdGEpLFxuICAgICAgICAgICAgICAgIGNsaWVudF9kYXRhX2pzb246IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShyZXNwb25zZS5jbGllbnREYXRhSlNPTiksXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBuZXcgVWludDhBcnJheShyZXNwb25zZS5zaWduYXR1cmUpLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKCFjYm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZW5jb2RlIGNib3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYm9yLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmcm9tIFdlYkF1dGhuLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93IGZvciBKU09OIHNlcmlhbGl6YXRpb24gb2YgYWxsIGluZm9ybWF0aW9uIG5lZWRlZCB0byByZXVzZSB0aGlzIGlkZW50aXR5LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogdG9IZXgodGhpcy5fcHVibGljS2V5LmdldENvc2UoKSksXG4gICAgICAgICAgICByYXdJZDogdG9IZXgodGhpcy5yYXdJZCksXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViYXV0aG4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/identity/lib/esm/identity/webauthn.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/identity/lib/esm/index.js":
/*!****************************************************************!*\
  !*** ../../../node_modules/@dfinity/identity/lib/esm/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CryptoError: function() { return /* reexport safe */ _identity_ecdsa__WEBPACK_IMPORTED_MODULE_1__.CryptoError; },\n/* harmony export */   DER_COSE_OID: function() { return /* reexport safe */ _dfinity_agent__WEBPACK_IMPORTED_MODULE_4__.DER_COSE_OID; },\n/* harmony export */   Delegation: function() { return /* reexport safe */ _identity_delegation__WEBPACK_IMPORTED_MODULE_2__.Delegation; },\n/* harmony export */   DelegationChain: function() { return /* reexport safe */ _identity_delegation__WEBPACK_IMPORTED_MODULE_2__.DelegationChain; },\n/* harmony export */   DelegationIdentity: function() { return /* reexport safe */ _identity_delegation__WEBPACK_IMPORTED_MODULE_2__.DelegationIdentity; },\n/* harmony export */   ECDSAKeyIdentity: function() { return /* reexport safe */ _identity_ecdsa__WEBPACK_IMPORTED_MODULE_1__.ECDSAKeyIdentity; },\n/* harmony export */   ED25519_OID: function() { return /* reexport safe */ _dfinity_agent__WEBPACK_IMPORTED_MODULE_4__.ED25519_OID; },\n/* harmony export */   Ed25519KeyIdentity: function() { return /* reexport safe */ _identity_ed25519__WEBPACK_IMPORTED_MODULE_0__.Ed25519KeyIdentity; },\n/* harmony export */   Ed25519PublicKey: function() { return /* reexport safe */ _identity_ed25519__WEBPACK_IMPORTED_MODULE_0__.Ed25519PublicKey; },\n/* harmony export */   Secp256k1KeyIdentity: function() { return /* binding */ Secp256k1KeyIdentity; },\n/* harmony export */   WebAuthnIdentity: function() { return /* reexport safe */ _identity_webauthn__WEBPACK_IMPORTED_MODULE_3__.WebAuthnIdentity; },\n/* harmony export */   isDelegationValid: function() { return /* reexport safe */ _identity_delegation__WEBPACK_IMPORTED_MODULE_2__.isDelegationValid; },\n/* harmony export */   unwrapDER: function() { return /* reexport safe */ _dfinity_agent__WEBPACK_IMPORTED_MODULE_4__.unwrapDER; },\n/* harmony export */   wrapDER: function() { return /* reexport safe */ _dfinity_agent__WEBPACK_IMPORTED_MODULE_4__.wrapDER; }\n/* harmony export */ });\n/* harmony import */ var _identity_ed25519__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity/ed25519 */ \"../../../node_modules/@dfinity/identity/lib/esm/identity/ed25519.js\");\n/* harmony import */ var _identity_ecdsa__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./identity/ecdsa */ \"../../../node_modules/@dfinity/identity/lib/esm/identity/ecdsa.js\");\n/* harmony import */ var _identity_delegation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./identity/delegation */ \"../../../node_modules/@dfinity/identity/lib/esm/identity/delegation.js\");\n/* harmony import */ var _identity_webauthn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./identity/webauthn */ \"../../../node_modules/@dfinity/identity/lib/esm/identity/webauthn.js\");\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @dfinity/agent */ \"../../../node_modules/@dfinity/agent/lib/esm/index.js\");\n\n\n\n\n\n/**\n * @deprecated due to size of dependencies. Use `@dfinity/identity-secp256k1` instead.\n */\nclass Secp256k1KeyIdentity {\n    constructor() {\n        throw new Error('Secp256k1KeyIdentity has been moved to a new repo: @dfinity/identity-secp256k1');\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2lkZW50aXR5L2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRTtBQUN6QztBQUNLO0FBQ2lCO0FBQ3dCO0FBQy9FO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L2lkZW50aXR5L2xpYi9lc20vaW5kZXguanM/ODVmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBFZDI1NTE5S2V5SWRlbnRpdHksIEVkMjU1MTlQdWJsaWNLZXkgfSBmcm9tICcuL2lkZW50aXR5L2VkMjU1MTknO1xuZXhwb3J0ICogZnJvbSAnLi9pZGVudGl0eS9lY2RzYSc7XG5leHBvcnQgKiBmcm9tICcuL2lkZW50aXR5L2RlbGVnYXRpb24nO1xuZXhwb3J0IHsgV2ViQXV0aG5JZGVudGl0eSB9IGZyb20gJy4vaWRlbnRpdHkvd2ViYXV0aG4nO1xuZXhwb3J0IHsgd3JhcERFUiwgdW53cmFwREVSLCBERVJfQ09TRV9PSUQsIEVEMjU1MTlfT0lEIH0gZnJvbSAnQGRmaW5pdHkvYWdlbnQnO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBkdWUgdG8gc2l6ZSBvZiBkZXBlbmRlbmNpZXMuIFVzZSBgQGRmaW5pdHkvaWRlbnRpdHktc2VjcDI1NmsxYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgY2xhc3MgU2VjcDI1NmsxS2V5SWRlbnRpdHkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3AyNTZrMUtleUlkZW50aXR5IGhhcyBiZWVuIG1vdmVkIHRvIGEgbmV3IHJlcG86IEBkZmluaXR5L2lkZW50aXR5LXNlY3AyNTZrMScpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/identity/lib/esm/index.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/principal/lib/esm/index.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/@dfinity/principal/lib/esm/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSON_KEY_PRINCIPAL: function() { return /* binding */ JSON_KEY_PRINCIPAL; },\n/* harmony export */   Principal: function() { return /* binding */ Principal; }\n/* harmony export */ });\n/* harmony import */ var _utils_base32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/base32 */ \"../../../node_modules/@dfinity/principal/lib/esm/utils/base32.js\");\n/* harmony import */ var _utils_getCrc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/getCrc */ \"../../../node_modules/@dfinity/principal/lib/esm/utils/getCrc.js\");\n/* harmony import */ var _utils_sha224__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/sha224 */ \"../../../node_modules/@dfinity/principal/lib/esm/utils/sha224.js\");\n\n\n\nconst JSON_KEY_PRINCIPAL = '__principal__';\nconst SELF_AUTHENTICATING_SUFFIX = 2;\nconst ANONYMOUS_SUFFIX = 4;\nconst MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR = 'aaaaa-aa';\nconst fromHexString = (hexString) => { var _a; return new Uint8Array(((_a = hexString.match(/.{1,2}/g)) !== null && _a !== void 0 ? _a : []).map(byte => parseInt(byte, 16))); };\nconst toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\nclass Principal {\n    constructor(_arr) {\n        this._arr = _arr;\n        this._isPrincipal = true;\n    }\n    static anonymous() {\n        return new this(new Uint8Array([ANONYMOUS_SUFFIX]));\n    }\n    /**\n     * Utility method, returning the principal representing the management canister, decoded from the hex string `'aaaaa-aa'`\n     * @returns {Principal} principal of the management canister\n     */\n    static managementCanister() {\n        return this.fromHex(MANAGEMENT_CANISTER_PRINCIPAL_HEX_STR);\n    }\n    static selfAuthenticating(publicKey) {\n        const sha = (0,_utils_sha224__WEBPACK_IMPORTED_MODULE_2__.sha224)(publicKey);\n        return new this(new Uint8Array([...sha, SELF_AUTHENTICATING_SUFFIX]));\n    }\n    static from(other) {\n        if (typeof other === 'string') {\n            return Principal.fromText(other);\n        }\n        else if (Object.getPrototypeOf(other) === Uint8Array.prototype) {\n            return new Principal(other);\n        }\n        else if (typeof other === 'object' &&\n            other !== null &&\n            other._isPrincipal === true) {\n            return new Principal(other._arr);\n        }\n        throw new Error(`Impossible to convert ${JSON.stringify(other)} to Principal.`);\n    }\n    static fromHex(hex) {\n        return new this(fromHexString(hex));\n    }\n    static fromText(text) {\n        let maybePrincipal = text;\n        // If formatted as JSON string, parse it first\n        if (text.includes(JSON_KEY_PRINCIPAL)) {\n            const obj = JSON.parse(text);\n            if (JSON_KEY_PRINCIPAL in obj) {\n                maybePrincipal = obj[JSON_KEY_PRINCIPAL];\n            }\n        }\n        const canisterIdNoDash = maybePrincipal.toLowerCase().replace(/-/g, '');\n        let arr = (0,_utils_base32__WEBPACK_IMPORTED_MODULE_0__.decode)(canisterIdNoDash);\n        arr = arr.slice(4, arr.length);\n        const principal = new this(arr);\n        if (principal.toText() !== maybePrincipal) {\n            throw new Error(`Principal \"${principal.toText()}\" does not have a valid checksum (original value \"${maybePrincipal}\" may not be a valid Principal ID).`);\n        }\n        return principal;\n    }\n    static fromUint8Array(arr) {\n        return new this(arr);\n    }\n    isAnonymous() {\n        return this._arr.byteLength === 1 && this._arr[0] === ANONYMOUS_SUFFIX;\n    }\n    toUint8Array() {\n        return this._arr;\n    }\n    toHex() {\n        return toHexString(this._arr).toUpperCase();\n    }\n    toText() {\n        const checksumArrayBuf = new ArrayBuffer(4);\n        const view = new DataView(checksumArrayBuf);\n        view.setUint32(0, (0,_utils_getCrc__WEBPACK_IMPORTED_MODULE_1__.getCrc32)(this._arr));\n        const checksum = new Uint8Array(checksumArrayBuf);\n        const bytes = Uint8Array.from(this._arr);\n        const array = new Uint8Array([...checksum, ...bytes]);\n        const result = (0,_utils_base32__WEBPACK_IMPORTED_MODULE_0__.encode)(array);\n        const matches = result.match(/.{1,5}/g);\n        if (!matches) {\n            // This should only happen if there's no character, which is unreachable.\n            throw new Error();\n        }\n        return matches.join('-');\n    }\n    toString() {\n        return this.toText();\n    }\n    /**\n     * Serializes to JSON\n     * @returns {JsonnablePrincipal} a JSON object with a single key, {@link JSON_KEY_PRINCIPAL}, whose value is the principal as a string\n     */\n    toJSON() {\n        return { [JSON_KEY_PRINCIPAL]: this.toText() };\n    }\n    /**\n     * Utility method taking a Principal to compare against. Used for determining canister ranges in certificate verification\n     * @param {Principal} other - a {@link Principal} to compare\n     * @returns {'lt' | 'eq' | 'gt'} `'lt' | 'eq' | 'gt'` a string, representing less than, equal to, or greater than\n     */\n    compareTo(other) {\n        for (let i = 0; i < Math.min(this._arr.length, other._arr.length); i++) {\n            if (this._arr[i] < other._arr[i])\n                return 'lt';\n            else if (this._arr[i] > other._arr[i])\n                return 'gt';\n        }\n        // Here, at least one principal is a prefix of the other principal (they could be the same)\n        if (this._arr.length < other._arr.length)\n            return 'lt';\n        if (this._arr.length > other._arr.length)\n            return 'gt';\n        return 'eq';\n    }\n    /**\n     * Utility method checking whether a provided Principal is less than or equal to the current one using the {@link Principal.compareTo} method\n     * @param other a {@link Principal} to compare\n     * @returns {boolean} boolean\n     */\n    ltEq(other) {\n        const cmp = this.compareTo(other);\n        return cmp == 'lt' || cmp == 'eq';\n    }\n    /**\n     * Utility method checking whether a provided Principal is greater than or equal to the current one using the {@link Principal.compareTo} method\n     * @param other a {@link Principal} to compare\n     * @returns {boolean} boolean\n     */\n    gtEq(other) {\n        const cmp = this.compareTo(other);\n        return cmp == 'gt' || cmp == 'eq';\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L3ByaW5jaXBhbC9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWdEO0FBQ047QUFDRjtBQUNqQztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRLGdEQUFnRCxJQUFJO0FBQ25HO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsdUJBQXVCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQixvREFBb0QsZUFBZTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFNO0FBQzdCLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CLGtDQUFrQyx5QkFBeUI7QUFDaEc7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVcsV0FBVyxpQkFBaUI7QUFDdEQsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0Esd0JBQXdCLG1EQUFtRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCwyQkFBMkI7QUFDM0ksdUJBQXVCLGlCQUFpQjtBQUN4QyxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUgsMkJBQTJCO0FBQzlJLHVCQUF1QixpQkFBaUI7QUFDeEMsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS9pbmRleC5qcz84NTA4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlY29kZSwgZW5jb2RlIH0gZnJvbSAnLi91dGlscy9iYXNlMzInO1xuaW1wb3J0IHsgZ2V0Q3JjMzIgfSBmcm9tICcuL3V0aWxzL2dldENyYyc7XG5pbXBvcnQgeyBzaGEyMjQgfSBmcm9tICcuL3V0aWxzL3NoYTIyNCc7XG5leHBvcnQgY29uc3QgSlNPTl9LRVlfUFJJTkNJUEFMID0gJ19fcHJpbmNpcGFsX18nO1xuY29uc3QgU0VMRl9BVVRIRU5USUNBVElOR19TVUZGSVggPSAyO1xuY29uc3QgQU5PTllNT1VTX1NVRkZJWCA9IDQ7XG5jb25zdCBNQU5BR0VNRU5UX0NBTklTVEVSX1BSSU5DSVBBTF9IRVhfU1RSID0gJ2FhYWFhLWFhJztcbmNvbnN0IGZyb21IZXhTdHJpbmcgPSAoaGV4U3RyaW5nKSA9PiB7IHZhciBfYTsgcmV0dXJuIG5ldyBVaW50OEFycmF5KCgoX2EgPSBoZXhTdHJpbmcubWF0Y2goLy57MSwyfS9nKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLm1hcChieXRlID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpOyB9O1xuY29uc3QgdG9IZXhTdHJpbmcgPSAoYnl0ZXMpID0+IGJ5dGVzLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpLCAnJyk7XG5leHBvcnQgY2xhc3MgUHJpbmNpcGFsIHtcbiAgICBjb25zdHJ1Y3RvcihfYXJyKSB7XG4gICAgICAgIHRoaXMuX2FyciA9IF9hcnI7XG4gICAgICAgIHRoaXMuX2lzUHJpbmNpcGFsID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljIGFub255bW91cygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG5ldyBVaW50OEFycmF5KFtBTk9OWU1PVVNfU1VGRklYXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCwgcmV0dXJuaW5nIHRoZSBwcmluY2lwYWwgcmVwcmVzZW50aW5nIHRoZSBtYW5hZ2VtZW50IGNhbmlzdGVyLCBkZWNvZGVkIGZyb20gdGhlIGhleCBzdHJpbmcgYCdhYWFhYS1hYSdgXG4gICAgICogQHJldHVybnMge1ByaW5jaXBhbH0gcHJpbmNpcGFsIG9mIHRoZSBtYW5hZ2VtZW50IGNhbmlzdGVyXG4gICAgICovXG4gICAgc3RhdGljIG1hbmFnZW1lbnRDYW5pc3RlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUhleChNQU5BR0VNRU5UX0NBTklTVEVSX1BSSU5DSVBBTF9IRVhfU1RSKTtcbiAgICB9XG4gICAgc3RhdGljIHNlbGZBdXRoZW50aWNhdGluZyhwdWJsaWNLZXkpIHtcbiAgICAgICAgY29uc3Qgc2hhID0gc2hhMjI0KHB1YmxpY0tleSk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhuZXcgVWludDhBcnJheShbLi4uc2hhLCBTRUxGX0FVVEhFTlRJQ0FUSU5HX1NVRkZJWF0pKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20ob3RoZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvdGhlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBQcmluY2lwYWwuZnJvbVRleHQob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvdGhlcikgPT09IFVpbnQ4QXJyYXkucHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByaW5jaXBhbChvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG90aGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgb3RoZXIgIT09IG51bGwgJiZcbiAgICAgICAgICAgIG90aGVyLl9pc1ByaW5jaXBhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmluY2lwYWwob3RoZXIuX2Fycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbXBvc3NpYmxlIHRvIGNvbnZlcnQgJHtKU09OLnN0cmluZ2lmeShvdGhlcil9IHRvIFByaW5jaXBhbC5gKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhmcm9tSGV4U3RyaW5nKGhleCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVRleHQodGV4dCkge1xuICAgICAgICBsZXQgbWF5YmVQcmluY2lwYWwgPSB0ZXh0O1xuICAgICAgICAvLyBJZiBmb3JtYXR0ZWQgYXMgSlNPTiBzdHJpbmcsIHBhcnNlIGl0IGZpcnN0XG4gICAgICAgIGlmICh0ZXh0LmluY2x1ZGVzKEpTT05fS0VZX1BSSU5DSVBBTCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICBpZiAoSlNPTl9LRVlfUFJJTkNJUEFMIGluIG9iaikge1xuICAgICAgICAgICAgICAgIG1heWJlUHJpbmNpcGFsID0gb2JqW0pTT05fS0VZX1BSSU5DSVBBTF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuaXN0ZXJJZE5vRGFzaCA9IG1heWJlUHJpbmNpcGFsLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnJyk7XG4gICAgICAgIGxldCBhcnIgPSBkZWNvZGUoY2FuaXN0ZXJJZE5vRGFzaCk7XG4gICAgICAgIGFyciA9IGFyci5zbGljZSg0LCBhcnIubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcHJpbmNpcGFsID0gbmV3IHRoaXMoYXJyKTtcbiAgICAgICAgaWYgKHByaW5jaXBhbC50b1RleHQoKSAhPT0gbWF5YmVQcmluY2lwYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJpbmNpcGFsIFwiJHtwcmluY2lwYWwudG9UZXh0KCl9XCIgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIGNoZWNrc3VtIChvcmlnaW5hbCB2YWx1ZSBcIiR7bWF5YmVQcmluY2lwYWx9XCIgbWF5IG5vdCBiZSBhIHZhbGlkIFByaW5jaXBhbCBJRCkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByaW5jaXBhbDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21VaW50OEFycmF5KGFycikge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMoYXJyKTtcbiAgICB9XG4gICAgaXNBbm9ueW1vdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcnIuYnl0ZUxlbmd0aCA9PT0gMSAmJiB0aGlzLl9hcnJbMF0gPT09IEFOT05ZTU9VU19TVUZGSVg7XG4gICAgfVxuICAgIHRvVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FycjtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiB0b0hleFN0cmluZyh0aGlzLl9hcnIpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHRvVGV4dCgpIHtcbiAgICAgICAgY29uc3QgY2hlY2tzdW1BcnJheUJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhjaGVja3N1bUFycmF5QnVmKTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgZ2V0Q3JjMzIodGhpcy5fYXJyKSk7XG4gICAgICAgIGNvbnN0IGNoZWNrc3VtID0gbmV3IFVpbnQ4QXJyYXkoY2hlY2tzdW1BcnJheUJ1Zik7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gVWludDhBcnJheS5mcm9tKHRoaXMuX2Fycik7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoWy4uLmNoZWNrc3VtLCAuLi5ieXRlc10pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlbmNvZGUoYXJyYXkpO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gcmVzdWx0Lm1hdGNoKC8uezEsNX0vZyk7XG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUncyBubyBjaGFyYWN0ZXIsIHdoaWNoIGlzIHVucmVhY2hhYmxlLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXMuam9pbignLScpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9UZXh0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgdG8gSlNPTlxuICAgICAqIEByZXR1cm5zIHtKc29ubmFibGVQcmluY2lwYWx9IGEgSlNPTiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXksIHtAbGluayBKU09OX0tFWV9QUklOQ0lQQUx9LCB3aG9zZSB2YWx1ZSBpcyB0aGUgcHJpbmNpcGFsIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBbSlNPTl9LRVlfUFJJTkNJUEFMXTogdGhpcy50b1RleHQoKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCB0YWtpbmcgYSBQcmluY2lwYWwgdG8gY29tcGFyZSBhZ2FpbnN0LiBVc2VkIGZvciBkZXRlcm1pbmluZyBjYW5pc3RlciByYW5nZXMgaW4gY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uXG4gICAgICogQHBhcmFtIHtQcmluY2lwYWx9IG90aGVyIC0gYSB7QGxpbmsgUHJpbmNpcGFsfSB0byBjb21wYXJlXG4gICAgICogQHJldHVybnMgeydsdCcgfCAnZXEnIHwgJ2d0J30gYCdsdCcgfCAnZXEnIHwgJ2d0J2AgYSBzdHJpbmcsIHJlcHJlc2VudGluZyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW5cbiAgICAgKi9cbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbih0aGlzLl9hcnIubGVuZ3RoLCBvdGhlci5fYXJyLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FycltpXSA8IG90aGVyLl9hcnJbaV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuICdsdCc7XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9hcnJbaV0gPiBvdGhlci5fYXJyW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiAnZ3QnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhlcmUsIGF0IGxlYXN0IG9uZSBwcmluY2lwYWwgaXMgYSBwcmVmaXggb2YgdGhlIG90aGVyIHByaW5jaXBhbCAodGhleSBjb3VsZCBiZSB0aGUgc2FtZSlcbiAgICAgICAgaWYgKHRoaXMuX2Fyci5sZW5ndGggPCBvdGhlci5fYXJyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiAnbHQnO1xuICAgICAgICBpZiAodGhpcy5fYXJyLmxlbmd0aCA+IG90aGVyLl9hcnIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuICdndCc7XG4gICAgICAgIHJldHVybiAnZXEnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBjaGVja2luZyB3aGV0aGVyIGEgcHJvdmlkZWQgUHJpbmNpcGFsIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBvbmUgdXNpbmcgdGhlIHtAbGluayBQcmluY2lwYWwuY29tcGFyZVRvfSBtZXRob2RcbiAgICAgKiBAcGFyYW0gb3RoZXIgYSB7QGxpbmsgUHJpbmNpcGFsfSB0byBjb21wYXJlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW5cbiAgICAgKi9cbiAgICBsdEVxKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyZVRvKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIGNtcCA9PSAnbHQnIHx8IGNtcCA9PSAnZXEnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IG1ldGhvZCBjaGVja2luZyB3aGV0aGVyIGEgcHJvdmlkZWQgUHJpbmNpcGFsIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgY3VycmVudCBvbmUgdXNpbmcgdGhlIHtAbGluayBQcmluY2lwYWwuY29tcGFyZVRvfSBtZXRob2RcbiAgICAgKiBAcGFyYW0gb3RoZXIgYSB7QGxpbmsgUHJpbmNpcGFsfSB0byBjb21wYXJlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGJvb2xlYW5cbiAgICAgKi9cbiAgICBndEVxKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IHRoaXMuY29tcGFyZVRvKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIGNtcCA9PSAnZ3QnIHx8IGNtcCA9PSAnZXEnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/principal/lib/esm/index.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/principal/lib/esm/utils/base32.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/@dfinity/principal/lib/esm/utils/base32.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: function() { return /* binding */ decode; },\n/* harmony export */   encode: function() { return /* binding */ encode; }\n/* harmony export */ });\nconst alphabet = 'abcdefghijklmnopqrstuvwxyz234567';\n// Build a lookup table for decoding.\nconst lookupTable = Object.create(null);\nfor (let i = 0; i < alphabet.length; i++) {\n    lookupTable[alphabet[i]] = i;\n}\n// Add aliases for rfc4648.\nlookupTable['0'] = lookupTable.o;\nlookupTable['1'] = lookupTable.i;\n/**\n * @param input The input array to encode.\n * @returns A Base32 string encoding the input.\n */\nfunction encode(input) {\n    // How many bits will we skip from the first byte.\n    let skip = 0;\n    // 5 high bits, carry from one byte to the next.\n    let bits = 0;\n    // The output string in base32.\n    let output = '';\n    function encodeByte(byte) {\n        if (skip < 0) {\n            // we have a carry from the previous byte\n            bits |= byte >> -skip;\n        }\n        else {\n            // no carry\n            bits = (byte << skip) & 248;\n        }\n        if (skip > 3) {\n            // Not enough data to produce a character, get us another one\n            skip -= 8;\n            return 1;\n        }\n        if (skip < 4) {\n            // produce a character\n            output += alphabet[bits >> 3];\n            skip += 5;\n        }\n        return 0;\n    }\n    for (let i = 0; i < input.length;) {\n        i += encodeByte(input[i]);\n    }\n    return output + (skip < 0 ? alphabet[bits >> 3] : '');\n}\n/**\n * @param input The base32 encoded string to decode.\n */\nfunction decode(input) {\n    // how many bits we have from the previous character.\n    let skip = 0;\n    // current byte we're producing.\n    let byte = 0;\n    const output = new Uint8Array(((input.length * 4) / 3) | 0);\n    let o = 0;\n    function decodeChar(char) {\n        // Consume a character from the stream, store\n        // the output in this.output. As before, better\n        // to use update().\n        let val = lookupTable[char.toLowerCase()];\n        if (val === undefined) {\n            throw new Error(`Invalid character: ${JSON.stringify(char)}`);\n        }\n        // move to the high bits\n        val <<= 3;\n        byte |= val >>> skip;\n        skip += 5;\n        if (skip >= 8) {\n            // We have enough bytes to produce an output\n            output[o++] = byte;\n            skip -= 8;\n            if (skip > 0) {\n                byte = (val << (5 - skip)) & 255;\n            }\n            else {\n                byte = 0;\n            }\n        }\n    }\n    for (const c of input) {\n        decodeChar(c);\n    }\n    return output.slice(0, o);\n}\n//# sourceMappingURL=base32.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L3ByaW5jaXBhbC9saWIvZXNtL3V0aWxzL2Jhc2UzMi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQXFCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZGZpbml0eS9wcmluY2lwYWwvbGliL2VzbS91dGlscy9iYXNlMzIuanM/YzA0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nyc7XG4vLyBCdWlsZCBhIGxvb2t1cCB0YWJsZSBmb3IgZGVjb2RpbmcuXG5jb25zdCBsb29rdXBUYWJsZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwVGFibGVbYWxwaGFiZXRbaV1dID0gaTtcbn1cbi8vIEFkZCBhbGlhc2VzIGZvciByZmM0NjQ4LlxubG9va3VwVGFibGVbJzAnXSA9IGxvb2t1cFRhYmxlLm87XG5sb29rdXBUYWJsZVsnMSddID0gbG9va3VwVGFibGUuaTtcbi8qKlxuICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBhcnJheSB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBBIEJhc2UzMiBzdHJpbmcgZW5jb2RpbmcgdGhlIGlucHV0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgLy8gSG93IG1hbnkgYml0cyB3aWxsIHdlIHNraXAgZnJvbSB0aGUgZmlyc3QgYnl0ZS5cbiAgICBsZXQgc2tpcCA9IDA7XG4gICAgLy8gNSBoaWdoIGJpdHMsIGNhcnJ5IGZyb20gb25lIGJ5dGUgdG8gdGhlIG5leHQuXG4gICAgbGV0IGJpdHMgPSAwO1xuICAgIC8vIFRoZSBvdXRwdXQgc3RyaW5nIGluIGJhc2UzMi5cbiAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgZnVuY3Rpb24gZW5jb2RlQnl0ZShieXRlKSB7XG4gICAgICAgIGlmIChza2lwIDwgMCkge1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIGNhcnJ5IGZyb20gdGhlIHByZXZpb3VzIGJ5dGVcbiAgICAgICAgICAgIGJpdHMgfD0gYnl0ZSA+PiAtc2tpcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGNhcnJ5XG4gICAgICAgICAgICBiaXRzID0gKGJ5dGUgPDwgc2tpcCkgJiAyNDg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXAgPiAzKSB7XG4gICAgICAgICAgICAvLyBOb3QgZW5vdWdoIGRhdGEgdG8gcHJvZHVjZSBhIGNoYXJhY3RlciwgZ2V0IHVzIGFub3RoZXIgb25lXG4gICAgICAgICAgICBza2lwIC09IDg7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcCA8IDQpIHtcbiAgICAgICAgICAgIC8vIHByb2R1Y2UgYSBjaGFyYWN0ZXJcbiAgICAgICAgICAgIG91dHB1dCArPSBhbHBoYWJldFtiaXRzID4+IDNdO1xuICAgICAgICAgICAgc2tpcCArPSA1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgaSArPSBlbmNvZGVCeXRlKGlucHV0W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dCArIChza2lwIDwgMCA/IGFscGhhYmV0W2JpdHMgPj4gM10gOiAnJyk7XG59XG4vKipcbiAqIEBwYXJhbSBpbnB1dCBUaGUgYmFzZTMyIGVuY29kZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICAgIC8vIGhvdyBtYW55IGJpdHMgd2UgaGF2ZSBmcm9tIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIuXG4gICAgbGV0IHNraXAgPSAwO1xuICAgIC8vIGN1cnJlbnQgYnl0ZSB3ZSdyZSBwcm9kdWNpbmcuXG4gICAgbGV0IGJ5dGUgPSAwO1xuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KCgoaW5wdXQubGVuZ3RoICogNCkgLyAzKSB8IDApO1xuICAgIGxldCBvID0gMDtcbiAgICBmdW5jdGlvbiBkZWNvZGVDaGFyKGNoYXIpIHtcbiAgICAgICAgLy8gQ29uc3VtZSBhIGNoYXJhY3RlciBmcm9tIHRoZSBzdHJlYW0sIHN0b3JlXG4gICAgICAgIC8vIHRoZSBvdXRwdXQgaW4gdGhpcy5vdXRwdXQuIEFzIGJlZm9yZSwgYmV0dGVyXG4gICAgICAgIC8vIHRvIHVzZSB1cGRhdGUoKS5cbiAgICAgICAgbGV0IHZhbCA9IGxvb2t1cFRhYmxlW2NoYXIudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYXJhY3RlcjogJHtKU09OLnN0cmluZ2lmeShjaGFyKX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtb3ZlIHRvIHRoZSBoaWdoIGJpdHNcbiAgICAgICAgdmFsIDw8PSAzO1xuICAgICAgICBieXRlIHw9IHZhbCA+Pj4gc2tpcDtcbiAgICAgICAgc2tpcCArPSA1O1xuICAgICAgICBpZiAoc2tpcCA+PSA4KSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGVub3VnaCBieXRlcyB0byBwcm9kdWNlIGFuIG91dHB1dFxuICAgICAgICAgICAgb3V0cHV0W28rK10gPSBieXRlO1xuICAgICAgICAgICAgc2tpcCAtPSA4O1xuICAgICAgICAgICAgaWYgKHNraXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZSA9ICh2YWwgPDwgKDUgLSBza2lwKSkgJiAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBieXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGMgb2YgaW5wdXQpIHtcbiAgICAgICAgZGVjb2RlQ2hhcihjKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5zbGljZSgwLCBvKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UzMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/principal/lib/esm/utils/base32.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/principal/lib/esm/utils/getCrc.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/@dfinity/principal/lib/esm/utils/getCrc.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCrc32: function() { return /* binding */ getCrc32; }\n/* harmony export */ });\n// This file is translated to JavaScript from\n// https://lxp32.github.io/docs/a-simple-example-crc32-calculation/\nconst lookUpTable = new Uint32Array([\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n]);\n/**\n * Calculate the CRC32 of an ArrayBufferLike.\n * @param buf The BufferLike to calculate the CRC32 of.\n */\nfunction getCrc32(buf) {\n    const b = new Uint8Array(buf);\n    let crc = -1;\n    for (let i = 0; i < b.length; i++) {\n        const byte = b[i];\n        const t = (byte ^ crc) & 0xff;\n        crc = lookUpTable[t] ^ (crc >>> 8);\n    }\n    return (crc ^ -1) >>> 0;\n}\n//# sourceMappingURL=getCrc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L3ByaW5jaXBhbC9saWIvZXNtL3V0aWxzL2dldENyYy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L3ByaW5jaXBhbC9saWIvZXNtL3V0aWxzL2dldENyYy5qcz85MzM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyB0cmFuc2xhdGVkIHRvIEphdmFTY3JpcHQgZnJvbVxuLy8gaHR0cHM6Ly9seHAzMi5naXRodWIuaW8vZG9jcy9hLXNpbXBsZS1leGFtcGxlLWNyYzMyLWNhbGN1bGF0aW9uL1xuY29uc3QgbG9va1VwVGFibGUgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4MDAwMDAwMDAsIDB4NzcwNzMwOTYsIDB4ZWUwZTYxMmMsIDB4OTkwOTUxYmEsIDB4MDc2ZGM0MTksIDB4NzA2YWY0OGYsIDB4ZTk2M2E1MzUsIDB4OWU2NDk1YTMsXG4gICAgMHgwZWRiODgzMiwgMHg3OWRjYjhhNCwgMHhlMGQ1ZTkxZSwgMHg5N2QyZDk4OCwgMHgwOWI2NGMyYiwgMHg3ZWIxN2NiZCwgMHhlN2I4MmQwNywgMHg5MGJmMWQ5MSxcbiAgICAweDFkYjcxMDY0LCAweDZhYjAyMGYyLCAweGYzYjk3MTQ4LCAweDg0YmU0MWRlLCAweDFhZGFkNDdkLCAweDZkZGRlNGViLCAweGY0ZDRiNTUxLCAweDgzZDM4NWM3LFxuICAgIDB4MTM2Yzk4NTYsIDB4NjQ2YmE4YzAsIDB4ZmQ2MmY5N2EsIDB4OGE2NWM5ZWMsIDB4MTQwMTVjNGYsIDB4NjMwNjZjZDksIDB4ZmEwZjNkNjMsIDB4OGQwODBkZjUsXG4gICAgMHgzYjZlMjBjOCwgMHg0YzY5MTA1ZSwgMHhkNTYwNDFlNCwgMHhhMjY3NzE3MiwgMHgzYzAzZTRkMSwgMHg0YjA0ZDQ0NywgMHhkMjBkODVmZCwgMHhhNTBhYjU2YixcbiAgICAweDM1YjVhOGZhLCAweDQyYjI5ODZjLCAweGRiYmJjOWQ2LCAweGFjYmNmOTQwLCAweDMyZDg2Y2UzLCAweDQ1ZGY1Yzc1LCAweGRjZDYwZGNmLCAweGFiZDEzZDU5LFxuICAgIDB4MjZkOTMwYWMsIDB4NTFkZTAwM2EsIDB4YzhkNzUxODAsIDB4YmZkMDYxMTYsIDB4MjFiNGY0YjUsIDB4NTZiM2M0MjMsIDB4Y2ZiYTk1OTksIDB4YjhiZGE1MGYsXG4gICAgMHgyODAyYjg5ZSwgMHg1ZjA1ODgwOCwgMHhjNjBjZDliMiwgMHhiMTBiZTkyNCwgMHgyZjZmN2M4NywgMHg1ODY4NGMxMSwgMHhjMTYxMWRhYiwgMHhiNjY2MmQzZCxcbiAgICAweDc2ZGM0MTkwLCAweDAxZGI3MTA2LCAweDk4ZDIyMGJjLCAweGVmZDUxMDJhLCAweDcxYjE4NTg5LCAweDA2YjZiNTFmLCAweDlmYmZlNGE1LCAweGU4YjhkNDMzLFxuICAgIDB4NzgwN2M5YTIsIDB4MGYwMGY5MzQsIDB4OTYwOWE4OGUsIDB4ZTEwZTk4MTgsIDB4N2Y2YTBkYmIsIDB4MDg2ZDNkMmQsIDB4OTE2NDZjOTcsIDB4ZTY2MzVjMDEsXG4gICAgMHg2YjZiNTFmNCwgMHgxYzZjNjE2MiwgMHg4NTY1MzBkOCwgMHhmMjYyMDA0ZSwgMHg2YzA2OTVlZCwgMHgxYjAxYTU3YiwgMHg4MjA4ZjRjMSwgMHhmNTBmYzQ1NyxcbiAgICAweDY1YjBkOWM2LCAweDEyYjdlOTUwLCAweDhiYmViOGVhLCAweGZjYjk4ODdjLCAweDYyZGQxZGRmLCAweDE1ZGEyZDQ5LCAweDhjZDM3Y2YzLCAweGZiZDQ0YzY1LFxuICAgIDB4NGRiMjYxNTgsIDB4M2FiNTUxY2UsIDB4YTNiYzAwNzQsIDB4ZDRiYjMwZTIsIDB4NGFkZmE1NDEsIDB4M2RkODk1ZDcsIDB4YTRkMWM0NmQsIDB4ZDNkNmY0ZmIsXG4gICAgMHg0MzY5ZTk2YSwgMHgzNDZlZDlmYywgMHhhZDY3ODg0NiwgMHhkYTYwYjhkMCwgMHg0NDA0MmQ3MywgMHgzMzAzMWRlNSwgMHhhYTBhNGM1ZiwgMHhkZDBkN2NjOSxcbiAgICAweDUwMDU3MTNjLCAweDI3MDI0MWFhLCAweGJlMGIxMDEwLCAweGM5MGMyMDg2LCAweDU3NjhiNTI1LCAweDIwNmY4NWIzLCAweGI5NjZkNDA5LCAweGNlNjFlNDlmLFxuICAgIDB4NWVkZWY5MGUsIDB4MjlkOWM5OTgsIDB4YjBkMDk4MjIsIDB4YzdkN2E4YjQsIDB4NTliMzNkMTcsIDB4MmViNDBkODEsIDB4YjdiZDVjM2IsIDB4YzBiYTZjYWQsXG4gICAgMHhlZGI4ODMyMCwgMHg5YWJmYjNiNiwgMHgwM2I2ZTIwYywgMHg3NGIxZDI5YSwgMHhlYWQ1NDczOSwgMHg5ZGQyNzdhZiwgMHgwNGRiMjYxNSwgMHg3M2RjMTY4MyxcbiAgICAweGUzNjMwYjEyLCAweDk0NjQzYjg0LCAweDBkNmQ2YTNlLCAweDdhNmE1YWE4LCAweGU0MGVjZjBiLCAweDkzMDlmZjlkLCAweDBhMDBhZTI3LCAweDdkMDc5ZWIxLFxuICAgIDB4ZjAwZjkzNDQsIDB4ODcwOGEzZDIsIDB4MWUwMWYyNjgsIDB4NjkwNmMyZmUsIDB4Zjc2MjU3NWQsIDB4ODA2NTY3Y2IsIDB4MTk2YzM2NzEsIDB4NmU2YjA2ZTcsXG4gICAgMHhmZWQ0MWI3NiwgMHg4OWQzMmJlMCwgMHgxMGRhN2E1YSwgMHg2N2RkNGFjYywgMHhmOWI5ZGY2ZiwgMHg4ZWJlZWZmOSwgMHgxN2I3YmU0MywgMHg2MGIwOGVkNSxcbiAgICAweGQ2ZDZhM2U4LCAweGExZDE5MzdlLCAweDM4ZDhjMmM0LCAweDRmZGZmMjUyLCAweGQxYmI2N2YxLCAweGE2YmM1NzY3LCAweDNmYjUwNmRkLCAweDQ4YjIzNjRiLFxuICAgIDB4ZDgwZDJiZGEsIDB4YWYwYTFiNGMsIDB4MzYwMzRhZjYsIDB4NDEwNDdhNjAsIDB4ZGY2MGVmYzMsIDB4YTg2N2RmNTUsIDB4MzE2ZThlZWYsIDB4NDY2OWJlNzksXG4gICAgMHhjYjYxYjM4YywgMHhiYzY2ODMxYSwgMHgyNTZmZDJhMCwgMHg1MjY4ZTIzNiwgMHhjYzBjNzc5NSwgMHhiYjBiNDcwMywgMHgyMjAyMTZiOSwgMHg1NTA1MjYyZixcbiAgICAweGM1YmEzYmJlLCAweGIyYmQwYjI4LCAweDJiYjQ1YTkyLCAweDVjYjM2YTA0LCAweGMyZDdmZmE3LCAweGI1ZDBjZjMxLCAweDJjZDk5ZThiLCAweDViZGVhZTFkLFxuICAgIDB4OWI2NGMyYjAsIDB4ZWM2M2YyMjYsIDB4NzU2YWEzOWMsIDB4MDI2ZDkzMGEsIDB4OWMwOTA2YTksIDB4ZWIwZTM2M2YsIDB4NzIwNzY3ODUsIDB4MDUwMDU3MTMsXG4gICAgMHg5NWJmNGE4MiwgMHhlMmI4N2ExNCwgMHg3YmIxMmJhZSwgMHgwY2I2MWIzOCwgMHg5MmQyOGU5YiwgMHhlNWQ1YmUwZCwgMHg3Y2RjZWZiNywgMHgwYmRiZGYyMSxcbiAgICAweDg2ZDNkMmQ0LCAweGYxZDRlMjQyLCAweDY4ZGRiM2Y4LCAweDFmZGE4MzZlLCAweDgxYmUxNmNkLCAweGY2YjkyNjViLCAweDZmYjA3N2UxLCAweDE4Yjc0Nzc3LFxuICAgIDB4ODgwODVhZTYsIDB4ZmYwZjZhNzAsIDB4NjYwNjNiY2EsIDB4MTEwMTBiNWMsIDB4OGY2NTllZmYsIDB4Zjg2MmFlNjksIDB4NjE2YmZmZDMsIDB4MTY2Y2NmNDUsXG4gICAgMHhhMDBhZTI3OCwgMHhkNzBkZDJlZSwgMHg0ZTA0ODM1NCwgMHgzOTAzYjNjMiwgMHhhNzY3MjY2MSwgMHhkMDYwMTZmNywgMHg0OTY5NDc0ZCwgMHgzZTZlNzdkYixcbiAgICAweGFlZDE2YTRhLCAweGQ5ZDY1YWRjLCAweDQwZGYwYjY2LCAweDM3ZDgzYmYwLCAweGE5YmNhZTUzLCAweGRlYmI5ZWM1LCAweDQ3YjJjZjdmLCAweDMwYjVmZmU5LFxuICAgIDB4YmRiZGYyMWMsIDB4Y2FiYWMyOGEsIDB4NTNiMzkzMzAsIDB4MjRiNGEzYTYsIDB4YmFkMDM2MDUsIDB4Y2RkNzA2OTMsIDB4NTRkZTU3MjksIDB4MjNkOTY3YmYsXG4gICAgMHhiMzY2N2EyZSwgMHhjNDYxNGFiOCwgMHg1ZDY4MWIwMiwgMHgyYTZmMmI5NCwgMHhiNDBiYmUzNywgMHhjMzBjOGVhMSwgMHg1YTA1ZGYxYiwgMHgyZDAyZWY4ZCxcbl0pO1xuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIENSQzMyIG9mIGFuIEFycmF5QnVmZmVyTGlrZS5cbiAqIEBwYXJhbSBidWYgVGhlIEJ1ZmZlckxpa2UgdG8gY2FsY3VsYXRlIHRoZSBDUkMzMiBvZi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENyYzMyKGJ1Zikge1xuICAgIGNvbnN0IGIgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIGxldCBjcmMgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IGJbaV07XG4gICAgICAgIGNvbnN0IHQgPSAoYnl0ZSBeIGNyYykgJiAweGZmO1xuICAgICAgICBjcmMgPSBsb29rVXBUYWJsZVt0XSBeIChjcmMgPj4+IDgpO1xuICAgIH1cbiAgICByZXR1cm4gKGNyYyBeIC0xKSA+Pj4gMDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldENyYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/principal/lib/esm/utils/getCrc.js\n"));

/***/ }),

/***/ "../../../node_modules/@dfinity/principal/lib/esm/utils/sha224.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/@dfinity/principal/lib/esm/utils/sha224.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: function() { return /* binding */ sha224; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"../../../node_modules/@noble/hashes/esm/sha256.js\");\n\n/**\n * Returns the SHA224 hash of the buffer.\n * @param data Arraybuffer to encode\n */\nfunction sha224(data) {\n    return _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha224.create().update(new Uint8Array(data)).digest();\n}\n//# sourceMappingURL=sha224.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BkZmluaXR5L3ByaW5jaXBhbC9saWIvZXNtL3V0aWxzL3NoYTIyNC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyx3REFBUTtBQUNuQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGRmaW5pdHkvcHJpbmNpcGFsL2xpYi9lc20vdXRpbHMvc2hhMjI0LmpzP2Q5ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hhMjI0IGFzIGpzU2hhMjI0IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBTSEEyMjQgaGFzaCBvZiB0aGUgYnVmZmVyLlxuICogQHBhcmFtIGRhdGEgQXJyYXlidWZmZXIgdG8gZW5jb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGEyMjQoZGF0YSkge1xuICAgIHJldHVybiBqc1NoYTIyNC5jcmVhdGUoKS51cGRhdGUobmV3IFVpbnQ4QXJyYXkoZGF0YSkpLmRpZ2VzdCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjI0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@dfinity/principal/lib/esm/utils/sha224.js\n"));

/***/ }),

/***/ "../../../node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(){\n  \"use strict\";\n\n  var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  // Use a lookup table to find the index.\n  var lookup = new Uint8Array(256);\n  for (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n  }\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = lookup[base64.charCodeAt(i)];\n      encoded2 = lookup[base64.charCodeAt(i+1)];\n      encoded3 = lookup[base64.charCodeAt(i+2)];\n      encoded4 = lookup[base64.charCodeAt(i+3)];\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBLEVBQUUsY0FBYztBQUNoQjtBQUNBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRSxjQUFjO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzPzllYTgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKCl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuXG4gIC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbiAgdmFyIGxvb2t1cCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMSldO1xuICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsyKV07XG4gICAgICBlbmNvZGVkNCA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzMpXTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/base64-arraybuffer/lib/base64-arraybuffer.js\n"));

/***/ }),

/***/ "../../../node_modules/base64-js/index.js":
/*!************************************************!*\
  !*** ../../../node_modules/base64-js/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanM/NjJiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "../../../node_modules/bignumber.js/bignumber.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/bignumber.js/bignumber.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v9.1.2\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n      alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(v, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor call without `new`.\r\n      if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n      if (b == null) {\r\n\r\n        if (v && v._isBigNumber === true) {\r\n          x.s = v.s;\r\n\r\n          if (!v.c || v.e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else if (v.e < MIN_EXP) {\r\n            x.c = [x.e = 0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.c = v.c.slice();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n          // Fast path for integers, where n < 2147483648 (2**31).\r\n          if (v === ~~v) {\r\n            for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n            if (e > MAX_EXP) {\r\n              x.c = x.e = null;\r\n            } else {\r\n              x.e = e;\r\n              x.c = [v];\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          str = String(v);\r\n        } else {\r\n\r\n          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n          x = new BigNumber(v);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        str = String(v);\r\n\r\n        if (isNum = typeof v == 'number') {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + v);\r\n          }\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp, so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(v), isNum, b);\r\n          }\r\n        }\r\n\r\n        // Prevent later check for length on converted number.\r\n        isNum = false;\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      if (str = str.slice(i, ++len)) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * v));\r\n        }\r\n\r\n         // Overflow?\r\n        if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            i = LOG_BASE - (str = str.slice(i)).length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if less than two characters,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      if (!v || v._isBigNumber !== true) return false;\r\n      if (!BigNumber.DEBUG) return true;\r\n\r\n      var i, n,\r\n        c = v.c,\r\n        e = v.e,\r\n        s = v.s;\r\n\r\n      out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n          // If the first element is zero, the BigNumber value must be zero.\r\n          if (c[0] === 0) {\r\n            if (e === 0 && c.length === 1) return true;\r\n            break out;\r\n          }\r\n\r\n          // Calculate number of digits that c[0] should have, based on the exponent.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (i < 1) i += LOG_BASE;\r\n\r\n          // Calculate number of digits of c[0].\r\n          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n          if (String(c[0]).length == i) {\r\n\r\n            for (i = 0; i < c.length; i++) {\r\n              n = c[i];\r\n              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n            }\r\n\r\n            // Last element cannot be zero, unless it is the only element.\r\n            if (n !== 0) return true;\r\n          }\r\n        }\r\n\r\n      // Infinity/NaN\r\n      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n        return true;\r\n      }\r\n\r\n      throw Error\r\n        (bignumberError + 'Invalid BigNumber: ' + v);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, -1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    // If any number is NaN, return NaN.\r\n    function maxOrMin(args, n) {\r\n      var k, y,\r\n        i = 1,\r\n        x = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        y = new BigNumber(args[i]);\r\n        if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\r\n          x = y;\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.s = null;\r\n        }\r\n\r\n        x.c = x.e = null;\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = mathfloor(n / pows10[d - j - 1] % 10);\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return 0, else return Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) {\r\n        t = xc;\r\n        xc = yc;\r\n        yc = t;\r\n        y.s = -y.s;\r\n      }\r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return Infinity if either is Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return 0 if either is 0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) {\r\n        zc = xc;\r\n        xc = yc;\r\n        yc = zc;\r\n        i = xcL;\r\n        xcL = ycL;\r\n        ycL = i;\r\n      }\r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return Infinity if either Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) {\r\n        t = yc;\r\n        yc = xc;\r\n        xc = t;\r\n        b = a;\r\n      }\r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '5e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) {\r\n          i = g1;\r\n          g1 = g2;\r\n          g2 = i;\r\n          len -= i;\r\n        }\r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(coeffToString(n.c), e)\r\n           : toFixedPoint(coeffToString(n.c), e, '0');\r\n        } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n          str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n  // These functions don't need access to variables,\r\n  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== mathfloor(n)) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsbUNBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVEQUF1RDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxLQUFLO0FBQy9DLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxxQkFBcUIs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkMsWUFBWSx5QkFBeUI7QUFDckM7QUFDQSxvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsR0FBRztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBeUM7QUFDL0MsSUFBSSxtQ0FBTyxjQUFjLG1CQUFtQjtBQUFBLGtHQUFDO0FBQzdDO0FBQ0E7QUFDQSxJQUFJLEtBQUssRUFVTjtBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzP2Q2NmQiXSwic291cmNlc0NvbnRlbnQiOlsiOyhmdW5jdGlvbiAoZ2xvYmFsT2JqZWN0KSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuLypcclxuICogICAgICBiaWdudW1iZXIuanMgdjkuMS4yXHJcbiAqICAgICAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMjIgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogICAgICBNSVQgTGljZW5zZWQuXHJcbiAqXHJcbiAqICAgICAgQmlnTnVtYmVyLnByb3RvdHlwZSBtZXRob2RzICAgICB8ICBCaWdOdW1iZXIgbWV0aG9kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGFic29sdXRlVmFsdWUgICAgICAgICAgICBhYnMgICAgfCAgY2xvbmVcclxuICogICAgICBjb21wYXJlZFRvICAgICAgICAgICAgICAgICAgICAgIHwgIGNvbmZpZyAgICAgICAgICAgICAgIHNldFxyXG4gKiAgICAgIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICBkcCAgICAgfCAgICAgIERFQ0lNQUxfUExBQ0VTXHJcbiAqICAgICAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgIGRpdiAgICB8ICAgICAgUk9VTkRJTkdfTU9ERVxyXG4gKiAgICAgIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICBpZGl2ICAgfCAgICAgIEVYUE9ORU5USUFMX0FUXHJcbiAqICAgICAgZXhwb25lbnRpYXRlZEJ5ICAgICAgICAgIHBvdyAgICB8ICAgICAgUkFOR0VcclxuICogICAgICBpbnRlZ2VyVmFsdWUgICAgICAgICAgICAgICAgICAgIHwgICAgICBDUllQVE9cclxuICogICAgICBpc0VxdWFsVG8gICAgICAgICAgICAgICAgZXEgICAgIHwgICAgICBNT0RVTE9fTU9ERVxyXG4gKiAgICAgIGlzRmluaXRlICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIFBPV19QUkVDSVNJT05cclxuICogICAgICBpc0dyZWF0ZXJUaGFuICAgICAgICAgICAgZ3QgICAgIHwgICAgICBGT1JNQVRcclxuICogICAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvICAgZ3RlICAgIHwgICAgICBBTFBIQUJFVFxyXG4gKiAgICAgIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgICAgICAgfCAgaXNCaWdOdW1iZXJcclxuICogICAgICBpc0xlc3NUaGFuICAgICAgICAgICAgICAgbHQgICAgIHwgIG1heGltdW0gICAgICAgICAgICAgIG1heFxyXG4gKiAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG8gICAgICBsdGUgICAgfCAgbWluaW11bSAgICAgICAgICAgICAgbWluXHJcbiAqICAgICAgaXNOYU4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByYW5kb21cclxuICogICAgICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgICAgICAgIHwgIHN1bVxyXG4gKiAgICAgIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGlzWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1pbnVzICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1vZHVsbyAgICAgICAgICAgICAgICAgICBtb2QgICAgfFxyXG4gKiAgICAgIG11bHRpcGxpZWRCeSAgICAgICAgICAgICB0aW1lcyAgfFxyXG4gKiAgICAgIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHBsdXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHByZWNpc2lvbiAgICAgICAgICAgICAgICBzZCAgICAgfFxyXG4gKiAgICAgIHNoaWZ0ZWRCeSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHNxdWFyZVJvb3QgICAgICAgICAgICAgICBzcXJ0ICAgfFxyXG4gKiAgICAgIHRvRXhwb25lbnRpYWwgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRml4ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRnJhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvSlNPTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvUHJlY2lzaW9uICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG4gIHZhciBCaWdOdW1iZXIsXHJcbiAgICBpc051bWVyaWMgPSAvXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxcclxuICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuXHJcbiAgICBiaWdudW1iZXJFcnJvciA9ICdbQmlnTnVtYmVyIEVycm9yXSAnLFxyXG4gICAgdG9vTWFueURpZ2l0cyA9IGJpZ251bWJlckVycm9yICsgJ051bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6ICcsXHJcblxyXG4gICAgQkFTRSA9IDFlMTQsXHJcbiAgICBMT0dfQkFTRSA9IDE0LFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYsICAgICAgICAgLy8gMl41MyAtIDFcclxuICAgIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gICAgU1FSVF9CQVNFID0gMWU3LFxyXG5cclxuICAgIC8vIEVESVRBQkxFXHJcbiAgICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAgIC8vIHRoZSBhcmd1bWVudHMgdG8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQsIGFuZCB0b1ByZWNpc2lvbi5cclxuICAgIE1BWCA9IDFFOTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0lOVDMyXHJcblxyXG5cclxuICAvKlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNsb25lKGNvbmZpZ09iamVjdCkge1xyXG4gICAgdmFyIGRpdiwgY29udmVydEJhc2UsIHBhcnNlTnVtZXJpYyxcclxuICAgICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBCaWdOdW1iZXIsIHRvU3RyaW5nOiBudWxsLCB2YWx1ZU9mOiBudWxsIH0sXHJcbiAgICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUQUJMRSBDT05GSUcgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAgIC8vIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuc2V0LlxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbi5cclxuICAgICAgREVDSU1BTF9QTEFDRVMgPSAyMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcywgYW5kIHdoZW4gdXNpbmdcclxuICAgICAgLy8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQgYW5kIHRvUHJlY2lzaW9uLCBhbmQgcm91bmQgKGRlZmF1bHQgdmFsdWUpLlxyXG4gICAgICAvLyBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAgIC8vIERPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAgIC8vIENFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgICAvLyBIQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAgIC8vIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgICAgLy8gSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAvLyBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgICAgLy8gICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAgIC8vIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgICAgLy8gSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgIC8vIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgICAgLy8gICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAgIC8vIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAgIC8vIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgTU9EVUxPX01PREUgPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiB0aGUgZXhwb25lbnRpYXRlZEJ5IG9wZXJhdGlvbi5cclxuICAgICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgIFBPV19QUkVDSVNJT04gPSAwLCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgICAgRk9STUFUID0ge1xyXG4gICAgICAgIHByZWZpeDogJycsXHJcbiAgICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgc3VmZml4OiAnJ1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy8gVGhlIGFscGhhYmV0IHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi4gSXQgbXVzdCBiZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgbG9uZywgd2l0aCBubyAnKycsXHJcbiAgICAgIC8vICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgIC8vICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJ1xyXG4gICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxyXG4gICAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB0cnVlO1xyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZ051bWJlciBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogdiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqIFtiXSB7bnVtYmVyfSBUaGUgYmFzZSBvZiB2LiBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJpZ051bWJlcih2LCBiKSB7XHJcbiAgICAgIHZhciBhbHBoYWJldCwgYywgY2FzZUNoYW5nZWQsIGUsIGksIGlzTnVtLCBsZW4sIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgYG5ld2AuXHJcbiAgICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSByZXR1cm4gbmV3IEJpZ051bWJlcih2LCBiKTtcclxuXHJcbiAgICAgIGlmIChiID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHYgJiYgdi5faXNCaWdOdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgIHgucyA9IHYucztcclxuXHJcbiAgICAgICAgICBpZiAoIXYuYyB8fCB2LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgICB4LmMgPSB2LmMuc2xpY2UoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpICYmIHYgKiAwID09IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBVc2UgYDEgLyBuYCB0byBoYW5kbGUgbWludXMgemVybyBhbHNvLlxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHYgPSAtdiwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLCB3aGVyZSBuIDwgMjE0NzQ4MzY0OCAoMioqMzEpLlxyXG4gICAgICAgICAgaWYgKHYgPT09IH5+dikge1xyXG4gICAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgICB4LmMgPSBbdl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBpZiAoIWlzTnVtZXJpYy50ZXN0KHN0ciA9IFN0cmluZyh2KSkpIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSk7XHJcblxyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICAgICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG5cclxuICAgICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudCwgd2hpbGVcclxuICAgICAgICAvLyBhbHNvIHJvdW5kaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgICAgaWYgKGIgPT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih2KTtcclxuICAgICAgICAgIHJldHVybiByb3VuZCh4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG5cclxuICAgICAgICBpZiAoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICAgIGlmICh2ICogMCAhPSAwKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0sIGIpO1xyXG5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcgJiYgc3RyLnJlcGxhY2UoL14wXFwuMCp8XFwuLywgJycpLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWxwaGFiZXQgPSBBTFBIQUJFVC5zbGljZSgwLCBiKTtcclxuICAgICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRoYXQgc3RyIGlzIGEgdmFsaWQgYmFzZSBiIG51bWJlci5cclxuICAgICAgICAvLyBEb24ndCB1c2UgUmVnRXhwLCBzbyBhbHBoYWJldCBjYW4gY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGMgPSBzdHIuY2hhckF0KGkpKSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmICcuJyBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXQgaGFzIG5vdCBiZSBmb3VuZCBiZWZvcmUuXHJcbiAgICAgICAgICAgICAgaWYgKGkgPiBlKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gbGVuO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjYXNlQ2hhbmdlZCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBBbGxvdyBlLmcuIGhleGFkZWNpbWFsICdGRicgYXMgd2VsbCBhcyAnZmYnLlxyXG4gICAgICAgICAgICAgIGlmIChzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgICAgICBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWMoeCwgU3RyaW5nKHYpLCBpc051bSwgYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgICBpc051bSA9IGZhbHNlO1xyXG4gICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ciwgYiwgMTAsIHgucyk7XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgZWxzZSBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4Oyk7XHJcblxyXG4gICAgICBpZiAoc3RyID0gc3RyLnNsaWNlKGksICsrbGVuKSkge1xyXG4gICAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgIGlmIChpc051bSAmJiBCaWdOdW1iZXIuREVCVUcgJiZcclxuICAgICAgICAgIGxlbiA+IDE1ICYmICh2ID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2ICE9PSBtYXRoZmxvb3IodikpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAodG9vTWFueURpZ2l0cyArICh4LnMgKiB2KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgaWYgKChlID0gZSAtIGkgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFOyAgLy8gaSA8IDFcclxuXHJcbiAgICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgICB4LmMucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaSA9IExPR19CQVNFIC0gKHN0ciA9IHN0ci5zbGljZShpKSkubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcclxuXHJcblxyXG4gICAgQmlnTnVtYmVyLmNsb25lID0gY2xvbmU7XHJcblxyXG4gICAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICAgIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEFjY2VwdCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgKGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzXHJcbiAgICAgKiBhIG51bWJlciwgaXQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIHN0YXRlZCk6XHJcbiAgICAgKlxyXG4gICAgICogICBERUNJTUFMX1BMQUNFUyAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBST1VORElOR19NT0RFICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDhcclxuICAgICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgICAqICAgUkFOR0UgICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggKG5vdCB6ZXJvKSAgb3IgIFstTUFYIHRvIC0xLCAxIHRvIE1BWF1cclxuICAgICAqICAgQ1JZUFRPICAgICAgICAgICB7Ym9vbGVhbn0gICAgICAgICAgdHJ1ZSBvciBmYWxzZVxyXG4gICAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgICAqICAgUE9XX1BSRUNJU0lPTiAgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgQUxQSEFCRVQgICAgICAgICB7c3RyaW5nfSAgICAgICAgICAgQSBzdHJpbmcgb2YgdHdvIG9yIG1vcmUgdW5pcXVlIGNoYXJhY3RlcnMgd2hpY2ggZG9lc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICAgKiAgIEZPUk1BVCAgICAgICAgICAge29iamVjdH0gICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHNvbWUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAgICogICAgIHByZWZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cclxuICAgICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKlxyXG4gICAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgICAqXHJcbiAgICAgKiBFLmcuXHJcbiAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAqXHJcbiAgICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgZXhjZXB0IGZvciBBTFBIQUJFVC5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5jb25maWcgPSBCaWdOdW1iZXIuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICB2YXIgcCwgdjtcclxuXHJcbiAgICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBERUNJTUFMX1BMQUNFUyB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnREVDSU1BTF9QTEFDRVMnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJPVU5ESU5HX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA4LCBwKTtcclxuICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBFWFBPTkVOVElBTF9BVCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF07XHJcbiAgICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIC0xIGluY2x1c2l2ZSwgaW50ZWdlciAxIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJBTkdFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZXxjYW5ub3QgYmUgemVyb306IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDEsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF07XHJcbiAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgTUlOX0VYUCA9IC0oTUFYX0VYUCA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBjYW5ub3QgYmUgemVybzogJyArIHYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQ1JZUFRPJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgPT09ICEhdikge1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgICAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSAhdjtcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IHRydWUgb3IgZmFsc2U6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTU9EVUxPX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOSwgcCk7XHJcbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdQT1dfUFJFQ0lTSU9OJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdGT1JNQVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ29iamVjdCcpIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBBTFBIQUJFVCB7c3RyaW5nfVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdBTFBIQUJFVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcblxyXG4gICAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBsZXNzIHRoYW4gdHdvIGNoYXJhY3RlcnMsXHJcbiAgICAgICAgICAgIC8vIG9yIGlmIGl0IGNvbnRhaW5zICcrJywgJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIGEgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ3N0cmluZycgJiYgIS9eLj8kfFsrXFwtLlxcc118KC4pLipcXDEvLnRlc3QodikpIHtcclxuICAgICAgICAgICAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB2LnNsaWNlKDAsIDEwKSA9PSAnMDEyMzQ1Njc4OSc7XHJcbiAgICAgICAgICAgICAgQUxQSEFCRVQgPSB2O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGludmFsaWQ6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBPYmplY3QgZXhwZWN0ZWQ6IHt2fSdcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ09iamVjdCBleHBlY3RlZDogJyArIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIERFQ0lNQUxfUExBQ0VTOiBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICAgIEVYUE9ORU5USUFMX0FUOiBbVE9fRVhQX05FRywgVE9fRVhQX1BPU10sXHJcbiAgICAgICAgUkFOR0U6IFtNSU5fRVhQLCBNQVhfRVhQXSxcclxuICAgICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgICBNT0RVTE9fTU9ERTogTU9EVUxPX01PREUsXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTjogUE9XX1BSRUNJU0lPTixcclxuICAgICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgICBBTFBIQUJFVDogQUxQSEFCRVRcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB2IGlzIGEgQmlnTnVtYmVyIGluc3RhbmNlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIElmIEJpZ051bWJlci5ERUJVRyBpcyB0cnVlLCB0aHJvdyBpZiBhIEJpZ051bWJlciBpbnN0YW5jZSBpcyBub3Qgd2VsbC1mb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogdiB7YW55fVxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBJbnZhbGlkIEJpZ051bWJlcjoge3Z9J1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICBpZiAoIXYgfHwgdi5faXNCaWdOdW1iZXIgIT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgdmFyIGksIG4sXHJcbiAgICAgICAgYyA9IHYuYyxcclxuICAgICAgICBlID0gdi5lLFxyXG4gICAgICAgIHMgPSB2LnM7XHJcblxyXG4gICAgICBvdXQ6IGlmICh7fS50b1N0cmluZy5jYWxsKGMpID09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuXHJcbiAgICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgemVybywgdGhlIEJpZ051bWJlciB2YWx1ZSBtdXN0IGJlIHplcm8uXHJcbiAgICAgICAgICBpZiAoY1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoaSA8IDEpIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAgIC8vaWYgKE1hdGguY2VpbChNYXRoLmxvZyhjWzBdICsgMSkgLyBNYXRoLkxOMTApID09IGkpIHtcclxuICAgICAgICAgIGlmIChTdHJpbmcoY1swXSkubGVuZ3RoID09IGkpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbiA9IGNbaV07XHJcbiAgICAgICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gQkFTRSB8fCBuICE9PSBtYXRoZmxvb3IobikpIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGFzdCBlbGVtZW50IGNhbm5vdCBiZSB6ZXJvLCB1bmxlc3MgaXQgaXMgdGhlIG9ubHkgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKG4gIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdJbnZhbGlkIEJpZ051bWJlcjogJyArIHYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIC0xKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgICAvLyBDaGVjayBpZiBNYXRoLnJhbmRvbSgpIHByb2R1Y2VzIG1vcmUgdGhhbiAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXHJcbiAgICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgICB2YXIgcmFuZG9tNTNiaXRJbnQgPSAoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpICYgMHgxZmZmZmZcclxuICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGMgPSBbXSxcclxuICAgICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAgIGlmIChkcCA9PSBudWxsKSBkcCA9IERFQ0lNQUxfUExBQ0VTO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoayAqPSAyKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XHJcbiAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgNF0gPDwgMTYpICsgKGFbaSArIDVdIDw8IDgpICsgYVtpICsgNl07XHJcblxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgIGRwICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cclxuICAgICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByYW5kLmUgPSBlO1xyXG4gICAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuc3VtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICBzdW0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgICBjb252ZXJ0QmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICogQ29udmVydCBzdHJpbmcgb2YgYmFzZUluIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYmFzZU91dC5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgdmFyIGosXHJcbiAgICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgICBhcnJMLFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgICAgYXJyWzBdICs9IGFscGhhYmV0LmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PSBudWxsKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgdG9TdHJpbmcsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZSAxMCB0byBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICAgIHZhciBhbHBoYWJldCwgZCwgZSwgaywgciwgeCwgeGMsIHksXHJcbiAgICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgICAgeS5jID0gdG9CYXNlT3V0KHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKHguYyksIHguZSwgJzAnKSxcclxuICAgICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICAgID8gKGFscGhhYmV0ID0gQUxQSEFCRVQsIGRlY2ltYWwpXHJcbiAgICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgICBlID0gayA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIC0tZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5jID0geGM7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgICB4YyA9IHguYztcclxuICAgICAgICAgIHIgPSB4LnI7XHJcbiAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGNvbnZlcnRlZCB0byBiYXNlT3V0LlxyXG5cclxuICAgICAgICAvLyBUSGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQ6IHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICAgIGsgPSBiYXNlT3V0IC8gMjtcclxuICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiYgeGNbZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgICAgLy8gemVybywgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBiYXNlIGNvbnZlcnNpb24gaXMgemVybyBvciwgaWYgcm91bmRpbmcgdXAsIGEgdmFsdWVcclxuICAgICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIDFeLWRwIG9yIDBcclxuICAgICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB4YyB0byB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgICAgeGMgPSBbMV0uY29uY2F0KHhjKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsIGFscGhhYmV0LmNoYXJBdCgwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHgsIGssIGJhc2UpIHtcclxuICAgICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICBpID0geC5sZW5ndGgsXHJcbiAgICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOykge1xyXG4gICAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcclxuICAgICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcclxuXHJcbiAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXHJcbiAgICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSAtIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IDA7IHljW2ldID09ICh4Y1tpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICAgICAgaWYgKHljW2ldID4gKHhjW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgICAgcWMucHVzaCgxKTtcclxuICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsaXNlIHhjIGFuZCB5YyBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHljIGlzID49IGJhc2UgLyAyLlxyXG5cclxuICAgICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gaGFuZGxlIG9kZCBiYXNlcyB3aGVyZSB5Y1swXSA9PSAoYmFzZSAvIDIpIC0gMS5cclxuICAgICAgICAgIC8vIGlmIChuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyKSB7XHJcbiAgICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgICAgeWMgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHhjID0gbXVsdGlwbHkoeGMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgIHJlbSA9IHhjLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyByZW1bcmVtTCsrXSA9IDApO1xyXG4gICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICAgIHljMCA9IHljWzBdO1xyXG4gICAgICAgICAgaWYgKHljWzFdID49IGJhc2UgLyAyKSB5YzArKztcclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgIC8vIGVsc2UgaWYgKGJhc2UgPT0gMyAmJiB5YzAgPT0gMSkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgY21wID0gY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXHJcblxyXG4gICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgIC8vICBwcm9kdWN0ID0gZGl2aXNvciBtdWx0aXBsaWVkIGJ5IHRyaWFsIGRpZ2l0IChuKS5cclxuICAgICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3QgaXMgZ3JlYXRlciB0aGFuIHJlbWFpbmRlcjpcclxuICAgICAgICAgICAgICAvLyAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdCwgZGVjcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IHdhcyBsZXNzIHRoYW4gcmVtYWluZGVyIGF0IHRoZSBsYXN0IGNvbXBhcmU6XHJcbiAgICAgICAgICAgICAgLy8gICAgQ29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yLlxyXG4gICAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgICAvLyAgICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIsIGluY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0ID4gcmVtYWluZGVyIHRoZW4gdHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5YywgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3csXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBpZiAobiA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYmFzZSA9PSBCQVNFKSB7XHJcblxyXG4gICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIHJvdW5kKHEsIGRwICsgKHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSArIDEsIHJtLCBtb3JlKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcTtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAgICogbm90YXRpb24gcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAqXHJcbiAgICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgICAqIGk6IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICAgKiBybTogdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXQobiwgaSwgcm0sIGlkKSB7XHJcbiAgICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIGMwID0gbi5jWzBdO1xyXG4gICAgICBuZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgc3RyID0gaWQgPT0gMSB8fCBpZCA9PSAyICYmIChuZSA8PSBUT19FWFBfTkVHIHx8IG5lID49IFRPX0VYUF9QT1MpXHJcbiAgICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIG5lLCAnMCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAgIC8vIG4uZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSB3YXMgcm91bmRlZCB1cC5cclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGZvciAoOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyk7XHJcbiAgICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBpZiAoZSArIDEgPiBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgKz0gZSAtIGxlbjtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICBmdW5jdGlvbiBtYXhPck1pbihhcmdzLCBuKSB7XHJcbiAgICAgIHZhciBrLCB5LFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYXJnc1tpXSk7XHJcbiAgICAgICAgaWYgKCF5LnMgfHwgKGsgPSBjb21wYXJlKHgsIHkpKSA9PT0gbiB8fCBrID09PSAwICYmIHgucyA9PT0gbikge1xyXG4gICAgICAgICAgeCA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGogPSBjLmxlbmd0aDtcclxuXHJcbiAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmFzZSAxMCBleHBvbmVudC4gRmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKChlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgbi5jID0gW24uZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4uZSA9IGU7XHJcbiAgICAgICAgbi5jID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSxcclxuICAgICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxyXG4gICAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgICB2YXIgYmFzZSxcclxuICAgICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICAgIGlmIChpc0luZmluaXR5T3JOYU4udGVzdChzKSkge1xyXG4gICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICghaXNOdW0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSAocDIgPSBwMi50b0xvd2VyQ2FzZSgpKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xyXG4gICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZG90QWZ0ZXIsICckMScpLnJlcGxhY2UoZG90QmVmb3JlLCAnMC4kMScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxyXG4gICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuaSA+PSB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICAgIGZvciAoOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkpO1xyXG4gICAgICAgICAgICAgICAgbiA9IHJkID0gMDtcclxuICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLlxyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cclxuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IG4ucyAqICgyIC0gaXNPZGQobikpIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICAgKi9cclxuICAgIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMucztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC0gMCA9IG5cclxuICAgICAqICBuIC0gTiA9IE5cclxuICAgICAqICBuIC0gSSA9IC1JXHJcbiAgICAgKiAgMCAtIG4gPSAtblxyXG4gICAgICogIDAgLSAwID0gMFxyXG4gICAgICogIDAgLSBOID0gTlxyXG4gICAgICogIDAgLSBJID0gLUlcclxuICAgICAqICBOIC0gbiA9IE5cclxuICAgICAqICBOIC0gMCA9IE5cclxuICAgICAqICBOIC0gTiA9IE5cclxuICAgICAqICBOIC0gSSA9IE5cclxuICAgICAqICBJIC0gbiA9IElcclxuICAgICAqICBJIC0gMCA9IElcclxuICAgICAqICBJIC0gTiA9IE5cclxuICAgICAqICBJIC0gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmICh4TFR5KSB7XHJcbiAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIHhjID0geWM7XHJcbiAgICAgICAgeWMgPSB0O1xyXG4gICAgICAgIHkucyA9IC15LnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB7XHJcbiAgICAgICAgemMgPSB4YztcclxuICAgICAgICB4YyA9IHljO1xyXG4gICAgICAgIHljID0gemM7XHJcbiAgICAgICAgaSA9IHhjTDtcclxuICAgICAgICB4Y0wgPSB5Y0w7XHJcbiAgICAgICAgeWNMID0gaTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChrID0geGNMLCBqID0gaSArIGs7IGogPiBpOykge1xyXG4gICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xyXG4gICAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpjW2pdID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICArK2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHpjLCBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAgICovXHJcbiAgICBQLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgaWYgKGEgLSBiIDwgMCkge1xyXG4gICAgICAgIHQgPSB5YztcclxuICAgICAgICB5YyA9IHhjO1xyXG4gICAgICAgIHhjID0gdDtcclxuICAgICAgICBiID0gYTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgICArK3llO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgICAqXHJcbiAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICAgKi9cclxuICAgIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIHNxcnQoLW4pID0gIE5cclxuICAgICAqICBzcXJ0KE4pID0gIE5cclxuICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYyA9IHguYyxcclxuICAgICAgICBzID0geC5zLFxyXG4gICAgICAgIGUgPSB4LmUsXHJcbiAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICBzID0gZSArIGRwO1xyXG4gICAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogRk9STUFUID0ge1xyXG4gICAgICogICBwcmVmaXg6ICcnLFxyXG4gICAgICogICBncm91cFNpemU6IDMsXHJcbiAgICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAqICAgc3VmZml4OiAnJ1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICAgIGlmICh4LmMpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGcyKSB7XHJcbiAgICAgICAgICBpID0gZzE7XHJcbiAgICAgICAgICBnMSA9IGcyO1xyXG4gICAgICAgICAgZzIgPSBpO1xyXG4gICAgICAgICAgbGVuIC09IGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIG4uZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICAgKi9cclxuICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgICByZXR1cm4gQmlnTnVtYmVyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuICAvLyBUaGVzZSBmdW5jdGlvbnMgZG9uJ3QgbmVlZCBhY2Nlc3MgdG8gdmFyaWFibGVzLFxyXG4gIC8vIGUuZy4gREVDSU1BTF9QTEFDRVMsIGluIHRoZSBzY29wZSBvZiB0aGUgYGNsb25lYCBmdW5jdGlvbiBhYm92ZS5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgIHZhciBpID0gbiB8IDA7XHJcbiAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICB9XHJcblxyXG5cclxuICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgIHZhciBzLCB6LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgIGZvciAoOyBpIDwgajspIHtcclxuICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgICByICs9IHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICAgIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuICBmdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICAgIHZhciBhLCBiLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmMsXHJcbiAgICAgIGkgPSB4LnMsXHJcbiAgICAgIGogPSB5LnMsXHJcbiAgICAgIGsgPSB4LmUsXHJcbiAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICAgIGEgPSBpIDwgMDtcclxuICAgIGIgPSBrID09IGw7XHJcblxyXG4gICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IG1hdGhmbG9vcihuKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG4gIGZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICAgIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgICB2YXIgbGVuLCB6cztcclxuXHJcbiAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICAgIHN0ciArPSB6cztcclxuICAgICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBFWFBPUlRcclxuXHJcblxyXG4gIEJpZ051bWJlciA9IGNsb25lKCk7XHJcbiAgQmlnTnVtYmVyWydkZWZhdWx0J10gPSBCaWdOdW1iZXIuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBBTUQuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlnTnVtYmVyOyB9KTtcclxuXHJcbiAgLy8gTm9kZS5qcyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBCcm93c2VyLlxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWdsb2JhbE9iamVjdCkge1xyXG4gICAgICBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmID8gc2VsZiA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxPYmplY3QuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/bignumber.js/bignumber.js\n"));

/***/ }),

/***/ "../../../node_modules/borc/src/constants.js":
/*!***************************************************!*\
  !*** ../../../node_modules/borc/src/constants.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"../../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nexports.MT = {\n  POS_INT: 0,\n  NEG_INT: 1,\n  BYTE_STRING: 2,\n  UTF8_STRING: 3,\n  ARRAY: 4,\n  MAP: 5,\n  TAG: 6,\n  SIMPLE_FLOAT: 7\n}\n\nexports.TAG = {\n  DATE_STRING: 0,\n  DATE_EPOCH: 1,\n  POS_BIGINT: 2,\n  NEG_BIGINT: 3,\n  DECIMAL_FRAC: 4,\n  BIGFLOAT: 5,\n  BASE64URL_EXPECTED: 21,\n  BASE64_EXPECTED: 22,\n  BASE16_EXPECTED: 23,\n  CBOR: 24,\n  URI: 32,\n  BASE64URL: 33,\n  BASE64: 34,\n  REGEXP: 35,\n  MIME: 36\n}\n\nexports.NUMBYTES = {\n  ZERO: 0,\n  ONE: 24,\n  TWO: 25,\n  FOUR: 26,\n  EIGHT: 27,\n  INDEFINITE: 31\n}\n\nexports.SIMPLE = {\n  FALSE: 20,\n  TRUE: 21,\n  NULL: 22,\n  UNDEFINED: 23\n}\n\nexports.SYMS = {\n  NULL: Symbol('null'),\n  UNDEFINED: Symbol('undef'),\n  PARENT: Symbol('parent'),\n  BREAK: Symbol('break'),\n  STREAM: Symbol('stream')\n}\n\nexports.SHIFT32 = Math.pow(2, 32)\nexports.SHIFT16 = Math.pow(2, 16)\n\nexports.MAX_SAFE_HIGH = 0x1fffff\nexports.NEG_ONE = new Bignumber(-1)\nexports.TEN = new Bignumber(10)\nexports.TWO = new Bignumber(2)\n\nexports.PARENT = {\n  ARRAY: 0,\n  OBJECT: 1,\n  MAP: 2,\n  TAG: 3,\n  BYTE_STRING: 4,\n  UTF8_STRING: 5\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0Isc0dBQWlDOztBQUVuRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2YsZUFBZTs7QUFFZixxQkFBcUI7QUFDckIsZUFBZTtBQUNmLFdBQVc7QUFDWCxXQUFXOztBQUVYLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2NvbnN0YW50cy5qcz8xMTllIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBCaWdudW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKS5CaWdOdW1iZXJcblxuZXhwb3J0cy5NVCA9IHtcbiAgUE9TX0lOVDogMCxcbiAgTkVHX0lOVDogMSxcbiAgQllURV9TVFJJTkc6IDIsXG4gIFVURjhfU1RSSU5HOiAzLFxuICBBUlJBWTogNCxcbiAgTUFQOiA1LFxuICBUQUc6IDYsXG4gIFNJTVBMRV9GTE9BVDogN1xufVxuXG5leHBvcnRzLlRBRyA9IHtcbiAgREFURV9TVFJJTkc6IDAsXG4gIERBVEVfRVBPQ0g6IDEsXG4gIFBPU19CSUdJTlQ6IDIsXG4gIE5FR19CSUdJTlQ6IDMsXG4gIERFQ0lNQUxfRlJBQzogNCxcbiAgQklHRkxPQVQ6IDUsXG4gIEJBU0U2NFVSTF9FWFBFQ1RFRDogMjEsXG4gIEJBU0U2NF9FWFBFQ1RFRDogMjIsXG4gIEJBU0UxNl9FWFBFQ1RFRDogMjMsXG4gIENCT1I6IDI0LFxuICBVUkk6IDMyLFxuICBCQVNFNjRVUkw6IDMzLFxuICBCQVNFNjQ6IDM0LFxuICBSRUdFWFA6IDM1LFxuICBNSU1FOiAzNlxufVxuXG5leHBvcnRzLk5VTUJZVEVTID0ge1xuICBaRVJPOiAwLFxuICBPTkU6IDI0LFxuICBUV086IDI1LFxuICBGT1VSOiAyNixcbiAgRUlHSFQ6IDI3LFxuICBJTkRFRklOSVRFOiAzMVxufVxuXG5leHBvcnRzLlNJTVBMRSA9IHtcbiAgRkFMU0U6IDIwLFxuICBUUlVFOiAyMSxcbiAgTlVMTDogMjIsXG4gIFVOREVGSU5FRDogMjNcbn1cblxuZXhwb3J0cy5TWU1TID0ge1xuICBOVUxMOiBTeW1ib2woJ251bGwnKSxcbiAgVU5ERUZJTkVEOiBTeW1ib2woJ3VuZGVmJyksXG4gIFBBUkVOVDogU3ltYm9sKCdwYXJlbnQnKSxcbiAgQlJFQUs6IFN5bWJvbCgnYnJlYWsnKSxcbiAgU1RSRUFNOiBTeW1ib2woJ3N0cmVhbScpXG59XG5cbmV4cG9ydHMuU0hJRlQzMiA9IE1hdGgucG93KDIsIDMyKVxuZXhwb3J0cy5TSElGVDE2ID0gTWF0aC5wb3coMiwgMTYpXG5cbmV4cG9ydHMuTUFYX1NBRkVfSElHSCA9IDB4MWZmZmZmXG5leHBvcnRzLk5FR19PTkUgPSBuZXcgQmlnbnVtYmVyKC0xKVxuZXhwb3J0cy5URU4gPSBuZXcgQmlnbnVtYmVyKDEwKVxuZXhwb3J0cy5UV08gPSBuZXcgQmlnbnVtYmVyKDIpXG5cbmV4cG9ydHMuUEFSRU5UID0ge1xuICBBUlJBWTogMCxcbiAgT0JKRUNUOiAxLFxuICBNQVA6IDIsXG4gIFRBRzogMyxcbiAgQllURV9TVFJJTkc6IDQsXG4gIFVURjhfU1RSSU5HOiA1XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/borc/src/constants.js\n"));

/***/ }),

/***/ "../../../node_modules/borc/src/decoder.asm.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/borc/src/decoder.asm.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* eslint-disable */\n\nmodule.exports = function decodeAsm (stdlib, foreign, buffer) {\n  'use asm'\n\n  // -- Imports\n\n  var heap = new stdlib.Uint8Array(buffer)\n  // var log = foreign.log\n  var pushInt = foreign.pushInt\n  var pushInt32 = foreign.pushInt32\n  var pushInt32Neg = foreign.pushInt32Neg\n  var pushInt64 = foreign.pushInt64\n  var pushInt64Neg = foreign.pushInt64Neg\n  var pushFloat = foreign.pushFloat\n  var pushFloatSingle = foreign.pushFloatSingle\n  var pushFloatDouble = foreign.pushFloatDouble\n  var pushTrue = foreign.pushTrue\n  var pushFalse = foreign.pushFalse\n  var pushUndefined = foreign.pushUndefined\n  var pushNull = foreign.pushNull\n  var pushInfinity = foreign.pushInfinity\n  var pushInfinityNeg = foreign.pushInfinityNeg\n  var pushNaN = foreign.pushNaN\n  var pushNaNNeg = foreign.pushNaNNeg\n\n  var pushArrayStart = foreign.pushArrayStart\n  var pushArrayStartFixed = foreign.pushArrayStartFixed\n  var pushArrayStartFixed32 = foreign.pushArrayStartFixed32\n  var pushArrayStartFixed64 = foreign.pushArrayStartFixed64\n  var pushObjectStart = foreign.pushObjectStart\n  var pushObjectStartFixed = foreign.pushObjectStartFixed\n  var pushObjectStartFixed32 = foreign.pushObjectStartFixed32\n  var pushObjectStartFixed64 = foreign.pushObjectStartFixed64\n\n  var pushByteString = foreign.pushByteString\n  var pushByteStringStart = foreign.pushByteStringStart\n  var pushUtf8String = foreign.pushUtf8String\n  var pushUtf8StringStart = foreign.pushUtf8StringStart\n\n  var pushSimpleUnassigned = foreign.pushSimpleUnassigned\n\n  var pushTagStart = foreign.pushTagStart\n  var pushTagStart4 = foreign.pushTagStart4\n  var pushTagStart8 = foreign.pushTagStart8\n  var pushTagUnassigned = foreign.pushTagUnassigned\n\n  var pushBreak = foreign.pushBreak\n\n  var pow = stdlib.Math.pow\n\n  // -- Constants\n\n\n  // -- Mutable Variables\n\n  var offset = 0\n  var inputLength = 0\n  var code = 0\n\n  // Decode a cbor string represented as Uint8Array\n  // which is allocated on the heap from 0 to inputLength\n  //\n  // input - Int\n  //\n  // Returns Code - Int,\n  // Success = 0\n  // Error > 0\n  function parse (input) {\n    input = input | 0\n\n    offset = 0\n    inputLength = input\n\n    while ((offset | 0) < (inputLength | 0)) {\n      code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0\n\n      if ((code | 0) > 0) {\n        break\n      }\n    }\n\n    return code | 0\n  }\n\n  // -- Helper Function\n\n  function checkOffset (n) {\n    n = n | 0\n\n    if ((((offset | 0) + (n | 0)) | 0) < (inputLength | 0)) {\n      return 0\n    }\n\n    return 1\n  }\n\n  function readUInt16 (n) {\n    n = n | 0\n\n    return (\n      (heap[n | 0] << 8) | heap[(n + 1) | 0]\n    ) | 0\n  }\n\n  function readUInt32 (n) {\n    n = n | 0\n\n    return (\n      (heap[n | 0] << 24) | (heap[(n + 1) | 0] << 16) | (heap[(n + 2) | 0] << 8) | heap[(n + 3) | 0]\n    ) | 0\n  }\n\n  // -- Initial Byte Handlers\n\n  function INT_P (octet) {\n    octet = octet | 0\n\n    pushInt(octet | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UINT_P_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushInt(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function UINT_P_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushInt(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function UINT_P_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushInt32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function UINT_P_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushInt64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function INT_N (octet) {\n    octet = octet | 0\n\n    pushInt((-1 - ((octet - 32) | 0)) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UINT_N_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushInt(\n      (-1 - (heap[(offset + 1) | 0] | 0)) | 0\n    )\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function UINT_N_16 (octet) {\n    octet = octet | 0\n\n    var val = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    val = readUInt16((offset + 1) | 0) | 0\n    pushInt((-1 - (val | 0)) | 0)\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function UINT_N_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushInt32Neg(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function UINT_N_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushInt64Neg(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function BYTE_STRING (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var step = 0\n\n    step = (octet - 64) | 0\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    start = (offset + 1) | 0\n    end = (((offset + 1) | 0) + (step | 0)) | 0\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_8 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    length = heap[(offset + 1) | 0] | 0\n    start = (offset + 2) | 0\n    end = (((offset + 2) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 1) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_16 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    length = readUInt16((offset + 1) | 0) | 0\n    start = (offset + 3) | 0\n    end = (((offset + 3) | 0) + (length | 0)) | 0\n\n\n    if (checkOffset((length + 2) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_32 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    length = readUInt32((offset + 1) | 0) | 0\n    start = (offset + 5) | 0\n    end = (((offset + 5) | 0) + (length | 0)) | 0\n\n\n    if (checkOffset((length + 4) | 0) | 0) {\n      return 1\n    }\n\n    pushByteString(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function BYTE_STRING_64 (octet) {\n    // NOT IMPLEMENTED\n    octet = octet | 0\n\n    return 1\n  }\n\n  function BYTE_STRING_BREAK (octet) {\n    octet = octet | 0\n\n    pushByteStringStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function UTF8_STRING (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var step = 0\n\n    step = (octet - 96) | 0\n\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    start = (offset + 1) | 0\n    end = (((offset + 1) | 0) + (step | 0)) | 0\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_8 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    length = heap[(offset + 1) | 0] | 0\n    start = (offset + 2) | 0\n    end = (((offset + 2) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 1) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_16 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    length = readUInt16((offset + 1) | 0) | 0\n    start = (offset + 3) | 0\n    end = (((offset + 3) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 2) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_32 (octet) {\n    octet = octet | 0\n\n    var start = 0\n    var end = 0\n    var length = 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    length = readUInt32((offset + 1) | 0) | 0\n    start = (offset + 5) | 0\n    end = (((offset + 5) | 0) + (length | 0)) | 0\n\n    if (checkOffset((length + 4) | 0) | 0) {\n      return 1\n    }\n\n    pushUtf8String(start | 0, end | 0)\n\n    offset = end | 0\n\n    return 0\n  }\n\n  function UTF8_STRING_64 (octet) {\n    // NOT IMPLEMENTED\n    octet = octet | 0\n\n    return 1\n  }\n\n  function UTF8_STRING_BREAK (octet) {\n    octet = octet | 0\n\n    pushUtf8StringStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function ARRAY (octet) {\n    octet = octet | 0\n\n    pushArrayStartFixed((octet - 128) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function ARRAY_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function ARRAY_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function ARRAY_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function ARRAY_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushArrayStartFixed64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function ARRAY_BREAK (octet) {\n    octet = octet | 0\n\n    pushArrayStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function MAP (octet) {\n    octet = octet | 0\n\n    var step = 0\n\n    step = (octet - 160) | 0\n\n    if (checkOffset(step | 0) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(step | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function MAP_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2) | 0\n\n    return 0\n  }\n\n  function MAP_16 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function MAP_32 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed32(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function MAP_64 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushObjectStartFixed64(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function MAP_BREAK (octet) {\n    octet = octet | 0\n\n    pushObjectStart()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function TAG_KNOWN (octet) {\n    octet = octet | 0\n\n    pushTagStart((octet - 192| 0) | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_POS (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_NEG (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_FRAC (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BIGNUM_FLOAT (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_UNASSIGNED (octet) {\n    octet = octet | 0\n\n    pushTagStart((octet - 192| 0) | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE64_URL (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE64 (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_BASE16 (octet) {\n    octet = octet | 0\n\n    pushTagStart(octet | 0)\n\n    offset = (offset + 1 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_1 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushTagStart(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_2 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    pushTagStart(\n      readUInt16((offset + 1) | 0) | 0\n    )\n\n    offset = (offset + 3 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_4 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushTagStart4(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0\n    )\n\n    offset = (offset + 5 | 0)\n\n    return 0\n  }\n\n  function TAG_MORE_8 (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushTagStart8(\n      readUInt16((offset + 1) | 0) | 0,\n      readUInt16((offset + 3) | 0) | 0,\n      readUInt16((offset + 5) | 0) | 0,\n      readUInt16((offset + 7) | 0) | 0\n    )\n\n    offset = (offset + 9 | 0)\n\n    return 0\n  }\n\n  function SIMPLE_UNASSIGNED (octet) {\n    octet = octet | 0\n\n    pushSimpleUnassigned(((octet | 0) - 224) | 0)\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FALSE (octet) {\n    octet = octet | 0\n\n    pushFalse()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_TRUE (octet) {\n    octet = octet | 0\n\n    pushTrue()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_NULL (octet) {\n    octet = octet | 0\n\n    pushNull()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_UNDEFINED (octet) {\n    octet = octet | 0\n\n    pushUndefined()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  function SIMPLE_BYTE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(1) | 0) {\n      return 1\n    }\n\n    pushSimpleUnassigned(heap[(offset + 1) | 0] | 0)\n\n    offset = (offset + 2)  | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_HALF (octet) {\n    octet = octet | 0\n\n    var f = 0\n    var g = 0\n    var sign = 1.0\n    var exp = 0.0\n    var mant = 0.0\n    var r = 0.0\n    if (checkOffset(2) | 0) {\n      return 1\n    }\n\n    f = heap[(offset + 1) | 0] | 0\n    g = heap[(offset + 2) | 0] | 0\n\n    if ((f | 0) & 0x80) {\n      sign = -1.0\n    }\n\n    exp = +(((f | 0) & 0x7C) >> 2)\n    mant = +((((f | 0) & 0x03) << 8) | g)\n\n    if (+exp == 0.0) {\n      pushFloat(+(\n        (+sign) * +5.9604644775390625e-8 * (+mant)\n      ))\n    } else if (+exp == 31.0) {\n      if (+sign == 1.0) {\n        if (+mant > 0.0) {\n          pushNaN()\n        } else {\n          pushInfinity()\n        }\n      } else {\n        if (+mant > 0.0) {\n          pushNaNNeg()\n        } else {\n          pushInfinityNeg()\n        }\n      }\n    } else {\n      pushFloat(+(\n        +sign * pow(+2, +(+exp - 25.0)) * +(1024.0 + mant)\n      ))\n    }\n\n    offset = (offset + 3) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_SINGLE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(4) | 0) {\n      return 1\n    }\n\n    pushFloatSingle(\n      heap[(offset + 1) | 0] | 0,\n      heap[(offset + 2) | 0] | 0,\n      heap[(offset + 3) | 0] | 0,\n      heap[(offset + 4) | 0] | 0\n    )\n\n    offset = (offset + 5) | 0\n\n    return 0\n  }\n\n  function SIMPLE_FLOAT_DOUBLE (octet) {\n    octet = octet | 0\n\n    if (checkOffset(8) | 0) {\n      return 1\n    }\n\n    pushFloatDouble(\n      heap[(offset + 1) | 0] | 0,\n      heap[(offset + 2) | 0] | 0,\n      heap[(offset + 3) | 0] | 0,\n      heap[(offset + 4) | 0] | 0,\n      heap[(offset + 5) | 0] | 0,\n      heap[(offset + 6) | 0] | 0,\n      heap[(offset + 7) | 0] | 0,\n      heap[(offset + 8) | 0] | 0\n    )\n\n    offset = (offset + 9) | 0\n\n    return 0\n  }\n\n  function ERROR (octet) {\n    octet = octet | 0\n\n    return 1\n  }\n\n  function BREAK (octet) {\n    octet = octet | 0\n\n    pushBreak()\n\n    offset = (offset + 1) | 0\n\n    return 0\n  }\n\n  // -- Jump Table\n\n  var jumpTable = [\n    // Integer 0x00..0x17 (0..23)\n    INT_P, // 0x00\n    INT_P, // 0x01\n    INT_P, // 0x02\n    INT_P, // 0x03\n    INT_P, // 0x04\n    INT_P, // 0x05\n    INT_P, // 0x06\n    INT_P, // 0x07\n    INT_P, // 0x08\n    INT_P, // 0x09\n    INT_P, // 0x0A\n    INT_P, // 0x0B\n    INT_P, // 0x0C\n    INT_P, // 0x0D\n    INT_P, // 0x0E\n    INT_P, // 0x0F\n    INT_P, // 0x10\n    INT_P, // 0x11\n    INT_P, // 0x12\n    INT_P, // 0x13\n    INT_P, // 0x14\n    INT_P, // 0x15\n    INT_P, // 0x16\n    INT_P, // 0x17\n    // Unsigned integer (one-byte uint8_t follows)\n    UINT_P_8, // 0x18\n    // Unsigned integer (two-byte uint16_t follows)\n    UINT_P_16, // 0x19\n    // Unsigned integer (four-byte uint32_t follows)\n    UINT_P_32, // 0x1a\n    // Unsigned integer (eight-byte uint64_t follows)\n    UINT_P_64, // 0x1b\n    ERROR, // 0x1c\n    ERROR, // 0x1d\n    ERROR, // 0x1e\n    ERROR, // 0x1f\n    // Negative integer -1-0x00..-1-0x17 (-1..-24)\n    INT_N, // 0x20\n    INT_N, // 0x21\n    INT_N, // 0x22\n    INT_N, // 0x23\n    INT_N, // 0x24\n    INT_N, // 0x25\n    INT_N, // 0x26\n    INT_N, // 0x27\n    INT_N, // 0x28\n    INT_N, // 0x29\n    INT_N, // 0x2A\n    INT_N, // 0x2B\n    INT_N, // 0x2C\n    INT_N, // 0x2D\n    INT_N, // 0x2E\n    INT_N, // 0x2F\n    INT_N, // 0x30\n    INT_N, // 0x31\n    INT_N, // 0x32\n    INT_N, // 0x33\n    INT_N, // 0x34\n    INT_N, // 0x35\n    INT_N, // 0x36\n    INT_N, // 0x37\n    // Negative integer -1-n (one-byte uint8_t for n follows)\n    UINT_N_8, // 0x38\n    // Negative integer -1-n (two-byte uint16_t for n follows)\n    UINT_N_16, // 0x39\n    // Negative integer -1-n (four-byte uint32_t for nfollows)\n    UINT_N_32, // 0x3a\n    // Negative integer -1-n (eight-byte uint64_t for n follows)\n    UINT_N_64, // 0x3b\n    ERROR, // 0x3c\n    ERROR, // 0x3d\n    ERROR, // 0x3e\n    ERROR, // 0x3f\n    // byte string (0x00..0x17 bytes follow)\n    BYTE_STRING, // 0x40\n    BYTE_STRING, // 0x41\n    BYTE_STRING, // 0x42\n    BYTE_STRING, // 0x43\n    BYTE_STRING, // 0x44\n    BYTE_STRING, // 0x45\n    BYTE_STRING, // 0x46\n    BYTE_STRING, // 0x47\n    BYTE_STRING, // 0x48\n    BYTE_STRING, // 0x49\n    BYTE_STRING, // 0x4A\n    BYTE_STRING, // 0x4B\n    BYTE_STRING, // 0x4C\n    BYTE_STRING, // 0x4D\n    BYTE_STRING, // 0x4E\n    BYTE_STRING, // 0x4F\n    BYTE_STRING, // 0x50\n    BYTE_STRING, // 0x51\n    BYTE_STRING, // 0x52\n    BYTE_STRING, // 0x53\n    BYTE_STRING, // 0x54\n    BYTE_STRING, // 0x55\n    BYTE_STRING, // 0x56\n    BYTE_STRING, // 0x57\n    // byte string (one-byte uint8_t for n, and then n bytes follow)\n    BYTE_STRING_8, // 0x58\n    // byte string (two-byte uint16_t for n, and then n bytes follow)\n    BYTE_STRING_16, // 0x59\n    // byte string (four-byte uint32_t for n, and then n bytes follow)\n    BYTE_STRING_32, // 0x5a\n    // byte string (eight-byte uint64_t for n, and then n bytes follow)\n    BYTE_STRING_64, // 0x5b\n    ERROR, // 0x5c\n    ERROR, // 0x5d\n    ERROR, // 0x5e\n    // byte string, byte strings follow, terminated by \"break\"\n    BYTE_STRING_BREAK, // 0x5f\n    // UTF-8 string (0x00..0x17 bytes follow)\n    UTF8_STRING, // 0x60\n    UTF8_STRING, // 0x61\n    UTF8_STRING, // 0x62\n    UTF8_STRING, // 0x63\n    UTF8_STRING, // 0x64\n    UTF8_STRING, // 0x65\n    UTF8_STRING, // 0x66\n    UTF8_STRING, // 0x67\n    UTF8_STRING, // 0x68\n    UTF8_STRING, // 0x69\n    UTF8_STRING, // 0x6A\n    UTF8_STRING, // 0x6B\n    UTF8_STRING, // 0x6C\n    UTF8_STRING, // 0x6D\n    UTF8_STRING, // 0x6E\n    UTF8_STRING, // 0x6F\n    UTF8_STRING, // 0x70\n    UTF8_STRING, // 0x71\n    UTF8_STRING, // 0x72\n    UTF8_STRING, // 0x73\n    UTF8_STRING, // 0x74\n    UTF8_STRING, // 0x75\n    UTF8_STRING, // 0x76\n    UTF8_STRING, // 0x77\n    // UTF-8 string (one-byte uint8_t for n, and then n bytes follow)\n    UTF8_STRING_8, // 0x78\n    // UTF-8 string (two-byte uint16_t for n, and then n bytes follow)\n    UTF8_STRING_16, // 0x79\n    // UTF-8 string (four-byte uint32_t for n, and then n bytes follow)\n    UTF8_STRING_32, // 0x7a\n    // UTF-8 string (eight-byte uint64_t for n, and then n bytes follow)\n    UTF8_STRING_64, // 0x7b\n    // UTF-8 string, UTF-8 strings follow, terminated by \"break\"\n    ERROR, // 0x7c\n    ERROR, // 0x7d\n    ERROR, // 0x7e\n    UTF8_STRING_BREAK, // 0x7f\n    // array (0x00..0x17 data items follow)\n    ARRAY, // 0x80\n    ARRAY, // 0x81\n    ARRAY, // 0x82\n    ARRAY, // 0x83\n    ARRAY, // 0x84\n    ARRAY, // 0x85\n    ARRAY, // 0x86\n    ARRAY, // 0x87\n    ARRAY, // 0x88\n    ARRAY, // 0x89\n    ARRAY, // 0x8A\n    ARRAY, // 0x8B\n    ARRAY, // 0x8C\n    ARRAY, // 0x8D\n    ARRAY, // 0x8E\n    ARRAY, // 0x8F\n    ARRAY, // 0x90\n    ARRAY, // 0x91\n    ARRAY, // 0x92\n    ARRAY, // 0x93\n    ARRAY, // 0x94\n    ARRAY, // 0x95\n    ARRAY, // 0x96\n    ARRAY, // 0x97\n    // array (one-byte uint8_t fo, and then n data items follow)\n    ARRAY_8, // 0x98\n    // array (two-byte uint16_t for n, and then n data items follow)\n    ARRAY_16, // 0x99\n    // array (four-byte uint32_t for n, and then n data items follow)\n    ARRAY_32, // 0x9a\n    // array (eight-byte uint64_t for n, and then n data items follow)\n    ARRAY_64, // 0x9b\n    // array, data items follow, terminated by \"break\"\n    ERROR, // 0x9c\n    ERROR, // 0x9d\n    ERROR, // 0x9e\n    ARRAY_BREAK, // 0x9f\n    // map (0x00..0x17 pairs of data items follow)\n    MAP, // 0xa0\n    MAP, // 0xa1\n    MAP, // 0xa2\n    MAP, // 0xa3\n    MAP, // 0xa4\n    MAP, // 0xa5\n    MAP, // 0xa6\n    MAP, // 0xa7\n    MAP, // 0xa8\n    MAP, // 0xa9\n    MAP, // 0xaA\n    MAP, // 0xaB\n    MAP, // 0xaC\n    MAP, // 0xaD\n    MAP, // 0xaE\n    MAP, // 0xaF\n    MAP, // 0xb0\n    MAP, // 0xb1\n    MAP, // 0xb2\n    MAP, // 0xb3\n    MAP, // 0xb4\n    MAP, // 0xb5\n    MAP, // 0xb6\n    MAP, // 0xb7\n    // map (one-byte uint8_t for n, and then n pairs of data items follow)\n    MAP_8, // 0xb8\n    // map (two-byte uint16_t for n, and then n pairs of data items follow)\n    MAP_16, // 0xb9\n    // map (four-byte uint32_t for n, and then n pairs of data items follow)\n    MAP_32, // 0xba\n    // map (eight-byte uint64_t for n, and then n pairs of data items follow)\n    MAP_64, // 0xbb\n    ERROR, // 0xbc\n    ERROR, // 0xbd\n    ERROR, // 0xbe\n    // map, pairs of data items follow, terminated by \"break\"\n    MAP_BREAK, // 0xbf\n    // Text-based date/time (data item follows; see Section 2.4.1)\n    TAG_KNOWN, // 0xc0\n    // Epoch-based date/time (data item follows; see Section 2.4.1)\n    TAG_KNOWN, // 0xc1\n    // Positive bignum (data item \"byte string\" follows)\n    TAG_KNOWN, // 0xc2\n    // Negative bignum (data item \"byte string\" follows)\n    TAG_KNOWN, // 0xc3\n    // Decimal Fraction (data item \"array\" follows; see Section 2.4.3)\n    TAG_KNOWN, // 0xc4\n    // Bigfloat (data item \"array\" follows; see Section 2.4.3)\n    TAG_KNOWN, // 0xc5\n    // (tagged item)\n    TAG_UNASSIGNED, // 0xc6\n    TAG_UNASSIGNED, // 0xc7\n    TAG_UNASSIGNED, // 0xc8\n    TAG_UNASSIGNED, // 0xc9\n    TAG_UNASSIGNED, // 0xca\n    TAG_UNASSIGNED, // 0xcb\n    TAG_UNASSIGNED, // 0xcc\n    TAG_UNASSIGNED, // 0xcd\n    TAG_UNASSIGNED, // 0xce\n    TAG_UNASSIGNED, // 0xcf\n    TAG_UNASSIGNED, // 0xd0\n    TAG_UNASSIGNED, // 0xd1\n    TAG_UNASSIGNED, // 0xd2\n    TAG_UNASSIGNED, // 0xd3\n    TAG_UNASSIGNED, // 0xd4\n    // Expected Conversion (data item follows; see Section 2.4.4.2)\n    TAG_UNASSIGNED, // 0xd5\n    TAG_UNASSIGNED, // 0xd6\n    TAG_UNASSIGNED, // 0xd7\n    // (more tagged items, 1/2/4/8 bytes and then a data item follow)\n    TAG_MORE_1, // 0xd8\n    TAG_MORE_2, // 0xd9\n    TAG_MORE_4, // 0xda\n    TAG_MORE_8, // 0xdb\n    ERROR, // 0xdc\n    ERROR, // 0xdd\n    ERROR, // 0xde\n    ERROR, // 0xdf\n    // (simple value)\n    SIMPLE_UNASSIGNED, // 0xe0\n    SIMPLE_UNASSIGNED, // 0xe1\n    SIMPLE_UNASSIGNED, // 0xe2\n    SIMPLE_UNASSIGNED, // 0xe3\n    SIMPLE_UNASSIGNED, // 0xe4\n    SIMPLE_UNASSIGNED, // 0xe5\n    SIMPLE_UNASSIGNED, // 0xe6\n    SIMPLE_UNASSIGNED, // 0xe7\n    SIMPLE_UNASSIGNED, // 0xe8\n    SIMPLE_UNASSIGNED, // 0xe9\n    SIMPLE_UNASSIGNED, // 0xea\n    SIMPLE_UNASSIGNED, // 0xeb\n    SIMPLE_UNASSIGNED, // 0xec\n    SIMPLE_UNASSIGNED, // 0xed\n    SIMPLE_UNASSIGNED, // 0xee\n    SIMPLE_UNASSIGNED, // 0xef\n    SIMPLE_UNASSIGNED, // 0xf0\n    SIMPLE_UNASSIGNED, // 0xf1\n    SIMPLE_UNASSIGNED, // 0xf2\n    SIMPLE_UNASSIGNED, // 0xf3\n    // False\n    SIMPLE_FALSE, // 0xf4\n    // True\n    SIMPLE_TRUE, // 0xf5\n    // Null\n    SIMPLE_NULL, // 0xf6\n    // Undefined\n    SIMPLE_UNDEFINED, // 0xf7\n    // (simple value, one byte follows)\n    SIMPLE_BYTE, // 0xf8\n    // Half-Precision Float (two-byte IEEE 754)\n    SIMPLE_FLOAT_HALF, // 0xf9\n    // Single-Precision Float (four-byte IEEE 754)\n    SIMPLE_FLOAT_SINGLE, // 0xfa\n    // Double-Precision Float (eight-byte IEEE 754)\n    SIMPLE_FLOAT_DOUBLE, // 0xfb\n    ERROR, // 0xfc\n    ERROR, // 0xfd\n    ERROR, // 0xfe\n    // \"break\" stop code\n    BREAK // 0xff\n  ]\n\n  // --\n\n  return {\n    parse: parse\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RlY29kZXIuYXNtLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RlY29kZXIuYXNtLmpzPzE3MTciXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWNvZGVBc20gKHN0ZGxpYiwgZm9yZWlnbiwgYnVmZmVyKSB7XG4gICd1c2UgYXNtJ1xuXG4gIC8vIC0tIEltcG9ydHNcblxuICB2YXIgaGVhcCA9IG5ldyBzdGRsaWIuVWludDhBcnJheShidWZmZXIpXG4gIC8vIHZhciBsb2cgPSBmb3JlaWduLmxvZ1xuICB2YXIgcHVzaEludCA9IGZvcmVpZ24ucHVzaEludFxuICB2YXIgcHVzaEludDMyID0gZm9yZWlnbi5wdXNoSW50MzJcbiAgdmFyIHB1c2hJbnQzMk5lZyA9IGZvcmVpZ24ucHVzaEludDMyTmVnXG4gIHZhciBwdXNoSW50NjQgPSBmb3JlaWduLnB1c2hJbnQ2NFxuICB2YXIgcHVzaEludDY0TmVnID0gZm9yZWlnbi5wdXNoSW50NjROZWdcbiAgdmFyIHB1c2hGbG9hdCA9IGZvcmVpZ24ucHVzaEZsb2F0XG4gIHZhciBwdXNoRmxvYXRTaW5nbGUgPSBmb3JlaWduLnB1c2hGbG9hdFNpbmdsZVxuICB2YXIgcHVzaEZsb2F0RG91YmxlID0gZm9yZWlnbi5wdXNoRmxvYXREb3VibGVcbiAgdmFyIHB1c2hUcnVlID0gZm9yZWlnbi5wdXNoVHJ1ZVxuICB2YXIgcHVzaEZhbHNlID0gZm9yZWlnbi5wdXNoRmFsc2VcbiAgdmFyIHB1c2hVbmRlZmluZWQgPSBmb3JlaWduLnB1c2hVbmRlZmluZWRcbiAgdmFyIHB1c2hOdWxsID0gZm9yZWlnbi5wdXNoTnVsbFxuICB2YXIgcHVzaEluZmluaXR5ID0gZm9yZWlnbi5wdXNoSW5maW5pdHlcbiAgdmFyIHB1c2hJbmZpbml0eU5lZyA9IGZvcmVpZ24ucHVzaEluZmluaXR5TmVnXG4gIHZhciBwdXNoTmFOID0gZm9yZWlnbi5wdXNoTmFOXG4gIHZhciBwdXNoTmFOTmVnID0gZm9yZWlnbi5wdXNoTmFOTmVnXG5cbiAgdmFyIHB1c2hBcnJheVN0YXJ0ID0gZm9yZWlnbi5wdXNoQXJyYXlTdGFydFxuICB2YXIgcHVzaEFycmF5U3RhcnRGaXhlZCA9IGZvcmVpZ24ucHVzaEFycmF5U3RhcnRGaXhlZFxuICB2YXIgcHVzaEFycmF5U3RhcnRGaXhlZDMyID0gZm9yZWlnbi5wdXNoQXJyYXlTdGFydEZpeGVkMzJcbiAgdmFyIHB1c2hBcnJheVN0YXJ0Rml4ZWQ2NCA9IGZvcmVpZ24ucHVzaEFycmF5U3RhcnRGaXhlZDY0XG4gIHZhciBwdXNoT2JqZWN0U3RhcnQgPSBmb3JlaWduLnB1c2hPYmplY3RTdGFydFxuICB2YXIgcHVzaE9iamVjdFN0YXJ0Rml4ZWQgPSBmb3JlaWduLnB1c2hPYmplY3RTdGFydEZpeGVkXG4gIHZhciBwdXNoT2JqZWN0U3RhcnRGaXhlZDMyID0gZm9yZWlnbi5wdXNoT2JqZWN0U3RhcnRGaXhlZDMyXG4gIHZhciBwdXNoT2JqZWN0U3RhcnRGaXhlZDY0ID0gZm9yZWlnbi5wdXNoT2JqZWN0U3RhcnRGaXhlZDY0XG5cbiAgdmFyIHB1c2hCeXRlU3RyaW5nID0gZm9yZWlnbi5wdXNoQnl0ZVN0cmluZ1xuICB2YXIgcHVzaEJ5dGVTdHJpbmdTdGFydCA9IGZvcmVpZ24ucHVzaEJ5dGVTdHJpbmdTdGFydFxuICB2YXIgcHVzaFV0ZjhTdHJpbmcgPSBmb3JlaWduLnB1c2hVdGY4U3RyaW5nXG4gIHZhciBwdXNoVXRmOFN0cmluZ1N0YXJ0ID0gZm9yZWlnbi5wdXNoVXRmOFN0cmluZ1N0YXJ0XG5cbiAgdmFyIHB1c2hTaW1wbGVVbmFzc2lnbmVkID0gZm9yZWlnbi5wdXNoU2ltcGxlVW5hc3NpZ25lZFxuXG4gIHZhciBwdXNoVGFnU3RhcnQgPSBmb3JlaWduLnB1c2hUYWdTdGFydFxuICB2YXIgcHVzaFRhZ1N0YXJ0NCA9IGZvcmVpZ24ucHVzaFRhZ1N0YXJ0NFxuICB2YXIgcHVzaFRhZ1N0YXJ0OCA9IGZvcmVpZ24ucHVzaFRhZ1N0YXJ0OFxuICB2YXIgcHVzaFRhZ1VuYXNzaWduZWQgPSBmb3JlaWduLnB1c2hUYWdVbmFzc2lnbmVkXG5cbiAgdmFyIHB1c2hCcmVhayA9IGZvcmVpZ24ucHVzaEJyZWFrXG5cbiAgdmFyIHBvdyA9IHN0ZGxpYi5NYXRoLnBvd1xuXG4gIC8vIC0tIENvbnN0YW50c1xuXG5cbiAgLy8gLS0gTXV0YWJsZSBWYXJpYWJsZXNcblxuICB2YXIgb2Zmc2V0ID0gMFxuICB2YXIgaW5wdXRMZW5ndGggPSAwXG4gIHZhciBjb2RlID0gMFxuXG4gIC8vIERlY29kZSBhIGNib3Igc3RyaW5nIHJlcHJlc2VudGVkIGFzIFVpbnQ4QXJyYXlcbiAgLy8gd2hpY2ggaXMgYWxsb2NhdGVkIG9uIHRoZSBoZWFwIGZyb20gMCB0byBpbnB1dExlbmd0aFxuICAvL1xuICAvLyBpbnB1dCAtIEludFxuICAvL1xuICAvLyBSZXR1cm5zIENvZGUgLSBJbnQsXG4gIC8vIFN1Y2Nlc3MgPSAwXG4gIC8vIEVycm9yID4gMFxuICBmdW5jdGlvbiBwYXJzZSAoaW5wdXQpIHtcbiAgICBpbnB1dCA9IGlucHV0IHwgMFxuXG4gICAgb2Zmc2V0ID0gMFxuICAgIGlucHV0TGVuZ3RoID0gaW5wdXRcblxuICAgIHdoaWxlICgob2Zmc2V0IHwgMCkgPCAoaW5wdXRMZW5ndGggfCAwKSkge1xuICAgICAgY29kZSA9IGp1bXBUYWJsZVtoZWFwW29mZnNldF0gJiAyNTVdKGhlYXBbb2Zmc2V0XSB8IDApIHwgMFxuXG4gICAgICBpZiAoKGNvZGUgfCAwKSA+IDApIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29kZSB8IDBcbiAgfVxuXG4gIC8vIC0tIEhlbHBlciBGdW5jdGlvblxuXG4gIGZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChuKSB7XG4gICAgbiA9IG4gfCAwXG5cbiAgICBpZiAoKCgob2Zmc2V0IHwgMCkgKyAobiB8IDApKSB8IDApIDwgKGlucHV0TGVuZ3RoIHwgMCkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRVSW50MTYgKG4pIHtcbiAgICBuID0gbiB8IDBcblxuICAgIHJldHVybiAoXG4gICAgICAoaGVhcFtuIHwgMF0gPDwgOCkgfCBoZWFwWyhuICsgMSkgfCAwXVxuICAgICkgfCAwXG4gIH1cblxuICBmdW5jdGlvbiByZWFkVUludDMyIChuKSB7XG4gICAgbiA9IG4gfCAwXG5cbiAgICByZXR1cm4gKFxuICAgICAgKGhlYXBbbiB8IDBdIDw8IDI0KSB8IChoZWFwWyhuICsgMSkgfCAwXSA8PCAxNikgfCAoaGVhcFsobiArIDIpIHwgMF0gPDwgOCkgfCBoZWFwWyhuICsgMykgfCAwXVxuICAgICkgfCAwXG4gIH1cblxuICAvLyAtLSBJbml0aWFsIEJ5dGUgSGFuZGxlcnNcblxuICBmdW5jdGlvbiBJTlRfUCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEludChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVUlOVF9QXzggKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludChoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAyKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX1BfMTYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEludChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDMpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVJTlRfUF8zMiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDQpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoSW50MzIoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDUpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVJTlRfUF82NCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDgpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoSW50NjQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA3KSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA5KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBJTlRfTiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaEludCgoLTEgLSAoKG9jdGV0IC0gMzIpIHwgMCkpIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVSU5UX05fOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoSW50KFxuICAgICAgKC0xIC0gKGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwKSkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDIpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVJTlRfTl8xNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHZhbCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgdmFsID0gcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICBwdXNoSW50KCgtMSAtICh2YWwgfCAwKSkgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDMpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVJTlRfTl8zMiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDQpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoSW50MzJOZWcoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDUpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVJTlRfTl82NCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDgpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoSW50NjROZWcoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA3KSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA5KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBCWVRFX1NUUklORyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIHN0ZXAgPSAwXG5cbiAgICBzdGVwID0gKG9jdGV0IC0gNjQpIHwgMFxuICAgIGlmIChjaGVja09mZnNldChzdGVwIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDEpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDEpIHwgMCkgKyAoc3RlcCB8IDApKSB8IDBcblxuICAgIHB1c2hCeXRlU3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBCWVRFX1NUUklOR184IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZW5ndGggPSBoZWFwWyhvZmZzZXQgKyAxKSB8IDBdIHwgMFxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDIpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDIpIHwgMCkgKyAobGVuZ3RoIHwgMCkpIHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KChsZW5ndGggKyAxKSB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoQnl0ZVN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQllURV9TVFJJTkdfMTYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGxlbmd0aCA9IHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgMykgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgMykgfCAwKSArIChsZW5ndGggfCAwKSkgfCAwXG5cblxuICAgIGlmIChjaGVja09mZnNldCgobGVuZ3RoICsgMikgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEJ5dGVTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEJZVEVfU1RSSU5HXzMyIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDQpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZW5ndGggPSByZWFkVUludDMyKChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDUpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDUpIHwgMCkgKyAobGVuZ3RoIHwgMCkpIHwgMFxuXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoKGxlbmd0aCArIDQpIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hCeXRlU3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBCWVRFX1NUUklOR182NCAob2N0ZXQpIHtcbiAgICAvLyBOT1QgSU1QTEVNRU5URURcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIGZ1bmN0aW9uIEJZVEVfU1RSSU5HX0JSRUFLIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoQnl0ZVN0cmluZ1N0YXJ0KClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVVEY4X1NUUklORyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIHN0ZXAgPSAwXG5cbiAgICBzdGVwID0gKG9jdGV0IC0gOTYpIHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KHN0ZXAgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgMSkgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgMSkgfCAwKSArIChzdGVwIHwgMCkpIHwgMFxuXG4gICAgcHVzaFV0ZjhTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVURjhfU1RSSU5HXzggKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHZhciBzdGFydCA9IDBcbiAgICB2YXIgZW5kID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGxlbmd0aCA9IGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwXG4gICAgc3RhcnQgPSAob2Zmc2V0ICsgMikgfCAwXG4gICAgZW5kID0gKCgob2Zmc2V0ICsgMikgfCAwKSArIChsZW5ndGggfCAwKSkgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoKGxlbmd0aCArIDEpIHwgMCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hVdGY4U3RyaW5nKHN0YXJ0IHwgMCwgZW5kIHwgMClcblxuICAgIG9mZnNldCA9IGVuZCB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBVVEY4X1NUUklOR18xNiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIHN0YXJ0ID0gMFxuICAgIHZhciBlbmQgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGVuZ3RoID0gcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICBzdGFydCA9IChvZmZzZXQgKyAzKSB8IDBcbiAgICBlbmQgPSAoKChvZmZzZXQgKyAzKSB8IDApICsgKGxlbmd0aCB8IDApKSB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgobGVuZ3RoICsgMikgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFV0ZjhTdHJpbmcoc3RhcnQgfCAwLCBlbmQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gZW5kIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFVURjhfU1RSSU5HXzMyIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RhcnQgPSAwXG4gICAgdmFyIGVuZCA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDQpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZW5ndGggPSByZWFkVUludDMyKChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIHN0YXJ0ID0gKG9mZnNldCArIDUpIHwgMFxuICAgIGVuZCA9ICgoKG9mZnNldCArIDUpIHwgMCkgKyAobGVuZ3RoIHwgMCkpIHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KChsZW5ndGggKyA0KSB8IDApIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoVXRmOFN0cmluZyhzdGFydCB8IDAsIGVuZCB8IDApXG5cbiAgICBvZmZzZXQgPSBlbmQgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVVRGOF9TVFJJTkdfNjQgKG9jdGV0KSB7XG4gICAgLy8gTk9UIElNUExFTUVOVEVEXG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHJldHVybiAxXG4gIH1cblxuICBmdW5jdGlvbiBVVEY4X1NUUklOR19CUkVBSyAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFV0ZjhTdHJpbmdTdGFydCgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQVJSQVkgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hBcnJheVN0YXJ0Rml4ZWQoKG9jdGV0IC0gMTI4KSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gQVJSQVlfOCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoQXJyYXlTdGFydEZpeGVkKGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDIpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEFSUkFZXzE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hBcnJheVN0YXJ0Rml4ZWQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAzKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBBUlJBWV8zMiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDQpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoQXJyYXlTdGFydEZpeGVkMzIoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDUpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEFSUkFZXzY0IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoOCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hBcnJheVN0YXJ0Rml4ZWQ2NChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA1KSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDcpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDkpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIEFSUkFZX0JSRUFLIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoQXJyYXlTdGFydCgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gTUFQIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICB2YXIgc3RlcCA9IDBcblxuICAgIHN0ZXAgPSAob2N0ZXQgLSAxNjApIHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KHN0ZXAgfCAwKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQoc3RlcCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gTUFQXzggKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCgxKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQoaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMikgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gTUFQXzE2IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMikgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hPYmplY3RTdGFydEZpeGVkKFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMykgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gTUFQXzMyIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hPYmplY3RTdGFydEZpeGVkMzIoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDUpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIE1BUF82NCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDgpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZDY0KFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMSkgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAzKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDUpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgNykgfCAwKSB8IDBcbiAgICApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgOSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gTUFQX0JSRUFLIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoT2JqZWN0U3RhcnQoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19LTk9XTiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KChvY3RldCAtIDE5MnwgMCkgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19CSUdOVU1fUE9TIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19CSUdOVU1fTkVHIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19GUkFDIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19CSUdOVU1fRkxPQVQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX1VOQVNTSUdORUQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydCgob2N0ZXQgLSAxOTJ8IDApIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfQkFTRTY0X1VSTCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaFRhZ1N0YXJ0KG9jdGV0IHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfQkFTRTY0IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoVGFnU3RhcnQob2N0ZXQgfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19CQVNFMTYgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUYWdTdGFydChvY3RldCB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX01PUkVfMSAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDEpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoVGFnU3RhcnQoaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDApXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMiB8IDApXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gVEFHX01PUkVfMiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgaWYgKGNoZWNrT2Zmc2V0KDIpIHwgMCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBwdXNoVGFnU3RhcnQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAzIHwgMClcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBUQUdfTU9SRV80IChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hUYWdTdGFydDQoXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyAxKSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDMpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDUgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFRBR19NT1JFXzggKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg4KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaFRhZ1N0YXJ0OChcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDEpIHwgMCkgfCAwLFxuICAgICAgcmVhZFVJbnQxNigob2Zmc2V0ICsgMykgfCAwKSB8IDAsXG4gICAgICByZWFkVUludDE2KChvZmZzZXQgKyA1KSB8IDApIHwgMCxcbiAgICAgIHJlYWRVSW50MTYoKG9mZnNldCArIDcpIHwgMCkgfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDkgfCAwKVxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9VTkFTU0lHTkVEIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoU2ltcGxlVW5hc3NpZ25lZCgoKG9jdGV0IHwgMCkgLSAyMjQpIHwgMClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfRkFMU0UgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hGYWxzZSgpXG5cbiAgICBvZmZzZXQgPSAob2Zmc2V0ICsgMSkgfCAwXG5cbiAgICByZXR1cm4gMFxuICB9XG5cbiAgZnVuY3Rpb24gU0lNUExFX1RSVUUgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hUcnVlKClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAxKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfTlVMTCAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcHVzaE51bGwoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9VTkRFRklORUQgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIHB1c2hVbmRlZmluZWQoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9CWVRFIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoMSkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hTaW1wbGVVbmFzc2lnbmVkKGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDIpICB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfRkxPQVRfSEFMRiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgdmFyIGYgPSAwXG4gICAgdmFyIGcgPSAwXG4gICAgdmFyIHNpZ24gPSAxLjBcbiAgICB2YXIgZXhwID0gMC4wXG4gICAgdmFyIG1hbnQgPSAwLjBcbiAgICB2YXIgciA9IDAuMFxuICAgIGlmIChjaGVja09mZnNldCgyKSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgZiA9IGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwXG4gICAgZyA9IGhlYXBbKG9mZnNldCArIDIpIHwgMF0gfCAwXG5cbiAgICBpZiAoKGYgfCAwKSAmIDB4ODApIHtcbiAgICAgIHNpZ24gPSAtMS4wXG4gICAgfVxuXG4gICAgZXhwID0gKygoKGYgfCAwKSAmIDB4N0MpID4+IDIpXG4gICAgbWFudCA9ICsoKCgoZiB8IDApICYgMHgwMykgPDwgOCkgfCBnKVxuXG4gICAgaWYgKCtleHAgPT0gMC4wKSB7XG4gICAgICBwdXNoRmxvYXQoKyhcbiAgICAgICAgKCtzaWduKSAqICs1Ljk2MDQ2NDQ3NzUzOTA2MjVlLTggKiAoK21hbnQpXG4gICAgICApKVxuICAgIH0gZWxzZSBpZiAoK2V4cCA9PSAzMS4wKSB7XG4gICAgICBpZiAoK3NpZ24gPT0gMS4wKSB7XG4gICAgICAgIGlmICgrbWFudCA+IDAuMCkge1xuICAgICAgICAgIHB1c2hOYU4oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1c2hJbmZpbml0eSgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgrbWFudCA+IDAuMCkge1xuICAgICAgICAgIHB1c2hOYU5OZWcoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1c2hJbmZpbml0eU5lZygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaEZsb2F0KCsoXG4gICAgICAgICtzaWduICogcG93KCsyLCArKCtleHAgLSAyNS4wKSkgKiArKDEwMjQuMCArIG1hbnQpXG4gICAgICApKVxuICAgIH1cblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyAzKSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBTSU1QTEVfRkxPQVRfU0lOR0xFIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBpZiAoY2hlY2tPZmZzZXQoNCkgfCAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHB1c2hGbG9hdFNpbmdsZShcbiAgICAgIGhlYXBbKG9mZnNldCArIDEpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgMikgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyAzKSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDQpIHwgMF0gfCAwXG4gICAgKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDUpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGZ1bmN0aW9uIFNJTVBMRV9GTE9BVF9ET1VCTEUgKG9jdGV0KSB7XG4gICAgb2N0ZXQgPSBvY3RldCB8IDBcblxuICAgIGlmIChjaGVja09mZnNldCg4KSB8IDApIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgcHVzaEZsb2F0RG91YmxlKFxuICAgICAgaGVhcFsob2Zmc2V0ICsgMSkgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyAyKSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDMpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgNCkgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyA1KSB8IDBdIHwgMCxcbiAgICAgIGhlYXBbKG9mZnNldCArIDYpIHwgMF0gfCAwLFxuICAgICAgaGVhcFsob2Zmc2V0ICsgNykgfCAwXSB8IDAsXG4gICAgICBoZWFwWyhvZmZzZXQgKyA4KSB8IDBdIHwgMFxuICAgIClcblxuICAgIG9mZnNldCA9IChvZmZzZXQgKyA5KSB8IDBcblxuICAgIHJldHVybiAwXG4gIH1cblxuICBmdW5jdGlvbiBFUlJPUiAob2N0ZXQpIHtcbiAgICBvY3RldCA9IG9jdGV0IHwgMFxuXG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIGZ1bmN0aW9uIEJSRUFLIChvY3RldCkge1xuICAgIG9jdGV0ID0gb2N0ZXQgfCAwXG5cbiAgICBwdXNoQnJlYWsoKVxuXG4gICAgb2Zmc2V0ID0gKG9mZnNldCArIDEpIHwgMFxuXG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIC0tIEp1bXAgVGFibGVcblxuICB2YXIganVtcFRhYmxlID0gW1xuICAgIC8vIEludGVnZXIgMHgwMC4uMHgxNyAoMC4uMjMpXG4gICAgSU5UX1AsIC8vIDB4MDBcbiAgICBJTlRfUCwgLy8gMHgwMVxuICAgIElOVF9QLCAvLyAweDAyXG4gICAgSU5UX1AsIC8vIDB4MDNcbiAgICBJTlRfUCwgLy8gMHgwNFxuICAgIElOVF9QLCAvLyAweDA1XG4gICAgSU5UX1AsIC8vIDB4MDZcbiAgICBJTlRfUCwgLy8gMHgwN1xuICAgIElOVF9QLCAvLyAweDA4XG4gICAgSU5UX1AsIC8vIDB4MDlcbiAgICBJTlRfUCwgLy8gMHgwQVxuICAgIElOVF9QLCAvLyAweDBCXG4gICAgSU5UX1AsIC8vIDB4MENcbiAgICBJTlRfUCwgLy8gMHgwRFxuICAgIElOVF9QLCAvLyAweDBFXG4gICAgSU5UX1AsIC8vIDB4MEZcbiAgICBJTlRfUCwgLy8gMHgxMFxuICAgIElOVF9QLCAvLyAweDExXG4gICAgSU5UX1AsIC8vIDB4MTJcbiAgICBJTlRfUCwgLy8gMHgxM1xuICAgIElOVF9QLCAvLyAweDE0XG4gICAgSU5UX1AsIC8vIDB4MTVcbiAgICBJTlRfUCwgLy8gMHgxNlxuICAgIElOVF9QLCAvLyAweDE3XG4gICAgLy8gVW5zaWduZWQgaW50ZWdlciAob25lLWJ5dGUgdWludDhfdCBmb2xsb3dzKVxuICAgIFVJTlRfUF84LCAvLyAweDE4XG4gICAgLy8gVW5zaWduZWQgaW50ZWdlciAodHdvLWJ5dGUgdWludDE2X3QgZm9sbG93cylcbiAgICBVSU5UX1BfMTYsIC8vIDB4MTlcbiAgICAvLyBVbnNpZ25lZCBpbnRlZ2VyIChmb3VyLWJ5dGUgdWludDMyX3QgZm9sbG93cylcbiAgICBVSU5UX1BfMzIsIC8vIDB4MWFcbiAgICAvLyBVbnNpZ25lZCBpbnRlZ2VyIChlaWdodC1ieXRlIHVpbnQ2NF90IGZvbGxvd3MpXG4gICAgVUlOVF9QXzY0LCAvLyAweDFiXG4gICAgRVJST1IsIC8vIDB4MWNcbiAgICBFUlJPUiwgLy8gMHgxZFxuICAgIEVSUk9SLCAvLyAweDFlXG4gICAgRVJST1IsIC8vIDB4MWZcbiAgICAvLyBOZWdhdGl2ZSBpbnRlZ2VyIC0xLTB4MDAuLi0xLTB4MTcgKC0xLi4tMjQpXG4gICAgSU5UX04sIC8vIDB4MjBcbiAgICBJTlRfTiwgLy8gMHgyMVxuICAgIElOVF9OLCAvLyAweDIyXG4gICAgSU5UX04sIC8vIDB4MjNcbiAgICBJTlRfTiwgLy8gMHgyNFxuICAgIElOVF9OLCAvLyAweDI1XG4gICAgSU5UX04sIC8vIDB4MjZcbiAgICBJTlRfTiwgLy8gMHgyN1xuICAgIElOVF9OLCAvLyAweDI4XG4gICAgSU5UX04sIC8vIDB4MjlcbiAgICBJTlRfTiwgLy8gMHgyQVxuICAgIElOVF9OLCAvLyAweDJCXG4gICAgSU5UX04sIC8vIDB4MkNcbiAgICBJTlRfTiwgLy8gMHgyRFxuICAgIElOVF9OLCAvLyAweDJFXG4gICAgSU5UX04sIC8vIDB4MkZcbiAgICBJTlRfTiwgLy8gMHgzMFxuICAgIElOVF9OLCAvLyAweDMxXG4gICAgSU5UX04sIC8vIDB4MzJcbiAgICBJTlRfTiwgLy8gMHgzM1xuICAgIElOVF9OLCAvLyAweDM0XG4gICAgSU5UX04sIC8vIDB4MzVcbiAgICBJTlRfTiwgLy8gMHgzNlxuICAgIElOVF9OLCAvLyAweDM3XG4gICAgLy8gTmVnYXRpdmUgaW50ZWdlciAtMS1uIChvbmUtYnl0ZSB1aW50OF90IGZvciBuIGZvbGxvd3MpXG4gICAgVUlOVF9OXzgsIC8vIDB4MzhcbiAgICAvLyBOZWdhdGl2ZSBpbnRlZ2VyIC0xLW4gKHR3by1ieXRlIHVpbnQxNl90IGZvciBuIGZvbGxvd3MpXG4gICAgVUlOVF9OXzE2LCAvLyAweDM5XG4gICAgLy8gTmVnYXRpdmUgaW50ZWdlciAtMS1uIChmb3VyLWJ5dGUgdWludDMyX3QgZm9yIG5mb2xsb3dzKVxuICAgIFVJTlRfTl8zMiwgLy8gMHgzYVxuICAgIC8vIE5lZ2F0aXZlIGludGVnZXIgLTEtbiAoZWlnaHQtYnl0ZSB1aW50NjRfdCBmb3IgbiBmb2xsb3dzKVxuICAgIFVJTlRfTl82NCwgLy8gMHgzYlxuICAgIEVSUk9SLCAvLyAweDNjXG4gICAgRVJST1IsIC8vIDB4M2RcbiAgICBFUlJPUiwgLy8gMHgzZVxuICAgIEVSUk9SLCAvLyAweDNmXG4gICAgLy8gYnl0ZSBzdHJpbmcgKDB4MDAuLjB4MTcgYnl0ZXMgZm9sbG93KVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQwXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDFcbiAgICBCWVRFX1NUUklORywgLy8gMHg0MlxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQzXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDRcbiAgICBCWVRFX1NUUklORywgLy8gMHg0NVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQ2XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NDdcbiAgICBCWVRFX1NUUklORywgLy8gMHg0OFxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDQ5XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NEFcbiAgICBCWVRFX1NUUklORywgLy8gMHg0QlxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDRDXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NERcbiAgICBCWVRFX1NUUklORywgLy8gMHg0RVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDRGXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTBcbiAgICBCWVRFX1NUUklORywgLy8gMHg1MVxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDUyXG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTNcbiAgICBCWVRFX1NUUklORywgLy8gMHg1NFxuICAgIEJZVEVfU1RSSU5HLCAvLyAweDU1XG4gICAgQllURV9TVFJJTkcsIC8vIDB4NTZcbiAgICBCWVRFX1NUUklORywgLy8gMHg1N1xuICAgIC8vIGJ5dGUgc3RyaW5nIChvbmUtYnl0ZSB1aW50OF90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBCWVRFX1NUUklOR184LCAvLyAweDU4XG4gICAgLy8gYnl0ZSBzdHJpbmcgKHR3by1ieXRlIHVpbnQxNl90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBCWVRFX1NUUklOR18xNiwgLy8gMHg1OVxuICAgIC8vIGJ5dGUgc3RyaW5nIChmb3VyLWJ5dGUgdWludDMyX3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIEJZVEVfU1RSSU5HXzMyLCAvLyAweDVhXG4gICAgLy8gYnl0ZSBzdHJpbmcgKGVpZ2h0LWJ5dGUgdWludDY0X3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIEJZVEVfU1RSSU5HXzY0LCAvLyAweDViXG4gICAgRVJST1IsIC8vIDB4NWNcbiAgICBFUlJPUiwgLy8gMHg1ZFxuICAgIEVSUk9SLCAvLyAweDVlXG4gICAgLy8gYnl0ZSBzdHJpbmcsIGJ5dGUgc3RyaW5ncyBmb2xsb3csIHRlcm1pbmF0ZWQgYnkgXCJicmVha1wiXG4gICAgQllURV9TVFJJTkdfQlJFQUssIC8vIDB4NWZcbiAgICAvLyBVVEYtOCBzdHJpbmcgKDB4MDAuLjB4MTcgYnl0ZXMgZm9sbG93KVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDYwXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjFcbiAgICBVVEY4X1NUUklORywgLy8gMHg2MlxuICAgIFVURjhfU1RSSU5HLCAvLyAweDYzXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjRcbiAgICBVVEY4X1NUUklORywgLy8gMHg2NVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDY2XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NjdcbiAgICBVVEY4X1NUUklORywgLy8gMHg2OFxuICAgIFVURjhfU1RSSU5HLCAvLyAweDY5XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NkFcbiAgICBVVEY4X1NUUklORywgLy8gMHg2QlxuICAgIFVURjhfU1RSSU5HLCAvLyAweDZDXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NkRcbiAgICBVVEY4X1NUUklORywgLy8gMHg2RVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDZGXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzBcbiAgICBVVEY4X1NUUklORywgLy8gMHg3MVxuICAgIFVURjhfU1RSSU5HLCAvLyAweDcyXG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzNcbiAgICBVVEY4X1NUUklORywgLy8gMHg3NFxuICAgIFVURjhfU1RSSU5HLCAvLyAweDc1XG4gICAgVVRGOF9TVFJJTkcsIC8vIDB4NzZcbiAgICBVVEY4X1NUUklORywgLy8gMHg3N1xuICAgIC8vIFVURi04IHN0cmluZyAob25lLWJ5dGUgdWludDhfdCBmb3IgbiwgYW5kIHRoZW4gbiBieXRlcyBmb2xsb3cpXG4gICAgVVRGOF9TVFJJTkdfOCwgLy8gMHg3OFxuICAgIC8vIFVURi04IHN0cmluZyAodHdvLWJ5dGUgdWludDE2X3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIFVURjhfU1RSSU5HXzE2LCAvLyAweDc5XG4gICAgLy8gVVRGLTggc3RyaW5nIChmb3VyLWJ5dGUgdWludDMyX3QgZm9yIG4sIGFuZCB0aGVuIG4gYnl0ZXMgZm9sbG93KVxuICAgIFVURjhfU1RSSU5HXzMyLCAvLyAweDdhXG4gICAgLy8gVVRGLTggc3RyaW5nIChlaWdodC1ieXRlIHVpbnQ2NF90IGZvciBuLCBhbmQgdGhlbiBuIGJ5dGVzIGZvbGxvdylcbiAgICBVVEY4X1NUUklOR182NCwgLy8gMHg3YlxuICAgIC8vIFVURi04IHN0cmluZywgVVRGLTggc3RyaW5ncyBmb2xsb3csIHRlcm1pbmF0ZWQgYnkgXCJicmVha1wiXG4gICAgRVJST1IsIC8vIDB4N2NcbiAgICBFUlJPUiwgLy8gMHg3ZFxuICAgIEVSUk9SLCAvLyAweDdlXG4gICAgVVRGOF9TVFJJTkdfQlJFQUssIC8vIDB4N2ZcbiAgICAvLyBhcnJheSAoMHgwMC4uMHgxNyBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBBUlJBWSwgLy8gMHg4MFxuICAgIEFSUkFZLCAvLyAweDgxXG4gICAgQVJSQVksIC8vIDB4ODJcbiAgICBBUlJBWSwgLy8gMHg4M1xuICAgIEFSUkFZLCAvLyAweDg0XG4gICAgQVJSQVksIC8vIDB4ODVcbiAgICBBUlJBWSwgLy8gMHg4NlxuICAgIEFSUkFZLCAvLyAweDg3XG4gICAgQVJSQVksIC8vIDB4ODhcbiAgICBBUlJBWSwgLy8gMHg4OVxuICAgIEFSUkFZLCAvLyAweDhBXG4gICAgQVJSQVksIC8vIDB4OEJcbiAgICBBUlJBWSwgLy8gMHg4Q1xuICAgIEFSUkFZLCAvLyAweDhEXG4gICAgQVJSQVksIC8vIDB4OEVcbiAgICBBUlJBWSwgLy8gMHg4RlxuICAgIEFSUkFZLCAvLyAweDkwXG4gICAgQVJSQVksIC8vIDB4OTFcbiAgICBBUlJBWSwgLy8gMHg5MlxuICAgIEFSUkFZLCAvLyAweDkzXG4gICAgQVJSQVksIC8vIDB4OTRcbiAgICBBUlJBWSwgLy8gMHg5NVxuICAgIEFSUkFZLCAvLyAweDk2XG4gICAgQVJSQVksIC8vIDB4OTdcbiAgICAvLyBhcnJheSAob25lLWJ5dGUgdWludDhfdCBmbywgYW5kIHRoZW4gbiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBBUlJBWV84LCAvLyAweDk4XG4gICAgLy8gYXJyYXkgKHR3by1ieXRlIHVpbnQxNl90IGZvciBuLCBhbmQgdGhlbiBuIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIEFSUkFZXzE2LCAvLyAweDk5XG4gICAgLy8gYXJyYXkgKGZvdXItYnl0ZSB1aW50MzJfdCBmb3IgbiwgYW5kIHRoZW4gbiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBBUlJBWV8zMiwgLy8gMHg5YVxuICAgIC8vIGFycmF5IChlaWdodC1ieXRlIHVpbnQ2NF90IGZvciBuLCBhbmQgdGhlbiBuIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIEFSUkFZXzY0LCAvLyAweDliXG4gICAgLy8gYXJyYXksIGRhdGEgaXRlbXMgZm9sbG93LCB0ZXJtaW5hdGVkIGJ5IFwiYnJlYWtcIlxuICAgIEVSUk9SLCAvLyAweDljXG4gICAgRVJST1IsIC8vIDB4OWRcbiAgICBFUlJPUiwgLy8gMHg5ZVxuICAgIEFSUkFZX0JSRUFLLCAvLyAweDlmXG4gICAgLy8gbWFwICgweDAwLi4weDE3IHBhaXJzIG9mIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIE1BUCwgLy8gMHhhMFxuICAgIE1BUCwgLy8gMHhhMVxuICAgIE1BUCwgLy8gMHhhMlxuICAgIE1BUCwgLy8gMHhhM1xuICAgIE1BUCwgLy8gMHhhNFxuICAgIE1BUCwgLy8gMHhhNVxuICAgIE1BUCwgLy8gMHhhNlxuICAgIE1BUCwgLy8gMHhhN1xuICAgIE1BUCwgLy8gMHhhOFxuICAgIE1BUCwgLy8gMHhhOVxuICAgIE1BUCwgLy8gMHhhQVxuICAgIE1BUCwgLy8gMHhhQlxuICAgIE1BUCwgLy8gMHhhQ1xuICAgIE1BUCwgLy8gMHhhRFxuICAgIE1BUCwgLy8gMHhhRVxuICAgIE1BUCwgLy8gMHhhRlxuICAgIE1BUCwgLy8gMHhiMFxuICAgIE1BUCwgLy8gMHhiMVxuICAgIE1BUCwgLy8gMHhiMlxuICAgIE1BUCwgLy8gMHhiM1xuICAgIE1BUCwgLy8gMHhiNFxuICAgIE1BUCwgLy8gMHhiNVxuICAgIE1BUCwgLy8gMHhiNlxuICAgIE1BUCwgLy8gMHhiN1xuICAgIC8vIG1hcCAob25lLWJ5dGUgdWludDhfdCBmb3IgbiwgYW5kIHRoZW4gbiBwYWlycyBvZiBkYXRhIGl0ZW1zIGZvbGxvdylcbiAgICBNQVBfOCwgLy8gMHhiOFxuICAgIC8vIG1hcCAodHdvLWJ5dGUgdWludDE2X3QgZm9yIG4sIGFuZCB0aGVuIG4gcGFpcnMgb2YgZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgTUFQXzE2LCAvLyAweGI5XG4gICAgLy8gbWFwIChmb3VyLWJ5dGUgdWludDMyX3QgZm9yIG4sIGFuZCB0aGVuIG4gcGFpcnMgb2YgZGF0YSBpdGVtcyBmb2xsb3cpXG4gICAgTUFQXzMyLCAvLyAweGJhXG4gICAgLy8gbWFwIChlaWdodC1ieXRlIHVpbnQ2NF90IGZvciBuLCBhbmQgdGhlbiBuIHBhaXJzIG9mIGRhdGEgaXRlbXMgZm9sbG93KVxuICAgIE1BUF82NCwgLy8gMHhiYlxuICAgIEVSUk9SLCAvLyAweGJjXG4gICAgRVJST1IsIC8vIDB4YmRcbiAgICBFUlJPUiwgLy8gMHhiZVxuICAgIC8vIG1hcCwgcGFpcnMgb2YgZGF0YSBpdGVtcyBmb2xsb3csIHRlcm1pbmF0ZWQgYnkgXCJicmVha1wiXG4gICAgTUFQX0JSRUFLLCAvLyAweGJmXG4gICAgLy8gVGV4dC1iYXNlZCBkYXRlL3RpbWUgKGRhdGEgaXRlbSBmb2xsb3dzOyBzZWUgU2VjdGlvbiAyLjQuMSlcbiAgICBUQUdfS05PV04sIC8vIDB4YzBcbiAgICAvLyBFcG9jaC1iYXNlZCBkYXRlL3RpbWUgKGRhdGEgaXRlbSBmb2xsb3dzOyBzZWUgU2VjdGlvbiAyLjQuMSlcbiAgICBUQUdfS05PV04sIC8vIDB4YzFcbiAgICAvLyBQb3NpdGl2ZSBiaWdudW0gKGRhdGEgaXRlbSBcImJ5dGUgc3RyaW5nXCIgZm9sbG93cylcbiAgICBUQUdfS05PV04sIC8vIDB4YzJcbiAgICAvLyBOZWdhdGl2ZSBiaWdudW0gKGRhdGEgaXRlbSBcImJ5dGUgc3RyaW5nXCIgZm9sbG93cylcbiAgICBUQUdfS05PV04sIC8vIDB4YzNcbiAgICAvLyBEZWNpbWFsIEZyYWN0aW9uIChkYXRhIGl0ZW0gXCJhcnJheVwiIGZvbGxvd3M7IHNlZSBTZWN0aW9uIDIuNC4zKVxuICAgIFRBR19LTk9XTiwgLy8gMHhjNFxuICAgIC8vIEJpZ2Zsb2F0IChkYXRhIGl0ZW0gXCJhcnJheVwiIGZvbGxvd3M7IHNlZSBTZWN0aW9uIDIuNC4zKVxuICAgIFRBR19LTk9XTiwgLy8gMHhjNVxuICAgIC8vICh0YWdnZWQgaXRlbSlcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjNlxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGM3XG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4YzhcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjOVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGNhXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4Y2JcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjY1xuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGNkXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4Y2VcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhjZlxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQwXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDFcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkMlxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQzXG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDRcbiAgICAvLyBFeHBlY3RlZCBDb252ZXJzaW9uIChkYXRhIGl0ZW0gZm9sbG93czsgc2VlIFNlY3Rpb24gMi40LjQuMilcbiAgICBUQUdfVU5BU1NJR05FRCwgLy8gMHhkNVxuICAgIFRBR19VTkFTU0lHTkVELCAvLyAweGQ2XG4gICAgVEFHX1VOQVNTSUdORUQsIC8vIDB4ZDdcbiAgICAvLyAobW9yZSB0YWdnZWQgaXRlbXMsIDEvMi80LzggYnl0ZXMgYW5kIHRoZW4gYSBkYXRhIGl0ZW0gZm9sbG93KVxuICAgIFRBR19NT1JFXzEsIC8vIDB4ZDhcbiAgICBUQUdfTU9SRV8yLCAvLyAweGQ5XG4gICAgVEFHX01PUkVfNCwgLy8gMHhkYVxuICAgIFRBR19NT1JFXzgsIC8vIDB4ZGJcbiAgICBFUlJPUiwgLy8gMHhkY1xuICAgIEVSUk9SLCAvLyAweGRkXG4gICAgRVJST1IsIC8vIDB4ZGVcbiAgICBFUlJPUiwgLy8gMHhkZlxuICAgIC8vIChzaW1wbGUgdmFsdWUpXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTBcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlMVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGUyXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTNcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlNFxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGU1XG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTZcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlN1xuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGU4XG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZTlcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlYVxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGViXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZWNcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhlZFxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGVlXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZWZcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhmMFxuICAgIFNJTVBMRV9VTkFTU0lHTkVELCAvLyAweGYxXG4gICAgU0lNUExFX1VOQVNTSUdORUQsIC8vIDB4ZjJcbiAgICBTSU1QTEVfVU5BU1NJR05FRCwgLy8gMHhmM1xuICAgIC8vIEZhbHNlXG4gICAgU0lNUExFX0ZBTFNFLCAvLyAweGY0XG4gICAgLy8gVHJ1ZVxuICAgIFNJTVBMRV9UUlVFLCAvLyAweGY1XG4gICAgLy8gTnVsbFxuICAgIFNJTVBMRV9OVUxMLCAvLyAweGY2XG4gICAgLy8gVW5kZWZpbmVkXG4gICAgU0lNUExFX1VOREVGSU5FRCwgLy8gMHhmN1xuICAgIC8vIChzaW1wbGUgdmFsdWUsIG9uZSBieXRlIGZvbGxvd3MpXG4gICAgU0lNUExFX0JZVEUsIC8vIDB4ZjhcbiAgICAvLyBIYWxmLVByZWNpc2lvbiBGbG9hdCAodHdvLWJ5dGUgSUVFRSA3NTQpXG4gICAgU0lNUExFX0ZMT0FUX0hBTEYsIC8vIDB4ZjlcbiAgICAvLyBTaW5nbGUtUHJlY2lzaW9uIEZsb2F0IChmb3VyLWJ5dGUgSUVFRSA3NTQpXG4gICAgU0lNUExFX0ZMT0FUX1NJTkdMRSwgLy8gMHhmYVxuICAgIC8vIERvdWJsZS1QcmVjaXNpb24gRmxvYXQgKGVpZ2h0LWJ5dGUgSUVFRSA3NTQpXG4gICAgU0lNUExFX0ZMT0FUX0RPVUJMRSwgLy8gMHhmYlxuICAgIEVSUk9SLCAvLyAweGZjXG4gICAgRVJST1IsIC8vIDB4ZmRcbiAgICBFUlJPUiwgLy8gMHhmZVxuICAgIC8vIFwiYnJlYWtcIiBzdG9wIGNvZGVcbiAgICBCUkVBSyAvLyAweGZmXG4gIF1cblxuICAvLyAtLVxuXG4gIHJldHVybiB7XG4gICAgcGFyc2U6IHBhcnNlXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/borc/src/decoder.asm.js\n"));

/***/ }),

/***/ "../../../node_modules/borc/src/decoder.js":
/*!*************************************************!*\
  !*** ../../../node_modules/borc/src/decoder.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"../../../node_modules/buffer/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"../../../node_modules/ieee754/index.js\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"../../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst parser = __webpack_require__(/*! ./decoder.asm */ \"../../../node_modules/borc/src/decoder.asm.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"../../../node_modules/borc/src/utils.js\")\nconst c = __webpack_require__(/*! ./constants */ \"../../../node_modules/borc/src/constants.js\")\nconst Simple = __webpack_require__(/*! ./simple */ \"../../../node_modules/borc/src/simple.js\")\nconst Tagged = __webpack_require__(/*! ./tagged */ \"../../../node_modules/borc/src/tagged.js\")\nconst { URL } = __webpack_require__(/*! iso-url */ \"../../../node_modules/iso-url/index.js\")\n\n/**\n * Transform binary cbor data into JavaScript objects.\n */\nclass Decoder {\n  /**\n   * @param {Object} [opts={}]\n   * @param {number} [opts.size=65536] - Size of the allocated heap.\n   */\n  constructor (opts) {\n    opts = opts || {}\n\n    if (!opts.size || opts.size < 0x10000) {\n      opts.size = 0x10000\n    } else {\n      // Ensure the size is a power of 2\n      opts.size = utils.nextPowerOf2(opts.size)\n    }\n\n    // Heap use to share the input with the parser\n    this._heap = new ArrayBuffer(opts.size)\n    this._heap8 = new Uint8Array(this._heap)\n    this._buffer = Buffer.from(this._heap)\n\n    this._reset()\n\n    // Known tags\n    this._knownTags = Object.assign({\n      0: (val) => new Date(val),\n      1: (val) => new Date(val * 1000),\n      2: (val) => utils.arrayBufferToBignumber(val),\n      3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),\n      4: (v) => {\n        // const v = new Uint8Array(val)\n        return c.TEN.pow(v[0]).times(v[1])\n      },\n      5: (v) => {\n        // const v = new Uint8Array(val)\n        return c.TWO.pow(v[0]).times(v[1])\n      },\n      32: (val) => new URL(val),\n      35: (val) => new RegExp(val)\n    }, opts.tags)\n\n    // Initialize asm based parser\n    this.parser = parser(__webpack_require__.g, {\n      // eslint-disable-next-line no-console\n      log: console.log.bind(console),\n      pushInt: this.pushInt.bind(this),\n      pushInt32: this.pushInt32.bind(this),\n      pushInt32Neg: this.pushInt32Neg.bind(this),\n      pushInt64: this.pushInt64.bind(this),\n      pushInt64Neg: this.pushInt64Neg.bind(this),\n      pushFloat: this.pushFloat.bind(this),\n      pushFloatSingle: this.pushFloatSingle.bind(this),\n      pushFloatDouble: this.pushFloatDouble.bind(this),\n      pushTrue: this.pushTrue.bind(this),\n      pushFalse: this.pushFalse.bind(this),\n      pushUndefined: this.pushUndefined.bind(this),\n      pushNull: this.pushNull.bind(this),\n      pushInfinity: this.pushInfinity.bind(this),\n      pushInfinityNeg: this.pushInfinityNeg.bind(this),\n      pushNaN: this.pushNaN.bind(this),\n      pushNaNNeg: this.pushNaNNeg.bind(this),\n      pushArrayStart: this.pushArrayStart.bind(this),\n      pushArrayStartFixed: this.pushArrayStartFixed.bind(this),\n      pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),\n      pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),\n      pushObjectStart: this.pushObjectStart.bind(this),\n      pushObjectStartFixed: this.pushObjectStartFixed.bind(this),\n      pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),\n      pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),\n      pushByteString: this.pushByteString.bind(this),\n      pushByteStringStart: this.pushByteStringStart.bind(this),\n      pushUtf8String: this.pushUtf8String.bind(this),\n      pushUtf8StringStart: this.pushUtf8StringStart.bind(this),\n      pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),\n      pushTagUnassigned: this.pushTagUnassigned.bind(this),\n      pushTagStart: this.pushTagStart.bind(this),\n      pushTagStart4: this.pushTagStart4.bind(this),\n      pushTagStart8: this.pushTagStart8.bind(this),\n      pushBreak: this.pushBreak.bind(this)\n    }, this._heap)\n  }\n\n  get _depth () {\n    return this._parents.length\n  }\n\n  get _currentParent () {\n    return this._parents[this._depth - 1]\n  }\n\n  get _ref () {\n    return this._currentParent.ref\n  }\n\n  // Finish the current parent\n  _closeParent () {\n    var p = this._parents.pop()\n\n    if (p.length > 0) {\n      throw new Error(`Missing ${p.length} elements`)\n    }\n\n    switch (p.type) {\n      case c.PARENT.TAG:\n        this._push(\n          this.createTag(p.ref[0], p.ref[1])\n        )\n        break\n      case c.PARENT.BYTE_STRING:\n        this._push(this.createByteString(p.ref, p.length))\n        break\n      case c.PARENT.UTF8_STRING:\n        this._push(this.createUtf8String(p.ref, p.length))\n        break\n      case c.PARENT.MAP:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map')\n        }\n        this._push(this.createMap(p.ref, p.length))\n        break\n      case c.PARENT.OBJECT:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map')\n        }\n        this._push(this.createObject(p.ref, p.length))\n        break\n      case c.PARENT.ARRAY:\n        this._push(this.createArray(p.ref, p.length))\n        break\n      default:\n        break\n    }\n\n    if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {\n      this._dec()\n    }\n  }\n\n  // Reduce the expected length of the current parent by one\n  _dec () {\n    const p = this._currentParent\n    // The current parent does not know the epxected child length\n\n    if (p.length < 0) {\n      return\n    }\n\n    p.length--\n\n    // All children were seen, we can close the current parent\n    if (p.length === 0) {\n      this._closeParent()\n    }\n  }\n\n  // Push any value to the current parent\n  _push (val, hasChildren) {\n    const p = this._currentParent\n    p.values++\n\n    switch (p.type) {\n      case c.PARENT.ARRAY:\n      case c.PARENT.BYTE_STRING:\n      case c.PARENT.UTF8_STRING:\n        if (p.length > -1) {\n          this._ref[this._ref.length - p.length] = val\n        } else {\n          this._ref.push(val)\n        }\n        this._dec()\n        break\n      case c.PARENT.OBJECT:\n        if (p.tmpKey != null) {\n          this._ref[p.tmpKey] = val\n          p.tmpKey = null\n          this._dec()\n        } else {\n          p.tmpKey = val\n\n          if (typeof p.tmpKey !== 'string') {\n            // too bad, convert to a Map\n            p.type = c.PARENT.MAP\n            p.ref = utils.buildMap(p.ref)\n          }\n        }\n        break\n      case c.PARENT.MAP:\n        if (p.tmpKey != null) {\n          this._ref.set(p.tmpKey, val)\n          p.tmpKey = null\n          this._dec()\n        } else {\n          p.tmpKey = val\n        }\n        break\n      case c.PARENT.TAG:\n        this._ref.push(val)\n        if (!hasChildren) {\n          this._dec()\n        }\n        break\n      default:\n        throw new Error('Unknown parent type')\n    }\n  }\n\n  // Create a new parent in the parents list\n  _createParent (obj, type, len) {\n    this._parents[this._depth] = {\n      type: type,\n      length: len,\n      ref: obj,\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  // Reset all state back to the beginning, also used for initiatlization\n  _reset () {\n    this._res = []\n    this._parents = [{\n      type: c.PARENT.ARRAY,\n      length: -1,\n      ref: this._res,\n      values: 0,\n      tmpKey: null\n    }]\n  }\n\n  // -- Interface to customize deoding behaviour\n  createTag (tagNumber, value) {\n    const typ = this._knownTags[tagNumber]\n\n    if (!typ) {\n      return new Tagged(tagNumber, value)\n    }\n\n    return typ(value)\n  }\n\n  createMap (obj, len) {\n    return obj\n  }\n\n  createObject (obj, len) {\n    return obj\n  }\n\n  createArray (arr, len) {\n    return arr\n  }\n\n  createByteString (raw, len) {\n    return Buffer.concat(raw)\n  }\n\n  createByteStringFromHeap (start, end) {\n    if (start === end) {\n      return Buffer.alloc(0)\n    }\n\n    return Buffer.from(this._heap.slice(start, end))\n  }\n\n  createInt (val) {\n    return val\n  }\n\n  createInt32 (f, g) {\n    return utils.buildInt32(f, g)\n  }\n\n  createInt64 (f1, f2, g1, g2) {\n    return utils.buildInt64(f1, f2, g1, g2)\n  }\n\n  createFloat (val) {\n    return val\n  }\n\n  createFloatSingle (a, b, c, d) {\n    return ieee754.read([a, b, c, d], 0, false, 23, 4)\n  }\n\n  createFloatDouble (a, b, c, d, e, f, g, h) {\n    return ieee754.read([a, b, c, d, e, f, g, h], 0, false, 52, 8)\n  }\n\n  createInt32Neg (f, g) {\n    return -1 - utils.buildInt32(f, g)\n  }\n\n  createInt64Neg (f1, f2, g1, g2) {\n    const f = utils.buildInt32(f1, f2)\n    const g = utils.buildInt32(g1, g2)\n\n    if (f > c.MAX_SAFE_HIGH) {\n      return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g))\n    }\n\n    return -1 - ((f * c.SHIFT32) + g)\n  }\n\n  createTrue () {\n    return true\n  }\n\n  createFalse () {\n    return false\n  }\n\n  createNull () {\n    return null\n  }\n\n  createUndefined () {\n    return undefined\n  }\n\n  createInfinity () {\n    return Infinity\n  }\n\n  createInfinityNeg () {\n    return -Infinity\n  }\n\n  createNaN () {\n    return NaN\n  }\n\n  createNaNNeg () {\n    return -NaN\n  }\n\n  createUtf8String (raw, len) {\n    return raw.join('')\n  }\n\n  createUtf8StringFromHeap (start, end) {\n    if (start === end) {\n      return ''\n    }\n\n    return this._buffer.toString('utf8', start, end)\n  }\n\n  createSimpleUnassigned (val) {\n    return new Simple(val)\n  }\n\n  // -- Interface for decoder.asm.js\n\n  pushInt (val) {\n    this._push(this.createInt(val))\n  }\n\n  pushInt32 (f, g) {\n    this._push(this.createInt32(f, g))\n  }\n\n  pushInt64 (f1, f2, g1, g2) {\n    this._push(this.createInt64(f1, f2, g1, g2))\n  }\n\n  pushFloat (val) {\n    this._push(this.createFloat(val))\n  }\n\n  pushFloatSingle (a, b, c, d) {\n    this._push(this.createFloatSingle(a, b, c, d))\n  }\n\n  pushFloatDouble (a, b, c, d, e, f, g, h) {\n    this._push(this.createFloatDouble(a, b, c, d, e, f, g, h))\n  }\n\n  pushInt32Neg (f, g) {\n    this._push(this.createInt32Neg(f, g))\n  }\n\n  pushInt64Neg (f1, f2, g1, g2) {\n    this._push(this.createInt64Neg(f1, f2, g1, g2))\n  }\n\n  pushTrue () {\n    this._push(this.createTrue())\n  }\n\n  pushFalse () {\n    this._push(this.createFalse())\n  }\n\n  pushNull () {\n    this._push(this.createNull())\n  }\n\n  pushUndefined () {\n    this._push(this.createUndefined())\n  }\n\n  pushInfinity () {\n    this._push(this.createInfinity())\n  }\n\n  pushInfinityNeg () {\n    this._push(this.createInfinityNeg())\n  }\n\n  pushNaN () {\n    this._push(this.createNaN())\n  }\n\n  pushNaNNeg () {\n    this._push(this.createNaNNeg())\n  }\n\n  pushArrayStart () {\n    this._createParent([], c.PARENT.ARRAY, -1)\n  }\n\n  pushArrayStartFixed (len) {\n    this._createArrayStartFixed(len)\n  }\n\n  pushArrayStartFixed32 (len1, len2) {\n    const len = utils.buildInt32(len1, len2)\n    this._createArrayStartFixed(len)\n  }\n\n  pushArrayStartFixed64 (len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4)\n    this._createArrayStartFixed(len)\n  }\n\n  pushObjectStart () {\n    this._createObjectStartFixed(-1)\n  }\n\n  pushObjectStartFixed (len) {\n    this._createObjectStartFixed(len)\n  }\n\n  pushObjectStartFixed32 (len1, len2) {\n    const len = utils.buildInt32(len1, len2)\n    this._createObjectStartFixed(len)\n  }\n\n  pushObjectStartFixed64 (len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4)\n    this._createObjectStartFixed(len)\n  }\n\n  pushByteStringStart () {\n    this._parents[this._depth] = {\n      type: c.PARENT.BYTE_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  pushByteString (start, end) {\n    this._push(this.createByteStringFromHeap(start, end))\n  }\n\n  pushUtf8StringStart () {\n    this._parents[this._depth] = {\n      type: c.PARENT.UTF8_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    }\n  }\n\n  pushUtf8String (start, end) {\n    this._push(this.createUtf8StringFromHeap(start, end))\n  }\n\n  pushSimpleUnassigned (val) {\n    this._push(this.createSimpleUnassigned(val))\n  }\n\n  pushTagStart (tag) {\n    this._parents[this._depth] = {\n      type: c.PARENT.TAG,\n      length: 1,\n      ref: [tag]\n    }\n  }\n\n  pushTagStart4 (f, g) {\n    this.pushTagStart(utils.buildInt32(f, g))\n  }\n\n  pushTagStart8 (f1, f2, g1, g2) {\n    this.pushTagStart(utils.buildInt64(f1, f2, g1, g2))\n  }\n\n  pushTagUnassigned (tagNumber) {\n    this._push(this.createTag(tagNumber))\n  }\n\n  pushBreak () {\n    if (this._currentParent.length > -1) {\n      throw new Error('Unexpected break')\n    }\n\n    this._closeParent()\n  }\n\n  _createObjectStartFixed (len) {\n    if (len === 0) {\n      this._push(this.createObject({}))\n      return\n    }\n\n    this._createParent({}, c.PARENT.OBJECT, len)\n  }\n\n  _createArrayStartFixed (len) {\n    if (len === 0) {\n      this._push(this.createArray([]))\n      return\n    }\n\n    this._createParent(new Array(len), c.PARENT.ARRAY, len)\n  }\n\n  _decode (input) {\n    if (input.byteLength === 0) {\n      throw new Error('Input too short')\n    }\n\n    this._reset()\n    this._heap8.set(input)\n    const code = this.parser.parse(input.byteLength)\n\n    if (this._depth > 1) {\n      while (this._currentParent.length === 0) {\n        this._closeParent()\n      }\n      if (this._depth > 1) {\n        throw new Error('Undeterminated nesting')\n      }\n    }\n\n    if (code > 0) {\n      throw new Error('Failed to parse')\n    }\n\n    if (this._res.length === 0) {\n      throw new Error('No valid result')\n    }\n  }\n\n  // -- Public Interface\n\n  decodeFirst (input) {\n    this._decode(input)\n\n    return this._res[0]\n  }\n\n  decodeAll (input) {\n    this._decode(input)\n\n    return this._res\n  }\n\n  /**\n   * Decode the first cbor object.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {*}\n   */\n  static decode (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Decoder({ size: input.length })\n    return dec.decodeFirst(input)\n  }\n\n  /**\n   * Decode all cbor objects.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {Array<*>}\n   */\n  static decodeAll (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Decoder({ size: input.length })\n    return dec.decodeAll(input)\n  }\n}\n\nDecoder.decodeFirst = Decoder.decode\n\nmodule.exports = Decoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxREFBUTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBUztBQUNqQyxrQkFBa0Isc0dBQWlDOztBQUVuRCxlQUFlLG1CQUFPLENBQUMsb0VBQWU7QUFDdEMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFVBQVUsbUJBQU8sQ0FBQyxnRUFBYTtBQUMvQixlQUFlLG1CQUFPLENBQUMsMERBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLDBEQUFVO0FBQ2pDLFFBQVEsTUFBTSxFQUFFLG1CQUFPLENBQUMsdURBQVM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsUUFBUTtBQUM3QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSx5QkFBeUIscUJBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsb0JBQW9CO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RlY29kZXIuanM/N2I5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBCaWdudW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKS5CaWdOdW1iZXJcblxuY29uc3QgcGFyc2VyID0gcmVxdWlyZSgnLi9kZWNvZGVyLmFzbScpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgYyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IFNpbXBsZSA9IHJlcXVpcmUoJy4vc2ltcGxlJylcbmNvbnN0IFRhZ2dlZCA9IHJlcXVpcmUoJy4vdGFnZ2VkJylcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCdpc28tdXJsJylcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYmluYXJ5IGNib3IgZGF0YSBpbnRvIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuY2xhc3MgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5zaXplPTY1NTM2XSAtIFNpemUgb2YgdGhlIGFsbG9jYXRlZCBoZWFwLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgaWYgKCFvcHRzLnNpemUgfHwgb3B0cy5zaXplIDwgMHgxMDAwMCkge1xuICAgICAgb3B0cy5zaXplID0gMHgxMDAwMFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgdGhlIHNpemUgaXMgYSBwb3dlciBvZiAyXG4gICAgICBvcHRzLnNpemUgPSB1dGlscy5uZXh0UG93ZXJPZjIob3B0cy5zaXplKVxuICAgIH1cblxuICAgIC8vIEhlYXAgdXNlIHRvIHNoYXJlIHRoZSBpbnB1dCB3aXRoIHRoZSBwYXJzZXJcbiAgICB0aGlzLl9oZWFwID0gbmV3IEFycmF5QnVmZmVyKG9wdHMuc2l6ZSlcbiAgICB0aGlzLl9oZWFwOCA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2hlYXApXG4gICAgdGhpcy5fYnVmZmVyID0gQnVmZmVyLmZyb20odGhpcy5faGVhcClcblxuICAgIHRoaXMuX3Jlc2V0KClcblxuICAgIC8vIEtub3duIHRhZ3NcbiAgICB0aGlzLl9rbm93blRhZ3MgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIDA6ICh2YWwpID0+IG5ldyBEYXRlKHZhbCksXG4gICAgICAxOiAodmFsKSA9PiBuZXcgRGF0ZSh2YWwgKiAxMDAwKSxcbiAgICAgIDI6ICh2YWwpID0+IHV0aWxzLmFycmF5QnVmZmVyVG9CaWdudW1iZXIodmFsKSxcbiAgICAgIDM6ICh2YWwpID0+IGMuTkVHX09ORS5taW51cyh1dGlscy5hcnJheUJ1ZmZlclRvQmlnbnVtYmVyKHZhbCkpLFxuICAgICAgNDogKHYpID0+IHtcbiAgICAgICAgLy8gY29uc3QgdiA9IG5ldyBVaW50OEFycmF5KHZhbClcbiAgICAgICAgcmV0dXJuIGMuVEVOLnBvdyh2WzBdKS50aW1lcyh2WzFdKVxuICAgICAgfSxcbiAgICAgIDU6ICh2KSA9PiB7XG4gICAgICAgIC8vIGNvbnN0IHYgPSBuZXcgVWludDhBcnJheSh2YWwpXG4gICAgICAgIHJldHVybiBjLlRXTy5wb3codlswXSkudGltZXModlsxXSlcbiAgICAgIH0sXG4gICAgICAzMjogKHZhbCkgPT4gbmV3IFVSTCh2YWwpLFxuICAgICAgMzU6ICh2YWwpID0+IG5ldyBSZWdFeHAodmFsKVxuICAgIH0sIG9wdHMudGFncylcblxuICAgIC8vIEluaXRpYWxpemUgYXNtIGJhc2VkIHBhcnNlclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyKGdsb2JhbCwge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGxvZzogY29uc29sZS5sb2cuYmluZChjb25zb2xlKSxcbiAgICAgIHB1c2hJbnQ6IHRoaXMucHVzaEludC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDMyOiB0aGlzLnB1c2hJbnQzMi5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDMyTmVnOiB0aGlzLnB1c2hJbnQzMk5lZy5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDY0OiB0aGlzLnB1c2hJbnQ2NC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEludDY0TmVnOiB0aGlzLnB1c2hJbnQ2NE5lZy5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEZsb2F0OiB0aGlzLnB1c2hGbG9hdC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEZsb2F0U2luZ2xlOiB0aGlzLnB1c2hGbG9hdFNpbmdsZS5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEZsb2F0RG91YmxlOiB0aGlzLnB1c2hGbG9hdERvdWJsZS5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFRydWU6IHRoaXMucHVzaFRydWUuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hGYWxzZTogdGhpcy5wdXNoRmFsc2UuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hVbmRlZmluZWQ6IHRoaXMucHVzaFVuZGVmaW5lZC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE51bGw6IHRoaXMucHVzaE51bGwuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hJbmZpbml0eTogdGhpcy5wdXNoSW5maW5pdHkuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hJbmZpbml0eU5lZzogdGhpcy5wdXNoSW5maW5pdHlOZWcuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hOYU46IHRoaXMucHVzaE5hTi5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE5hTk5lZzogdGhpcy5wdXNoTmFOTmVnLmJpbmQodGhpcyksXG4gICAgICBwdXNoQXJyYXlTdGFydDogdGhpcy5wdXNoQXJyYXlTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaEFycmF5U3RhcnRGaXhlZDogdGhpcy5wdXNoQXJyYXlTdGFydEZpeGVkLmJpbmQodGhpcyksXG4gICAgICBwdXNoQXJyYXlTdGFydEZpeGVkMzI6IHRoaXMucHVzaEFycmF5U3RhcnRGaXhlZDMyLmJpbmQodGhpcyksXG4gICAgICBwdXNoQXJyYXlTdGFydEZpeGVkNjQ6IHRoaXMucHVzaEFycmF5U3RhcnRGaXhlZDY0LmJpbmQodGhpcyksXG4gICAgICBwdXNoT2JqZWN0U3RhcnQ6IHRoaXMucHVzaE9iamVjdFN0YXJ0LmJpbmQodGhpcyksXG4gICAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZDogdGhpcy5wdXNoT2JqZWN0U3RhcnRGaXhlZC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQzMjogdGhpcy5wdXNoT2JqZWN0U3RhcnRGaXhlZDMyLmJpbmQodGhpcyksXG4gICAgICBwdXNoT2JqZWN0U3RhcnRGaXhlZDY0OiB0aGlzLnB1c2hPYmplY3RTdGFydEZpeGVkNjQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hCeXRlU3RyaW5nOiB0aGlzLnB1c2hCeXRlU3RyaW5nLmJpbmQodGhpcyksXG4gICAgICBwdXNoQnl0ZVN0cmluZ1N0YXJ0OiB0aGlzLnB1c2hCeXRlU3RyaW5nU3RhcnQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hVdGY4U3RyaW5nOiB0aGlzLnB1c2hVdGY4U3RyaW5nLmJpbmQodGhpcyksXG4gICAgICBwdXNoVXRmOFN0cmluZ1N0YXJ0OiB0aGlzLnB1c2hVdGY4U3RyaW5nU3RhcnQuYmluZCh0aGlzKSxcbiAgICAgIHB1c2hTaW1wbGVVbmFzc2lnbmVkOiB0aGlzLnB1c2hTaW1wbGVVbmFzc2lnbmVkLmJpbmQodGhpcyksXG4gICAgICBwdXNoVGFnVW5hc3NpZ25lZDogdGhpcy5wdXNoVGFnVW5hc3NpZ25lZC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFRhZ1N0YXJ0OiB0aGlzLnB1c2hUYWdTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgcHVzaFRhZ1N0YXJ0NDogdGhpcy5wdXNoVGFnU3RhcnQ0LmJpbmQodGhpcyksXG4gICAgICBwdXNoVGFnU3RhcnQ4OiB0aGlzLnB1c2hUYWdTdGFydDguYmluZCh0aGlzKSxcbiAgICAgIHB1c2hCcmVhazogdGhpcy5wdXNoQnJlYWsuYmluZCh0aGlzKVxuICAgIH0sIHRoaXMuX2hlYXApXG4gIH1cblxuICBnZXQgX2RlcHRoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50cy5sZW5ndGhcbiAgfVxuXG4gIGdldCBfY3VycmVudFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudHNbdGhpcy5fZGVwdGggLSAxXVxuICB9XG5cbiAgZ2V0IF9yZWYgKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50UGFyZW50LnJlZlxuICB9XG5cbiAgLy8gRmluaXNoIHRoZSBjdXJyZW50IHBhcmVudFxuICBfY2xvc2VQYXJlbnQgKCkge1xuICAgIHZhciBwID0gdGhpcy5fcGFyZW50cy5wb3AoKVxuXG4gICAgaWYgKHAubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nICR7cC5sZW5ndGh9IGVsZW1lbnRzYClcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHAudHlwZSkge1xuICAgICAgY2FzZSBjLlBBUkVOVC5UQUc6XG4gICAgICAgIHRoaXMuX3B1c2goXG4gICAgICAgICAgdGhpcy5jcmVhdGVUYWcocC5yZWZbMF0sIHAucmVmWzFdKVxuICAgICAgICApXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULkJZVEVfU1RSSU5HOlxuICAgICAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlQnl0ZVN0cmluZyhwLnJlZiwgcC5sZW5ndGgpKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5VVEY4X1NUUklORzpcbiAgICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZVV0ZjhTdHJpbmcocC5yZWYsIHAubGVuZ3RoKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuTUFQOlxuICAgICAgICBpZiAocC52YWx1ZXMgJSAyID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2RkIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbWFwJylcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlTWFwKHAucmVmLCBwLmxlbmd0aCkpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULk9CSkVDVDpcbiAgICAgICAgaWYgKHAudmFsdWVzICUgMiA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09kZCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIG1hcCcpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZU9iamVjdChwLnJlZiwgcC5sZW5ndGgpKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBjLlBBUkVOVC5BUlJBWTpcbiAgICAgICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZUFycmF5KHAucmVmLCBwLmxlbmd0aCkpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jdXJyZW50UGFyZW50ICYmIHRoaXMuX2N1cnJlbnRQYXJlbnQudHlwZSA9PT0gYy5QQVJFTlQuVEFHKSB7XG4gICAgICB0aGlzLl9kZWMoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZHVjZSB0aGUgZXhwZWN0ZWQgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IHBhcmVudCBieSBvbmVcbiAgX2RlYyAoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX2N1cnJlbnRQYXJlbnRcbiAgICAvLyBUaGUgY3VycmVudCBwYXJlbnQgZG9lcyBub3Qga25vdyB0aGUgZXB4ZWN0ZWQgY2hpbGQgbGVuZ3RoXG5cbiAgICBpZiAocC5sZW5ndGggPCAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBwLmxlbmd0aC0tXG5cbiAgICAvLyBBbGwgY2hpbGRyZW4gd2VyZSBzZWVuLCB3ZSBjYW4gY2xvc2UgdGhlIGN1cnJlbnQgcGFyZW50XG4gICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9jbG9zZVBhcmVudCgpXG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBhbnkgdmFsdWUgdG8gdGhlIGN1cnJlbnQgcGFyZW50XG4gIF9wdXNoICh2YWwsIGhhc0NoaWxkcmVuKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX2N1cnJlbnRQYXJlbnRcbiAgICBwLnZhbHVlcysrXG5cbiAgICBzd2l0Y2ggKHAudHlwZSkge1xuICAgICAgY2FzZSBjLlBBUkVOVC5BUlJBWTpcbiAgICAgIGNhc2UgYy5QQVJFTlQuQllURV9TVFJJTkc6XG4gICAgICBjYXNlIGMuUEFSRU5ULlVURjhfU1RSSU5HOlxuICAgICAgICBpZiAocC5sZW5ndGggPiAtMSkge1xuICAgICAgICAgIHRoaXMuX3JlZlt0aGlzLl9yZWYubGVuZ3RoIC0gcC5sZW5ndGhdID0gdmFsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVmLnB1c2godmFsKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlYygpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGMuUEFSRU5ULk9CSkVDVDpcbiAgICAgICAgaWYgKHAudG1wS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9yZWZbcC50bXBLZXldID0gdmFsXG4gICAgICAgICAgcC50bXBLZXkgPSBudWxsXG4gICAgICAgICAgdGhpcy5fZGVjKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwLnRtcEtleSA9IHZhbFxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBwLnRtcEtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIHRvbyBiYWQsIGNvbnZlcnQgdG8gYSBNYXBcbiAgICAgICAgICAgIHAudHlwZSA9IGMuUEFSRU5ULk1BUFxuICAgICAgICAgICAgcC5yZWYgPSB1dGlscy5idWlsZE1hcChwLnJlZilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuTUFQOlxuICAgICAgICBpZiAocC50bXBLZXkgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX3JlZi5zZXQocC50bXBLZXksIHZhbClcbiAgICAgICAgICBwLnRtcEtleSA9IG51bGxcbiAgICAgICAgICB0aGlzLl9kZWMoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAudG1wS2V5ID0gdmFsXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYy5QQVJFTlQuVEFHOlxuICAgICAgICB0aGlzLl9yZWYucHVzaCh2YWwpXG4gICAgICAgIGlmICghaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICB0aGlzLl9kZWMoKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcGFyZW50IHR5cGUnKVxuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyBwYXJlbnQgaW4gdGhlIHBhcmVudHMgbGlzdFxuICBfY3JlYXRlUGFyZW50IChvYmosIHR5cGUsIGxlbikge1xuICAgIHRoaXMuX3BhcmVudHNbdGhpcy5fZGVwdGhdID0ge1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGxlbmd0aDogbGVuLFxuICAgICAgcmVmOiBvYmosXG4gICAgICB2YWx1ZXM6IDAsXG4gICAgICB0bXBLZXk6IG51bGxcbiAgICB9XG4gIH1cblxuICAvLyBSZXNldCBhbGwgc3RhdGUgYmFjayB0byB0aGUgYmVnaW5uaW5nLCBhbHNvIHVzZWQgZm9yIGluaXRpYXRsaXphdGlvblxuICBfcmVzZXQgKCkge1xuICAgIHRoaXMuX3JlcyA9IFtdXG4gICAgdGhpcy5fcGFyZW50cyA9IFt7XG4gICAgICB0eXBlOiBjLlBBUkVOVC5BUlJBWSxcbiAgICAgIGxlbmd0aDogLTEsXG4gICAgICByZWY6IHRoaXMuX3JlcyxcbiAgICAgIHZhbHVlczogMCxcbiAgICAgIHRtcEtleTogbnVsbFxuICAgIH1dXG4gIH1cblxuICAvLyAtLSBJbnRlcmZhY2UgdG8gY3VzdG9taXplIGRlb2RpbmcgYmVoYXZpb3VyXG4gIGNyZWF0ZVRhZyAodGFnTnVtYmVyLCB2YWx1ZSkge1xuICAgIGNvbnN0IHR5cCA9IHRoaXMuX2tub3duVGFnc1t0YWdOdW1iZXJdXG5cbiAgICBpZiAoIXR5cCkge1xuICAgICAgcmV0dXJuIG5ldyBUYWdnZWQodGFnTnVtYmVyLCB2YWx1ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwKHZhbHVlKVxuICB9XG5cbiAgY3JlYXRlTWFwIChvYmosIGxlbikge1xuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIGNyZWF0ZU9iamVjdCAob2JqLCBsZW4pIHtcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICBjcmVhdGVBcnJheSAoYXJyLCBsZW4pIHtcbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBjcmVhdGVCeXRlU3RyaW5nIChyYXcsIGxlbikge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KHJhdylcbiAgfVxuXG4gIGNyZWF0ZUJ5dGVTdHJpbmdGcm9tSGVhcCAoc3RhcnQsIGVuZCkge1xuICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX2hlYXAuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cblxuICBjcmVhdGVJbnQgKHZhbCkge1xuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIGNyZWF0ZUludDMyIChmLCBnKSB7XG4gICAgcmV0dXJuIHV0aWxzLmJ1aWxkSW50MzIoZiwgZylcbiAgfVxuXG4gIGNyZWF0ZUludDY0IChmMSwgZjIsIGcxLCBnMikge1xuICAgIHJldHVybiB1dGlscy5idWlsZEludDY0KGYxLCBmMiwgZzEsIGcyKVxuICB9XG5cbiAgY3JlYXRlRmxvYXQgKHZhbCkge1xuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIGNyZWF0ZUZsb2F0U2luZ2xlIChhLCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGllZWU3NTQucmVhZChbYSwgYiwgYywgZF0sIDAsIGZhbHNlLCAyMywgNClcbiAgfVxuXG4gIGNyZWF0ZUZsb2F0RG91YmxlIChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XG4gICAgcmV0dXJuIGllZWU3NTQucmVhZChbYSwgYiwgYywgZCwgZSwgZiwgZywgaF0sIDAsIGZhbHNlLCA1MiwgOClcbiAgfVxuXG4gIGNyZWF0ZUludDMyTmVnIChmLCBnKSB7XG4gICAgcmV0dXJuIC0xIC0gdXRpbHMuYnVpbGRJbnQzMihmLCBnKVxuICB9XG5cbiAgY3JlYXRlSW50NjROZWcgKGYxLCBmMiwgZzEsIGcyKSB7XG4gICAgY29uc3QgZiA9IHV0aWxzLmJ1aWxkSW50MzIoZjEsIGYyKVxuICAgIGNvbnN0IGcgPSB1dGlscy5idWlsZEludDMyKGcxLCBnMilcblxuICAgIGlmIChmID4gYy5NQVhfU0FGRV9ISUdIKSB7XG4gICAgICByZXR1cm4gYy5ORUdfT05FLm1pbnVzKG5ldyBCaWdudW1iZXIoZikudGltZXMoYy5TSElGVDMyKS5wbHVzKGcpKVxuICAgIH1cblxuICAgIHJldHVybiAtMSAtICgoZiAqIGMuU0hJRlQzMikgKyBnKVxuICB9XG5cbiAgY3JlYXRlVHJ1ZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNyZWF0ZUZhbHNlICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNyZWF0ZU51bGwgKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjcmVhdGVVbmRlZmluZWQgKCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNyZWF0ZUluZmluaXR5ICgpIHtcbiAgICByZXR1cm4gSW5maW5pdHlcbiAgfVxuXG4gIGNyZWF0ZUluZmluaXR5TmVnICgpIHtcbiAgICByZXR1cm4gLUluZmluaXR5XG4gIH1cblxuICBjcmVhdGVOYU4gKCkge1xuICAgIHJldHVybiBOYU5cbiAgfVxuXG4gIGNyZWF0ZU5hTk5lZyAoKSB7XG4gICAgcmV0dXJuIC1OYU5cbiAgfVxuXG4gIGNyZWF0ZVV0ZjhTdHJpbmcgKHJhdywgbGVuKSB7XG4gICAgcmV0dXJuIHJhdy5qb2luKCcnKVxuICB9XG5cbiAgY3JlYXRlVXRmOFN0cmluZ0Zyb21IZWFwIChzdGFydCwgZW5kKSB7XG4gICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9idWZmZXIudG9TdHJpbmcoJ3V0ZjgnLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgY3JlYXRlU2ltcGxlVW5hc3NpZ25lZCAodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGUodmFsKVxuICB9XG5cbiAgLy8gLS0gSW50ZXJmYWNlIGZvciBkZWNvZGVyLmFzbS5qc1xuXG4gIHB1c2hJbnQgKHZhbCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbnQodmFsKSlcbiAgfVxuXG4gIHB1c2hJbnQzMiAoZiwgZykge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbnQzMihmLCBnKSlcbiAgfVxuXG4gIHB1c2hJbnQ2NCAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW50NjQoZjEsIGYyLCBnMSwgZzIpKVxuICB9XG5cbiAgcHVzaEZsb2F0ICh2YWwpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlRmxvYXQodmFsKSlcbiAgfVxuXG4gIHB1c2hGbG9hdFNpbmdsZSAoYSwgYiwgYywgZCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVGbG9hdFNpbmdsZShhLCBiLCBjLCBkKSlcbiAgfVxuXG4gIHB1c2hGbG9hdERvdWJsZSAoYSwgYiwgYywgZCwgZSwgZiwgZywgaCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVGbG9hdERvdWJsZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSlcbiAgfVxuXG4gIHB1c2hJbnQzMk5lZyAoZiwgZykge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbnQzMk5lZyhmLCBnKSlcbiAgfVxuXG4gIHB1c2hJbnQ2NE5lZyAoZjEsIGYyLCBnMSwgZzIpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW50NjROZWcoZjEsIGYyLCBnMSwgZzIpKVxuICB9XG5cbiAgcHVzaFRydWUgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVUcnVlKCkpXG4gIH1cblxuICBwdXNoRmFsc2UgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVGYWxzZSgpKVxuICB9XG5cbiAgcHVzaE51bGwgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVOdWxsKCkpXG4gIH1cblxuICBwdXNoVW5kZWZpbmVkICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlVW5kZWZpbmVkKCkpXG4gIH1cblxuICBwdXNoSW5maW5pdHkgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVJbmZpbml0eSgpKVxuICB9XG5cbiAgcHVzaEluZmluaXR5TmVnICgpIHtcbiAgICB0aGlzLl9wdXNoKHRoaXMuY3JlYXRlSW5maW5pdHlOZWcoKSlcbiAgfVxuXG4gIHB1c2hOYU4gKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVOYU4oKSlcbiAgfVxuXG4gIHB1c2hOYU5OZWcgKCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVOYU5OZWcoKSlcbiAgfVxuXG4gIHB1c2hBcnJheVN0YXJ0ICgpIHtcbiAgICB0aGlzLl9jcmVhdGVQYXJlbnQoW10sIGMuUEFSRU5ULkFSUkFZLCAtMSlcbiAgfVxuXG4gIHB1c2hBcnJheVN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIHRoaXMuX2NyZWF0ZUFycmF5U3RhcnRGaXhlZChsZW4pXG4gIH1cblxuICBwdXNoQXJyYXlTdGFydEZpeGVkMzIgKGxlbjEsIGxlbjIpIHtcbiAgICBjb25zdCBsZW4gPSB1dGlscy5idWlsZEludDMyKGxlbjEsIGxlbjIpXG4gICAgdGhpcy5fY3JlYXRlQXJyYXlTdGFydEZpeGVkKGxlbilcbiAgfVxuXG4gIHB1c2hBcnJheVN0YXJ0Rml4ZWQ2NCAobGVuMSwgbGVuMiwgbGVuMywgbGVuNCkge1xuICAgIGNvbnN0IGxlbiA9IHV0aWxzLmJ1aWxkSW50NjQobGVuMSwgbGVuMiwgbGVuMywgbGVuNClcbiAgICB0aGlzLl9jcmVhdGVBcnJheVN0YXJ0Rml4ZWQobGVuKVxuICB9XG5cbiAgcHVzaE9iamVjdFN0YXJ0ICgpIHtcbiAgICB0aGlzLl9jcmVhdGVPYmplY3RTdGFydEZpeGVkKC0xKVxuICB9XG5cbiAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIHRoaXMuX2NyZWF0ZU9iamVjdFN0YXJ0Rml4ZWQobGVuKVxuICB9XG5cbiAgcHVzaE9iamVjdFN0YXJ0Rml4ZWQzMiAobGVuMSwgbGVuMikge1xuICAgIGNvbnN0IGxlbiA9IHV0aWxzLmJ1aWxkSW50MzIobGVuMSwgbGVuMilcbiAgICB0aGlzLl9jcmVhdGVPYmplY3RTdGFydEZpeGVkKGxlbilcbiAgfVxuXG4gIHB1c2hPYmplY3RTdGFydEZpeGVkNjQgKGxlbjEsIGxlbjIsIGxlbjMsIGxlbjQpIHtcbiAgICBjb25zdCBsZW4gPSB1dGlscy5idWlsZEludDY0KGxlbjEsIGxlbjIsIGxlbjMsIGxlbjQpXG4gICAgdGhpcy5fY3JlYXRlT2JqZWN0U3RhcnRGaXhlZChsZW4pXG4gIH1cblxuICBwdXNoQnl0ZVN0cmluZ1N0YXJ0ICgpIHtcbiAgICB0aGlzLl9wYXJlbnRzW3RoaXMuX2RlcHRoXSA9IHtcbiAgICAgIHR5cGU6IGMuUEFSRU5ULkJZVEVfU1RSSU5HLFxuICAgICAgbGVuZ3RoOiAtMSxcbiAgICAgIHJlZjogW10sXG4gICAgICB2YWx1ZXM6IDAsXG4gICAgICB0bXBLZXk6IG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoQnl0ZVN0cmluZyAoc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVCeXRlU3RyaW5nRnJvbUhlYXAoc3RhcnQsIGVuZCkpXG4gIH1cblxuICBwdXNoVXRmOFN0cmluZ1N0YXJ0ICgpIHtcbiAgICB0aGlzLl9wYXJlbnRzW3RoaXMuX2RlcHRoXSA9IHtcbiAgICAgIHR5cGU6IGMuUEFSRU5ULlVURjhfU1RSSU5HLFxuICAgICAgbGVuZ3RoOiAtMSxcbiAgICAgIHJlZjogW10sXG4gICAgICB2YWx1ZXM6IDAsXG4gICAgICB0bXBLZXk6IG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoVXRmOFN0cmluZyAoc3RhcnQsIGVuZCkge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVVdGY4U3RyaW5nRnJvbUhlYXAoc3RhcnQsIGVuZCkpXG4gIH1cblxuICBwdXNoU2ltcGxlVW5hc3NpZ25lZCAodmFsKSB7XG4gICAgdGhpcy5fcHVzaCh0aGlzLmNyZWF0ZVNpbXBsZVVuYXNzaWduZWQodmFsKSlcbiAgfVxuXG4gIHB1c2hUYWdTdGFydCAodGFnKSB7XG4gICAgdGhpcy5fcGFyZW50c1t0aGlzLl9kZXB0aF0gPSB7XG4gICAgICB0eXBlOiBjLlBBUkVOVC5UQUcsXG4gICAgICBsZW5ndGg6IDEsXG4gICAgICByZWY6IFt0YWddXG4gICAgfVxuICB9XG5cbiAgcHVzaFRhZ1N0YXJ0NCAoZiwgZykge1xuICAgIHRoaXMucHVzaFRhZ1N0YXJ0KHV0aWxzLmJ1aWxkSW50MzIoZiwgZykpXG4gIH1cblxuICBwdXNoVGFnU3RhcnQ4IChmMSwgZjIsIGcxLCBnMikge1xuICAgIHRoaXMucHVzaFRhZ1N0YXJ0KHV0aWxzLmJ1aWxkSW50NjQoZjEsIGYyLCBnMSwgZzIpKVxuICB9XG5cbiAgcHVzaFRhZ1VuYXNzaWduZWQgKHRhZ051bWJlcikge1xuICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVUYWcodGFnTnVtYmVyKSlcbiAgfVxuXG4gIHB1c2hCcmVhayAoKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYXJlbnQubGVuZ3RoID4gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBicmVhaycpXG4gICAgfVxuXG4gICAgdGhpcy5fY2xvc2VQYXJlbnQoKVxuICB9XG5cbiAgX2NyZWF0ZU9iamVjdFN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVPYmplY3Qoe30pKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fY3JlYXRlUGFyZW50KHt9LCBjLlBBUkVOVC5PQkpFQ1QsIGxlbilcbiAgfVxuXG4gIF9jcmVhdGVBcnJheVN0YXJ0Rml4ZWQgKGxlbikge1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRoaXMuX3B1c2godGhpcy5jcmVhdGVBcnJheShbXSkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9jcmVhdGVQYXJlbnQobmV3IEFycmF5KGxlbiksIGMuUEFSRU5ULkFSUkFZLCBsZW4pXG4gIH1cblxuICBfZGVjb2RlIChpbnB1dCkge1xuICAgIGlmIChpbnB1dC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHRvbyBzaG9ydCcpXG4gICAgfVxuXG4gICAgdGhpcy5fcmVzZXQoKVxuICAgIHRoaXMuX2hlYXA4LnNldChpbnB1dClcbiAgICBjb25zdCBjb2RlID0gdGhpcy5wYXJzZXIucGFyc2UoaW5wdXQuYnl0ZUxlbmd0aClcblxuICAgIGlmICh0aGlzLl9kZXB0aCA+IDEpIHtcbiAgICAgIHdoaWxlICh0aGlzLl9jdXJyZW50UGFyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jbG9zZVBhcmVudCgpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGVwdGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5kZXRlcm1pbmF0ZWQgbmVzdGluZycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZScpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Jlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgcmVzdWx0JylcbiAgICB9XG4gIH1cblxuICAvLyAtLSBQdWJsaWMgSW50ZXJmYWNlXG5cbiAgZGVjb2RlRmlyc3QgKGlucHV0KSB7XG4gICAgdGhpcy5fZGVjb2RlKGlucHV0KVxuXG4gICAgcmV0dXJuIHRoaXMuX3Jlc1swXVxuICB9XG5cbiAgZGVjb2RlQWxsIChpbnB1dCkge1xuICAgIHRoaXMuX2RlY29kZShpbnB1dClcblxuICAgIHJldHVybiB0aGlzLl9yZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgdGhlIGZpcnN0IGNib3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd9IGlucHV0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jPSdoZXgnXSAtIEVuY29kaW5nIHVzZWQgaWYgYSBzdHJpbmcgaXMgcGFzc2VkLlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHN0YXRpYyBkZWNvZGUgKGlucHV0LCBlbmMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgaW5wdXQgPSBCdWZmZXIuZnJvbShpbnB1dCwgZW5jIHx8ICdoZXgnKVxuICAgIH1cblxuICAgIGNvbnN0IGRlYyA9IG5ldyBEZWNvZGVyKHsgc2l6ZTogaW5wdXQubGVuZ3RoIH0pXG4gICAgcmV0dXJuIGRlYy5kZWNvZGVGaXJzdChpbnB1dClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYWxsIGNib3Igb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBpbnB1dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2VuYz0naGV4J10gLSBFbmNvZGluZyB1c2VkIGlmIGEgc3RyaW5nIGlzIHBhc3NlZC5cbiAgICogQHJldHVybnMge0FycmF5PCo+fVxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbCAoaW5wdXQsIGVuYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKGlucHV0LCBlbmMgfHwgJ2hleCcpXG4gICAgfVxuXG4gICAgY29uc3QgZGVjID0gbmV3IERlY29kZXIoeyBzaXplOiBpbnB1dC5sZW5ndGggfSlcbiAgICByZXR1cm4gZGVjLmRlY29kZUFsbChpbnB1dClcbiAgfVxufVxuXG5EZWNvZGVyLmRlY29kZUZpcnN0ID0gRGVjb2Rlci5kZWNvZGVcblxubW9kdWxlLmV4cG9ydHMgPSBEZWNvZGVyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/borc/src/decoder.js\n"));

/***/ }),

/***/ "../../../node_modules/borc/src/diagnose.js":
/*!**************************************************!*\
  !*** ../../../node_modules/borc/src/diagnose.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"../../../node_modules/buffer/index.js\")\nconst Decoder = __webpack_require__(/*! ./decoder */ \"../../../node_modules/borc/src/decoder.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"../../../node_modules/borc/src/utils.js\")\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n */\nclass Diagnose extends Decoder {\n  createTag (tagNumber, value) {\n    return `${tagNumber}(${value})`\n  }\n\n  createInt (val) {\n    return super.createInt(val).toString()\n  }\n\n  createInt32 (f, g) {\n    return super.createInt32(f, g).toString()\n  }\n\n  createInt64 (f1, f2, g1, g2) {\n    return super.createInt64(f1, f2, g1, g2).toString()\n  }\n\n  createInt32Neg (f, g) {\n    return super.createInt32Neg(f, g).toString()\n  }\n\n  createInt64Neg (f1, f2, g1, g2) {\n    return super.createInt64Neg(f1, f2, g1, g2).toString()\n  }\n\n  createTrue () {\n    return 'true'\n  }\n\n  createFalse () {\n    return 'false'\n  }\n\n  createFloat (val) {\n    const fl = super.createFloat(val)\n    if (utils.isNegativeZero(val)) {\n      return '-0_1'\n    }\n\n    return `${fl}_1`\n  }\n\n  createFloatSingle (a, b, c, d) {\n    const fl = super.createFloatSingle(a, b, c, d)\n    return `${fl}_2`\n  }\n\n  createFloatDouble (a, b, c, d, e, f, g, h) {\n    const fl = super.createFloatDouble(a, b, c, d, e, f, g, h)\n    return `${fl}_3`\n  }\n\n  createByteString (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n    return `h'${val}`\n  }\n\n  createByteStringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createByteStringFromHeap(start, end)\n    )).toString('hex')\n\n    return `h'${val}'`\n  }\n\n  createInfinity () {\n    return 'Infinity_1'\n  }\n\n  createInfinityNeg () {\n    return '-Infinity_1'\n  }\n\n  createNaN () {\n    return 'NaN_1'\n  }\n\n  createNaNNeg () {\n    return '-NaN_1'\n  }\n\n  createNull () {\n    return 'null'\n  }\n\n  createUndefined () {\n    return 'undefined'\n  }\n\n  createSimpleUnassigned (val) {\n    return `simple(${val})`\n  }\n\n  createArray (arr, len) {\n    const val = super.createArray(arr, len)\n\n    if (len === -1) {\n      // indefinite\n      return `[_ ${val.join(', ')}]`\n    }\n\n    return `[${val.join(', ')}]`\n  }\n\n  createMap (map, len) {\n    const val = super.createMap(map)\n    const list = Array.from(val.keys())\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${list}}`\n    }\n\n    return `{${list}}`\n  }\n\n  createObject (obj, len) {\n    const val = super.createObject(obj)\n    const map = Object.keys(val)\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${map}}`\n    }\n\n    return `{${map}}`\n  }\n\n  createUtf8String (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n\n    return `\"${val}\"`\n  }\n\n  createUtf8StringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createUtf8StringFromHeap(start, end)\n    )).toString('utf8')\n\n    return `\"${val}\"`\n  }\n\n  static diagnose (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Diagnose()\n    return dec.decodeFirst(input)\n  }\n}\n\nmodule.exports = Diagnose\n\nfunction collectObject (val) {\n  return (acc, key) => {\n    if (acc) {\n      return `${acc}, ${key}: ${val[key]}`\n    }\n    return `${key}: ${val[key]}`\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2RpYWdub3NlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMscURBQVE7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsNERBQVc7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVUsR0FBRyxNQUFNO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsR0FBRztBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxHQUFHO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxjQUFjLEdBQUc7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsSUFBSTtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQzs7QUFFQSxlQUFlLGVBQWU7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLElBQUksTUFBTTtBQUN6Qjs7QUFFQSxhQUFhLEVBQUUsTUFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsSUFBSSxLQUFLO0FBQ3hCOztBQUVBLGFBQWEsRUFBRSxLQUFLO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsSUFBSTtBQUN2Qjs7QUFFQSxlQUFlLElBQUk7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxJQUFJO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJLElBQUksSUFBSSxJQUFJLFNBQVM7QUFDekM7QUFDQSxjQUFjLElBQUksSUFBSSxTQUFTO0FBQy9CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9ib3JjL3NyYy9kaWFnbm9zZS5qcz8xMDIyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IERlY29kZXIgPSByZXF1aXJlKCcuL2RlY29kZXInKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcblxuLyoqXG4gKiBPdXRwdXQgdGhlIGRpYWdub3N0aWMgZm9ybWF0IGZyb20gYSBzdHJlYW0gb2YgQ0JPUiBieXRlcy5cbiAqXG4gKi9cbmNsYXNzIERpYWdub3NlIGV4dGVuZHMgRGVjb2RlciB7XG4gIGNyZWF0ZVRhZyAodGFnTnVtYmVyLCB2YWx1ZSkge1xuICAgIHJldHVybiBgJHt0YWdOdW1iZXJ9KCR7dmFsdWV9KWBcbiAgfVxuXG4gIGNyZWF0ZUludCAodmFsKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUludCh2YWwpLnRvU3RyaW5nKClcbiAgfVxuXG4gIGNyZWF0ZUludDMyIChmLCBnKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUludDMyKGYsIGcpLnRvU3RyaW5nKClcbiAgfVxuXG4gIGNyZWF0ZUludDY0IChmMSwgZjIsIGcxLCBnMikge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGVJbnQ2NChmMSwgZjIsIGcxLCBnMikudG9TdHJpbmcoKVxuICB9XG5cbiAgY3JlYXRlSW50MzJOZWcgKGYsIGcpIHtcbiAgICByZXR1cm4gc3VwZXIuY3JlYXRlSW50MzJOZWcoZiwgZykudG9TdHJpbmcoKVxuICB9XG5cbiAgY3JlYXRlSW50NjROZWcgKGYxLCBmMiwgZzEsIGcyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZUludDY0TmVnKGYxLCBmMiwgZzEsIGcyKS50b1N0cmluZygpXG4gIH1cblxuICBjcmVhdGVUcnVlICgpIHtcbiAgICByZXR1cm4gJ3RydWUnXG4gIH1cblxuICBjcmVhdGVGYWxzZSAoKSB7XG4gICAgcmV0dXJuICdmYWxzZSdcbiAgfVxuXG4gIGNyZWF0ZUZsb2F0ICh2YWwpIHtcbiAgICBjb25zdCBmbCA9IHN1cGVyLmNyZWF0ZUZsb2F0KHZhbClcbiAgICBpZiAodXRpbHMuaXNOZWdhdGl2ZVplcm8odmFsKSkge1xuICAgICAgcmV0dXJuICctMF8xJ1xuICAgIH1cblxuICAgIHJldHVybiBgJHtmbH1fMWBcbiAgfVxuXG4gIGNyZWF0ZUZsb2F0U2luZ2xlIChhLCBiLCBjLCBkKSB7XG4gICAgY29uc3QgZmwgPSBzdXBlci5jcmVhdGVGbG9hdFNpbmdsZShhLCBiLCBjLCBkKVxuICAgIHJldHVybiBgJHtmbH1fMmBcbiAgfVxuXG4gIGNyZWF0ZUZsb2F0RG91YmxlIChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XG4gICAgY29uc3QgZmwgPSBzdXBlci5jcmVhdGVGbG9hdERvdWJsZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKVxuICAgIHJldHVybiBgJHtmbH1fM2BcbiAgfVxuXG4gIGNyZWF0ZUJ5dGVTdHJpbmcgKHJhdywgbGVuKSB7XG4gICAgY29uc3QgdmFsID0gcmF3LmpvaW4oJywgJylcblxuICAgIGlmIChsZW4gPT09IC0xKSB7XG4gICAgICByZXR1cm4gYChfICR7dmFsfSlgXG4gICAgfVxuICAgIHJldHVybiBgaCcke3ZhbH1gXG4gIH1cblxuICBjcmVhdGVCeXRlU3RyaW5nRnJvbUhlYXAgKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCB2YWwgPSAoQnVmZmVyLmZyb20oXG4gICAgICBzdXBlci5jcmVhdGVCeXRlU3RyaW5nRnJvbUhlYXAoc3RhcnQsIGVuZClcbiAgICApKS50b1N0cmluZygnaGV4JylcblxuICAgIHJldHVybiBgaCcke3ZhbH0nYFxuICB9XG5cbiAgY3JlYXRlSW5maW5pdHkgKCkge1xuICAgIHJldHVybiAnSW5maW5pdHlfMSdcbiAgfVxuXG4gIGNyZWF0ZUluZmluaXR5TmVnICgpIHtcbiAgICByZXR1cm4gJy1JbmZpbml0eV8xJ1xuICB9XG5cbiAgY3JlYXRlTmFOICgpIHtcbiAgICByZXR1cm4gJ05hTl8xJ1xuICB9XG5cbiAgY3JlYXRlTmFOTmVnICgpIHtcbiAgICByZXR1cm4gJy1OYU5fMSdcbiAgfVxuXG4gIGNyZWF0ZU51bGwgKCkge1xuICAgIHJldHVybiAnbnVsbCdcbiAgfVxuXG4gIGNyZWF0ZVVuZGVmaW5lZCAoKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnXG4gIH1cblxuICBjcmVhdGVTaW1wbGVVbmFzc2lnbmVkICh2YWwpIHtcbiAgICByZXR1cm4gYHNpbXBsZSgke3ZhbH0pYFxuICB9XG5cbiAgY3JlYXRlQXJyYXkgKGFyciwgbGVuKSB7XG4gICAgY29uc3QgdmFsID0gc3VwZXIuY3JlYXRlQXJyYXkoYXJyLCBsZW4pXG5cbiAgICBpZiAobGVuID09PSAtMSkge1xuICAgICAgLy8gaW5kZWZpbml0ZVxuICAgICAgcmV0dXJuIGBbXyAke3ZhbC5qb2luKCcsICcpfV1gXG4gICAgfVxuXG4gICAgcmV0dXJuIGBbJHt2YWwuam9pbignLCAnKX1dYFxuICB9XG5cbiAgY3JlYXRlTWFwIChtYXAsIGxlbikge1xuICAgIGNvbnN0IHZhbCA9IHN1cGVyLmNyZWF0ZU1hcChtYXApXG4gICAgY29uc3QgbGlzdCA9IEFycmF5LmZyb20odmFsLmtleXMoKSlcbiAgICAgIC5yZWR1Y2UoY29sbGVjdE9iamVjdCh2YWwpLCAnJylcblxuICAgIGlmIChsZW4gPT09IC0xKSB7XG4gICAgICByZXR1cm4gYHtfICR7bGlzdH19YFxuICAgIH1cblxuICAgIHJldHVybiBgeyR7bGlzdH19YFxuICB9XG5cbiAgY3JlYXRlT2JqZWN0IChvYmosIGxlbikge1xuICAgIGNvbnN0IHZhbCA9IHN1cGVyLmNyZWF0ZU9iamVjdChvYmopXG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmtleXModmFsKVxuICAgICAgLnJlZHVjZShjb2xsZWN0T2JqZWN0KHZhbCksICcnKVxuXG4gICAgaWYgKGxlbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBge18gJHttYXB9fWBcbiAgICB9XG5cbiAgICByZXR1cm4gYHske21hcH19YFxuICB9XG5cbiAgY3JlYXRlVXRmOFN0cmluZyAocmF3LCBsZW4pIHtcbiAgICBjb25zdCB2YWwgPSByYXcuam9pbignLCAnKVxuXG4gICAgaWYgKGxlbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBgKF8gJHt2YWx9KWBcbiAgICB9XG5cbiAgICByZXR1cm4gYFwiJHt2YWx9XCJgXG4gIH1cblxuICBjcmVhdGVVdGY4U3RyaW5nRnJvbUhlYXAgKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCB2YWwgPSAoQnVmZmVyLmZyb20oXG4gICAgICBzdXBlci5jcmVhdGVVdGY4U3RyaW5nRnJvbUhlYXAoc3RhcnQsIGVuZClcbiAgICApKS50b1N0cmluZygndXRmOCcpXG5cbiAgICByZXR1cm4gYFwiJHt2YWx9XCJgXG4gIH1cblxuICBzdGF0aWMgZGlhZ25vc2UgKGlucHV0LCBlbmMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgaW5wdXQgPSBCdWZmZXIuZnJvbShpbnB1dCwgZW5jIHx8ICdoZXgnKVxuICAgIH1cblxuICAgIGNvbnN0IGRlYyA9IG5ldyBEaWFnbm9zZSgpXG4gICAgcmV0dXJuIGRlYy5kZWNvZGVGaXJzdChpbnB1dClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpYWdub3NlXG5cbmZ1bmN0aW9uIGNvbGxlY3RPYmplY3QgKHZhbCkge1xuICByZXR1cm4gKGFjYywga2V5KSA9PiB7XG4gICAgaWYgKGFjYykge1xuICAgICAgcmV0dXJuIGAke2FjY30sICR7a2V5fTogJHt2YWxba2V5XX1gXG4gICAgfVxuICAgIHJldHVybiBgJHtrZXl9OiAke3ZhbFtrZXldfWBcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/borc/src/diagnose.js\n"));

/***/ }),

/***/ "../../../node_modules/borc/src/encoder.js":
/*!*************************************************!*\
  !*** ../../../node_modules/borc/src/encoder.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"../../../node_modules/buffer/index.js\")\nconst { URL } = __webpack_require__(/*! iso-url */ \"../../../node_modules/iso-url/index.js\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"../../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst utils = __webpack_require__(/*! ./utils */ \"../../../node_modules/borc/src/utils.js\")\nconst constants = __webpack_require__(/*! ./constants */ \"../../../node_modules/borc/src/constants.js\")\nconst MT = constants.MT\nconst NUMBYTES = constants.NUMBYTES\nconst SHIFT32 = constants.SHIFT32\nconst SYMS = constants.SYMS\nconst TAG = constants.TAG\nconst HALF = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.TWO\nconst FLOAT = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.FOUR\nconst DOUBLE = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.EIGHT\nconst TRUE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.TRUE\nconst FALSE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.FALSE\nconst UNDEFINED = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.UNDEFINED\nconst NULL = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.NULL\n\nconst MAXINT_BN = new Bignumber('0x20000000000000')\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\n\nfunction toType (obj) {\n  // [object Type]\n  // --------8---1\n  return ({}).toString.call(obj).slice(8, -1)\n}\n\n/**\n * Transform JavaScript values into CBOR bytes\n *\n */\nclass Encoder {\n  /**\n   * @param {Object} [options={}]\n   * @param {function(Buffer)} options.stream\n   */\n  constructor (options) {\n    options = options || {}\n\n    this.streaming = typeof options.stream === 'function'\n    this.onData = options.stream\n\n    this.semanticTypes = [\n      [URL, this._pushUrl],\n      [Bignumber, this._pushBigNumber]\n    ]\n\n    const addTypes = options.genTypes || []\n    const len = addTypes.length\n    for (let i = 0; i < len; i++) {\n      this.addSemanticType(\n        addTypes[i][0],\n        addTypes[i][1]\n      )\n    }\n\n    this._reset()\n  }\n\n  addSemanticType (type, fun) {\n    const len = this.semanticTypes.length\n    for (let i = 0; i < len; i++) {\n      const typ = this.semanticTypes[i][0]\n      if (typ === type) {\n        const old = this.semanticTypes[i][1]\n        this.semanticTypes[i][1] = fun\n        return old\n      }\n    }\n    this.semanticTypes.push([type, fun])\n    return null\n  }\n\n  push (val) {\n    if (!val) {\n      return true\n    }\n\n    this.result[this.offset] = val\n    this.resultMethod[this.offset] = 0\n    this.resultLength[this.offset] = val.length\n    this.offset++\n\n    if (this.streaming) {\n      this.onData(this.finalize())\n    }\n\n    return true\n  }\n\n  pushWrite (val, method, len) {\n    this.result[this.offset] = val\n    this.resultMethod[this.offset] = method\n    this.resultLength[this.offset] = len\n    this.offset++\n\n    if (this.streaming) {\n      this.onData(this.finalize())\n    }\n\n    return true\n  }\n\n  _pushUInt8 (val) {\n    return this.pushWrite(val, 1, 1)\n  }\n\n  _pushUInt16BE (val) {\n    return this.pushWrite(val, 2, 2)\n  }\n\n  _pushUInt32BE (val) {\n    return this.pushWrite(val, 3, 4)\n  }\n\n  _pushDoubleBE (val) {\n    return this.pushWrite(val, 4, 8)\n  }\n\n  _pushNaN () {\n    return this.push(BUF_NAN)\n  }\n\n  _pushInfinity (obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  _pushFloat (obj) {\n    const b2 = Buffer.allocUnsafe(2)\n\n    if (utils.writeHalf(b2, obj)) {\n      if (utils.parseHalf(b2) === obj) {\n        return this._pushUInt8(HALF) && this.push(b2)\n      }\n    }\n\n    const b4 = Buffer.allocUnsafe(4)\n    b4.writeFloatBE(obj, 0)\n    if (b4.readFloatBE(0) === obj) {\n      return this._pushUInt8(FLOAT) && this.push(b4)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  _pushInt (obj, mt, orig) {\n    const m = mt << 5\n    if (obj < 24) {\n      return this._pushUInt8(m | obj)\n    }\n\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n    }\n\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n    }\n\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n    }\n\n    if (obj <= Number.MAX_SAFE_INTEGER) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n        this._pushUInt32BE(obj % SHIFT32)\n    }\n\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig)\n    }\n\n    return this._pushFloat(obj)\n  }\n\n  _pushIntNum (obj) {\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    } else {\n      return this._pushInt(obj, MT.POS_INT)\n    }\n  }\n\n  _pushNumber (obj) {\n    switch (false) {\n      case (obj === obj): // eslint-disable-line\n        return this._pushNaN(obj)\n      case isFinite(obj):\n        return this._pushInfinity(obj)\n      case ((obj % 1) !== 0):\n        return this._pushIntNum(obj)\n      default:\n        return this._pushFloat(obj)\n    }\n  }\n\n  _pushString (obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len)\n  }\n\n  _pushBoolean (obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  _pushUndefined (obj) {\n    return this._pushUInt8(UNDEFINED)\n  }\n\n  _pushArray (gen, obj) {\n    const len = obj.length\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushTag (tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  _pushDate (gen, obj) {\n    // Round date, to get seconds since 1970-01-01 00:00:00 as defined in\n    // Sec. 2.4.1 and get a possibly more compact encoding. Note that it is\n    // still allowed to encode fractions of seconds which can be achieved by\n    // changing overwriting the encode function for Date objects.\n    return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1000))\n  }\n\n  _pushBuffer (gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  _pushNoFilter (gen, obj) {\n    return gen._pushBuffer(gen, obj.slice())\n  }\n\n  _pushRegexp (gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  _pushSet (gen, obj) {\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  _pushUrl (gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format())\n  }\n\n  _pushBigint (obj) {\n    let tag = TAG.POS_BIGINT\n    if (obj.isNegative()) {\n      obj = obj.negated().minus(1)\n      tag = TAG.NEG_BIGINT\n    }\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = '0' + str\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && this._pushBuffer(this, buf)\n  }\n\n  _pushBigNumber (gen, obj) {\n    if (obj.isNaN()) {\n      return gen._pushNaN()\n    }\n    if (!obj.isFinite()) {\n      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity)\n    }\n    if (obj.isInteger()) {\n      return gen._pushBigint(obj)\n    }\n    if (!(gen._pushTag(TAG.DECIMAL_FRAC) &&\n      gen._pushInt(2, MT.ARRAY))) {\n      return false\n    }\n\n    const dec = obj.decimalPlaces()\n    const slide = obj.multipliedBy(new Bignumber(10).pow(dec))\n    if (!gen._pushIntNum(-dec)) {\n      return false\n    }\n    if (slide.abs().isLessThan(MAXINT_BN)) {\n      return gen._pushIntNum(slide.toNumber())\n    } else {\n      return gen._pushBigint(slide)\n    }\n  }\n\n  _pushMap (gen, obj) {\n    if (!gen._pushInt(obj.size, MT.MAP)) {\n      return false\n    }\n\n    return this._pushRawMap(\n      obj.size,\n      Array.from(obj)\n    )\n  }\n\n  _pushObject (obj) {\n    if (!obj) {\n      return this._pushUInt8(NULL)\n    }\n\n    var len = this.semanticTypes.length\n    for (var i = 0; i < len; i++) {\n      if (obj instanceof this.semanticTypes[i][0]) {\n        return this.semanticTypes[i][1].call(obj, this, obj)\n      }\n    }\n\n    var f = obj.encodeCBOR\n    if (typeof f === 'function') {\n      return f.call(obj, this)\n    }\n\n    var keys = Object.keys(obj)\n    var keyLength = keys.length\n    if (!this._pushInt(keyLength, MT.MAP)) {\n      return false\n    }\n\n    return this._pushRawMap(\n      keyLength,\n      keys.map((k) => [k, obj[k]])\n    )\n  }\n\n  _pushRawMap (len, map) {\n    // Sort keys for canoncialization\n    // 1. encode key\n    // 2. shorter key comes before longer key\n    // 3. same length keys are sorted with lower\n    //    byte value before higher\n\n    map = map.map(function (a) {\n      a[0] = Encoder.encode(a[0])\n      return a\n    }).sort(utils.keySorter)\n\n    for (var j = 0; j < len; j++) {\n      if (!this.push(map[j][0])) {\n        return false\n      }\n\n      if (!this.pushAny(map[j][1])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Alias for `.pushAny`\n   *\n   * @param {*} obj\n   * @returns {boolean} true on success\n   */\n  write (obj) {\n    return this.pushAny(obj)\n  }\n\n  /**\n   * Push any supported type onto the encoded stream\n   *\n   * @param {any} obj\n   * @returns {boolean} true on success\n   */\n  pushAny (obj) {\n    var typ = toType(obj)\n\n    switch (typ) {\n      case 'Number':\n        return this._pushNumber(obj)\n      case 'String':\n        return this._pushString(obj)\n      case 'Boolean':\n        return this._pushBoolean(obj)\n      case 'Object':\n        return this._pushObject(obj)\n      case 'Array':\n        return this._pushArray(this, obj)\n      case 'Uint8Array':\n        return this._pushBuffer(this, Buffer.isBuffer(obj) ? obj : Buffer.from(obj))\n      case 'Null':\n        return this._pushUInt8(NULL)\n      case 'Undefined':\n        return this._pushUndefined(obj)\n      case 'Map':\n        return this._pushMap(this, obj)\n      case 'Set':\n        return this._pushSet(this, obj)\n      case 'URL':\n        return this._pushUrl(this, obj)\n      case 'BigNumber':\n        return this._pushBigNumber(this, obj)\n      case 'Date':\n        return this._pushDate(this, obj)\n      case 'RegExp':\n        return this._pushRegexp(this, obj)\n      case 'Symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushObject(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new Error('Unknown symbol: ' + obj.toString())\n        }\n      default:\n        throw new Error('Unknown type: ' + typeof obj + ', ' + (obj ? obj.toString() : ''))\n    }\n  }\n\n  finalize () {\n    if (this.offset === 0) {\n      return null\n    }\n\n    var result = this.result\n    var resultLength = this.resultLength\n    var resultMethod = this.resultMethod\n    var offset = this.offset\n\n    // Determine the size of the buffer\n    var size = 0\n    var i = 0\n\n    for (; i < offset; i++) {\n      size += resultLength[i]\n    }\n\n    var res = Buffer.allocUnsafe(size)\n    var index = 0\n    var length = 0\n\n    // Write the content into the result buffer\n    for (i = 0; i < offset; i++) {\n      length = resultLength[i]\n\n      switch (resultMethod[i]) {\n        case 0:\n          result[i].copy(res, index)\n          break\n        case 1:\n          res.writeUInt8(result[i], index, true)\n          break\n        case 2:\n          res.writeUInt16BE(result[i], index, true)\n          break\n        case 3:\n          res.writeUInt32BE(result[i], index, true)\n          break\n        case 4:\n          res.writeDoubleBE(result[i], index, true)\n          break\n        case 5:\n          res.write(result[i], index, length, 'utf8')\n          break\n        default:\n          throw new Error('unkown method')\n      }\n\n      index += length\n    }\n\n    var tmp = res\n\n    this._reset()\n\n    return tmp\n  }\n\n  _reset () {\n    this.result = []\n    this.resultMethod = []\n    this.resultLength = []\n    this.offset = 0\n  }\n\n  /**\n   * Encode the given value\n   * @param {*} o\n   * @returns {Buffer}\n   */\n  static encode (o) {\n    const enc = new Encoder()\n    const ret = enc.pushAny(o)\n    if (!ret) {\n      throw new Error('Failed to encode input')\n    }\n\n    return enc.finalize()\n  }\n}\n\nmodule.exports = Encoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2VuY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxREFBUTtBQUNuQyxRQUFRLE1BQU0sRUFBRSxtQkFBTyxDQUFDLHVEQUFTO0FBQ2pDLGtCQUFrQixzR0FBaUM7O0FBRW5ELGNBQWMsbUJBQU8sQ0FBQyx3REFBUztBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUSxXQUFXO0FBQ2hDLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9ib3JjL3NyYy9lbmNvZGVyLmpzPzA3ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ2lzby11cmwnKVxuY29uc3QgQmlnbnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJykuQmlnTnVtYmVyXG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBNVCA9IGNvbnN0YW50cy5NVFxuY29uc3QgTlVNQllURVMgPSBjb25zdGFudHMuTlVNQllURVNcbmNvbnN0IFNISUZUMzIgPSBjb25zdGFudHMuU0hJRlQzMlxuY29uc3QgU1lNUyA9IGNvbnN0YW50cy5TWU1TXG5jb25zdCBUQUcgPSBjb25zdGFudHMuVEFHXG5jb25zdCBIQUxGID0gKGNvbnN0YW50cy5NVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBjb25zdGFudHMuTlVNQllURVMuVFdPXG5jb25zdCBGTE9BVCA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLk5VTUJZVEVTLkZPVVJcbmNvbnN0IERPVUJMRSA9IChjb25zdGFudHMuTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgY29uc3RhbnRzLk5VTUJZVEVTLkVJR0hUXG5jb25zdCBUUlVFID0gKGNvbnN0YW50cy5NVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBjb25zdGFudHMuU0lNUExFLlRSVUVcbmNvbnN0IEZBTFNFID0gKGNvbnN0YW50cy5NVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBjb25zdGFudHMuU0lNUExFLkZBTFNFXG5jb25zdCBVTkRFRklORUQgPSAoY29uc3RhbnRzLk1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IGNvbnN0YW50cy5TSU1QTEUuVU5ERUZJTkVEXG5jb25zdCBOVUxMID0gKGNvbnN0YW50cy5NVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBjb25zdGFudHMuU0lNUExFLk5VTExcblxuY29uc3QgTUFYSU5UX0JOID0gbmV3IEJpZ251bWJlcignMHgyMDAwMDAwMDAwMDAwMCcpXG5jb25zdCBCVUZfTkFOID0gQnVmZmVyLmZyb20oJ2Y5N2UwMCcsICdoZXgnKVxuY29uc3QgQlVGX0lORl9ORUcgPSBCdWZmZXIuZnJvbSgnZjlmYzAwJywgJ2hleCcpXG5jb25zdCBCVUZfSU5GX1BPUyA9IEJ1ZmZlci5mcm9tKCdmOTdjMDAnLCAnaGV4JylcblxuZnVuY3Rpb24gdG9UeXBlIChvYmopIHtcbiAgLy8gW29iamVjdCBUeXBlXVxuICAvLyAtLS0tLS0tLTgtLS0xXG4gIHJldHVybiAoe30pLnRvU3RyaW5nLmNhbGwob2JqKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gSmF2YVNjcmlwdCB2YWx1ZXMgaW50byBDQk9SIGJ5dGVzXG4gKlxuICovXG5jbGFzcyBFbmNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihCdWZmZXIpfSBvcHRpb25zLnN0cmVhbVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgdGhpcy5zdHJlYW1pbmcgPSB0eXBlb2Ygb3B0aW9ucy5zdHJlYW0gPT09ICdmdW5jdGlvbidcbiAgICB0aGlzLm9uRGF0YSA9IG9wdGlvbnMuc3RyZWFtXG5cbiAgICB0aGlzLnNlbWFudGljVHlwZXMgPSBbXG4gICAgICBbVVJMLCB0aGlzLl9wdXNoVXJsXSxcbiAgICAgIFtCaWdudW1iZXIsIHRoaXMuX3B1c2hCaWdOdW1iZXJdXG4gICAgXVxuXG4gICAgY29uc3QgYWRkVHlwZXMgPSBvcHRpb25zLmdlblR5cGVzIHx8IFtdXG4gICAgY29uc3QgbGVuID0gYWRkVHlwZXMubGVuZ3RoXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5hZGRTZW1hbnRpY1R5cGUoXG4gICAgICAgIGFkZFR5cGVzW2ldWzBdLFxuICAgICAgICBhZGRUeXBlc1tpXVsxXVxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuX3Jlc2V0KClcbiAgfVxuXG4gIGFkZFNlbWFudGljVHlwZSAodHlwZSwgZnVuKSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5zZW1hbnRpY1R5cGVzLmxlbmd0aFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHR5cCA9IHRoaXMuc2VtYW50aWNUeXBlc1tpXVswXVxuICAgICAgaWYgKHR5cCA9PT0gdHlwZSkge1xuICAgICAgICBjb25zdCBvbGQgPSB0aGlzLnNlbWFudGljVHlwZXNbaV1bMV1cbiAgICAgICAgdGhpcy5zZW1hbnRpY1R5cGVzW2ldWzFdID0gZnVuXG4gICAgICAgIHJldHVybiBvbGRcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZW1hbnRpY1R5cGVzLnB1c2goW3R5cGUsIGZ1bl0pXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHB1c2ggKHZhbCkge1xuICAgIGlmICghdmFsKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMucmVzdWx0W3RoaXMub2Zmc2V0XSA9IHZhbFxuICAgIHRoaXMucmVzdWx0TWV0aG9kW3RoaXMub2Zmc2V0XSA9IDBcbiAgICB0aGlzLnJlc3VsdExlbmd0aFt0aGlzLm9mZnNldF0gPSB2YWwubGVuZ3RoXG4gICAgdGhpcy5vZmZzZXQrK1xuXG4gICAgaWYgKHRoaXMuc3RyZWFtaW5nKSB7XG4gICAgICB0aGlzLm9uRGF0YSh0aGlzLmZpbmFsaXplKCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHB1c2hXcml0ZSAodmFsLCBtZXRob2QsIGxlbikge1xuICAgIHRoaXMucmVzdWx0W3RoaXMub2Zmc2V0XSA9IHZhbFxuICAgIHRoaXMucmVzdWx0TWV0aG9kW3RoaXMub2Zmc2V0XSA9IG1ldGhvZFxuICAgIHRoaXMucmVzdWx0TGVuZ3RoW3RoaXMub2Zmc2V0XSA9IGxlblxuICAgIHRoaXMub2Zmc2V0KytcblxuICAgIGlmICh0aGlzLnN0cmVhbWluZykge1xuICAgICAgdGhpcy5vbkRhdGEodGhpcy5maW5hbGl6ZSgpKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBfcHVzaFVJbnQ4ICh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoV3JpdGUodmFsLCAxLCAxKVxuICB9XG5cbiAgX3B1c2hVSW50MTZCRSAodmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFdyaXRlKHZhbCwgMiwgMilcbiAgfVxuXG4gIF9wdXNoVUludDMyQkUgKHZhbCkge1xuICAgIHJldHVybiB0aGlzLnB1c2hXcml0ZSh2YWwsIDMsIDQpXG4gIH1cblxuICBfcHVzaERvdWJsZUJFICh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoV3JpdGUodmFsLCA0LCA4KVxuICB9XG5cbiAgX3B1c2hOYU4gKCkge1xuICAgIHJldHVybiB0aGlzLnB1c2goQlVGX05BTilcbiAgfVxuXG4gIF9wdXNoSW5maW5pdHkgKG9iaikge1xuICAgIGNvbnN0IGhhbGYgPSAob2JqIDwgMCkgPyBCVUZfSU5GX05FRyA6IEJVRl9JTkZfUE9TXG4gICAgcmV0dXJuIHRoaXMucHVzaChoYWxmKVxuICB9XG5cbiAgX3B1c2hGbG9hdCAob2JqKSB7XG4gICAgY29uc3QgYjIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMilcblxuICAgIGlmICh1dGlscy53cml0ZUhhbGYoYjIsIG9iaikpIHtcbiAgICAgIGlmICh1dGlscy5wYXJzZUhhbGYoYjIpID09PSBvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChIQUxGKSAmJiB0aGlzLnB1c2goYjIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYjQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNClcbiAgICBiNC53cml0ZUZsb2F0QkUob2JqLCAwKVxuICAgIGlmIChiNC5yZWFkRmxvYXRCRSgwKSA9PT0gb2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KEZMT0FUKSAmJiB0aGlzLnB1c2goYjQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChET1VCTEUpICYmIHRoaXMuX3B1c2hEb3VibGVCRShvYmopXG4gIH1cblxuICBfcHVzaEludCAob2JqLCBtdCwgb3JpZykge1xuICAgIGNvbnN0IG0gPSBtdCA8PCA1XG4gICAgaWYgKG9iaiA8IDI0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KG0gfCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iaiA8PSAweGZmKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KG0gfCBOVU1CWVRFUy5PTkUpICYmIHRoaXMuX3B1c2hVSW50OChvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iaiA8PSAweGZmZmYpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgobSB8IE5VTUJZVEVTLlRXTykgJiYgdGhpcy5fcHVzaFVJbnQxNkJFKG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgobSB8IE5VTUJZVEVTLkZPVVIpICYmIHRoaXMuX3B1c2hVSW50MzJCRShvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iaiA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChtIHwgTlVNQllURVMuRUlHSFQpICYmXG4gICAgICAgIHRoaXMuX3B1c2hVSW50MzJCRShNYXRoLmZsb29yKG9iaiAvIFNISUZUMzIpKSAmJlxuICAgICAgICB0aGlzLl9wdXNoVUludDMyQkUob2JqICUgU0hJRlQzMilcbiAgICB9XG5cbiAgICBpZiAobXQgPT09IE1ULk5FR19JTlQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoRmxvYXQob3JpZylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHVzaEZsb2F0KG9iailcbiAgfVxuXG4gIF9wdXNoSW50TnVtIChvYmopIHtcbiAgICBpZiAob2JqIDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hJbnQoLW9iaiAtIDEsIE1ULk5FR19JTlQsIG9iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hJbnQob2JqLCBNVC5QT1NfSU5UKVxuICAgIH1cbiAgfVxuXG4gIF9wdXNoTnVtYmVyIChvYmopIHtcbiAgICBzd2l0Y2ggKGZhbHNlKSB7XG4gICAgICBjYXNlIChvYmogPT09IG9iaik6IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hOYU4ob2JqKVxuICAgICAgY2FzZSBpc0Zpbml0ZShvYmopOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEluZmluaXR5KG9iailcbiAgICAgIGNhc2UgKChvYmogJSAxKSAhPT0gMCk6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoSW50TnVtKG9iailcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoRmxvYXQob2JqKVxuICAgIH1cbiAgfVxuXG4gIF9wdXNoU3RyaW5nIChvYmopIHtcbiAgICBjb25zdCBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChvYmosICd1dGY4JylcbiAgICByZXR1cm4gdGhpcy5fcHVzaEludChsZW4sIE1ULlVURjhfU1RSSU5HKSAmJiB0aGlzLnB1c2hXcml0ZShvYmosIDUsIGxlbilcbiAgfVxuXG4gIF9wdXNoQm9vbGVhbiAob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChvYmogPyBUUlVFIDogRkFMU0UpXG4gIH1cblxuICBfcHVzaFVuZGVmaW5lZCAob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChVTkRFRklORUQpXG4gIH1cblxuICBfcHVzaEFycmF5IChnZW4sIG9iaikge1xuICAgIGNvbnN0IGxlbiA9IG9iai5sZW5ndGhcbiAgICBpZiAoIWdlbi5fcHVzaEludChsZW4sIE1ULkFSUkFZKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGlmICghZ2VuLnB1c2hBbnkob2JqW2pdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIF9wdXNoVGFnICh0YWcpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaEludCh0YWcsIE1ULlRBRylcbiAgfVxuXG4gIF9wdXNoRGF0ZSAoZ2VuLCBvYmopIHtcbiAgICAvLyBSb3VuZCBkYXRlLCB0byBnZXQgc2Vjb25kcyBzaW5jZSAxOTcwLTAxLTAxIDAwOjAwOjAwIGFzIGRlZmluZWQgaW5cbiAgICAvLyBTZWMuIDIuNC4xIGFuZCBnZXQgYSBwb3NzaWJseSBtb3JlIGNvbXBhY3QgZW5jb2RpbmcuIE5vdGUgdGhhdCBpdCBpc1xuICAgIC8vIHN0aWxsIGFsbG93ZWQgdG8gZW5jb2RlIGZyYWN0aW9ucyBvZiBzZWNvbmRzIHdoaWNoIGNhbiBiZSBhY2hpZXZlZCBieVxuICAgIC8vIGNoYW5naW5nIG92ZXJ3cml0aW5nIHRoZSBlbmNvZGUgZnVuY3Rpb24gZm9yIERhdGUgb2JqZWN0cy5cbiAgICByZXR1cm4gZ2VuLl9wdXNoVGFnKFRBRy5EQVRFX0VQT0NIKSAmJiBnZW4ucHVzaEFueShNYXRoLnJvdW5kKG9iaiAvIDEwMDApKVxuICB9XG5cbiAgX3B1c2hCdWZmZXIgKGdlbiwgb2JqKSB7XG4gICAgcmV0dXJuIGdlbi5fcHVzaEludChvYmoubGVuZ3RoLCBNVC5CWVRFX1NUUklORykgJiYgZ2VuLnB1c2gob2JqKVxuICB9XG5cbiAgX3B1c2hOb0ZpbHRlciAoZ2VuLCBvYmopIHtcbiAgICByZXR1cm4gZ2VuLl9wdXNoQnVmZmVyKGdlbiwgb2JqLnNsaWNlKCkpXG4gIH1cblxuICBfcHVzaFJlZ2V4cCAoZ2VuLCBvYmopIHtcbiAgICByZXR1cm4gZ2VuLl9wdXNoVGFnKFRBRy5SRUdFWFApICYmIGdlbi5wdXNoQW55KG9iai5zb3VyY2UpXG4gIH1cblxuICBfcHVzaFNldCAoZ2VuLCBvYmopIHtcbiAgICBpZiAoIWdlbi5fcHVzaEludChvYmouc2l6ZSwgTVQuQVJSQVkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgZm9yIChjb25zdCB4IG9mIG9iaikge1xuICAgICAgaWYgKCFnZW4ucHVzaEFueSh4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIF9wdXNoVXJsIChnZW4sIG9iaikge1xuICAgIHJldHVybiBnZW4uX3B1c2hUYWcoVEFHLlVSSSkgJiYgZ2VuLnB1c2hBbnkob2JqLmZvcm1hdCgpKVxuICB9XG5cbiAgX3B1c2hCaWdpbnQgKG9iaikge1xuICAgIGxldCB0YWcgPSBUQUcuUE9TX0JJR0lOVFxuICAgIGlmIChvYmouaXNOZWdhdGl2ZSgpKSB7XG4gICAgICBvYmogPSBvYmoubmVnYXRlZCgpLm1pbnVzKDEpXG4gICAgICB0YWcgPSBUQUcuTkVHX0JJR0lOVFxuICAgIH1cbiAgICBsZXQgc3RyID0gb2JqLnRvU3RyaW5nKDE2KVxuICAgIGlmIChzdHIubGVuZ3RoICUgMikge1xuICAgICAgc3RyID0gJzAnICsgc3RyXG4gICAgfVxuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHN0ciwgJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hUYWcodGFnKSAmJiB0aGlzLl9wdXNoQnVmZmVyKHRoaXMsIGJ1ZilcbiAgfVxuXG4gIF9wdXNoQmlnTnVtYmVyIChnZW4sIG9iaikge1xuICAgIGlmIChvYmouaXNOYU4oKSkge1xuICAgICAgcmV0dXJuIGdlbi5fcHVzaE5hTigpXG4gICAgfVxuICAgIGlmICghb2JqLmlzRmluaXRlKCkpIHtcbiAgICAgIHJldHVybiBnZW4uX3B1c2hJbmZpbml0eShvYmouaXNOZWdhdGl2ZSgpID8gLUluZmluaXR5IDogSW5maW5pdHkpXG4gICAgfVxuICAgIGlmIChvYmouaXNJbnRlZ2VyKCkpIHtcbiAgICAgIHJldHVybiBnZW4uX3B1c2hCaWdpbnQob2JqKVxuICAgIH1cbiAgICBpZiAoIShnZW4uX3B1c2hUYWcoVEFHLkRFQ0lNQUxfRlJBQykgJiZcbiAgICAgIGdlbi5fcHVzaEludCgyLCBNVC5BUlJBWSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBkZWMgPSBvYmouZGVjaW1hbFBsYWNlcygpXG4gICAgY29uc3Qgc2xpZGUgPSBvYmoubXVsdGlwbGllZEJ5KG5ldyBCaWdudW1iZXIoMTApLnBvdyhkZWMpKVxuICAgIGlmICghZ2VuLl9wdXNoSW50TnVtKC1kZWMpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKHNsaWRlLmFicygpLmlzTGVzc1RoYW4oTUFYSU5UX0JOKSkge1xuICAgICAgcmV0dXJuIGdlbi5fcHVzaEludE51bShzbGlkZS50b051bWJlcigpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2VuLl9wdXNoQmlnaW50KHNsaWRlKVxuICAgIH1cbiAgfVxuXG4gIF9wdXNoTWFwIChnZW4sIG9iaikge1xuICAgIGlmICghZ2VuLl9wdXNoSW50KG9iai5zaXplLCBNVC5NQVApKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHVzaFJhd01hcChcbiAgICAgIG9iai5zaXplLFxuICAgICAgQXJyYXkuZnJvbShvYmopXG4gICAgKVxuICB9XG5cbiAgX3B1c2hPYmplY3QgKG9iaikge1xuICAgIGlmICghb2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KE5VTEwpXG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IHRoaXMuc2VtYW50aWNUeXBlcy5sZW5ndGhcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgdGhpcy5zZW1hbnRpY1R5cGVzW2ldWzBdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbWFudGljVHlwZXNbaV1bMV0uY2FsbChvYmosIHRoaXMsIG9iailcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZiA9IG9iai5lbmNvZGVDQk9SXG4gICAgaWYgKHR5cGVvZiBmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZi5jYWxsKG9iaiwgdGhpcylcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iailcbiAgICB2YXIga2V5TGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICBpZiAoIXRoaXMuX3B1c2hJbnQoa2V5TGVuZ3RoLCBNVC5NQVApKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHVzaFJhd01hcChcbiAgICAgIGtleUxlbmd0aCxcbiAgICAgIGtleXMubWFwKChrKSA9PiBbaywgb2JqW2tdXSlcbiAgICApXG4gIH1cblxuICBfcHVzaFJhd01hcCAobGVuLCBtYXApIHtcbiAgICAvLyBTb3J0IGtleXMgZm9yIGNhbm9uY2lhbGl6YXRpb25cbiAgICAvLyAxLiBlbmNvZGUga2V5XG4gICAgLy8gMi4gc2hvcnRlciBrZXkgY29tZXMgYmVmb3JlIGxvbmdlciBrZXlcbiAgICAvLyAzLiBzYW1lIGxlbmd0aCBrZXlzIGFyZSBzb3J0ZWQgd2l0aCBsb3dlclxuICAgIC8vICAgIGJ5dGUgdmFsdWUgYmVmb3JlIGhpZ2hlclxuXG4gICAgbWFwID0gbWFwLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgYVswXSA9IEVuY29kZXIuZW5jb2RlKGFbMF0pXG4gICAgICByZXR1cm4gYVxuICAgIH0pLnNvcnQodXRpbHMua2V5U29ydGVyKVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgaWYgKCF0aGlzLnB1c2gobWFwW2pdWzBdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnB1c2hBbnkobWFwW2pdWzFdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBgLnB1c2hBbnlgXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb2JqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlIChvYmopIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoQW55KG9iailcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGFueSBzdXBwb3J0ZWQgdHlwZSBvbnRvIHRoZSBlbmNvZGVkIHN0cmVhbVxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gb2JqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHB1c2hBbnkgKG9iaikge1xuICAgIHZhciB0eXAgPSB0b1R5cGUob2JqKVxuXG4gICAgc3dpdGNoICh0eXApIHtcbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoTnVtYmVyKG9iailcbiAgICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoU3RyaW5nKG9iailcbiAgICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEJvb2xlYW4ob2JqKVxuICAgICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hPYmplY3Qob2JqKVxuICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEFycmF5KHRoaXMsIG9iailcbiAgICAgIGNhc2UgJ1VpbnQ4QXJyYXknOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEJ1ZmZlcih0aGlzLCBCdWZmZXIuaXNCdWZmZXIob2JqKSA/IG9iaiA6IEJ1ZmZlci5mcm9tKG9iaikpXG4gICAgICBjYXNlICdOdWxsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChOVUxMKVxuICAgICAgY2FzZSAnVW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVbmRlZmluZWQob2JqKVxuICAgICAgY2FzZSAnTWFwJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hNYXAodGhpcywgb2JqKVxuICAgICAgY2FzZSAnU2V0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hTZXQodGhpcywgb2JqKVxuICAgICAgY2FzZSAnVVJMJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVcmwodGhpcywgb2JqKVxuICAgICAgY2FzZSAnQmlnTnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hCaWdOdW1iZXIodGhpcywgb2JqKVxuICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoRGF0ZSh0aGlzLCBvYmopXG4gICAgICBjYXNlICdSZWdFeHAnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFJlZ2V4cCh0aGlzLCBvYmopXG4gICAgICBjYXNlICdTeW1ib2wnOlxuICAgICAgICBzd2l0Y2ggKG9iaikge1xuICAgICAgICAgIGNhc2UgU1lNUy5OVUxMOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hPYmplY3QobnVsbClcbiAgICAgICAgICBjYXNlIFNZTVMuVU5ERUZJTkVEOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVbmRlZmluZWQodW5kZWZpbmVkKVxuICAgICAgICAgIC8vIFRPRE86IEFkZCBwbHVnZ2FibGUgc3VwcG9ydCBmb3Igb3RoZXIgc3ltYm9sc1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc3ltYm9sOiAnICsgb2JqLnRvU3RyaW5nKCkpXG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgdHlwZW9mIG9iaiArICcsICcgKyAob2JqID8gb2JqLnRvU3RyaW5nKCkgOiAnJykpXG4gICAgfVxuICB9XG5cbiAgZmluYWxpemUgKCkge1xuICAgIGlmICh0aGlzLm9mZnNldCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRcbiAgICB2YXIgcmVzdWx0TGVuZ3RoID0gdGhpcy5yZXN1bHRMZW5ndGhcbiAgICB2YXIgcmVzdWx0TWV0aG9kID0gdGhpcy5yZXN1bHRNZXRob2RcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXRcblxuICAgIC8vIERldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyXG4gICAgdmFyIHNpemUgPSAwXG4gICAgdmFyIGkgPSAwXG5cbiAgICBmb3IgKDsgaSA8IG9mZnNldDsgaSsrKSB7XG4gICAgICBzaXplICs9IHJlc3VsdExlbmd0aFtpXVxuICAgIH1cblxuICAgIHZhciByZXMgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSlcbiAgICB2YXIgaW5kZXggPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcblxuICAgIC8vIFdyaXRlIHRoZSBjb250ZW50IGludG8gdGhlIHJlc3VsdCBidWZmZXJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2Zmc2V0OyBpKyspIHtcbiAgICAgIGxlbmd0aCA9IHJlc3VsdExlbmd0aFtpXVxuXG4gICAgICBzd2l0Y2ggKHJlc3VsdE1ldGhvZFtpXSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmVzdWx0W2ldLmNvcHkocmVzLCBpbmRleClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmVzLndyaXRlVUludDgocmVzdWx0W2ldLCBpbmRleCwgdHJ1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmVzLndyaXRlVUludDE2QkUocmVzdWx0W2ldLCBpbmRleCwgdHJ1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmVzLndyaXRlVUludDMyQkUocmVzdWx0W2ldLCBpbmRleCwgdHJ1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmVzLndyaXRlRG91YmxlQkUocmVzdWx0W2ldLCBpbmRleCwgdHJ1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVzLndyaXRlKHJlc3VsdFtpXSwgaW5kZXgsIGxlbmd0aCwgJ3V0ZjgnKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtvd24gbWV0aG9kJylcbiAgICAgIH1cblxuICAgICAgaW5kZXggKz0gbGVuZ3RoXG4gICAgfVxuXG4gICAgdmFyIHRtcCA9IHJlc1xuXG4gICAgdGhpcy5fcmVzZXQoKVxuXG4gICAgcmV0dXJuIHRtcFxuICB9XG5cbiAgX3Jlc2V0ICgpIHtcbiAgICB0aGlzLnJlc3VsdCA9IFtdXG4gICAgdGhpcy5yZXN1bHRNZXRob2QgPSBbXVxuICAgIHRoaXMucmVzdWx0TGVuZ3RoID0gW11cbiAgICB0aGlzLm9mZnNldCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgdGhlIGdpdmVuIHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gb1xuICAgKiBAcmV0dXJucyB7QnVmZmVyfVxuICAgKi9cbiAgc3RhdGljIGVuY29kZSAobykge1xuICAgIGNvbnN0IGVuYyA9IG5ldyBFbmNvZGVyKClcbiAgICBjb25zdCByZXQgPSBlbmMucHVzaEFueShvKVxuICAgIGlmICghcmV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBlbmNvZGUgaW5wdXQnKVxuICAgIH1cblxuICAgIHJldHVybiBlbmMuZmluYWxpemUoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRW5jb2RlclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/borc/src/encoder.js\n"));

/***/ }),

/***/ "../../../node_modules/borc/src/index.js":
/*!***********************************************!*\
  !*** ../../../node_modules/borc/src/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n// exports.Commented = require('./commented')\nexports.Diagnose = __webpack_require__(/*! ./diagnose */ \"../../../node_modules/borc/src/diagnose.js\")\nexports.Decoder = __webpack_require__(/*! ./decoder */ \"../../../node_modules/borc/src/decoder.js\")\nexports.Encoder = __webpack_require__(/*! ./encoder */ \"../../../node_modules/borc/src/encoder.js\")\nexports.Simple = __webpack_require__(/*! ./simple */ \"../../../node_modules/borc/src/simple.js\")\nexports.Tagged = __webpack_require__(/*! ./tagged */ \"../../../node_modules/borc/src/tagged.js\")\n\n// exports.comment = exports.Commented.comment\nexports.decodeAll = exports.Decoder.decodeAll\nexports.decodeFirst = exports.Decoder.decodeFirst\nexports.diagnose = exports.Diagnose.diagnose\nexports.encode = exports.Encoder.encode\nexports.decode = exports.Decoder.decode\n\nexports.leveldb = {\n  decode: exports.Decoder.decodeAll,\n  encode: exports.Encoder.encode,\n  buffer: true,\n  name: 'cbor'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0Esc0dBQXdDO0FBQ3hDLG1HQUFzQztBQUN0QyxtR0FBc0M7QUFDdEMsZ0dBQW9DO0FBQ3BDLGdHQUFvQzs7QUFFcEM7QUFDQSxpQkFBaUI7QUFDakIsbUJBQW1CO0FBQ25CLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsY0FBYzs7QUFFZCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL2luZGV4LmpzP2FkY2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIGV4cG9ydHMuQ29tbWVudGVkID0gcmVxdWlyZSgnLi9jb21tZW50ZWQnKVxuZXhwb3J0cy5EaWFnbm9zZSA9IHJlcXVpcmUoJy4vZGlhZ25vc2UnKVxuZXhwb3J0cy5EZWNvZGVyID0gcmVxdWlyZSgnLi9kZWNvZGVyJylcbmV4cG9ydHMuRW5jb2RlciA9IHJlcXVpcmUoJy4vZW5jb2RlcicpXG5leHBvcnRzLlNpbXBsZSA9IHJlcXVpcmUoJy4vc2ltcGxlJylcbmV4cG9ydHMuVGFnZ2VkID0gcmVxdWlyZSgnLi90YWdnZWQnKVxuXG4vLyBleHBvcnRzLmNvbW1lbnQgPSBleHBvcnRzLkNvbW1lbnRlZC5jb21tZW50XG5leHBvcnRzLmRlY29kZUFsbCA9IGV4cG9ydHMuRGVjb2Rlci5kZWNvZGVBbGxcbmV4cG9ydHMuZGVjb2RlRmlyc3QgPSBleHBvcnRzLkRlY29kZXIuZGVjb2RlRmlyc3RcbmV4cG9ydHMuZGlhZ25vc2UgPSBleHBvcnRzLkRpYWdub3NlLmRpYWdub3NlXG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuRW5jb2Rlci5lbmNvZGVcbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5EZWNvZGVyLmRlY29kZVxuXG5leHBvcnRzLmxldmVsZGIgPSB7XG4gIGRlY29kZTogZXhwb3J0cy5EZWNvZGVyLmRlY29kZUFsbCxcbiAgZW5jb2RlOiBleHBvcnRzLkVuY29kZXIuZW5jb2RlLFxuICBidWZmZXI6IHRydWUsXG4gIG5hbWU6ICdjYm9yJ1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/borc/src/index.js\n"));

/***/ }),

/***/ "../../../node_modules/borc/src/simple.js":
/*!************************************************!*\
  !*** ../../../node_modules/borc/src/simple.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst constants = __webpack_require__(/*! ./constants */ \"../../../node_modules/borc/src/constants.js\")\nconst MT = constants.MT\nconst SIMPLE = constants.SIMPLE\nconst SYMS = constants.SYMS\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {integer} value - the simple value's integer value\n   */\n  constructor (value) {\n    if (typeof value !== 'number') {\n      throw new Error('Invalid Simple type: ' + (typeof value))\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error('value must be a small positive integer: ' + value)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  toString () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Debug string for simple value\n   *\n   * @returns {string} simple(value)\n   */\n  inspect () {\n    return 'simple(' + this.value + ')'\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj - object to test\n   * @returns {bool} - is it Simple?\n   */\n  static isSimple (obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {Number} val - the CBOR additional info to convert\n   * @param {bool} hasParent - Does the CBOR item have a parent?\n   * @returns {(null|undefined|Boolean|Symbol)} - the decoded value\n   */\n  static decode (val, hasParent) {\n    if (hasParent == null) {\n      hasParent = true\n    }\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (hasParent) {\n          return null\n        } else {\n          return SYMS.NULL\n        }\n      case SIMPLE.UNDEFINED:\n        if (hasParent) {\n          return undefined\n        } else {\n          return SYMS.UNDEFINED\n        }\n      case -1:\n        if (!hasParent) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL3NpbXBsZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0IsbUJBQU8sQ0FBQyxnRUFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsTUFBTTtBQUNuQixlQUFlLGlDQUFpQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL3NpbXBsZS5qcz9lMDY2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBNVCA9IGNvbnN0YW50cy5NVFxuY29uc3QgU0lNUExFID0gY29uc3RhbnRzLlNJTVBMRVxuY29uc3QgU1lNUyA9IGNvbnN0YW50cy5TWU1TXG5cbi8qKlxuICogQSBDQk9SIFNpbXBsZSBWYWx1ZSB0aGF0IGRvZXMgbm90IG1hcCBvbnRvIGEga25vd24gY29uc3RhbnQuXG4gKi9cbmNsYXNzIFNpbXBsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFNpbXBsZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSAtIHRoZSBzaW1wbGUgdmFsdWUncyBpbnRlZ2VyIHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFNpbXBsZSB0eXBlOiAnICsgKHR5cGVvZiB2YWx1ZSkpXG4gICAgfVxuICAgIGlmICgodmFsdWUgPCAwKSB8fCAodmFsdWUgPiAyNTUpIHx8ICgodmFsdWUgfCAwKSAhPT0gdmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYSBzbWFsbCBwb3NpdGl2ZSBpbnRlZ2VyOiAnICsgdmFsdWUpXG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIERlYnVnIHN0cmluZyBmb3Igc2ltcGxlIHZhbHVlXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHNpbXBsZSh2YWx1ZSlcbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gJ3NpbXBsZSgnICsgdGhpcy52YWx1ZSArICcpJ1xuICB9XG5cbiAgLyoqXG4gICAqIERlYnVnIHN0cmluZyBmb3Igc2ltcGxlIHZhbHVlXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHNpbXBsZSh2YWx1ZSlcbiAgICovXG4gIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAnc2ltcGxlKCcgKyB0aGlzLnZhbHVlICsgJyknXG4gIH1cblxuICAvKipcbiAgICogUHVzaCB0aGUgc2ltcGxlIHZhbHVlIG9udG8gdGhlIENCT1Igc3RyZWFtXG4gICAqXG4gICAqIEBwYXJhbSB7Y2Jvci5FbmNvZGVyfSBnZW4gVGhlIGdlbmVyYXRvciB0byBwdXNoIG9udG9cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGVuY29kZUNCT1IgKGdlbikge1xuICAgIHJldHVybiBnZW4uX3B1c2hJbnQodGhpcy52YWx1ZSwgTVQuU0lNUExFX0ZMT0FUKVxuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSBnaXZlbiBvYmplY3QgYSBTaW1wbGU/XG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBvYmogLSBvYmplY3QgdG8gdGVzdFxuICAgKiBAcmV0dXJucyB7Ym9vbH0gLSBpcyBpdCBTaW1wbGU/XG4gICAqL1xuICBzdGF0aWMgaXNTaW1wbGUgKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBTaW1wbGVcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgZnJvbSB0aGUgQ0JPUiBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGludG8gYSBKYXZhU2NyaXB0IHZhbHVlLlxuICAgKiBJZiB0aGUgQ0JPUiBpdGVtIGhhcyBubyBwYXJlbnQsIHJldHVybiBhIFwic2FmZVwiIHN5bWJvbCBpbnN0ZWFkIG9mXG4gICAqIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgc28gdGhhdCB0aGUgdmFsdWUgY2FuIGJlIHBhc3NlZCB0aHJvdWdoIGFcbiAgICogc3RyZWFtIGluIG9iamVjdCBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsIC0gdGhlIENCT1IgYWRkaXRpb25hbCBpbmZvIHRvIGNvbnZlcnRcbiAgICogQHBhcmFtIHtib29sfSBoYXNQYXJlbnQgLSBEb2VzIHRoZSBDQk9SIGl0ZW0gaGF2ZSBhIHBhcmVudD9cbiAgICogQHJldHVybnMgeyhudWxsfHVuZGVmaW5lZHxCb29sZWFufFN5bWJvbCl9IC0gdGhlIGRlY29kZWQgdmFsdWVcbiAgICovXG4gIHN0YXRpYyBkZWNvZGUgKHZhbCwgaGFzUGFyZW50KSB7XG4gICAgaWYgKGhhc1BhcmVudCA9PSBudWxsKSB7XG4gICAgICBoYXNQYXJlbnQgPSB0cnVlXG4gICAgfVxuICAgIHN3aXRjaCAodmFsKSB7XG4gICAgICBjYXNlIFNJTVBMRS5GQUxTRTpcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICBjYXNlIFNJTVBMRS5UUlVFOlxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgY2FzZSBTSU1QTEUuTlVMTDpcbiAgICAgICAgaWYgKGhhc1BhcmVudCkge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFNZTVMuTlVMTFxuICAgICAgICB9XG4gICAgICBjYXNlIFNJTVBMRS5VTkRFRklORUQ6XG4gICAgICAgIGlmIChoYXNQYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFNZTVMuVU5ERUZJTkVEXG4gICAgICAgIH1cbiAgICAgIGNhc2UgLTE6XG4gICAgICAgIGlmICghaGFzUGFyZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEJSRUFLJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1lNUy5CUkVBS1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGUodmFsKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/borc/src/simple.js\n"));

/***/ }),

/***/ "../../../node_modules/borc/src/tagged.js":
/*!************************************************!*\
  !*** ../../../node_modules/borc/src/tagged.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {Number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} err - the error that was thrown parsing the tag, or null\n   */\n  constructor (tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error('Tag must be a positive integer: ' + this.tag)\n    }\n  }\n\n  /**\n   * Convert to a String\n   *\n   * @returns {String} string of the form '1(2)'\n   */\n  toString () {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {cbor.Encoder} gen The generator to push onto\n   * @returns {number}\n   */\n  encodeCBOR (gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n  convert (converters) {\n    var er, f\n    f = converters != null ? converters[this.tag] : undefined\n    if (typeof f !== 'function') {\n      f = Tagged['_tag' + this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(Tagged, this.value)\n    } catch (error) {\n      er = error\n      this.err = er\n      return this\n    }\n  }\n}\n\nmodule.exports = Tagged\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL3RhZ2dlZC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLFNBQVMsR0FBRywyQkFBMkI7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9ib3JjL3NyYy90YWdnZWQuanM/ZDgxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBBIENCT1IgdGFnZ2VkIGl0ZW0sIHdoZXJlIHRoZSB0YWcgZG9lcyBub3QgaGF2ZSBzZW1hbnRpY3Mgc3BlY2lmaWVkIGF0IHRoZVxuICogbW9tZW50LCBvciB0aG9zZSBzZW1hbnRpY3MgdGhyZXcgYW4gZXJyb3IgZHVyaW5nIHBhcnNpbmcuIFR5cGljYWxseSB0aGlzIHdpbGxcbiAqIGJlIGFuIGV4dGVuc2lvbiBwb2ludCB5b3UncmUgbm90IHlldCBleHBlY3RpbmcuXG4gKi9cbmNsYXNzIFRhZ2dlZCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFRhZ2dlZC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRhZyAtIHRoZSBudW1iZXIgb2YgdGhlIHRhZ1xuICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSB0aGUgdmFsdWUgaW5zaWRlIHRoZSB0YWdcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gdGhlIGVycm9yIHRoYXQgd2FzIHRocm93biBwYXJzaW5nIHRoZSB0YWcsIG9yIG51bGxcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YWcsIHZhbHVlLCBlcnIpIHtcbiAgICB0aGlzLnRhZyA9IHRhZ1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuZXJyID0gZXJyXG4gICAgaWYgKHR5cGVvZiB0aGlzLnRhZyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWcgdHlwZSAoJyArICh0eXBlb2YgdGhpcy50YWcpICsgJyknKVxuICAgIH1cbiAgICBpZiAoKHRoaXMudGFnIDwgMCkgfHwgKCh0aGlzLnRhZyB8IDApICE9PSB0aGlzLnRhZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGFnIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyOiAnICsgdGhpcy50YWcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdG8gYSBTdHJpbmdcbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIG9mIHRoZSBmb3JtICcxKDIpJ1xuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiBgJHt0aGlzLnRhZ30oJHtKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlKX0pYFxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggdGhlIHNpbXBsZSB2YWx1ZSBvbnRvIHRoZSBDQk9SIHN0cmVhbVxuICAgKlxuICAgKiBAcGFyYW0ge2Nib3IuRW5jb2Rlcn0gZ2VuIFRoZSBnZW5lcmF0b3IgdG8gcHVzaCBvbnRvXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBlbmNvZGVDQk9SIChnZW4pIHtcbiAgICBnZW4uX3B1c2hUYWcodGhpcy50YWcpXG4gICAgcmV0dXJuIGdlbi5wdXNoQW55KHRoaXMudmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogSWYgd2UgaGF2ZSBhIGNvbnZlcnRlciBmb3IgdGhpcyB0eXBlLCBkbyB0aGUgY29udmVyc2lvbi4gIFNvbWUgY29udmVydGVyc1xuICAgKiBhcmUgYnVpbHQtaW4uICBBZGRpdGlvbmFsIG9uZXMgY2FuIGJlIHBhc3NlZCBpbi4gIElmIHlvdSB3YW50IHRvIHJlbW92ZVxuICAgKiBhIGJ1aWx0LWluIGNvbnZlcnRlciwgcGFzcyBhIGNvbnZlcnRlciBpbiB3aG9zZSB2YWx1ZSBpcyAnbnVsbCcgaW5zdGVhZFxuICAgKiBvZiBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udmVydGVycyAtIGtleXMgaW4gdGhlIG9iamVjdCBhcmUgYSB0YWcgbnVtYmVyLCB0aGUgdmFsdWVcbiAgICogICBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIGRlY29kZWQgQ0JPUiBhbmQgcmV0dXJucyBhIEphdmFTY3JpcHQgdmFsdWVcbiAgICogICBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZS4gIFRocm93IGFuIGV4Y2VwdGlvbiBpbiB0aGUgZnVuY3Rpb24gb24gZXJyb3JzLlxuICAgKiBAcmV0dXJucyB7YW55fSAtIHRoZSBjb252ZXJ0ZWQgaXRlbVxuICAgKi9cbiAgY29udmVydCAoY29udmVydGVycykge1xuICAgIHZhciBlciwgZlxuICAgIGYgPSBjb252ZXJ0ZXJzICE9IG51bGwgPyBjb252ZXJ0ZXJzW3RoaXMudGFnXSA6IHVuZGVmaW5lZFxuICAgIGlmICh0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZiA9IFRhZ2dlZFsnX3RhZycgKyB0aGlzLnRhZ11cbiAgICAgIGlmICh0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGYuY2FsbChUYWdnZWQsIHRoaXMudmFsdWUpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVyID0gZXJyb3JcbiAgICAgIHRoaXMuZXJyID0gZXJcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGFnZ2VkXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/borc/src/tagged.js\n"));

/***/ }),

/***/ "../../../node_modules/borc/src/utils.js":
/*!***********************************************!*\
  !*** ../../../node_modules/borc/src/utils.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"../../../node_modules/buffer/index.js\")\nconst Bignumber = (__webpack_require__(/*! bignumber.js */ \"../../../node_modules/bignumber.js/bignumber.js\").BigNumber)\n\nconst constants = __webpack_require__(/*! ./constants */ \"../../../node_modules/borc/src/constants.js\")\nconst SHIFT32 = constants.SHIFT32\nconst SHIFT16 = constants.SHIFT16\nconst MAX_SAFE_HIGH = 0x1fffff\n\nexports.parseHalf = function parseHalf (buf) {\n  var exp, mant, sign\n  sign = buf[0] & 0x80 ? -1 : 1\n  exp = (buf[0] & 0x7C) >> 2\n  mant = ((buf[0] & 0x03) << 8) | buf[1]\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308)\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant)\n  }\n}\n\nfunction toHex (n) {\n  if (n < 16) {\n    return '0' + n.toString(16)\n  }\n\n  return n.toString(16)\n}\n\nexports.arrayBufferToBignumber = function (buf) {\n  const len = buf.byteLength\n  let res = ''\n  for (let i = 0; i < len; i++) {\n    res += toHex(buf[i])\n  }\n\n  return new Bignumber(res, 16)\n}\n\n// convert an Object into a Map\nexports.buildMap = (obj) => {\n  const res = new Map()\n  const keys = Object.keys(obj)\n  const length = keys.length\n  for (let i = 0; i < length; i++) {\n    res.set(keys[i], obj[keys[i]])\n  }\n  return res\n}\n\nexports.buildInt32 = (f, g) => {\n  return f * SHIFT16 + g\n}\n\nexports.buildInt64 = (f1, f2, g1, g2) => {\n  const f = exports.buildInt32(f1, f2)\n  const g = exports.buildInt32(g1, g2)\n\n  if (f > MAX_SAFE_HIGH) {\n    return new Bignumber(f).times(SHIFT32).plus(g)\n  } else {\n    return (f * SHIFT32) + g\n  }\n}\n\nexports.writeHalf = function writeHalf (buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4)\n  u32.writeFloatBE(half, 0)\n  const u = u32.readUInt32BE(0)\n\n  // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits are 0, we won't lose anything in the conversion\n  if ((u & 0x1FFF) !== 0) {\n    return false\n  }\n\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  var s16 = (u >> 16) & 0x8000 // top bit is sign\n  const exp = (u >> 23) & 0xff // then 5 bits of exponent\n  const mant = u & 0x7fffff\n\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13)\n\n  //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n  //     if (mant & ((1 << (126 - exp)) - 1))\n  //       goto float32;         /* loss of precision */\n  //     s16 += ((mant + 0x800000) >> (126 - exp));\n  } else if ((exp >= 103) && (exp < 113)) {\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp))\n\n    //   } else if (exp == 255 && mant == 0) { /* Inf */\n    //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n  //   } else\n  //     goto float32;           /* loss of range */\n  } else {\n    return false\n  }\n\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16, 0)\n  return true\n}\n\nexports.keySorter = function (a, b) {\n  var lenA = a[0].byteLength\n  var lenB = b[0].byteLength\n\n  if (lenA > lenB) {\n    return 1\n  }\n\n  if (lenB > lenA) {\n    return -1\n  }\n\n  return a[0].compare(b[0])\n}\n\n// Adapted from http://www.2ality.com/2012/03/signedzero.html\nexports.isNegativeZero = (x) => {\n  return x === 0 && (1 / x < 0)\n}\n\nexports.nextPowerOf2 = (n) => {\n  let count = 0\n  // First n in the below condition is for\n  // the case where n is 0\n  if (n && !(n & (n - 1))) {\n    return n\n  }\n\n  while (n !== 0) {\n    n >>= 1\n    count += 1\n  }\n\n  return 1 << count\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JvcmMvc3JjL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMscURBQVE7QUFDbkMsa0JBQWtCLHNHQUFpQzs7QUFFbkQsa0JBQWtCLG1CQUFPLENBQUMsZ0VBQWE7QUFDdkM7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxvQ0FBb0M7QUFDL0M7O0FBRUE7O0FBRUEsU0FBUztBQUNULGlDQUFpQztBQUNqQyxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYm9yYy9zcmMvdXRpbHMuanM/NDczNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBCaWdudW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKS5CaWdOdW1iZXJcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgU0hJRlQzMiA9IGNvbnN0YW50cy5TSElGVDMyXG5jb25zdCBTSElGVDE2ID0gY29uc3RhbnRzLlNISUZUMTZcbmNvbnN0IE1BWF9TQUZFX0hJR0ggPSAweDFmZmZmZlxuXG5leHBvcnRzLnBhcnNlSGFsZiA9IGZ1bmN0aW9uIHBhcnNlSGFsZiAoYnVmKSB7XG4gIHZhciBleHAsIG1hbnQsIHNpZ25cbiAgc2lnbiA9IGJ1ZlswXSAmIDB4ODAgPyAtMSA6IDFcbiAgZXhwID0gKGJ1ZlswXSAmIDB4N0MpID4+IDJcbiAgbWFudCA9ICgoYnVmWzBdICYgMHgwMykgPDwgOCkgfCBidWZbMV1cbiAgaWYgKCFleHApIHtcbiAgICByZXR1cm4gc2lnbiAqIDUuOTYwNDY0NDc3NTM5MDYyNWUtOCAqIG1hbnRcbiAgfSBlbHNlIGlmIChleHAgPT09IDB4MWYpIHtcbiAgICByZXR1cm4gc2lnbiAqIChtYW50ID8gMCAvIDAgOiAyZTMwOClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2lnbiAqIE1hdGgucG93KDIsIGV4cCAtIDI1KSAqICgxMDI0ICsgbWFudClcbiAgfVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSB7XG4gICAgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIH1cblxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZXhwb3J0cy5hcnJheUJ1ZmZlclRvQmlnbnVtYmVyID0gZnVuY3Rpb24gKGJ1Zikge1xuICBjb25zdCBsZW4gPSBidWYuYnl0ZUxlbmd0aFxuICBsZXQgcmVzID0gJydcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlcyArPSB0b0hleChidWZbaV0pXG4gIH1cblxuICByZXR1cm4gbmV3IEJpZ251bWJlcihyZXMsIDE2KVxufVxuXG4vLyBjb252ZXJ0IGFuIE9iamVjdCBpbnRvIGEgTWFwXG5leHBvcnRzLmJ1aWxkTWFwID0gKG9iaikgPT4ge1xuICBjb25zdCByZXMgPSBuZXcgTWFwKClcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iailcbiAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlcy5zZXQoa2V5c1tpXSwgb2JqW2tleXNbaV1dKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZXhwb3J0cy5idWlsZEludDMyID0gKGYsIGcpID0+IHtcbiAgcmV0dXJuIGYgKiBTSElGVDE2ICsgZ1xufVxuXG5leHBvcnRzLmJ1aWxkSW50NjQgPSAoZjEsIGYyLCBnMSwgZzIpID0+IHtcbiAgY29uc3QgZiA9IGV4cG9ydHMuYnVpbGRJbnQzMihmMSwgZjIpXG4gIGNvbnN0IGcgPSBleHBvcnRzLmJ1aWxkSW50MzIoZzEsIGcyKVxuXG4gIGlmIChmID4gTUFYX1NBRkVfSElHSCkge1xuICAgIHJldHVybiBuZXcgQmlnbnVtYmVyKGYpLnRpbWVzKFNISUZUMzIpLnBsdXMoZylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGYgKiBTSElGVDMyKSArIGdcbiAgfVxufVxuXG5leHBvcnRzLndyaXRlSGFsZiA9IGZ1bmN0aW9uIHdyaXRlSGFsZiAoYnVmLCBoYWxmKSB7XG4gIC8vIGFzc3VtZSAwLCAtMCwgTmFOLCBJbmZpbml0eSwgYW5kIC1JbmZpbml0eSBoYXZlIGFscmVhZHkgYmVlbiBjYXVnaHRcblxuICAvLyBIQUNLOiBldmVyeW9uZSBzZXR0bGUgaW4uICBUaGlzIGlzbid0IGdvaW5nIHRvIGJlIHByZXR0eS5cbiAgLy8gVHJhbnNsYXRlIGNuLWNib3IncyBDIGNvZGUgKGZyb20gQ2Fyc3RlbiBCb3JtYW4pOlxuXG4gIC8vIHVpbnQzMl90IGJlMzI7XG4gIC8vIHVpbnQxNl90IGJlMTYsIHUxNjtcbiAgLy8gdW5pb24ge1xuICAvLyAgIGZsb2F0IGY7XG4gIC8vICAgdWludDMyX3QgdTtcbiAgLy8gfSB1MzI7XG4gIC8vIHUzMi5mID0gZmxvYXRfdmFsO1xuXG4gIGNvbnN0IHUzMiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KVxuICB1MzIud3JpdGVGbG9hdEJFKGhhbGYsIDApXG4gIGNvbnN0IHUgPSB1MzIucmVhZFVJbnQzMkJFKDApXG5cbiAgLy8gaWYgKCh1MzIudSAmIDB4MUZGRikgPT0gMCkgeyAvKiB3b3J0aCB0cnlpbmcgaGFsZiAqL1xuXG4gIC8vIGhpbGRqajogSWYgdGhlIGxvd2VyIDEzIGJpdHMgYXJlIDAsIHdlIHdvbid0IGxvc2UgYW55dGhpbmcgaW4gdGhlIGNvbnZlcnNpb25cbiAgaWYgKCh1ICYgMHgxRkZGKSAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gICBpbnQgczE2ID0gKHUzMi51ID4+IDE2KSAmIDB4ODAwMDtcbiAgLy8gICBpbnQgZXhwID0gKHUzMi51ID4+IDIzKSAmIDB4ZmY7XG4gIC8vICAgaW50IG1hbnQgPSB1MzIudSAmIDB4N2ZmZmZmO1xuXG4gIHZhciBzMTYgPSAodSA+PiAxNikgJiAweDgwMDAgLy8gdG9wIGJpdCBpcyBzaWduXG4gIGNvbnN0IGV4cCA9ICh1ID4+IDIzKSAmIDB4ZmYgLy8gdGhlbiA1IGJpdHMgb2YgZXhwb25lbnRcbiAgY29uc3QgbWFudCA9IHUgJiAweDdmZmZmZlxuXG4gIC8vICAgaWYgKGV4cCA9PSAwICYmIG1hbnQgPT0gMClcbiAgLy8gICAgIDsgICAgICAgICAgICAgIC8qIDAuMCwgLTAuMCAqL1xuXG4gIC8vIGhpbGRqajogemVyb3MgYWxyZWFkeSBoYW5kbGVkLiAgQXNzZXJ0IGlmIHlvdSBkb24ndCBiZWxpZXZlIG1lLlxuXG4gIC8vICAgZWxzZSBpZiAoZXhwID49IDExMyAmJiBleHAgPD0gMTQyKSAvKiBub3JtYWxpemVkICovXG4gIC8vICAgICBzMTYgKz0gKChleHAgLSAxMTIpIDw8IDEwKSArIChtYW50ID4+IDEzKTtcbiAgaWYgKChleHAgPj0gMTEzKSAmJiAoZXhwIDw9IDE0MikpIHtcbiAgICBzMTYgKz0gKChleHAgLSAxMTIpIDw8IDEwKSArIChtYW50ID4+IDEzKVxuXG4gIC8vICAgZWxzZSBpZiAoZXhwID49IDEwMyAmJiBleHAgPCAxMTMpIHsgLyogZGVub3JtLCBleHAxNiA9IDAgKi9cbiAgLy8gICAgIGlmIChtYW50ICYgKCgxIDw8ICgxMjYgLSBleHApKSAtIDEpKVxuICAvLyAgICAgICBnb3RvIGZsb2F0MzI7ICAgICAgICAgLyogbG9zcyBvZiBwcmVjaXNpb24gKi9cbiAgLy8gICAgIHMxNiArPSAoKG1hbnQgKyAweDgwMDAwMCkgPj4gKDEyNiAtIGV4cCkpO1xuICB9IGVsc2UgaWYgKChleHAgPj0gMTAzKSAmJiAoZXhwIDwgMTEzKSkge1xuICAgIGlmIChtYW50ICYgKCgxIDw8ICgxMjYgLSBleHApKSAtIDEpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgczE2ICs9ICgobWFudCArIDB4ODAwMDAwKSA+PiAoMTI2IC0gZXhwKSlcblxuICAgIC8vICAgfSBlbHNlIGlmIChleHAgPT0gMjU1ICYmIG1hbnQgPT0gMCkgeyAvKiBJbmYgKi9cbiAgICAvLyAgICAgczE2ICs9IDB4N2MwMDtcblxuICAgIC8vIGhpbGRqajogSW5maW5pdHkgYWxyZWFkeSBoYW5kbGVkXG5cbiAgLy8gICB9IGVsc2VcbiAgLy8gICAgIGdvdG8gZmxvYXQzMjsgICAgICAgICAgIC8qIGxvc3Mgb2YgcmFuZ2UgKi9cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vICAgZW5zdXJlX3dyaXRhYmxlKDMpO1xuICAvLyAgIHUxNiA9IHMxNjtcbiAgLy8gICBiZTE2ID0gaHRvbjE2cCgoY29uc3QgdWludDhfdCopJnUxNik7XG4gIGJ1Zi53cml0ZVVJbnQxNkJFKHMxNiwgMClcbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0cy5rZXlTb3J0ZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgbGVuQSA9IGFbMF0uYnl0ZUxlbmd0aFxuICB2YXIgbGVuQiA9IGJbMF0uYnl0ZUxlbmd0aFxuXG4gIGlmIChsZW5BID4gbGVuQikge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBpZiAobGVuQiA+IGxlbkEpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIHJldHVybiBhWzBdLmNvbXBhcmUoYlswXSlcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cuMmFsaXR5LmNvbS8yMDEyLzAzL3NpZ25lZHplcm8uaHRtbFxuZXhwb3J0cy5pc05lZ2F0aXZlWmVybyA9ICh4KSA9PiB7XG4gIHJldHVybiB4ID09PSAwICYmICgxIC8geCA8IDApXG59XG5cbmV4cG9ydHMubmV4dFBvd2VyT2YyID0gKG4pID0+IHtcbiAgbGV0IGNvdW50ID0gMFxuICAvLyBGaXJzdCBuIGluIHRoZSBiZWxvdyBjb25kaXRpb24gaXMgZm9yXG4gIC8vIHRoZSBjYXNlIHdoZXJlIG4gaXMgMFxuICBpZiAobiAmJiAhKG4gJiAobiAtIDEpKSkge1xuICAgIHJldHVybiBuXG4gIH1cblxuICB3aGlsZSAobiAhPT0gMCkge1xuICAgIG4gPj49IDFcbiAgICBjb3VudCArPSAxXG4gIH1cblxuICByZXR1cm4gMSA8PCBjb3VudFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/borc/src/utils.js\n"));

/***/ }),

/***/ "../../../node_modules/buffer/index.js":
/*!*********************************************!*\
  !*** ../../../node_modules/buffer/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"../../../node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"../../../node_modules/ieee754/index.js\")\nvar customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    var proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    var copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        Buffer.from(buf).copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (var i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nvar hexSliceLookupTable = (function () {\n  var alphabet = '0123456789abcdef'\n  var table = new Array(256)\n  for (var i = 0; i < 16; ++i) {\n    var i16 = i * 16\n    for (var j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWixhQUFhLG1CQUFPLENBQUMsMkRBQVc7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLHVEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz80ODdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgQnVmZmVyLmZyb20oYnVmKS5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbnZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIHZhciBpMTYgPSBpICogMTZcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/buffer/index.js\n"));

/***/ }),

/***/ "../../../node_modules/ieee754/index.js":
/*!**********************************************!*\
  !*** ../../../node_modules/ieee754/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsU0FBUyxVQUFVOztBQUVuQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz84Nzc4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "../../../node_modules/iso-url/index.js":
/*!**********************************************!*\
  !*** ../../../node_modules/iso-url/index.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst {\n    URLWithLegacySupport,\n    format,\n    URLSearchParams,\n    defaultBase\n} = __webpack_require__(/*! ./src/url */ \"../../../node_modules/iso-url/src/url-browser.js\");\nconst relative = __webpack_require__(/*! ./src/relative */ \"../../../node_modules/iso-url/src/relative.js\");\n\nmodule.exports = {\n    URL: URLWithLegacySupport,\n    URLSearchParams,\n    format,\n    relative,\n    defaultBase\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lzby11cmwvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLG1FQUFXO0FBQ3ZCLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFnQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9pc28tdXJsL2luZGV4LmpzP2JiM2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7XG4gICAgVVJMV2l0aExlZ2FjeVN1cHBvcnQsXG4gICAgZm9ybWF0LFxuICAgIFVSTFNlYXJjaFBhcmFtcyxcbiAgICBkZWZhdWx0QmFzZVxufSA9IHJlcXVpcmUoJy4vc3JjL3VybCcpO1xuY29uc3QgcmVsYXRpdmUgPSByZXF1aXJlKCcuL3NyYy9yZWxhdGl2ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBVUkw6IFVSTFdpdGhMZWdhY3lTdXBwb3J0LFxuICAgIFVSTFNlYXJjaFBhcmFtcyxcbiAgICBmb3JtYXQsXG4gICAgcmVsYXRpdmUsXG4gICAgZGVmYXVsdEJhc2Vcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/iso-url/index.js\n"));

/***/ }),

/***/ "../../../node_modules/iso-url/src/relative.js":
/*!*****************************************************!*\
  !*** ../../../node_modules/iso-url/src/relative.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst { URLWithLegacySupport, format } = __webpack_require__(/*! ./url */ \"../../../node_modules/iso-url/src/url-browser.js\");\n\nmodule.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {\n    let protocol = location.protocol ?\n        location.protocol.replace(':', '') :\n        'http';\n\n    // Check protocol map\n    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ':';\n    let urlParsed;\n\n    try {\n        urlParsed = new URLWithLegacySupport(url);\n    } catch (err) {\n        urlParsed = {};\n    }\n\n    const base = Object.assign({}, location, {\n        protocol: protocol || urlParsed.protocol,\n        host: location.host || urlParsed.host\n    });\n\n    return new URLWithLegacySupport(url, format(base)).toString();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lzby11cmwvc3JjL3JlbGF0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsK0JBQStCLEVBQUUsbUJBQU8sQ0FBQywrREFBTzs7QUFFeEQsb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lzby11cmwvc3JjL3JlbGF0aXZlLmpzPzhlNGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFVSTFdpdGhMZWdhY3lTdXBwb3J0LCBmb3JtYXQgfSA9IHJlcXVpcmUoJy4vdXJsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKHVybCwgbG9jYXRpb24gPSB7fSwgcHJvdG9jb2xNYXAgPSB7fSwgZGVmYXVsdFByb3RvY29sKSA9PiB7XG4gICAgbGV0IHByb3RvY29sID0gbG9jYXRpb24ucHJvdG9jb2wgP1xuICAgICAgICBsb2NhdGlvbi5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpIDpcbiAgICAgICAgJ2h0dHAnO1xuXG4gICAgLy8gQ2hlY2sgcHJvdG9jb2wgbWFwXG4gICAgcHJvdG9jb2wgPSAocHJvdG9jb2xNYXBbcHJvdG9jb2xdIHx8IGRlZmF1bHRQcm90b2NvbCB8fCBwcm90b2NvbCkgKyAnOic7XG4gICAgbGV0IHVybFBhcnNlZDtcblxuICAgIHRyeSB7XG4gICAgICAgIHVybFBhcnNlZCA9IG5ldyBVUkxXaXRoTGVnYWN5U3VwcG9ydCh1cmwpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB1cmxQYXJzZWQgPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlID0gT2JqZWN0LmFzc2lnbih7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcHJvdG9jb2w6IHByb3RvY29sIHx8IHVybFBhcnNlZC5wcm90b2NvbCxcbiAgICAgICAgaG9zdDogbG9jYXRpb24uaG9zdCB8fCB1cmxQYXJzZWQuaG9zdFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBVUkxXaXRoTGVnYWN5U3VwcG9ydCh1cmwsIGZvcm1hdChiYXNlKSkudG9TdHJpbmcoKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/iso-url/src/relative.js\n"));

/***/ }),

/***/ "../../../node_modules/iso-url/src/url-browser.js":
/*!********************************************************!*\
  !*** ../../../node_modules/iso-url/src/url-browser.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst defaultBase = self.location ?\n    self.location.protocol + '//' + self.location.host :\n    '';\nconst URL = self.URL;\n\nclass URLWithLegacySupport {\n    constructor(url = '', base = defaultBase) {\n        this.super = new URL(url, base);\n        this.path = this.pathname + this.search;\n        this.auth =\n            this.username && this.password ?\n                this.username + ':' + this.password :\n                null;\n\n        this.query =\n            this.search && this.search.startsWith('?') ?\n                this.search.slice(1) :\n                null;\n    }\n\n    get hash() {\n        return this.super.hash;\n    }\n    get host() {\n        return this.super.host;\n    }\n    get hostname() {\n        return this.super.hostname;\n    }\n    get href() {\n        return this.super.href;\n    }\n    get origin() {\n        return this.super.origin;\n    }\n    get password() {\n        return this.super.password;\n    }\n    get pathname() {\n        return this.super.pathname;\n    }\n    get port() {\n        return this.super.port;\n    }\n    get protocol() {\n        return this.super.protocol;\n    }\n    get search() {\n        return this.super.search;\n    }\n    get searchParams() {\n        return this.super.searchParams;\n    }\n    get username() {\n        return this.super.username;\n    }\n\n    set hash(hash) {\n        this.super.hash = hash;\n    }\n    set host(host) {\n        this.super.host = host;\n    }\n    set hostname(hostname) {\n        this.super.hostname = hostname;\n    }\n    set href(href) {\n        this.super.href = href;\n    }\n    set origin(origin) {\n        this.super.origin = origin;\n    }\n    set password(password) {\n        this.super.password = password;\n    }\n    set pathname(pathname) {\n        this.super.pathname = pathname;\n    }\n    set port(port) {\n        this.super.port = port;\n    }\n    set protocol(protocol) {\n        this.super.protocol = protocol;\n    }\n    set search(search) {\n        this.super.search = search;\n    }\n    set searchParams(searchParams) {\n        this.super.searchParams = searchParams;\n    }\n    set username(username) {\n        this.super.username = username;\n    }\n\n    createObjectURL(o) {\n        return this.super.createObjectURL(o);\n    }\n    revokeObjectURL(o) {\n        this.super.revokeObjectURL(o);\n    }\n    toJSON() {\n        return this.super.toJSON();\n    }\n    toString() {\n        return this.super.toString();\n    }\n    format() {\n        return this.toString();\n    }\n}\n\nfunction format(obj) {\n    if (typeof obj === 'string') {\n        const url = new URL(obj);\n\n        return url.toString();\n    }\n\n    if (!(obj instanceof URL)) {\n        const userPass =\n            obj.username && obj.password ?\n                `${obj.username}:${obj.password}@` :\n                '';\n        const auth = obj.auth ? obj.auth + '@' : '';\n        const port = obj.port ? ':' + obj.port : '';\n        const protocol = obj.protocol ? obj.protocol + '//' : '';\n        const host = obj.host || '';\n        const hostname = obj.hostname || '';\n        const search = obj.search || (obj.query ? '?' + obj.query : '');\n        const hash = obj.hash || '';\n        const pathname = obj.pathname || '';\n        const path = obj.path || pathname + search;\n\n        return `${protocol}${userPass || auth}${host ||\n            hostname + port}${path}${hash}`;\n    }\n}\n\nmodule.exports = {\n    URLWithLegacySupport,\n    URLSearchParams: self.URLSearchParams,\n    defaultBase,\n    format\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lzby11cmwvc3JjL3VybC1icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLEdBQUcsYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUyxFQUFFLGlCQUFpQixFQUFFO0FBQ2hELDRCQUE0QixFQUFFLEtBQUssRUFBRSxLQUFLO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaXNvLXVybC9zcmMvdXJsLWJyb3dzZXIuanM/OGJmMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRlZmF1bHRCYXNlID0gc2VsZi5sb2NhdGlvbiA/XG4gICAgc2VsZi5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBzZWxmLmxvY2F0aW9uLmhvc3QgOlxuICAgICcnO1xuY29uc3QgVVJMID0gc2VsZi5VUkw7XG5cbmNsYXNzIFVSTFdpdGhMZWdhY3lTdXBwb3J0IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwgPSAnJywgYmFzZSA9IGRlZmF1bHRCYXNlKSB7XG4gICAgICAgIHRoaXMuc3VwZXIgPSBuZXcgVVJMKHVybCwgYmFzZSk7XG4gICAgICAgIHRoaXMucGF0aCA9IHRoaXMucGF0aG5hbWUgKyB0aGlzLnNlYXJjaDtcbiAgICAgICAgdGhpcy5hdXRoID1cbiAgICAgICAgICAgIHRoaXMudXNlcm5hbWUgJiYgdGhpcy5wYXNzd29yZCA/XG4gICAgICAgICAgICAgICAgdGhpcy51c2VybmFtZSArICc6JyArIHRoaXMucGFzc3dvcmQgOlxuICAgICAgICAgICAgICAgIG51bGw7XG5cbiAgICAgICAgdGhpcy5xdWVyeSA9XG4gICAgICAgICAgICB0aGlzLnNlYXJjaCAmJiB0aGlzLnNlYXJjaC5zdGFydHNXaXRoKCc/JykgP1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLnNsaWNlKDEpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIGdldCBoYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5oYXNoO1xuICAgIH1cbiAgICBnZXQgaG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuaG9zdDtcbiAgICB9XG4gICAgZ2V0IGhvc3RuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5ob3N0bmFtZTtcbiAgICB9XG4gICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLmhyZWY7XG4gICAgfVxuICAgIGdldCBvcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLm9yaWdpbjtcbiAgICB9XG4gICAgZ2V0IHBhc3N3b3JkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5wYXNzd29yZDtcbiAgICB9XG4gICAgZ2V0IHBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5wYXRobmFtZTtcbiAgICB9XG4gICAgZ2V0IHBvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnBvcnQ7XG4gICAgfVxuICAgIGdldCBwcm90b2NvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIucHJvdG9jb2w7XG4gICAgfVxuICAgIGdldCBzZWFyY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnNlYXJjaDtcbiAgICB9XG4gICAgZ2V0IHNlYXJjaFBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIuc2VhcmNoUGFyYW1zO1xuICAgIH1cbiAgICBnZXQgdXNlcm5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnVzZXJuYW1lO1xuICAgIH1cblxuICAgIHNldCBoYXNoKGhhc2gpIHtcbiAgICAgICAgdGhpcy5zdXBlci5oYXNoID0gaGFzaDtcbiAgICB9XG4gICAgc2V0IGhvc3QoaG9zdCkge1xuICAgICAgICB0aGlzLnN1cGVyLmhvc3QgPSBob3N0O1xuICAgIH1cbiAgICBzZXQgaG9zdG5hbWUoaG9zdG5hbWUpIHtcbiAgICAgICAgdGhpcy5zdXBlci5ob3N0bmFtZSA9IGhvc3RuYW1lO1xuICAgIH1cbiAgICBzZXQgaHJlZihocmVmKSB7XG4gICAgICAgIHRoaXMuc3VwZXIuaHJlZiA9IGhyZWY7XG4gICAgfVxuICAgIHNldCBvcmlnaW4ob3JpZ2luKSB7XG4gICAgICAgIHRoaXMuc3VwZXIub3JpZ2luID0gb3JpZ2luO1xuICAgIH1cbiAgICBzZXQgcGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICAgICAgdGhpcy5zdXBlci5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgIH1cbiAgICBzZXQgcGF0aG5hbWUocGF0aG5hbWUpIHtcbiAgICAgICAgdGhpcy5zdXBlci5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgIH1cbiAgICBzZXQgcG9ydChwb3J0KSB7XG4gICAgICAgIHRoaXMuc3VwZXIucG9ydCA9IHBvcnQ7XG4gICAgfVxuICAgIHNldCBwcm90b2NvbChwcm90b2NvbCkge1xuICAgICAgICB0aGlzLnN1cGVyLnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgfVxuICAgIHNldCBzZWFyY2goc2VhcmNoKSB7XG4gICAgICAgIHRoaXMuc3VwZXIuc2VhcmNoID0gc2VhcmNoO1xuICAgIH1cbiAgICBzZXQgc2VhcmNoUGFyYW1zKHNlYXJjaFBhcmFtcykge1xuICAgICAgICB0aGlzLnN1cGVyLnNlYXJjaFBhcmFtcyA9IHNlYXJjaFBhcmFtcztcbiAgICB9XG4gICAgc2V0IHVzZXJuYW1lKHVzZXJuYW1lKSB7XG4gICAgICAgIHRoaXMuc3VwZXIudXNlcm5hbWUgPSB1c2VybmFtZTtcbiAgICB9XG5cbiAgICBjcmVhdGVPYmplY3RVUkwobykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdXBlci5jcmVhdGVPYmplY3RVUkwobyk7XG4gICAgfVxuICAgIHJldm9rZU9iamVjdFVSTChvKSB7XG4gICAgICAgIHRoaXMuc3VwZXIucmV2b2tlT2JqZWN0VVJMKG8pO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyLnRvSlNPTigpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9ybWF0KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKG9iaik7XG5cbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgY29uc3QgdXNlclBhc3MgPVxuICAgICAgICAgICAgb2JqLnVzZXJuYW1lICYmIG9iai5wYXNzd29yZCA/XG4gICAgICAgICAgICAgICAgYCR7b2JqLnVzZXJuYW1lfToke29iai5wYXNzd29yZH1AYCA6XG4gICAgICAgICAgICAgICAgJyc7XG4gICAgICAgIGNvbnN0IGF1dGggPSBvYmouYXV0aCA/IG9iai5hdXRoICsgJ0AnIDogJyc7XG4gICAgICAgIGNvbnN0IHBvcnQgPSBvYmoucG9ydCA/ICc6JyArIG9iai5wb3J0IDogJyc7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gb2JqLnByb3RvY29sID8gb2JqLnByb3RvY29sICsgJy8vJyA6ICcnO1xuICAgICAgICBjb25zdCBob3N0ID0gb2JqLmhvc3QgfHwgJyc7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gb2JqLmhvc3RuYW1lIHx8ICcnO1xuICAgICAgICBjb25zdCBzZWFyY2ggPSBvYmouc2VhcmNoIHx8IChvYmoucXVlcnkgPyAnPycgKyBvYmoucXVlcnkgOiAnJyk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBvYmouaGFzaCB8fCAnJztcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBvYmoucGF0aG5hbWUgfHwgJyc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBvYmoucGF0aCB8fCBwYXRobmFtZSArIHNlYXJjaDtcblxuICAgICAgICByZXR1cm4gYCR7cHJvdG9jb2x9JHt1c2VyUGFzcyB8fCBhdXRofSR7aG9zdCB8fFxuICAgICAgICAgICAgaG9zdG5hbWUgKyBwb3J0fSR7cGF0aH0ke2hhc2h9YDtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFVSTFdpdGhMZWdhY3lTdXBwb3J0LFxuICAgIFVSTFNlYXJjaFBhcmFtczogc2VsZi5VUkxTZWFyY2hQYXJhbXMsXG4gICAgZGVmYXVsdEJhc2UsXG4gICAgZm9ybWF0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/iso-url/src/url-browser.js\n"));

/***/ }),

/***/ "../../../node_modules/next/dist/build/polyfills/process.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/next/dist/build/polyfills/process.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"../../../node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EscUNBQXFDLHFCQUFNLGlGQUFpRixxQkFBTSxrRUFBa0UscUJBQU0sV0FBVyxtQkFBTyxDQUFDLCtGQUE0Qjs7QUFFelAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Mzc5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[2]!./src/app/globals.css":
/*!***************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[2]!./src/app/globals.css ***!
  \***************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n! tailwindcss v3.3.6 | MIT License | https://tailwindcss.com\\n*//*\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\n*/\\n\\n*,\\n::before,\\n::after {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n\\n::before,\\n::after {\\n  --tw-content: '';\\n}\\n\\n/*\\n1. Use a consistent sensible line-height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n3. Use a more readable tab size.\\n4. Use the user's configured `sans` font-family by default.\\n5. Use the user's configured `sans` font-feature-settings by default.\\n6. Use the user's configured `sans` font-variation-settings by default.\\n*/\\n\\nhtml {\\n  line-height: 1.5; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */\\n  -moz-tab-size: 4; /* 3 */\\n  -o-tab-size: 4;\\n     tab-size: 4; /* 3 */\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\n  font-feature-settings: normal; /* 5 */\\n  font-variation-settings: normal; /* 6 */\\n}\\n\\n/*\\n1. Remove the margin in all browsers.\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\n*/\\n\\nbody {\\n  margin: 0; /* 1 */\\n  line-height: inherit; /* 2 */\\n}\\n\\n/*\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n3. Ensure horizontal rules are visible by default.\\n*/\\n\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n  border-top-width: 1px; /* 3 */\\n}\\n\\n/*\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\nabbr:where([title]) {\\n  -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n}\\n\\n/*\\nRemove the default font size and weight for headings.\\n*/\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n\\n/*\\nReset links to optimize for opt-in styling instead of opt-out.\\n*/\\n\\na {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n\\n/*\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n\\n/*\\n1. Use the user's configured `mono` font-family by default.\\n2. Use the user's configured `mono` font-feature-settings by default.\\n3. Use the user's configured `mono` font-variation-settings by default.\\n4. Correct the odd `em` font sizing in all browsers.\\n*/\\n\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\n  font-feature-settings: normal; /* 2 */\\n  font-variation-settings: normal; /* 3 */\\n  font-size: 1em; /* 4 */\\n}\\n\\n/*\\nAdd the correct font size in all browsers.\\n*/\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\n/*\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\n\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\n/*\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n3. Remove gaps between table borders by default.\\n*/\\n\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n  border-collapse: collapse; /* 3 */\\n}\\n\\n/*\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n3. Remove default padding in all browsers.\\n*/\\n\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-feature-settings: inherit; /* 1 */\\n  font-variation-settings: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  font-weight: inherit; /* 1 */\\n  line-height: inherit; /* 1 */\\n  color: inherit; /* 1 */\\n  margin: 0; /* 2 */\\n  padding: 0; /* 3 */\\n}\\n\\n/*\\nRemove the inheritance of text transform in Edge and Firefox.\\n*/\\n\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Remove default button styles.\\n*/\\n\\nbutton,\\n[type='button'],\\n[type='reset'],\\n[type='submit'] {\\n  -webkit-appearance: button; /* 1 */\\n  background-color: transparent; /* 2 */\\n  background-image: none; /* 2 */\\n}\\n\\n/*\\nUse the modern Firefox focus style for all focusable elements.\\n*/\\n\\n:-moz-focusring {\\n  outline: auto;\\n}\\n\\n/*\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n\\n/*\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\n/*\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n/*\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n\\n/*\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to `inherit` in Safari.\\n*/\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\nsummary {\\n  display: list-item;\\n}\\n\\n/*\\nRemoves the default spacing and border for appropriate elements.\\n*/\\n\\nblockquote,\\ndl,\\ndd,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nhr,\\nfigure,\\np,\\npre {\\n  margin: 0;\\n}\\n\\nfieldset {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nlegend {\\n  padding: 0;\\n}\\n\\nol,\\nul,\\nmenu {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/*\\nReset default styling for dialogs.\\n*/\\ndialog {\\n  padding: 0;\\n}\\n\\n/*\\nPrevent resizing textareas horizontally by default.\\n*/\\n\\ntextarea {\\n  resize: vertical;\\n}\\n\\n/*\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n2. Set the default placeholder color to the user's configured gray 400 color.\\n*/\\n\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\ninput::placeholder,\\ntextarea::placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\n/*\\nSet the default cursor for buttons.\\n*/\\n\\nbutton,\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\n\\n/*\\nMake sure disabled buttons don't get the pointer cursor.\\n*/\\n:disabled {\\n  cursor: default;\\n}\\n\\n/*\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\n\\nimg,\\nsvg,\\nvideo,\\ncanvas,\\naudio,\\niframe,\\nembed,\\nobject {\\n  display: block; /* 1 */\\n  vertical-align: middle; /* 2 */\\n}\\n\\n/*\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\n\\nimg,\\nvideo {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n/* Make elements with the HTML hidden attribute stay hidden by default */\\n[hidden] {\\n  display: none;\\n}\\n  :root {\\n    --background: 0 0% 100%;\\n    --foreground: 222.2 84% 4.9%;\\n\\n    --card: 0 0% 100%;\\n    --card-foreground: 222.2 84% 4.9%;\\n\\n    --popover: 0 0% 100%;\\n    --popover-foreground: 222.2 84% 4.9%;\\n\\n    --primary: 222.2 47.4% 11.2%;\\n    --primary-foreground: 210 40% 98%;\\n\\n    --secondary: 210 40% 96.1%;\\n    --secondary-foreground: 222.2 47.4% 11.2%;\\n\\n    --muted: 210 40% 96.1%;\\n    --muted-foreground: 215.4 16.3% 46.9%;\\n\\n    --accent: 210 40% 96.1%;\\n    --accent-foreground: 222.2 47.4% 11.2%;\\n\\n    --destructive: 0 84.2% 60.2%;\\n    --destructive-foreground: 210 40% 98%;\\n\\n    --border: 214.3 31.8% 91.4%;\\n    --input: 214.3 31.8% 91.4%;\\n    --ring: 222.2 84% 4.9%;\\n\\n    --radius: 0.5rem;\\n  }\\n  * {\\n  border-color: hsl(var(--border));\\n}\\n  body {\\n  background-color: hsl(var(--background));\\n  color: hsl(var(--foreground));\\n}\\n\\n*, ::before, ::after {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-gradient-from-position:  ;\\n  --tw-gradient-via-position:  ;\\n  --tw-gradient-to-position:  ;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n\\n::backdrop {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-gradient-from-position:  ;\\n  --tw-gradient-via-position:  ;\\n  --tw-gradient-to-position:  ;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n.sr-only {\\n  position: absolute;\\n  width: 1px;\\n  height: 1px;\\n  padding: 0;\\n  margin: -1px;\\n  overflow: hidden;\\n  clip: rect(0, 0, 0, 0);\\n  white-space: nowrap;\\n  border-width: 0;\\n}\\n.absolute {\\n  position: absolute;\\n}\\n.relative {\\n  position: relative;\\n}\\n.bottom-0 {\\n  bottom: 0px;\\n}\\n.m-auto {\\n  margin: auto;\\n}\\n.mx-auto {\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\n.my-2 {\\n  margin-top: 0.5rem;\\n  margin-bottom: 0.5rem;\\n}\\n.my-4 {\\n  margin-top: 1rem;\\n  margin-bottom: 1rem;\\n}\\n.mb-4 {\\n  margin-bottom: 1rem;\\n}\\n.ml-3 {\\n  margin-left: 0.75rem;\\n}\\n.ml-auto {\\n  margin-left: auto;\\n}\\n.mr-3 {\\n  margin-right: 0.75rem;\\n}\\n.mt-1 {\\n  margin-top: 0.25rem;\\n}\\n.mt-10 {\\n  margin-top: 2.5rem;\\n}\\n.mt-4 {\\n  margin-top: 1rem;\\n}\\n.block {\\n  display: block;\\n}\\n.flex {\\n  display: flex;\\n}\\n.inline-flex {\\n  display: inline-flex;\\n}\\n.grid {\\n  display: grid;\\n}\\n.aspect-square {\\n  aspect-ratio: 1 / 1;\\n}\\n.h-10 {\\n  height: 2.5rem;\\n}\\n.h-11 {\\n  height: 2.75rem;\\n}\\n.h-2 {\\n  height: 0.5rem;\\n}\\n.h-2\\\\.5 {\\n  height: 0.625rem;\\n}\\n.h-4 {\\n  height: 1rem;\\n}\\n.h-6 {\\n  height: 1.5rem;\\n}\\n.h-8 {\\n  height: 2rem;\\n}\\n.h-9 {\\n  height: 2.25rem;\\n}\\n.h-full {\\n  height: 100%;\\n}\\n.h-screen {\\n  height: 100vh;\\n}\\n.min-h-\\\\[80px\\\\] {\\n  min-height: 80px;\\n}\\n.w-10 {\\n  width: 2.5rem;\\n}\\n.w-2 {\\n  width: 0.5rem;\\n}\\n.w-2\\\\.5 {\\n  width: 0.625rem;\\n}\\n.w-4 {\\n  width: 1rem;\\n}\\n.w-6 {\\n  width: 1.5rem;\\n}\\n.w-8 {\\n  width: 2rem;\\n}\\n.w-9 {\\n  width: 2.25rem;\\n}\\n.w-\\\\[500px\\\\] {\\n  width: 500px;\\n}\\n.w-full {\\n  width: 100%;\\n}\\n.min-w-\\\\[500px\\\\] {\\n  min-width: 500px;\\n}\\n.max-w-\\\\[500px\\\\] {\\n  max-width: 500px;\\n}\\n.max-w-lg {\\n  max-width: 32rem;\\n}\\n.max-w-md {\\n  max-width: 28rem;\\n}\\n.max-w-sm {\\n  max-width: 24rem;\\n}\\n.flex-1 {\\n  flex: 1 1 0%;\\n}\\n.shrink-0 {\\n  flex-shrink: 0;\\n}\\n.touch-none {\\n  touch-action: none;\\n}\\n.select-none {\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\n.grid-cols-\\\\[50px_1fr\\\\] {\\n  grid-template-columns: 50px 1fr;\\n}\\n.flex-row {\\n  flex-direction: row;\\n}\\n.flex-col {\\n  flex-direction: column;\\n}\\n.items-start {\\n  align-items: flex-start;\\n}\\n.items-center {\\n  align-items: center;\\n}\\n.justify-center {\\n  justify-content: center;\\n}\\n.justify-between {\\n  justify-content: space-between;\\n}\\n.gap-1 {\\n  gap: 0.25rem;\\n}\\n.gap-1\\\\.5 {\\n  gap: 0.375rem;\\n}\\n.gap-2 {\\n  gap: 0.5rem;\\n}\\n.gap-4 {\\n  gap: 1rem;\\n}\\n.space-x-4 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-x-reverse: 0;\\n  margin-right: calc(1rem * var(--tw-space-x-reverse));\\n  margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));\\n}\\n.space-y-1 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(0.25rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(0.25rem * var(--tw-space-y-reverse));\\n}\\n.space-y-1\\\\.5 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(0.375rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(0.375rem * var(--tw-space-y-reverse));\\n}\\n.space-y-2 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(0.5rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(0.5rem * var(--tw-space-y-reverse));\\n}\\n.space-y-4 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(1rem * var(--tw-space-y-reverse));\\n}\\n.space-y-6 > :not([hidden]) ~ :not([hidden]) {\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(1.5rem * var(--tw-space-y-reverse));\\n}\\n.overflow-hidden {\\n  overflow: hidden;\\n}\\n.whitespace-nowrap {\\n  white-space: nowrap;\\n}\\n.rounded {\\n  border-radius: 0.25rem;\\n}\\n.rounded-\\\\[inherit\\\\] {\\n  border-radius: inherit;\\n}\\n.rounded-full {\\n  border-radius: 9999px;\\n}\\n.rounded-lg {\\n  border-radius: var(--radius);\\n}\\n.rounded-md {\\n  border-radius: calc(var(--radius) - 2px);\\n}\\n.rounded-none {\\n  border-radius: 0px;\\n}\\n.border {\\n  border-width: 1px;\\n}\\n.border-0 {\\n  border-width: 0px;\\n}\\n.border-y-0 {\\n  border-top-width: 0px;\\n  border-bottom-width: 0px;\\n}\\n.border-l {\\n  border-left-width: 1px;\\n}\\n.border-t {\\n  border-top-width: 1px;\\n}\\n.border-gray-300 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\n}\\n.border-input {\\n  border-color: hsl(var(--input));\\n}\\n.border-l-transparent {\\n  border-left-color: transparent;\\n}\\n.border-t-transparent {\\n  border-top-color: transparent;\\n}\\n.bg-background {\\n  background-color: hsl(var(--background));\\n}\\n.bg-border {\\n  background-color: hsl(var(--border));\\n}\\n.bg-card {\\n  background-color: hsl(var(--card));\\n}\\n.bg-destructive {\\n  background-color: hsl(var(--destructive));\\n}\\n.bg-muted {\\n  background-color: hsl(var(--muted));\\n}\\n.bg-primary {\\n  background-color: hsl(var(--primary));\\n}\\n.bg-purple-600 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(147 51 234 / var(--tw-bg-opacity));\\n}\\n.bg-secondary {\\n  background-color: hsl(var(--secondary));\\n}\\n.bg-white {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\n.object-cover {\\n  -o-object-fit: cover;\\n     object-fit: cover;\\n}\\n.p-0 {\\n  padding: 0px;\\n}\\n.p-2 {\\n  padding: 0.5rem;\\n}\\n.p-4 {\\n  padding: 1rem;\\n}\\n.p-6 {\\n  padding: 1.5rem;\\n}\\n.p-\\\\[1px\\\\] {\\n  padding: 1px;\\n}\\n.px-3 {\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n}\\n.px-4 {\\n  padding-left: 1rem;\\n  padding-right: 1rem;\\n}\\n.px-8 {\\n  padding-left: 2rem;\\n  padding-right: 2rem;\\n}\\n.py-10 {\\n  padding-top: 2.5rem;\\n  padding-bottom: 2.5rem;\\n}\\n.py-2 {\\n  padding-top: 0.5rem;\\n  padding-bottom: 0.5rem;\\n}\\n.pb-4 {\\n  padding-bottom: 1rem;\\n}\\n.pt-0 {\\n  padding-top: 0px;\\n}\\n.text-left {\\n  text-align: left;\\n}\\n.text-center {\\n  text-align: center;\\n}\\n.text-2xl {\\n  font-size: 1.5rem;\\n  line-height: 2rem;\\n}\\n.text-3xl {\\n  font-size: 1.875rem;\\n  line-height: 2.25rem;\\n}\\n.text-lg {\\n  font-size: 1.125rem;\\n  line-height: 1.75rem;\\n}\\n.text-sm {\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n}\\n.font-bold {\\n  font-weight: 700;\\n}\\n.font-medium {\\n  font-weight: 500;\\n}\\n.font-semibold {\\n  font-weight: 600;\\n}\\n.leading-none {\\n  line-height: 1;\\n}\\n.tracking-tight {\\n  letter-spacing: -0.025em;\\n}\\n.text-card-foreground {\\n  color: hsl(var(--card-foreground));\\n}\\n.text-destructive-foreground {\\n  color: hsl(var(--destructive-foreground));\\n}\\n.text-gray-500 {\\n  --tw-text-opacity: 1;\\n  color: rgb(107 114 128 / var(--tw-text-opacity));\\n}\\n.text-gray-700 {\\n  --tw-text-opacity: 1;\\n  color: rgb(55 65 81 / var(--tw-text-opacity));\\n}\\n.text-gray-900 {\\n  --tw-text-opacity: 1;\\n  color: rgb(17 24 39 / var(--tw-text-opacity));\\n}\\n.text-muted-foreground {\\n  color: hsl(var(--muted-foreground));\\n}\\n.text-primary {\\n  color: hsl(var(--primary));\\n}\\n.text-primary-foreground {\\n  color: hsl(var(--primary-foreground));\\n}\\n.text-secondary-foreground {\\n  color: hsl(var(--secondary-foreground));\\n}\\n.text-white {\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\n.underline-offset-4 {\\n  text-underline-offset: 4px;\\n}\\n.shadow-md {\\n  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n.shadow-none {\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n.shadow-sm {\\n  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\\n  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n.outline {\\n  outline-style: solid;\\n}\\n.ring-offset-background {\\n  --tw-ring-offset-color: hsl(var(--background));\\n}\\n.transition-colors {\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n@keyframes enter {\\n\\n  from {\\n    opacity: var(--tw-enter-opacity, 1);\\n    transform: translate3d(var(--tw-enter-translate-x, 0), var(--tw-enter-translate-y, 0), 0) scale3d(var(--tw-enter-scale, 1), var(--tw-enter-scale, 1), var(--tw-enter-scale, 1)) rotate(var(--tw-enter-rotate, 0));\\n  }\\n}\\n@keyframes exit {\\n\\n  to {\\n    opacity: var(--tw-exit-opacity, 1);\\n    transform: translate3d(var(--tw-exit-translate-x, 0), var(--tw-exit-translate-y, 0), 0) scale3d(var(--tw-exit-scale, 1), var(--tw-exit-scale, 1), var(--tw-exit-scale, 1)) rotate(var(--tw-exit-rotate, 0));\\n  }\\n}\\n\\n.file\\\\:border-0::file-selector-button {\\n  border-width: 0px;\\n}\\n\\n.file\\\\:bg-transparent::file-selector-button {\\n  background-color: transparent;\\n}\\n\\n.file\\\\:text-sm::file-selector-button {\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n}\\n\\n.file\\\\:font-medium::file-selector-button {\\n  font-weight: 500;\\n}\\n\\n.placeholder\\\\:text-muted-foreground::-moz-placeholder {\\n  color: hsl(var(--muted-foreground));\\n}\\n\\n.placeholder\\\\:text-muted-foreground::placeholder {\\n  color: hsl(var(--muted-foreground));\\n}\\n\\n.last\\\\:mb-0:last-child {\\n  margin-bottom: 0px;\\n}\\n\\n.last\\\\:pb-0:last-child {\\n  padding-bottom: 0px;\\n}\\n\\n.hover\\\\:bg-accent:hover {\\n  background-color: hsl(var(--accent));\\n}\\n\\n.hover\\\\:bg-destructive\\\\/90:hover {\\n  background-color: hsl(var(--destructive) / 0.9);\\n}\\n\\n.hover\\\\:bg-primary\\\\/90:hover {\\n  background-color: hsl(var(--primary) / 0.9);\\n}\\n\\n.hover\\\\:bg-secondary\\\\/80:hover {\\n  background-color: hsl(var(--secondary) / 0.8);\\n}\\n\\n.hover\\\\:text-accent-foreground:hover {\\n  color: hsl(var(--accent-foreground));\\n}\\n\\n.hover\\\\:underline:hover {\\n  text-decoration-line: underline;\\n}\\n\\n.focus-visible\\\\:outline-none:focus-visible {\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n}\\n\\n.focus-visible\\\\:ring-2:focus-visible {\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\n\\n.focus-visible\\\\:ring-ring:focus-visible {\\n  --tw-ring-color: hsl(var(--ring));\\n}\\n\\n.focus-visible\\\\:ring-offset-2:focus-visible {\\n  --tw-ring-offset-width: 2px;\\n}\\n\\n.disabled\\\\:pointer-events-none:disabled {\\n  pointer-events: none;\\n}\\n\\n.disabled\\\\:cursor-not-allowed:disabled {\\n  cursor: not-allowed;\\n}\\n\\n.disabled\\\\:opacity-50:disabled {\\n  opacity: 0.5;\\n}\\n\\n.peer:disabled ~ .peer-disabled\\\\:cursor-not-allowed {\\n  cursor: not-allowed;\\n}\\n\\n.peer:disabled ~ .peer-disabled\\\\:opacity-70 {\\n  opacity: 0.7;\\n}\\n\\n:is(.dark .dark\\\\:text-gray-400) {\\n  --tw-text-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-text-opacity));\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://src/app/globals.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"@tailwind base;\\n@tailwind components;\\n@tailwind utilities;\\n\\n@layer base {\\n  :root {\\n    --background: 0 0% 100%;\\n    --foreground: 222.2 84% 4.9%;\\n\\n    --card: 0 0% 100%;\\n    --card-foreground: 222.2 84% 4.9%;\\n\\n    --popover: 0 0% 100%;\\n    --popover-foreground: 222.2 84% 4.9%;\\n\\n    --primary: 222.2 47.4% 11.2%;\\n    --primary-foreground: 210 40% 98%;\\n\\n    --secondary: 210 40% 96.1%;\\n    --secondary-foreground: 222.2 47.4% 11.2%;\\n\\n    --muted: 210 40% 96.1%;\\n    --muted-foreground: 215.4 16.3% 46.9%;\\n\\n    --accent: 210 40% 96.1%;\\n    --accent-foreground: 222.2 47.4% 11.2%;\\n\\n    --destructive: 0 84.2% 60.2%;\\n    --destructive-foreground: 210 40% 98%;\\n\\n    --border: 214.3 31.8% 91.4%;\\n    --input: 214.3 31.8% 91.4%;\\n    --ring: 222.2 84% 4.9%;\\n\\n    --radius: 0.5rem;\\n  }\\n\\n  .dark {\\n    --background: 222.2 84% 4.9%;\\n    --foreground: 210 40% 98%;\\n\\n    --card: 222.2 84% 4.9%;\\n    --card-foreground: 210 40% 98%;\\n\\n    --popover: 222.2 84% 4.9%;\\n    --popover-foreground: 210 40% 98%;\\n\\n    --primary: 210 40% 98%;\\n    --primary-foreground: 222.2 47.4% 11.2%;\\n\\n    --secondary: 217.2 32.6% 17.5%;\\n    --secondary-foreground: 210 40% 98%;\\n\\n    --muted: 217.2 32.6% 17.5%;\\n    --muted-foreground: 215 20.2% 65.1%;\\n\\n    --accent: 217.2 32.6% 17.5%;\\n    --accent-foreground: 210 40% 98%;\\n\\n    --destructive: 0 62.8% 30.6%;\\n    --destructive-foreground: 210 40% 98%;\\n\\n    --border: 217.2 32.6% 17.5%;\\n    --input: 217.2 32.6% 17.5%;\\n    --ring: 212.7 26.8% 83.9%;\\n  }\\n}\\n\\n@layer base {\\n  * {\\n    @apply border-border;\\n  }\\n  body {\\n    @apply bg-background text-foreground;\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMTFdLm9uZU9mWzE0XS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzExXS5vbmVPZlsxNF0udXNlWzJdIS4vc3JjL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNvSTtBQUNwSSw4QkFBOEIsa0hBQTJCO0FBQ3pEO0FBQ0EsMFhBQTBYLDRCQUE0Qiw0QkFBNEIsZ0NBQWdDLGtDQUFrQyxVQUFVLHdCQUF3QixxQkFBcUIsR0FBRyxxWUFBcVksc0JBQXNCLDJDQUEyQyw2QkFBNkIsMEJBQTBCLG9CQUFvQix1UEFBdVAsMENBQTBDLDRDQUE0QyxVQUFVLGdLQUFnSyxlQUFlLGlDQUFpQyxVQUFVLDJOQUEyTixlQUFlLDJCQUEyQixrQ0FBa0MsVUFBVSxpR0FBaUcsOENBQThDLDhDQUE4QyxHQUFHLGtHQUFrRyx1QkFBdUIseUJBQXlCLEdBQUcsaUZBQWlGLG1CQUFtQiw2QkFBNkIsR0FBRywyRUFBMkUsd0JBQXdCLEdBQUcsMFNBQTBTLHlIQUF5SCwwQ0FBMEMsNENBQTRDLDJCQUEyQixVQUFVLGlFQUFpRSxtQkFBbUIsR0FBRywyR0FBMkcsbUJBQW1CLG1CQUFtQix1QkFBdUIsNkJBQTZCLEdBQUcsU0FBUyxvQkFBb0IsR0FBRyxTQUFTLGdCQUFnQixHQUFHLGdiQUFnYixvQkFBb0Isa0NBQWtDLHNDQUFzQyxVQUFVLGtNQUFrTSwwQkFBMEIsMkNBQTJDLDZDQUE2Qyw0QkFBNEIsaUNBQWlDLGlDQUFpQywyQkFBMkIsc0JBQXNCLHVCQUF1QixVQUFVLDhGQUE4Rix5QkFBeUIsR0FBRyxtTEFBbUwsZ0NBQWdDLDBDQUEwQyxt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QkFBcUIsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sT0FBTyxNQUFNLEtBQUsscUJBQXFCLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0saUJBQWlCLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLE9BQU8sV0FBVyxVQUFVLFVBQVUsTUFBTSxNQUFNLEtBQUssS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxLQUFLLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxZQUFZLG9CQUFvQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLFVBQVUsTUFBTSxXQUFXLEtBQUssVUFBVSxLQUFLLEtBQUssV0FBVyxZQUFZLFdBQVcsWUFBWSxXQUFXLFlBQVksV0FBVyxZQUFZLFdBQVcsWUFBWSxXQUFXLFlBQVksV0FBVyxZQUFZLFdBQVcsWUFBWSxXQUFXLFdBQVcsWUFBWSxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksYUFBYSxhQUFhLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sT0FBTyxLQUFLLFlBQVksTUFBTSxNQUFNLEtBQUssT0FBTyxLQUFLLFlBQVksTUFBTSxNQUFNLE1BQU0sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSx5Q0FBeUMsdUJBQXVCLHNCQUFzQixpQkFBaUIsV0FBVyw4QkFBOEIsbUNBQW1DLDBCQUEwQix3Q0FBd0MsNkJBQTZCLDJDQUEyQyxxQ0FBcUMsd0NBQXdDLG1DQUFtQyxnREFBZ0QsK0JBQStCLDRDQUE0QyxnQ0FBZ0MsNkNBQTZDLHFDQUFxQyw0Q0FBNEMsb0NBQW9DLGlDQUFpQyw2QkFBNkIseUJBQXlCLEtBQUssYUFBYSxtQ0FBbUMsZ0NBQWdDLCtCQUErQixxQ0FBcUMsa0NBQWtDLHdDQUF3QywrQkFBK0IsOENBQThDLHVDQUF1QywwQ0FBMEMsbUNBQW1DLDBDQUEwQyxvQ0FBb0MsdUNBQXVDLHFDQUFxQyw0Q0FBNEMsb0NBQW9DLGlDQUFpQyxnQ0FBZ0MsS0FBSyxHQUFHLGlCQUFpQixPQUFPLDJCQUEyQixLQUFLLFVBQVUsMkNBQTJDLEtBQUssR0FBRyxxQkFBcUI7QUFDL3U5QjtBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvZ2xvYmFscy5jc3M/YmEzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLypcXG4hIHRhaWx3aW5kY3NzIHYzLjMuNiB8IE1JVCBMaWNlbnNlIHwgaHR0cHM6Ly90YWlsd2luZGNzcy5jb21cXG4qLy8qXFxuMS4gUHJldmVudCBwYWRkaW5nIGFuZCBib3JkZXIgZnJvbSBhZmZlY3RpbmcgZWxlbWVudCB3aWR0aC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvNClcXG4yLiBBbGxvdyBhZGRpbmcgYSBib3JkZXIgdG8gYW4gZWxlbWVudCBieSBqdXN0IGFkZGluZyBhIGJvcmRlci13aWR0aC4gKGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGNzcy90YWlsd2luZGNzcy9wdWxsLzExNilcXG4qL1xcblxcbiosXFxuOjpiZWZvcmUsXFxuOjphZnRlciB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyAvKiAxICovXFxuICBib3JkZXItd2lkdGg6IDA7IC8qIDIgKi9cXG4gIGJvcmRlci1zdHlsZTogc29saWQ7IC8qIDIgKi9cXG4gIGJvcmRlci1jb2xvcjogI2U1ZTdlYjsgLyogMiAqL1xcbn1cXG5cXG46OmJlZm9yZSxcXG46OmFmdGVyIHtcXG4gIC0tdHctY29udGVudDogJyc7XFxufVxcblxcbi8qXFxuMS4gVXNlIGEgY29uc2lzdGVudCBzZW5zaWJsZSBsaW5lLWhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXFxuMi4gUHJldmVudCBhZGp1c3RtZW50cyBvZiBmb250IHNpemUgYWZ0ZXIgb3JpZW50YXRpb24gY2hhbmdlcyBpbiBpT1MuXFxuMy4gVXNlIGEgbW9yZSByZWFkYWJsZSB0YWIgc2l6ZS5cXG40LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBzYW5zYCBmb250LWZhbWlseSBieSBkZWZhdWx0LlxcbjUuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYHNhbnNgIGZvbnQtZmVhdHVyZS1zZXR0aW5ncyBieSBkZWZhdWx0LlxcbjYuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYHNhbnNgIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzIGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG5odG1sIHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7IC8qIDEgKi9cXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xcbiAgLW1vei10YWItc2l6ZTogNDsgLyogMyAqL1xcbiAgLW8tdGFiLXNpemU6IDQ7XFxuICAgICB0YWItc2l6ZTogNDsgLyogMyAqL1xcbiAgZm9udC1mYW1pbHk6IHVpLXNhbnMtc2VyaWYsIHN5c3RlbS11aSwgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBcXFwiU2Vnb2UgVUlcXFwiLCBSb2JvdG8sIFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIEFyaWFsLCBcXFwiTm90byBTYW5zXFxcIiwgc2Fucy1zZXJpZiwgXFxcIkFwcGxlIENvbG9yIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIFN5bWJvbFxcXCIsIFxcXCJOb3RvIENvbG9yIEVtb2ppXFxcIjsgLyogNCAqL1xcbiAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBub3JtYWw7IC8qIDUgKi9cXG4gIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiBub3JtYWw7IC8qIDYgKi9cXG59XFxuXFxuLypcXG4xLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBhbGwgYnJvd3NlcnMuXFxuMi4gSW5oZXJpdCBsaW5lLWhlaWdodCBmcm9tIGBodG1sYCBzbyB1c2VycyBjYW4gc2V0IHRoZW0gYXMgYSBjbGFzcyBkaXJlY3RseSBvbiB0aGUgYGh0bWxgIGVsZW1lbnQuXFxuKi9cXG5cXG5ib2R5IHtcXG4gIG1hcmdpbjogMDsgLyogMSAqL1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IC8qIDIgKi9cXG59XFxuXFxuLypcXG4xLiBBZGQgdGhlIGNvcnJlY3QgaGVpZ2h0IGluIEZpcmVmb3guXFxuMi4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2Ugb2YgYm9yZGVyIGNvbG9yIGluIEZpcmVmb3guIChodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTA2NTUpXFxuMy4gRW5zdXJlIGhvcml6b250YWwgcnVsZXMgYXJlIHZpc2libGUgYnkgZGVmYXVsdC5cXG4qL1xcblxcbmhyIHtcXG4gIGhlaWdodDogMDsgLyogMSAqL1xcbiAgY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cXG4gIGJvcmRlci10b3Atd2lkdGg6IDFweDsgLyogMyAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCB0ZXh0IGRlY29yYXRpb24gaW4gQ2hyb21lLCBFZGdlLCBhbmQgU2FmYXJpLlxcbiovXFxuXFxuYWJicjp3aGVyZShbdGl0bGVdKSB7XFxuICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbn1cXG5cXG4vKlxcblJlbW92ZSB0aGUgZGVmYXVsdCBmb250IHNpemUgYW5kIHdlaWdodCBmb3IgaGVhZGluZ3MuXFxuKi9cXG5cXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNiB7XFxuICBmb250LXNpemU6IGluaGVyaXQ7XFxuICBmb250LXdlaWdodDogaW5oZXJpdDtcXG59XFxuXFxuLypcXG5SZXNldCBsaW5rcyB0byBvcHRpbWl6ZSBmb3Igb3B0LWluIHN0eWxpbmcgaW5zdGVhZCBvZiBvcHQtb3V0LlxcbiovXFxuXFxuYSB7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIHRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDtcXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgZm9udCB3ZWlnaHQgaW4gRWRnZSBhbmQgU2FmYXJpLlxcbiovXFxuXFxuYixcXG5zdHJvbmcge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG59XFxuXFxuLypcXG4xLiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBtb25vYCBmb250LWZhbWlseSBieSBkZWZhdWx0LlxcbjIuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQtZmVhdHVyZS1zZXR0aW5ncyBieSBkZWZhdWx0LlxcbjMuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzIGJ5IGRlZmF1bHQuXFxuNC4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuY29kZSxcXG5rYmQsXFxuc2FtcCxcXG5wcmUge1xcbiAgZm9udC1mYW1pbHk6IHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcXFwiTGliZXJhdGlvbiBNb25vXFxcIiwgXFxcIkNvdXJpZXIgTmV3XFxcIiwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IG5vcm1hbDsgLyogMiAqL1xcbiAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IG5vcm1hbDsgLyogMyAqL1xcbiAgZm9udC1zaXplOiAxZW07IC8qIDQgKi9cXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbnNtYWxsIHtcXG4gIGZvbnQtc2l6ZTogODAlO1xcbn1cXG5cXG4vKlxcblByZXZlbnQgYHN1YmAgYW5kIGBzdXBgIGVsZW1lbnRzIGZyb20gYWZmZWN0aW5nIHRoZSBsaW5lIGhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5cXG5zdWIsXFxuc3VwIHtcXG4gIGZvbnQtc2l6ZTogNzUlO1xcbiAgbGluZS1oZWlnaHQ6IDA7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxufVxcblxcbnN1YiB7XFxuICBib3R0b206IC0wLjI1ZW07XFxufVxcblxcbnN1cCB7XFxuICB0b3A6IC0wLjVlbTtcXG59XFxuXFxuLypcXG4xLiBSZW1vdmUgdGV4dCBpbmRlbnRhdGlvbiBmcm9tIHRhYmxlIGNvbnRlbnRzIGluIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTk5MDg4LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjAxMjk3KVxcbjIuIENvcnJlY3QgdGFibGUgYm9yZGVyIGNvbG9yIGluaGVyaXRhbmNlIGluIGFsbCBDaHJvbWUgYW5kIFNhZmFyaS4gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkzNTcyOSwgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NTAxNilcXG4zLiBSZW1vdmUgZ2FwcyBiZXR3ZWVuIHRhYmxlIGJvcmRlcnMgYnkgZGVmYXVsdC5cXG4qL1xcblxcbnRhYmxlIHtcXG4gIHRleHQtaW5kZW50OiAwOyAvKiAxICovXFxuICBib3JkZXItY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7IC8qIDMgKi9cXG59XFxuXFxuLypcXG4xLiBDaGFuZ2UgdGhlIGZvbnQgc3R5bGVzIGluIGFsbCBicm93c2Vycy5cXG4yLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXFxuMy4gUmVtb3ZlIGRlZmF1bHQgcGFkZGluZyBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5cXG5idXR0b24sXFxuaW5wdXQsXFxub3B0Z3JvdXAsXFxuc2VsZWN0LFxcbnRleHRhcmVhIHtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0OyAvKiAxICovXFxuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiBpbmhlcml0OyAvKiAxICovXFxuICBmb250LXNpemU6IDEwMCU7IC8qIDEgKi9cXG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0OyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMSAqL1xcbiAgY29sb3I6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIG1hcmdpbjogMDsgLyogMiAqL1xcbiAgcGFkZGluZzogMDsgLyogMyAqL1xcbn1cXG5cXG4vKlxcblJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSBhbmQgRmlyZWZveC5cXG4qL1xcblxcbmJ1dHRvbixcXG5zZWxlY3Qge1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxufVxcblxcbi8qXFxuMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4yLiBSZW1vdmUgZGVmYXVsdCBidXR0b24gc3R5bGVzLlxcbiovXFxuXFxuYnV0dG9uLFxcblt0eXBlPSdidXR0b24nXSxcXG5bdHlwZT0ncmVzZXQnXSxcXG5bdHlwZT0nc3VibWl0J10ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDEgKi9cXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyAvKiAyICovXFxuICBiYWNrZ3JvdW5kLWltYWdlOiBub25lOyAvKiAyICovXFxufVxcblxcbi8qXFxuVXNlIHRoZSBtb2Rlcm4gRmlyZWZveCBmb2N1cyBzdHlsZSBmb3IgYWxsIGZvY3VzYWJsZSBlbGVtZW50cy5cXG4qL1xcblxcbjotbW96LWZvY3VzcmluZyB7XFxuICBvdXRsaW5lOiBhdXRvO1xcbn1cXG5cXG4vKlxcblJlbW92ZSB0aGUgYWRkaXRpb25hbCBgOmludmFsaWRgIHN0eWxlcyBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvMmY5ZWFjZDlkM2Q5OTVjOTM3YjQyNTFhNTU1N2Q5NWQ0OTRjOWJlMS9sYXlvdXQvc3R5bGUvcmVzL2Zvcm1zLmNzcyNMNzI4LUw3MzcpXFxuKi9cXG5cXG46LW1vei11aS1pbnZhbGlkIHtcXG4gIGJveC1zaGFkb3c6IG5vbmU7XFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IHZlcnRpY2FsIGFsaWdubWVudCBpbiBDaHJvbWUgYW5kIEZpcmVmb3guXFxuKi9cXG5cXG5wcm9ncmVzcyB7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxufVxcblxcbi8qXFxuQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gU2FmYXJpLlxcbiovXFxuXFxuOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcbjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi8qXFxuMS4gQ29ycmVjdCB0aGUgb2RkIGFwcGVhcmFuY2UgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxuMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXFxuKi9cXG5cXG5bdHlwZT0nc2VhcmNoJ10ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7IC8qIDEgKi9cXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4OyAvKiAyICovXFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGluIENocm9tZSBhbmQgU2FmYXJpIG9uIG1hY09TLlxcbiovXFxuXFxuOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbjIuIENoYW5nZSBmb250IHByb3BlcnRpZXMgdG8gYGluaGVyaXRgIGluIFNhZmFyaS5cXG4qL1xcblxcbjo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDEgKi9cXG4gIGZvbnQ6IGluaGVyaXQ7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXG4qL1xcblxcbnN1bW1hcnkge1xcbiAgZGlzcGxheTogbGlzdC1pdGVtO1xcbn1cXG5cXG4vKlxcblJlbW92ZXMgdGhlIGRlZmF1bHQgc3BhY2luZyBhbmQgYm9yZGVyIGZvciBhcHByb3ByaWF0ZSBlbGVtZW50cy5cXG4qL1xcblxcbmJsb2NrcXVvdGUsXFxuZGwsXFxuZGQsXFxuaDEsXFxuaDIsXFxuaDMsXFxuaDQsXFxuaDUsXFxuaDYsXFxuaHIsXFxuZmlndXJlLFxcbnAsXFxucHJlIHtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuZmllbGRzZXQge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxubGVnZW5kIHtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbm9sLFxcbnVsLFxcbm1lbnUge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbi8qXFxuUmVzZXQgZGVmYXVsdCBzdHlsaW5nIGZvciBkaWFsb2dzLlxcbiovXFxuZGlhbG9nIHtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbi8qXFxuUHJldmVudCByZXNpemluZyB0ZXh0YXJlYXMgaG9yaXpvbnRhbGx5IGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG50ZXh0YXJlYSB7XFxuICByZXNpemU6IHZlcnRpY2FsO1xcbn1cXG5cXG4vKlxcbjEuIFJlc2V0IHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIG9wYWNpdHkgaW4gRmlyZWZveC4gKGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvaXNzdWVzLzMzMDApXFxuMi4gU2V0IHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGNvbG9yIHRvIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBncmF5IDQwMCBjb2xvci5cXG4qL1xcblxcbmlucHV0OjotbW96LXBsYWNlaG9sZGVyLCB0ZXh0YXJlYTo6LW1vei1wbGFjZWhvbGRlciB7XFxuICBvcGFjaXR5OiAxOyAvKiAxICovXFxuICBjb2xvcjogIzljYTNhZjsgLyogMiAqL1xcbn1cXG5cXG5pbnB1dDo6cGxhY2Vob2xkZXIsXFxudGV4dGFyZWE6OnBsYWNlaG9sZGVyIHtcXG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXFxufVxcblxcbi8qXFxuU2V0IHRoZSBkZWZhdWx0IGN1cnNvciBmb3IgYnV0dG9ucy5cXG4qL1xcblxcbmJ1dHRvbixcXG5bcm9sZT1cXFwiYnV0dG9uXFxcIl0ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4vKlxcbk1ha2Ugc3VyZSBkaXNhYmxlZCBidXR0b25zIGRvbid0IGdldCB0aGUgcG9pbnRlciBjdXJzb3IuXFxuKi9cXG46ZGlzYWJsZWQge1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG5cXG4vKlxcbjEuIE1ha2UgcmVwbGFjZWQgZWxlbWVudHMgYGRpc3BsYXk6IGJsb2NrYCBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy8xNClcXG4yLiBBZGQgYHZlcnRpY2FsLWFsaWduOiBtaWRkbGVgIHRvIGFsaWduIHJlcGxhY2VkIGVsZW1lbnRzIG1vcmUgc2Vuc2libHkgYnkgZGVmYXVsdC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9qZW5zaW1tb25zL2Nzc3JlbWVkeS9pc3N1ZXMvMTQjaXNzdWVjb21tZW50LTYzNDkzNDIxMClcXG4gICBUaGlzIGNhbiB0cmlnZ2VyIGEgcG9vcmx5IGNvbnNpZGVyZWQgbGludCBlcnJvciBpbiBzb21lIHRvb2xzIGJ1dCBpcyBpbmNsdWRlZCBieSBkZXNpZ24uXFxuKi9cXG5cXG5pbWcsXFxuc3ZnLFxcbnZpZGVvLFxcbmNhbnZhcyxcXG5hdWRpbyxcXG5pZnJhbWUsXFxuZW1iZWQsXFxub2JqZWN0IHtcXG4gIGRpc3BsYXk6IGJsb2NrOyAvKiAxICovXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyAvKiAyICovXFxufVxcblxcbi8qXFxuQ29uc3RyYWluIGltYWdlcyBhbmQgdmlkZW9zIHRvIHRoZSBwYXJlbnQgd2lkdGggYW5kIHByZXNlcnZlIHRoZWlyIGludHJpbnNpYyBhc3BlY3QgcmF0aW8uIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcbiovXFxuXFxuaW1nLFxcbnZpZGVvIHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLyogTWFrZSBlbGVtZW50cyB3aXRoIHRoZSBIVE1MIGhpZGRlbiBhdHRyaWJ1dGUgc3RheSBoaWRkZW4gYnkgZGVmYXVsdCAqL1xcbltoaWRkZW5dIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbiAgOnJvb3Qge1xcbiAgICAtLWJhY2tncm91bmQ6IDAgMCUgMTAwJTtcXG4gICAgLS1mb3JlZ3JvdW5kOiAyMjIuMiA4NCUgNC45JTtcXG5cXG4gICAgLS1jYXJkOiAwIDAlIDEwMCU7XFxuICAgIC0tY2FyZC1mb3JlZ3JvdW5kOiAyMjIuMiA4NCUgNC45JTtcXG5cXG4gICAgLS1wb3BvdmVyOiAwIDAlIDEwMCU7XFxuICAgIC0tcG9wb3Zlci1mb3JlZ3JvdW5kOiAyMjIuMiA4NCUgNC45JTtcXG5cXG4gICAgLS1wcmltYXJ5OiAyMjIuMiA0Ny40JSAxMS4yJTtcXG4gICAgLS1wcmltYXJ5LWZvcmVncm91bmQ6IDIxMCA0MCUgOTglO1xcblxcbiAgICAtLXNlY29uZGFyeTogMjEwIDQwJSA5Ni4xJTtcXG4gICAgLS1zZWNvbmRhcnktZm9yZWdyb3VuZDogMjIyLjIgNDcuNCUgMTEuMiU7XFxuXFxuICAgIC0tbXV0ZWQ6IDIxMCA0MCUgOTYuMSU7XFxuICAgIC0tbXV0ZWQtZm9yZWdyb3VuZDogMjE1LjQgMTYuMyUgNDYuOSU7XFxuXFxuICAgIC0tYWNjZW50OiAyMTAgNDAlIDk2LjElO1xcbiAgICAtLWFjY2VudC1mb3JlZ3JvdW5kOiAyMjIuMiA0Ny40JSAxMS4yJTtcXG5cXG4gICAgLS1kZXN0cnVjdGl2ZTogMCA4NC4yJSA2MC4yJTtcXG4gICAgLS1kZXN0cnVjdGl2ZS1mb3JlZ3JvdW5kOiAyMTAgNDAlIDk4JTtcXG5cXG4gICAgLS1ib3JkZXI6IDIxNC4zIDMxLjglIDkxLjQlO1xcbiAgICAtLWlucHV0OiAyMTQuMyAzMS44JSA5MS40JTtcXG4gICAgLS1yaW5nOiAyMjIuMiA4NCUgNC45JTtcXG5cXG4gICAgLS1yYWRpdXM6IDAuNXJlbTtcXG4gIH1cXG4gICoge1xcbiAgYm9yZGVyLWNvbG9yOiBoc2wodmFyKC0tYm9yZGVyKSk7XFxufVxcbiAgYm9keSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2wodmFyKC0tYmFja2dyb3VuZCkpO1xcbiAgY29sb3I6IGhzbCh2YXIoLS1mb3JlZ3JvdW5kKSk7XFxufVxcblxcbiosIDo6YmVmb3JlLCA6OmFmdGVyIHtcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteDogMDtcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteTogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXg6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS15OiAwO1xcbiAgLS10dy1yb3RhdGU6IDA7XFxuICAtLXR3LXNrZXcteDogMDtcXG4gIC0tdHctc2tldy15OiAwO1xcbiAgLS10dy1zY2FsZS14OiAxO1xcbiAgLS10dy1zY2FsZS15OiAxO1xcbiAgLS10dy1wYW4teDogIDtcXG4gIC0tdHctcGFuLXk6ICA7XFxuICAtLXR3LXBpbmNoLXpvb206ICA7XFxuICAtLXR3LXNjcm9sbC1zbmFwLXN0cmljdG5lc3M6IHByb3hpbWl0eTtcXG4gIC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbjogIDtcXG4gIC0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uOiAgO1xcbiAgLS10dy1ncmFkaWVudC10by1wb3NpdGlvbjogIDtcXG4gIC0tdHctb3JkaW5hbDogIDtcXG4gIC0tdHctc2xhc2hlZC16ZXJvOiAgO1xcbiAgLS10dy1udW1lcmljLWZpZ3VyZTogIDtcXG4gIC0tdHctbnVtZXJpYy1zcGFjaW5nOiAgO1xcbiAgLS10dy1udW1lcmljLWZyYWN0aW9uOiAgO1xcbiAgLS10dy1yaW5nLWluc2V0OiAgO1xcbiAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMHB4O1xcbiAgLS10dy1yaW5nLW9mZnNldC1jb2xvcjogI2ZmZjtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyAwLjUpO1xcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctcmluZy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDAgIzAwMDA7XFxuICAtLXR3LWJsdXI6ICA7XFxuICAtLXR3LWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWNvbnRyYXN0OiAgO1xcbiAgLS10dy1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWludmVydDogIDtcXG4gIC0tdHctc2F0dXJhdGU6ICA7XFxuICAtLXR3LXNlcGlhOiAgO1xcbiAgLS10dy1kcm9wLXNoYWRvdzogIDtcXG4gIC0tdHctYmFja2Ryb3AtYmx1cjogIDtcXG4gIC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctYmFja2Ryb3AtY29udHJhc3Q6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaW52ZXJ0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1vcGFjaXR5OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2VwaWE6ICA7XFxufVxcblxcbjo6YmFja2Ryb3Age1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy14OiAwO1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy15OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteDogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXk6IDA7XFxuICAtLXR3LXJvdGF0ZTogMDtcXG4gIC0tdHctc2tldy14OiAwO1xcbiAgLS10dy1za2V3LXk6IDA7XFxuICAtLXR3LXNjYWxlLXg6IDE7XFxuICAtLXR3LXNjYWxlLXk6IDE7XFxuICAtLXR3LXBhbi14OiAgO1xcbiAgLS10dy1wYW4teTogIDtcXG4gIC0tdHctcGluY2gtem9vbTogIDtcXG4gIC0tdHctc2Nyb2xsLXNuYXAtc3RyaWN0bmVzczogcHJveGltaXR5O1xcbiAgLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uOiAgO1xcbiAgLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb246ICA7XFxuICAtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uOiAgO1xcbiAgLS10dy1vcmRpbmFsOiAgO1xcbiAgLS10dy1zbGFzaGVkLXplcm86ICA7XFxuICAtLXR3LW51bWVyaWMtZmlndXJlOiAgO1xcbiAgLS10dy1udW1lcmljLXNwYWNpbmc6ICA7XFxuICAtLXR3LW51bWVyaWMtZnJhY3Rpb246ICA7XFxuICAtLXR3LXJpbmctaW5zZXQ6ICA7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAwcHg7XFxuICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiAjZmZmO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIDAuNSk7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDtcXG4gIC0tdHctYmx1cjogIDtcXG4gIC0tdHctYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctY29udHJhc3Q6ICA7XFxuICAtLXR3LWdyYXlzY2FsZTogIDtcXG4gIC0tdHctaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctaW52ZXJ0OiAgO1xcbiAgLS10dy1zYXR1cmF0ZTogIDtcXG4gIC0tdHctc2VwaWE6ICA7XFxuICAtLXR3LWRyb3Atc2hhZG93OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1jb250cmFzdDogIDtcXG4gIC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1pbnZlcnQ6ICA7XFxuICAtLXR3LWJhY2tkcm9wLW9wYWNpdHk6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zZXBpYTogIDtcXG59XFxuLnNyLW9ubHkge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDFweDtcXG4gIGhlaWdodDogMXB4O1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogLTFweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBjbGlwOiByZWN0KDAsIDAsIDAsIDApO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIGJvcmRlci13aWR0aDogMDtcXG59XFxuLmFic29sdXRlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLnJlbGF0aXZlIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmJvdHRvbS0wIHtcXG4gIGJvdHRvbTogMHB4O1xcbn1cXG4ubS1hdXRvIHtcXG4gIG1hcmdpbjogYXV0bztcXG59XFxuLm14LWF1dG8ge1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxufVxcbi5teS0yIHtcXG4gIG1hcmdpbi10b3A6IDAuNXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG59XFxuLm15LTQge1xcbiAgbWFyZ2luLXRvcDogMXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07XFxufVxcbi5tYi00IHtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07XFxufVxcbi5tbC0zIHtcXG4gIG1hcmdpbi1sZWZ0OiAwLjc1cmVtO1xcbn1cXG4ubWwtYXV0byB7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG59XFxuLm1yLTMge1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjc1cmVtO1xcbn1cXG4ubXQtMSB7XFxuICBtYXJnaW4tdG9wOiAwLjI1cmVtO1xcbn1cXG4ubXQtMTAge1xcbiAgbWFyZ2luLXRvcDogMi41cmVtO1xcbn1cXG4ubXQtNCB7XFxuICBtYXJnaW4tdG9wOiAxcmVtO1xcbn1cXG4uYmxvY2sge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5mbGV4IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxufVxcbi5pbmxpbmUtZmxleCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG59XFxuLmdyaWQge1xcbiAgZGlzcGxheTogZ3JpZDtcXG59XFxuLmFzcGVjdC1zcXVhcmUge1xcbiAgYXNwZWN0LXJhdGlvOiAxIC8gMTtcXG59XFxuLmgtMTAge1xcbiAgaGVpZ2h0OiAyLjVyZW07XFxufVxcbi5oLTExIHtcXG4gIGhlaWdodDogMi43NXJlbTtcXG59XFxuLmgtMiB7XFxuICBoZWlnaHQ6IDAuNXJlbTtcXG59XFxuLmgtMlxcXFwuNSB7XFxuICBoZWlnaHQ6IDAuNjI1cmVtO1xcbn1cXG4uaC00IHtcXG4gIGhlaWdodDogMXJlbTtcXG59XFxuLmgtNiB7XFxuICBoZWlnaHQ6IDEuNXJlbTtcXG59XFxuLmgtOCB7XFxuICBoZWlnaHQ6IDJyZW07XFxufVxcbi5oLTkge1xcbiAgaGVpZ2h0OiAyLjI1cmVtO1xcbn1cXG4uaC1mdWxsIHtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuLmgtc2NyZWVuIHtcXG4gIGhlaWdodDogMTAwdmg7XFxufVxcbi5taW4taC1cXFxcWzgwcHhcXFxcXSB7XFxuICBtaW4taGVpZ2h0OiA4MHB4O1xcbn1cXG4udy0xMCB7XFxuICB3aWR0aDogMi41cmVtO1xcbn1cXG4udy0yIHtcXG4gIHdpZHRoOiAwLjVyZW07XFxufVxcbi53LTJcXFxcLjUge1xcbiAgd2lkdGg6IDAuNjI1cmVtO1xcbn1cXG4udy00IHtcXG4gIHdpZHRoOiAxcmVtO1xcbn1cXG4udy02IHtcXG4gIHdpZHRoOiAxLjVyZW07XFxufVxcbi53LTgge1xcbiAgd2lkdGg6IDJyZW07XFxufVxcbi53LTkge1xcbiAgd2lkdGg6IDIuMjVyZW07XFxufVxcbi53LVxcXFxbNTAwcHhcXFxcXSB7XFxuICB3aWR0aDogNTAwcHg7XFxufVxcbi53LWZ1bGwge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbi5taW4tdy1cXFxcWzUwMHB4XFxcXF0ge1xcbiAgbWluLXdpZHRoOiA1MDBweDtcXG59XFxuLm1heC13LVxcXFxbNTAwcHhcXFxcXSB7XFxuICBtYXgtd2lkdGg6IDUwMHB4O1xcbn1cXG4ubWF4LXctbGcge1xcbiAgbWF4LXdpZHRoOiAzMnJlbTtcXG59XFxuLm1heC13LW1kIHtcXG4gIG1heC13aWR0aDogMjhyZW07XFxufVxcbi5tYXgtdy1zbSB7XFxuICBtYXgtd2lkdGg6IDI0cmVtO1xcbn1cXG4uZmxleC0xIHtcXG4gIGZsZXg6IDEgMSAwJTtcXG59XFxuLnNocmluay0wIHtcXG4gIGZsZXgtc2hyaW5rOiAwO1xcbn1cXG4udG91Y2gtbm9uZSB7XFxuICB0b3VjaC1hY3Rpb246IG5vbmU7XFxufVxcbi5zZWxlY3Qtbm9uZSB7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcbi5ncmlkLWNvbHMtXFxcXFs1MHB4XzFmclxcXFxdIHtcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogNTBweCAxZnI7XFxufVxcbi5mbGV4LXJvdyB7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbn1cXG4uZmxleC1jb2wge1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuLml0ZW1zLXN0YXJ0IHtcXG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbn1cXG4uaXRlbXMtY2VudGVyIHtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5qdXN0aWZ5LWNlbnRlciB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuLmp1c3RpZnktYmV0d2VlbiB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcbi5nYXAtMSB7XFxuICBnYXA6IDAuMjVyZW07XFxufVxcbi5nYXAtMVxcXFwuNSB7XFxuICBnYXA6IDAuMzc1cmVtO1xcbn1cXG4uZ2FwLTIge1xcbiAgZ2FwOiAwLjVyZW07XFxufVxcbi5nYXAtNCB7XFxuICBnYXA6IDFyZW07XFxufVxcbi5zcGFjZS14LTQgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteC1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiBjYWxjKDFyZW0gKiB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKTtcXG4gIG1hcmdpbi1sZWZ0OiBjYWxjKDFyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS14LXJldmVyc2UpKSk7XFxufVxcbi5zcGFjZS15LTEgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteS1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXRvcDogY2FsYygwLjI1cmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSkpO1xcbiAgbWFyZ2luLWJvdHRvbTogY2FsYygwLjI1cmVtICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XFxufVxcbi5zcGFjZS15LTFcXFxcLjUgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteS1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXRvcDogY2FsYygwLjM3NXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXG4gIG1hcmdpbi1ib3R0b206IGNhbGMoMC4zNzVyZW0gKiB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTtcXG59XFxuLnNwYWNlLXktMiA+IDpub3QoW2hpZGRlbl0pIH4gOm5vdChbaGlkZGVuXSkge1xcbiAgLS10dy1zcGFjZS15LXJldmVyc2U6IDA7XFxuICBtYXJnaW4tdG9wOiBjYWxjKDAuNXJlbSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcXG4gIG1hcmdpbi1ib3R0b206IGNhbGMoMC41cmVtICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XFxufVxcbi5zcGFjZS15LTQgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteS1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXRvcDogY2FsYygxcmVtICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSkpO1xcbiAgbWFyZ2luLWJvdHRvbTogY2FsYygxcmVtICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XFxufVxcbi5zcGFjZS15LTYgPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pIHtcXG4gIC0tdHctc3BhY2UteS1yZXZlcnNlOiAwO1xcbiAgbWFyZ2luLXRvcDogY2FsYygxLjVyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKSk7XFxuICBtYXJnaW4tYm90dG9tOiBjYWxjKDEuNXJlbSAqIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpO1xcbn1cXG4ub3ZlcmZsb3ctaGlkZGVuIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcbi53aGl0ZXNwYWNlLW5vd3JhcCB7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG4ucm91bmRlZCB7XFxuICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xcbn1cXG4ucm91bmRlZC1cXFxcW2luaGVyaXRcXFxcXSB7XFxuICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xcbn1cXG4ucm91bmRlZC1mdWxsIHtcXG4gIGJvcmRlci1yYWRpdXM6IDk5OTlweDtcXG59XFxuLnJvdW5kZWQtbGcge1xcbiAgYm9yZGVyLXJhZGl1czogdmFyKC0tcmFkaXVzKTtcXG59XFxuLnJvdW5kZWQtbWQge1xcbiAgYm9yZGVyLXJhZGl1czogY2FsYyh2YXIoLS1yYWRpdXMpIC0gMnB4KTtcXG59XFxuLnJvdW5kZWQtbm9uZSB7XFxuICBib3JkZXItcmFkaXVzOiAwcHg7XFxufVxcbi5ib3JkZXIge1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxufVxcbi5ib3JkZXItMCB7XFxuICBib3JkZXItd2lkdGg6IDBweDtcXG59XFxuLmJvcmRlci15LTAge1xcbiAgYm9yZGVyLXRvcC13aWR0aDogMHB4O1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMHB4O1xcbn1cXG4uYm9yZGVyLWwge1xcbiAgYm9yZGVyLWxlZnQtd2lkdGg6IDFweDtcXG59XFxuLmJvcmRlci10IHtcXG4gIGJvcmRlci10b3Atd2lkdGg6IDFweDtcXG59XFxuLmJvcmRlci1ncmF5LTMwMCB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjA5IDIxMyAyMTkgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXG4uYm9yZGVyLWlucHV0IHtcXG4gIGJvcmRlci1jb2xvcjogaHNsKHZhcigtLWlucHV0KSk7XFxufVxcbi5ib3JkZXItbC10cmFuc3BhcmVudCB7XFxuICBib3JkZXItbGVmdC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcbi5ib3JkZXItdC10cmFuc3BhcmVudCB7XFxuICBib3JkZXItdG9wLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuLmJnLWJhY2tncm91bmQge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogaHNsKHZhcigtLWJhY2tncm91bmQpKTtcXG59XFxuLmJnLWJvcmRlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2wodmFyKC0tYm9yZGVyKSk7XFxufVxcbi5iZy1jYXJkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IGhzbCh2YXIoLS1jYXJkKSk7XFxufVxcbi5iZy1kZXN0cnVjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2wodmFyKC0tZGVzdHJ1Y3RpdmUpKTtcXG59XFxuLmJnLW11dGVkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IGhzbCh2YXIoLS1tdXRlZCkpO1xcbn1cXG4uYmctcHJpbWFyeSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2wodmFyKC0tcHJpbWFyeSkpO1xcbn1cXG4uYmctcHVycGxlLTYwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTQ3IDUxIDIzNCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmJnLXNlY29uZGFyeSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2wodmFyKC0tc2Vjb25kYXJ5KSk7XFxufVxcbi5iZy13aGl0ZSB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5vYmplY3QtY292ZXIge1xcbiAgLW8tb2JqZWN0LWZpdDogY292ZXI7XFxuICAgICBvYmplY3QtZml0OiBjb3ZlcjtcXG59XFxuLnAtMCB7XFxuICBwYWRkaW5nOiAwcHg7XFxufVxcbi5wLTIge1xcbiAgcGFkZGluZzogMC41cmVtO1xcbn1cXG4ucC00IHtcXG4gIHBhZGRpbmc6IDFyZW07XFxufVxcbi5wLTYge1xcbiAgcGFkZGluZzogMS41cmVtO1xcbn1cXG4ucC1cXFxcWzFweFxcXFxdIHtcXG4gIHBhZGRpbmc6IDFweDtcXG59XFxuLnB4LTMge1xcbiAgcGFkZGluZy1sZWZ0OiAwLjc1cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMC43NXJlbTtcXG59XFxuLnB4LTQge1xcbiAgcGFkZGluZy1sZWZ0OiAxcmVtO1xcbiAgcGFkZGluZy1yaWdodDogMXJlbTtcXG59XFxuLnB4LTgge1xcbiAgcGFkZGluZy1sZWZ0OiAycmVtO1xcbiAgcGFkZGluZy1yaWdodDogMnJlbTtcXG59XFxuLnB5LTEwIHtcXG4gIHBhZGRpbmctdG9wOiAyLjVyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMi41cmVtO1xcbn1cXG4ucHktMiB7XFxuICBwYWRkaW5nLXRvcDogMC41cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDAuNXJlbTtcXG59XFxuLnBiLTQge1xcbiAgcGFkZGluZy1ib3R0b206IDFyZW07XFxufVxcbi5wdC0wIHtcXG4gIHBhZGRpbmctdG9wOiAwcHg7XFxufVxcbi50ZXh0LWxlZnQge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuLnRleHQtY2VudGVyIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuLnRleHQtMnhsIHtcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDJyZW07XFxufVxcbi50ZXh0LTN4bCB7XFxuICBmb250LXNpemU6IDEuODc1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDIuMjVyZW07XFxufVxcbi50ZXh0LWxnIHtcXG4gIGZvbnQtc2l6ZTogMS4xMjVyZW07XFxuICBsaW5lLWhlaWdodDogMS43NXJlbTtcXG59XFxuLnRleHQtc20ge1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjI1cmVtO1xcbn1cXG4uZm9udC1ib2xkIHtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcbi5mb250LW1lZGl1bSB7XFxuICBmb250LXdlaWdodDogNTAwO1xcbn1cXG4uZm9udC1zZW1pYm9sZCB7XFxuICBmb250LXdlaWdodDogNjAwO1xcbn1cXG4ubGVhZGluZy1ub25lIHtcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcbn1cXG4udHJhY2tpbmctdGlnaHQge1xcbiAgbGV0dGVyLXNwYWNpbmc6IC0wLjAyNWVtO1xcbn1cXG4udGV4dC1jYXJkLWZvcmVncm91bmQge1xcbiAgY29sb3I6IGhzbCh2YXIoLS1jYXJkLWZvcmVncm91bmQpKTtcXG59XFxuLnRleHQtZGVzdHJ1Y3RpdmUtZm9yZWdyb3VuZCB7XFxuICBjb2xvcjogaHNsKHZhcigtLWRlc3RydWN0aXZlLWZvcmVncm91bmQpKTtcXG59XFxuLnRleHQtZ3JheS01MDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDEwNyAxMTQgMTI4IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LWdyYXktNzAwIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig1NSA2NSA4MSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG4udGV4dC1ncmF5LTkwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTcgMjQgMzkgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtbXV0ZWQtZm9yZWdyb3VuZCB7XFxuICBjb2xvcjogaHNsKHZhcigtLW11dGVkLWZvcmVncm91bmQpKTtcXG59XFxuLnRleHQtcHJpbWFyeSB7XFxuICBjb2xvcjogaHNsKHZhcigtLXByaW1hcnkpKTtcXG59XFxuLnRleHQtcHJpbWFyeS1mb3JlZ3JvdW5kIHtcXG4gIGNvbG9yOiBoc2wodmFyKC0tcHJpbWFyeS1mb3JlZ3JvdW5kKSk7XFxufVxcbi50ZXh0LXNlY29uZGFyeS1mb3JlZ3JvdW5kIHtcXG4gIGNvbG9yOiBoc2wodmFyKC0tc2Vjb25kYXJ5LWZvcmVncm91bmQpKTtcXG59XFxuLnRleHQtd2hpdGUge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi51bmRlcmxpbmUtb2Zmc2V0LTQge1xcbiAgdGV4dC11bmRlcmxpbmUtb2Zmc2V0OiA0cHg7XFxufVxcbi5zaGFkb3ctbWQge1xcbiAgLS10dy1zaGFkb3c6IDAgNHB4IDZweCAtMXB4IHJnYigwIDAgMCAvIDAuMSksIDAgMnB4IDRweCAtMnB4IHJnYigwIDAgMCAvIDAuMSk7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDRweCA2cHggLTFweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpLCAwIDJweCA0cHggLTJweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTtcXG59XFxuLnNoYWRvdy1ub25lIHtcXG4gIC0tdHctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDAgIzAwMDA7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcbn1cXG4uc2hhZG93LXNtIHtcXG4gIC0tdHctc2hhZG93OiAwIDFweCAycHggMCByZ2IoMCAwIDAgLyAwLjA1KTtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMXB4IDJweCAwIHZhcigtLXR3LXNoYWRvdy1jb2xvcik7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcbn1cXG4ub3V0bGluZSB7XFxuICBvdXRsaW5lLXN0eWxlOiBzb2xpZDtcXG59XFxuLnJpbmctb2Zmc2V0LWJhY2tncm91bmQge1xcbiAgLS10dy1yaW5nLW9mZnNldC1jb2xvcjogaHNsKHZhcigtLWJhY2tncm91bmQpKTtcXG59XFxuLnRyYW5zaXRpb24tY29sb3JzIHtcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlO1xcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG59XFxuQGtleWZyYW1lcyBlbnRlciB7XFxuXFxuICBmcm9tIHtcXG4gICAgb3BhY2l0eTogdmFyKC0tdHctZW50ZXItb3BhY2l0eSwgMSk7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QodmFyKC0tdHctZW50ZXItdHJhbnNsYXRlLXgsIDApLCB2YXIoLS10dy1lbnRlci10cmFuc2xhdGUteSwgMCksIDApIHNjYWxlM2QodmFyKC0tdHctZW50ZXItc2NhbGUsIDEpLCB2YXIoLS10dy1lbnRlci1zY2FsZSwgMSksIHZhcigtLXR3LWVudGVyLXNjYWxlLCAxKSkgcm90YXRlKHZhcigtLXR3LWVudGVyLXJvdGF0ZSwgMCkpO1xcbiAgfVxcbn1cXG5Aa2V5ZnJhbWVzIGV4aXQge1xcblxcbiAgdG8ge1xcbiAgICBvcGFjaXR5OiB2YXIoLS10dy1leGl0LW9wYWNpdHksIDEpO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKHZhcigtLXR3LWV4aXQtdHJhbnNsYXRlLXgsIDApLCB2YXIoLS10dy1leGl0LXRyYW5zbGF0ZS15LCAwKSwgMCkgc2NhbGUzZCh2YXIoLS10dy1leGl0LXNjYWxlLCAxKSwgdmFyKC0tdHctZXhpdC1zY2FsZSwgMSksIHZhcigtLXR3LWV4aXQtc2NhbGUsIDEpKSByb3RhdGUodmFyKC0tdHctZXhpdC1yb3RhdGUsIDApKTtcXG4gIH1cXG59XFxuXFxuLmZpbGVcXFxcOmJvcmRlci0wOjpmaWxlLXNlbGVjdG9yLWJ1dHRvbiB7XFxuICBib3JkZXItd2lkdGg6IDBweDtcXG59XFxuXFxuLmZpbGVcXFxcOmJnLXRyYW5zcGFyZW50OjpmaWxlLXNlbGVjdG9yLWJ1dHRvbiB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuLmZpbGVcXFxcOnRleHQtc206OmZpbGUtc2VsZWN0b3ItYnV0dG9uIHtcXG4gIGZvbnQtc2l6ZTogMC44NzVyZW07XFxuICBsaW5lLWhlaWdodDogMS4yNXJlbTtcXG59XFxuXFxuLmZpbGVcXFxcOmZvbnQtbWVkaXVtOjpmaWxlLXNlbGVjdG9yLWJ1dHRvbiB7XFxuICBmb250LXdlaWdodDogNTAwO1xcbn1cXG5cXG4ucGxhY2Vob2xkZXJcXFxcOnRleHQtbXV0ZWQtZm9yZWdyb3VuZDo6LW1vei1wbGFjZWhvbGRlciB7XFxuICBjb2xvcjogaHNsKHZhcigtLW11dGVkLWZvcmVncm91bmQpKTtcXG59XFxuXFxuLnBsYWNlaG9sZGVyXFxcXDp0ZXh0LW11dGVkLWZvcmVncm91bmQ6OnBsYWNlaG9sZGVyIHtcXG4gIGNvbG9yOiBoc2wodmFyKC0tbXV0ZWQtZm9yZWdyb3VuZCkpO1xcbn1cXG5cXG4ubGFzdFxcXFw6bWItMDpsYXN0LWNoaWxkIHtcXG4gIG1hcmdpbi1ib3R0b206IDBweDtcXG59XFxuXFxuLmxhc3RcXFxcOnBiLTA6bGFzdC1jaGlsZCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMHB4O1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLWFjY2VudDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2wodmFyKC0tYWNjZW50KSk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctZGVzdHJ1Y3RpdmVcXFxcLzkwOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IGhzbCh2YXIoLS1kZXN0cnVjdGl2ZSkgLyAwLjkpO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLXByaW1hcnlcXFxcLzkwOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IGhzbCh2YXIoLS1wcmltYXJ5KSAvIDAuOSk7XFxufVxcblxcbi5ob3ZlclxcXFw6Ymctc2Vjb25kYXJ5XFxcXC84MDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2wodmFyKC0tc2Vjb25kYXJ5KSAvIDAuOCk7XFxufVxcblxcbi5ob3ZlclxcXFw6dGV4dC1hY2NlbnQtZm9yZWdyb3VuZDpob3ZlciB7XFxuICBjb2xvcjogaHNsKHZhcigtLWFjY2VudC1mb3JlZ3JvdW5kKSk7XFxufVxcblxcbi5ob3ZlclxcXFw6dW5kZXJsaW5lOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbi1saW5lOiB1bmRlcmxpbmU7XFxufVxcblxcbi5mb2N1cy12aXNpYmxlXFxcXDpvdXRsaW5lLW5vbmU6Zm9jdXMtdmlzaWJsZSB7XFxuICBvdXRsaW5lOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBvdXRsaW5lLW9mZnNldDogMnB4O1xcbn1cXG5cXG4uZm9jdXMtdmlzaWJsZVxcXFw6cmluZy0yOmZvY3VzLXZpc2libGUge1xcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSB2YXIoLS10dy1yaW5nLW9mZnNldC1jb2xvcik7XFxuICAtLXR3LXJpbmctc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0KSAwIDAgMCBjYWxjKDJweCArIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSkgdmFyKC0tdHctcmluZy1jb2xvcik7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdywgMCAwICMwMDAwKTtcXG59XFxuXFxuLmZvY3VzLXZpc2libGVcXFxcOnJpbmctcmluZzpmb2N1cy12aXNpYmxlIHtcXG4gIC0tdHctcmluZy1jb2xvcjogaHNsKHZhcigtLXJpbmcpKTtcXG59XFxuXFxuLmZvY3VzLXZpc2libGVcXFxcOnJpbmctb2Zmc2V0LTI6Zm9jdXMtdmlzaWJsZSB7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAycHg7XFxufVxcblxcbi5kaXNhYmxlZFxcXFw6cG9pbnRlci1ldmVudHMtbm9uZTpkaXNhYmxlZCB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLmRpc2FibGVkXFxcXDpjdXJzb3Itbm90LWFsbG93ZWQ6ZGlzYWJsZWQge1xcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG59XFxuXFxuLmRpc2FibGVkXFxcXDpvcGFjaXR5LTUwOmRpc2FibGVkIHtcXG4gIG9wYWNpdHk6IDAuNTtcXG59XFxuXFxuLnBlZXI6ZGlzYWJsZWQgfiAucGVlci1kaXNhYmxlZFxcXFw6Y3Vyc29yLW5vdC1hbGxvd2VkIHtcXG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxufVxcblxcbi5wZWVyOmRpc2FibGVkIH4gLnBlZXItZGlzYWJsZWRcXFxcOm9wYWNpdHktNzAge1xcbiAgb3BhY2l0eTogMC43O1xcbn1cXG5cXG46aXMoLmRhcmsgLmRhcmtcXFxcOnRleHQtZ3JheS00MDApIHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigxNTYgMTYzIDE3NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3JjL2FwcC9nbG9iYWxzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7Q0FBYyxDQUFkOzs7Q0FBYzs7QUFBZDs7O0VBQUEsc0JBQWMsRUFBZCxNQUFjO0VBQWQsZUFBYyxFQUFkLE1BQWM7RUFBZCxtQkFBYyxFQUFkLE1BQWM7RUFBZCxxQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7RUFBQSxnQkFBYztBQUFBOztBQUFkOzs7Ozs7O0NBQWM7O0FBQWQ7RUFBQSxnQkFBYyxFQUFkLE1BQWM7RUFBZCw4QkFBYyxFQUFkLE1BQWM7RUFBZCxnQkFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjO0tBQWQsV0FBYyxFQUFkLE1BQWM7RUFBZCw0TkFBYyxFQUFkLE1BQWM7RUFBZCw2QkFBYyxFQUFkLE1BQWM7RUFBZCwrQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLG9CQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOzs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0VBQWQscUJBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSx5Q0FBYztVQUFkLGlDQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7Ozs7OztFQUFBLGtCQUFjO0VBQWQsb0JBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGNBQWM7RUFBZCx3QkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLG1CQUFjO0FBQUE7O0FBQWQ7Ozs7O0NBQWM7O0FBQWQ7Ozs7RUFBQSwrR0FBYyxFQUFkLE1BQWM7RUFBZCw2QkFBYyxFQUFkLE1BQWM7RUFBZCwrQkFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsY0FBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLGNBQWM7RUFBZCxjQUFjO0VBQWQsa0JBQWM7RUFBZCx3QkFBYztBQUFBOztBQUFkO0VBQUEsZUFBYztBQUFBOztBQUFkO0VBQUEsV0FBYztBQUFBOztBQUFkOzs7O0NBQWM7O0FBQWQ7RUFBQSxjQUFjLEVBQWQsTUFBYztFQUFkLHFCQUFjLEVBQWQsTUFBYztFQUFkLHlCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOzs7O0NBQWM7O0FBQWQ7Ozs7O0VBQUEsb0JBQWMsRUFBZCxNQUFjO0VBQWQsOEJBQWMsRUFBZCxNQUFjO0VBQWQsZ0NBQWMsRUFBZCxNQUFjO0VBQWQsZUFBYyxFQUFkLE1BQWM7RUFBZCxvQkFBYyxFQUFkLE1BQWM7RUFBZCxvQkFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjLEVBQWQsTUFBYztFQUFkLFNBQWMsRUFBZCxNQUFjO0VBQWQsVUFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7RUFBQSxvQkFBYztBQUFBOztBQUFkOzs7Q0FBYzs7QUFBZDs7OztFQUFBLDBCQUFjLEVBQWQsTUFBYztFQUFkLDZCQUFjLEVBQWQsTUFBYztFQUFkLHNCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsYUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsZ0JBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLHdCQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsWUFBYztBQUFBOztBQUFkOzs7Q0FBYzs7QUFBZDtFQUFBLDZCQUFjLEVBQWQsTUFBYztFQUFkLG9CQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsd0JBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSwwQkFBYyxFQUFkLE1BQWM7RUFBZCxhQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsa0JBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7Ozs7Ozs7Ozs7OztFQUFBLFNBQWM7QUFBQTs7QUFBZDtFQUFBLFNBQWM7RUFBZCxVQUFjO0FBQUE7O0FBQWQ7RUFBQSxVQUFjO0FBQUE7O0FBQWQ7OztFQUFBLGdCQUFjO0VBQWQsU0FBYztFQUFkLFVBQWM7QUFBQTs7QUFBZDs7Q0FBYztBQUFkO0VBQUEsVUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkO0VBQUEsZ0JBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSxVQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0VBQUEsVUFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLGVBQWM7QUFBQTs7QUFBZDs7Q0FBYztBQUFkO0VBQUEsZUFBYztBQUFBOztBQUFkOzs7O0NBQWM7O0FBQWQ7Ozs7Ozs7O0VBQUEsY0FBYyxFQUFkLE1BQWM7RUFBZCxzQkFBYyxFQUFkLE1BQWM7QUFB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O0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx5QkFBbUI7S0FBbkIsc0JBQW1CO1VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQixvREFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsK0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLGdFQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtFQUFuQiw4REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsNERBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CLDhEQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEscUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHFCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsNkVBQW1CO0VBQW5CLGlHQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQiw4QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSwwQ0FBbUI7RUFBbkIsdURBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLCtGQUFtQjtFQUFuQix3REFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7O0VBQUE7SUFBQSxtQ0FBbUI7SUFBbkI7RUFBbUI7QUFBQTtBQUFuQjs7RUFBQTtJQUFBLGtDQUFtQjtJQUFuQjtFQUFtQjtBQUFBOztBQUZuQjtFQUFBO0FBNEVBOztBQTVFQTtFQUFBO0FBNEVBOztBQTVFQTtFQUFBLG1CQTRFQTtFQTVFQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQSw4QkE0RUE7RUE1RUE7QUE0RUE7O0FBNUVBO0VBQUEsMkdBNEVBO0VBNUVBLHlHQTRFQTtFQTVFQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQTtBQTRFQTs7QUE1RUE7RUFBQSxvQkE0RUE7RUE1RUE7QUE0RUFcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQHRhaWx3aW5kIGJhc2U7XFxuQHRhaWx3aW5kIGNvbXBvbmVudHM7XFxuQHRhaWx3aW5kIHV0aWxpdGllcztcXG5cXG5AbGF5ZXIgYmFzZSB7XFxuICA6cm9vdCB7XFxuICAgIC0tYmFja2dyb3VuZDogMCAwJSAxMDAlO1xcbiAgICAtLWZvcmVncm91bmQ6IDIyMi4yIDg0JSA0LjklO1xcblxcbiAgICAtLWNhcmQ6IDAgMCUgMTAwJTtcXG4gICAgLS1jYXJkLWZvcmVncm91bmQ6IDIyMi4yIDg0JSA0LjklO1xcblxcbiAgICAtLXBvcG92ZXI6IDAgMCUgMTAwJTtcXG4gICAgLS1wb3BvdmVyLWZvcmVncm91bmQ6IDIyMi4yIDg0JSA0LjklO1xcblxcbiAgICAtLXByaW1hcnk6IDIyMi4yIDQ3LjQlIDExLjIlO1xcbiAgICAtLXByaW1hcnktZm9yZWdyb3VuZDogMjEwIDQwJSA5OCU7XFxuXFxuICAgIC0tc2Vjb25kYXJ5OiAyMTAgNDAlIDk2LjElO1xcbiAgICAtLXNlY29uZGFyeS1mb3JlZ3JvdW5kOiAyMjIuMiA0Ny40JSAxMS4yJTtcXG5cXG4gICAgLS1tdXRlZDogMjEwIDQwJSA5Ni4xJTtcXG4gICAgLS1tdXRlZC1mb3JlZ3JvdW5kOiAyMTUuNCAxNi4zJSA0Ni45JTtcXG5cXG4gICAgLS1hY2NlbnQ6IDIxMCA0MCUgOTYuMSU7XFxuICAgIC0tYWNjZW50LWZvcmVncm91bmQ6IDIyMi4yIDQ3LjQlIDExLjIlO1xcblxcbiAgICAtLWRlc3RydWN0aXZlOiAwIDg0LjIlIDYwLjIlO1xcbiAgICAtLWRlc3RydWN0aXZlLWZvcmVncm91bmQ6IDIxMCA0MCUgOTglO1xcblxcbiAgICAtLWJvcmRlcjogMjE0LjMgMzEuOCUgOTEuNCU7XFxuICAgIC0taW5wdXQ6IDIxNC4zIDMxLjglIDkxLjQlO1xcbiAgICAtLXJpbmc6IDIyMi4yIDg0JSA0LjklO1xcblxcbiAgICAtLXJhZGl1czogMC41cmVtO1xcbiAgfVxcblxcbiAgLmRhcmsge1xcbiAgICAtLWJhY2tncm91bmQ6IDIyMi4yIDg0JSA0LjklO1xcbiAgICAtLWZvcmVncm91bmQ6IDIxMCA0MCUgOTglO1xcblxcbiAgICAtLWNhcmQ6IDIyMi4yIDg0JSA0LjklO1xcbiAgICAtLWNhcmQtZm9yZWdyb3VuZDogMjEwIDQwJSA5OCU7XFxuXFxuICAgIC0tcG9wb3ZlcjogMjIyLjIgODQlIDQuOSU7XFxuICAgIC0tcG9wb3Zlci1mb3JlZ3JvdW5kOiAyMTAgNDAlIDk4JTtcXG5cXG4gICAgLS1wcmltYXJ5OiAyMTAgNDAlIDk4JTtcXG4gICAgLS1wcmltYXJ5LWZvcmVncm91bmQ6IDIyMi4yIDQ3LjQlIDExLjIlO1xcblxcbiAgICAtLXNlY29uZGFyeTogMjE3LjIgMzIuNiUgMTcuNSU7XFxuICAgIC0tc2Vjb25kYXJ5LWZvcmVncm91bmQ6IDIxMCA0MCUgOTglO1xcblxcbiAgICAtLW11dGVkOiAyMTcuMiAzMi42JSAxNy41JTtcXG4gICAgLS1tdXRlZC1mb3JlZ3JvdW5kOiAyMTUgMjAuMiUgNjUuMSU7XFxuXFxuICAgIC0tYWNjZW50OiAyMTcuMiAzMi42JSAxNy41JTtcXG4gICAgLS1hY2NlbnQtZm9yZWdyb3VuZDogMjEwIDQwJSA5OCU7XFxuXFxuICAgIC0tZGVzdHJ1Y3RpdmU6IDAgNjIuOCUgMzAuNiU7XFxuICAgIC0tZGVzdHJ1Y3RpdmUtZm9yZWdyb3VuZDogMjEwIDQwJSA5OCU7XFxuXFxuICAgIC0tYm9yZGVyOiAyMTcuMiAzMi42JSAxNy41JTtcXG4gICAgLS1pbnB1dDogMjE3LjIgMzIuNiUgMTcuNSU7XFxuICAgIC0tcmluZzogMjEyLjcgMjYuOCUgODMuOSU7XFxuICB9XFxufVxcblxcbkBsYXllciBiYXNlIHtcXG4gICoge1xcbiAgICBAYXBwbHkgYm9yZGVyLWJvcmRlcjtcXG4gIH1cXG4gIGJvZHkge1xcbiAgICBAYXBwbHkgYmctYmFja2dyb3VuZCB0ZXh0LWZvcmVncm91bmQ7XFxuICB9XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[2]!./src/app/globals.css\n"));

/***/ }),

/***/ "../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!*******************************************************************************************!*\
  !*** ../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \*******************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n            }\n            return content;\n        }).join(\"\");\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    // @ts-expect-error TODO: fix type\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    \"\"\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join(\"\\n\");\n    }\n    return [\n        content\n    ].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcz8xYzc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovIC8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuICAgIHZhciBsaXN0ID0gW10gLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICAgIDtcbiAgICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcbiAgICAgICAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICB9IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gICAgO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBmaXggdHlwZVxuICAgIGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgbW9kdWxlcyA9IFtcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZXMsXG4gICAgICAgICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgICAgIGlmIChkZWR1cGUpIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspe1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuICAgICAgICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICAgIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCBcIlwiIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIDtcbiAgICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gICAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICAgICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgXS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtcbiAgICAgICAgICAgIHNvdXJjZU1hcHBpbmdcbiAgICAgICAgXSkuam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29udGVudFxuICAgIF0uam9pbihcIlxcblwiKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "../../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!**************************************************************************************************************************************************!*\
  !*** ../../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \**************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./src/pages/_app.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1jbGllbnQtcGFnZXMtbG9hZGVyLmpzP2Fic29sdXRlUGFnZVBhdGg9cHJpdmF0ZS1uZXh0LXBhZ2VzJTJGX2FwcCZwYWdlPSUyRl9hcHAhIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMscURBQXlCO0FBQ2hEO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9jOGMxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvX2FwcFwiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcInByaXZhdGUtbmV4dC1wYWdlcy9fYXBwXCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9fYXBwXCJdKVxuICAgICAgfSk7XG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[1]!../../../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[2]!./globals.css */ \"../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[2]!./src/app/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[1]!../../../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[2]!./globals.css */ \"../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[2]!./src/app/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[1]!../../../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[2]!./globals.css */ \"../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[11].oneOf[14].use[2]!./src/app/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwL2dsb2JhbHMuY3NzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyx1T0FBb0g7QUFDdEksMEJBQTBCLG1CQUFPLENBQUMsc2hCQUEyUTs7QUFFN1M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLHNoQkFBMlE7QUFDalI7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxzaEJBQTJROztBQUVyUzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2dsb2JhbHMuY3NzP2ZlNzIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzExXS5vbmVPZlsxNF0udXNlWzFdIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxMV0ub25lT2ZbMTRdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxMV0ub25lT2ZbMTRdLnVzZVsxXSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMTFdLm9uZU9mWzE0XS51c2VbMl0hLi9nbG9iYWxzLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMTFdLm9uZU9mWzE0XS51c2VbMV0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzExXS5vbmVPZlsxNF0udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/app/globals.css\n"));

/***/ }),

/***/ "../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \*******************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTargetElement = function() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTargetElement(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, _options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/M2NkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICAgIGxldCBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgICAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xufSgpO1xuY29uc3QgZ2V0VGFyZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IG1lbW8gPSB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZXQgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuICAgICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgICB9O1xufSgpO1xuY29uc3Qgc3R5bGVzSW5Eb20gPSBbXTtcbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICBsZXQgcmVzdWx0ID0gLTE7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpZENvdW50TWFwID0ge307XG4gICAgY29uc3QgaWRlbnRpZmllcnMgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICBjb25zdCBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgICAgICBjb25zdCBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBpZCArIFwiIFwiICsgY291bnQudG9TdHJpbmcoKTtcbiAgICAgICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgICAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG4gICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICAgIHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnQgfHwgXCJoZWFkXCIpO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovIGNvbnN0IHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gICAgY29uc3QgdGV4dFN0b3JlID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICB9O1xufSgpO1xuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gICAgY29uc3QgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiICsgb2JqLm1lZGlhICsgXCIge1wiICsgb2JqLmNzcyArIFwifVwiIDogb2JqLmNzcztcbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgX29wdGlvbnMsIG9iaikge1xuICAgIGxldCBjc3MgPSBvYmouY3NzO1xuICAgIGNvbnN0IG1lZGlhID0gb2JqLm1lZGlhO1xuICAgIGNvbnN0IHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG4gICAgfVxuICAgIC8vIEZvciBvbGQgSUVcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZShzdHlsZS5maXJzdENoaWxkKXtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICAgIH1cbn1cbmxldCBzaW5nbGV0b24gPSBudWxsO1xubGV0IHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gICAgbGV0IHN0eWxlO1xuICAgIGxldCB1cGRhdGU7XG4gICAgbGV0IHJlbW92ZTtcbiAgICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICAgICAgY29uc3Qgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICAgICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgICAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuICAgICAgICByZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZShvYmopO1xuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICAgICAgaWYgKG5ld09iaikge1xuICAgICAgICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gICAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuICAgIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgICB9XG4gICAgbGlzdCA9IGxpc3QgfHwgW107XG4gICAgbGV0IGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICAgICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGlmIChzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gICAgfTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./src/declarations/index.ts":
/*!***********************************!*\
  !*** ./src/declarations/index.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canisters: function() { return /* binding */ Canisters; }\n/* harmony export */ });\n/* harmony import */ var _test__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./test */ \"./src/declarations/test/index.js\");\n/* harmony import */ var _user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./user */ \"./src/declarations/user/index.js\");\n\n\nconst Canisters = {\n    test: _test__WEBPACK_IMPORTED_MODULE_0__,\n    user: _user__WEBPACK_IMPORTED_MODULE_1__\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGVjbGFyYXRpb25zL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNBO0FBRXhCLE1BQU1FLFlBQVk7SUFDakJGLElBQUlBLG9DQUFBQTtJQUNaQyxJQUFJQSxvQ0FBQUE7QUFDQSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9kZWNsYXJhdGlvbnMvaW5kZXgudHM/Y2M3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0ZXN0IGZyb20gJy4vdGVzdCc7XG5pbXBvcnQgKiBhcyB1c2VyIGZyb20gJy4vdXNlcic7XG5cbmV4cG9ydCBjb25zdCBDYW5pc3RlcnMgPSB7XG4gICAgICAgIHRlc3QsXG51c2VyXG4gICAgfTtcblxuZXhwb3J0IHR5cGUgQ2FuaXN0ZXJUeXBlcyA9IHR5cGVvZiBDYW5pc3RlcnM7XG5cbmV4cG9ydCB0eXBlIENhbmlzdGVyVHlwZUtleXMgPSBrZXlvZiBDYW5pc3RlclR5cGVzOyJdLCJuYW1lcyI6WyJ0ZXN0IiwidXNlciIsIkNhbmlzdGVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/declarations/index.ts\n"));

/***/ }),

/***/ "./src/declarations/test/index.js":
/*!****************************************!*\
  !*** ./src/declarations/test/index.js ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canisterId: function() { return /* binding */ canisterId; },\n/* harmony export */   createActor: function() { return /* binding */ createActor; },\n/* harmony export */   idlFactory: function() { return /* reexport safe */ _test_did_js__WEBPACK_IMPORTED_MODULE_1__.idlFactory; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"../../../node_modules/@dfinity/agent/lib/esm/index.js\");\n/* harmony import */ var _test_did_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./test.did.js */ \"./src/declarations/test/test.did.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../../node_modules/next/dist/build/polyfills/process.js\");\n\n// Imports and re-exports candid interface\n\n\n/* CANISTER_ID is replaced by webpack based on node environment\n * Note: canister environment variable will be standardized as\n * process.env.CANISTER_ID_<CANISTER_NAME_UPPERCASE>\n * beginning in dfx 0.15.0\n */ const canisterId = process.env.CANISTER_ID_TEST || \"bd3sg-teaaa-aaaaa-qaaba-cai\";\nconst createActor = function(canisterId) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const agent = options.agent || new _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.HttpAgent({\n        ...options.agentOptions\n    });\n    if (options.agent && options.agentOptions) {\n        console.warn(\"Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.\");\n    }\n    // Fetch root key for certificate validation during development\n    if (true) {\n        agent.fetchRootKey().catch((err)=>{\n            console.warn(\"Unable to fetch root key. Check to ensure that your local replica is running\");\n            console.error(err);\n        });\n    }\n    // Creates an actor with using the candid interface and the HttpAgent\n    return _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(_test_did_js__WEBPACK_IMPORTED_MODULE_1__.idlFactory, {\n        agent,\n        canisterId,\n        ...options.actorOptions\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGVjbGFyYXRpb25zL3Rlc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtEO0FBRWxELDBDQUEwQztBQUNDO0FBQ0E7QUFFM0M7Ozs7Q0FJQyxHQUNNLE1BQU1HLGFBQ1hDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsZ0JBQWdCLElBQzVCRiw2QkFBd0MsQ0FBQztBQUVwQyxNQUFNSSxjQUFjLFNBQUNMO1FBQVlNLDJFQUFVLENBQUM7SUFDakQsTUFBTUMsUUFBUUQsUUFBUUMsS0FBSyxJQUFJLElBQUlULHFEQUFTQSxDQUFDO1FBQUUsR0FBR1EsUUFBUUUsWUFBWTtJQUFDO0lBRXZFLElBQUlGLFFBQVFDLEtBQUssSUFBSUQsUUFBUUUsWUFBWSxFQUFFO1FBQ3pDQyxRQUFRQyxJQUFJLENBQ1Y7SUFFSjtJQUVBLCtEQUErRDtJQUMvRCxJQUFJVCxJQUFnQyxFQUFFO1FBQ3BDTSxNQUFNSyxZQUFZLEdBQUdDLEtBQUssQ0FBQyxDQUFDQztZQUMxQkwsUUFBUUMsSUFBSSxDQUNWO1lBRUZELFFBQVFNLEtBQUssQ0FBQ0Q7UUFDaEI7SUFDRjtJQUVBLHFFQUFxRTtJQUNyRSxPQUFPakIsaURBQUtBLENBQUNRLFdBQVcsQ0FBQ04sb0RBQVVBLEVBQUU7UUFDbkNRO1FBQ0FQO1FBQ0EsR0FBR00sUUFBUVUsWUFBWTtJQUN6QjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2RlY2xhcmF0aW9ucy90ZXN0L2luZGV4LmpzPzJkODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0b3IsIEh0dHBBZ2VudCB9IGZyb20gXCJAZGZpbml0eS9hZ2VudFwiO1xuXG4vLyBJbXBvcnRzIGFuZCByZS1leHBvcnRzIGNhbmRpZCBpbnRlcmZhY2VcbmltcG9ydCB7IGlkbEZhY3RvcnkgfSBmcm9tIFwiLi90ZXN0LmRpZC5qc1wiO1xuZXhwb3J0IHsgaWRsRmFjdG9yeSB9IGZyb20gXCIuL3Rlc3QuZGlkLmpzXCI7XG5cbi8qIENBTklTVEVSX0lEIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgYmFzZWQgb24gbm9kZSBlbnZpcm9ubWVudFxuICogTm90ZTogY2FuaXN0ZXIgZW52aXJvbm1lbnQgdmFyaWFibGUgd2lsbCBiZSBzdGFuZGFyZGl6ZWQgYXNcbiAqIHByb2Nlc3MuZW52LkNBTklTVEVSX0lEXzxDQU5JU1RFUl9OQU1FX1VQUEVSQ0FTRT5cbiAqIGJlZ2lubmluZyBpbiBkZnggMC4xNS4wXG4gKi9cbmV4cG9ydCBjb25zdCBjYW5pc3RlcklkID1cbiAgcHJvY2Vzcy5lbnYuQ0FOSVNURVJfSURfVEVTVCB8fFxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19URVNUX0NBTklTVEVSX0lEO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQWN0b3IgPSAoY2FuaXN0ZXJJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGFnZW50ID0gb3B0aW9ucy5hZ2VudCB8fCBuZXcgSHR0cEFnZW50KHsgLi4ub3B0aW9ucy5hZ2VudE9wdGlvbnMgfSk7XG5cbiAgaWYgKG9wdGlvbnMuYWdlbnQgJiYgb3B0aW9ucy5hZ2VudE9wdGlvbnMpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIkRldGVjdGVkIGJvdGggYWdlbnQgYW5kIGFnZW50T3B0aW9ucyBwYXNzZWQgdG8gY3JlYXRlQWN0b3IuIElnbm9yaW5nIGFnZW50T3B0aW9ucyBhbmQgcHJvY2VlZGluZyB3aXRoIHRoZSBwcm92aWRlZCBhZ2VudC5cIlxuICAgICk7XG4gIH1cblxuICAvLyBGZXRjaCByb290IGtleSBmb3IgY2VydGlmaWNhdGUgdmFsaWRhdGlvbiBkdXJpbmcgZGV2ZWxvcG1lbnRcbiAgaWYgKHByb2Nlc3MuZW52LkRGWF9ORVRXT1JLICE9PSBcImljXCIpIHtcbiAgICBhZ2VudC5mZXRjaFJvb3RLZXkoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVW5hYmxlIHRvIGZldGNoIHJvb3Qga2V5LiBDaGVjayB0byBlbnN1cmUgdGhhdCB5b3VyIGxvY2FsIHJlcGxpY2EgaXMgcnVubmluZ1wiXG4gICAgICApO1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhbiBhY3RvciB3aXRoIHVzaW5nIHRoZSBjYW5kaWQgaW50ZXJmYWNlIGFuZCB0aGUgSHR0cEFnZW50XG4gIHJldHVybiBBY3Rvci5jcmVhdGVBY3RvcihpZGxGYWN0b3J5LCB7XG4gICAgYWdlbnQsXG4gICAgY2FuaXN0ZXJJZCxcbiAgICAuLi5vcHRpb25zLmFjdG9yT3B0aW9ucyxcbiAgfSk7XG59O1xuXG5cbiJdLCJuYW1lcyI6WyJBY3RvciIsIkh0dHBBZ2VudCIsImlkbEZhY3RvcnkiLCJjYW5pc3RlcklkIiwicHJvY2VzcyIsImVudiIsIkNBTklTVEVSX0lEX1RFU1QiLCJORVhUX1BVQkxJQ19URVNUX0NBTklTVEVSX0lEIiwiY3JlYXRlQWN0b3IiLCJvcHRpb25zIiwiYWdlbnQiLCJhZ2VudE9wdGlvbnMiLCJjb25zb2xlIiwid2FybiIsIkRGWF9ORVRXT1JLIiwiZmV0Y2hSb290S2V5IiwiY2F0Y2giLCJlcnIiLCJlcnJvciIsImFjdG9yT3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/declarations/test/index.js\n"));

/***/ }),

/***/ "./src/declarations/test/test.did.js":
/*!*******************************************!*\
  !*** ./src/declarations/test/test.did.js ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   idlFactory: function() { return /* binding */ idlFactory; },\n/* harmony export */   init: function() { return /* binding */ init; }\n/* harmony export */ });\nconst idlFactory = (param)=>{\n    let { IDL } = param;\n    return IDL.Service({\n        \"greet\": IDL.Func([\n            IDL.Text\n        ], [\n            IDL.Text\n        ], [\n            \"query\"\n        ])\n    });\n};\nconst init = (param)=>{\n    let { IDL } = param;\n    return [];\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGVjbGFyYXRpb25zL3Rlc3QvdGVzdC5kaWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxNQUFNQSxhQUFhO1FBQUMsRUFBRUMsR0FBRyxFQUFFO0lBQ2hDLE9BQU9BLElBQUlDLE9BQU8sQ0FBQztRQUFFLFNBQVVELElBQUlFLElBQUksQ0FBQztZQUFDRixJQUFJRyxJQUFJO1NBQUMsRUFBRTtZQUFDSCxJQUFJRyxJQUFJO1NBQUMsRUFBRTtZQUFDO1NBQVE7SUFBRTtBQUM3RSxFQUFFO0FBQ0ssTUFBTUMsT0FBTztRQUFDLEVBQUVKLEdBQUcsRUFBRTtJQUFPLE9BQU8sRUFBRTtBQUFFLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2RlY2xhcmF0aW9ucy90ZXN0L3Rlc3QuZGlkLmpzP2I2MGIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGlkbEZhY3RvcnkgPSAoeyBJREwgfSkgPT4ge1xuICByZXR1cm4gSURMLlNlcnZpY2UoeyAnZ3JlZXQnIDogSURMLkZ1bmMoW0lETC5UZXh0XSwgW0lETC5UZXh0XSwgWydxdWVyeSddKSB9KTtcbn07XG5leHBvcnQgY29uc3QgaW5pdCA9ICh7IElETCB9KSA9PiB7IHJldHVybiBbXTsgfTtcbiJdLCJuYW1lcyI6WyJpZGxGYWN0b3J5IiwiSURMIiwiU2VydmljZSIsIkZ1bmMiLCJUZXh0IiwiaW5pdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/declarations/test/test.did.js\n"));

/***/ }),

/***/ "./src/declarations/user/index.js":
/*!****************************************!*\
  !*** ./src/declarations/user/index.js ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canisterId: function() { return /* binding */ canisterId; },\n/* harmony export */   createActor: function() { return /* binding */ createActor; },\n/* harmony export */   idlFactory: function() { return /* reexport safe */ _user_did_js__WEBPACK_IMPORTED_MODULE_1__.idlFactory; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"../../../node_modules/@dfinity/agent/lib/esm/index.js\");\n/* harmony import */ var _user_did_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./user.did.js */ \"./src/declarations/user/user.did.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../../node_modules/next/dist/build/polyfills/process.js\");\n\n// Imports and re-exports candid interface\n\n\n/* CANISTER_ID is replaced by webpack based on node environment\n * Note: canister environment variable will be standardized as\n * process.env.CANISTER_ID_<CANISTER_NAME_UPPERCASE>\n * beginning in dfx 0.15.0\n */ const canisterId = process.env.CANISTER_ID_USER || \"be2us-64aaa-aaaaa-qaabq-cai\";\nconst createActor = function(canisterId) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const agent = options.agent || new _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.HttpAgent({\n        ...options.agentOptions\n    });\n    if (options.agent && options.agentOptions) {\n        console.warn(\"Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent.\");\n    }\n    // Fetch root key for certificate validation during development\n    if (true) {\n        agent.fetchRootKey().catch((err)=>{\n            console.warn(\"Unable to fetch root key. Check to ensure that your local replica is running\");\n            console.error(err);\n        });\n    }\n    // Creates an actor with using the candid interface and the HttpAgent\n    return _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(_user_did_js__WEBPACK_IMPORTED_MODULE_1__.idlFactory, {\n        agent,\n        canisterId,\n        ...options.actorOptions\n    });\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGVjbGFyYXRpb25zL3VzZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtEO0FBRWxELDBDQUEwQztBQUNDO0FBQ0E7QUFFM0M7Ozs7Q0FJQyxHQUNNLE1BQU1HLGFBQ1hDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsZ0JBQWdCLElBQzVCRiw2QkFBd0MsQ0FBQztBQUVwQyxNQUFNSSxjQUFjLFNBQUNMO1FBQVlNLDJFQUFVLENBQUM7SUFDakQsTUFBTUMsUUFBUUQsUUFBUUMsS0FBSyxJQUFJLElBQUlULHFEQUFTQSxDQUFDO1FBQUUsR0FBR1EsUUFBUUUsWUFBWTtJQUFDO0lBRXZFLElBQUlGLFFBQVFDLEtBQUssSUFBSUQsUUFBUUUsWUFBWSxFQUFFO1FBQ3pDQyxRQUFRQyxJQUFJLENBQ1Y7SUFFSjtJQUVBLCtEQUErRDtJQUMvRCxJQUFJVCxJQUFnQyxFQUFFO1FBQ3BDTSxNQUFNSyxZQUFZLEdBQUdDLEtBQUssQ0FBQyxDQUFDQztZQUMxQkwsUUFBUUMsSUFBSSxDQUNWO1lBRUZELFFBQVFNLEtBQUssQ0FBQ0Q7UUFDaEI7SUFDRjtJQUVBLHFFQUFxRTtJQUNyRSxPQUFPakIsaURBQUtBLENBQUNRLFdBQVcsQ0FBQ04sb0RBQVVBLEVBQUU7UUFDbkNRO1FBQ0FQO1FBQ0EsR0FBR00sUUFBUVUsWUFBWTtJQUN6QjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2RlY2xhcmF0aW9ucy91c2VyL2luZGV4LmpzPzA3MTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0b3IsIEh0dHBBZ2VudCB9IGZyb20gXCJAZGZpbml0eS9hZ2VudFwiO1xuXG4vLyBJbXBvcnRzIGFuZCByZS1leHBvcnRzIGNhbmRpZCBpbnRlcmZhY2VcbmltcG9ydCB7IGlkbEZhY3RvcnkgfSBmcm9tIFwiLi91c2VyLmRpZC5qc1wiO1xuZXhwb3J0IHsgaWRsRmFjdG9yeSB9IGZyb20gXCIuL3VzZXIuZGlkLmpzXCI7XG5cbi8qIENBTklTVEVSX0lEIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgYmFzZWQgb24gbm9kZSBlbnZpcm9ubWVudFxuICogTm90ZTogY2FuaXN0ZXIgZW52aXJvbm1lbnQgdmFyaWFibGUgd2lsbCBiZSBzdGFuZGFyZGl6ZWQgYXNcbiAqIHByb2Nlc3MuZW52LkNBTklTVEVSX0lEXzxDQU5JU1RFUl9OQU1FX1VQUEVSQ0FTRT5cbiAqIGJlZ2lubmluZyBpbiBkZnggMC4xNS4wXG4gKi9cbmV4cG9ydCBjb25zdCBjYW5pc3RlcklkID1cbiAgcHJvY2Vzcy5lbnYuQ0FOSVNURVJfSURfVVNFUiB8fFxuICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19VU0VSX0NBTklTVEVSX0lEO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQWN0b3IgPSAoY2FuaXN0ZXJJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGFnZW50ID0gb3B0aW9ucy5hZ2VudCB8fCBuZXcgSHR0cEFnZW50KHsgLi4ub3B0aW9ucy5hZ2VudE9wdGlvbnMgfSk7XG5cbiAgaWYgKG9wdGlvbnMuYWdlbnQgJiYgb3B0aW9ucy5hZ2VudE9wdGlvbnMpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIkRldGVjdGVkIGJvdGggYWdlbnQgYW5kIGFnZW50T3B0aW9ucyBwYXNzZWQgdG8gY3JlYXRlQWN0b3IuIElnbm9yaW5nIGFnZW50T3B0aW9ucyBhbmQgcHJvY2VlZGluZyB3aXRoIHRoZSBwcm92aWRlZCBhZ2VudC5cIlxuICAgICk7XG4gIH1cblxuICAvLyBGZXRjaCByb290IGtleSBmb3IgY2VydGlmaWNhdGUgdmFsaWRhdGlvbiBkdXJpbmcgZGV2ZWxvcG1lbnRcbiAgaWYgKHByb2Nlc3MuZW52LkRGWF9ORVRXT1JLICE9PSBcImljXCIpIHtcbiAgICBhZ2VudC5mZXRjaFJvb3RLZXkoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVW5hYmxlIHRvIGZldGNoIHJvb3Qga2V5LiBDaGVjayB0byBlbnN1cmUgdGhhdCB5b3VyIGxvY2FsIHJlcGxpY2EgaXMgcnVubmluZ1wiXG4gICAgICApO1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyBhbiBhY3RvciB3aXRoIHVzaW5nIHRoZSBjYW5kaWQgaW50ZXJmYWNlIGFuZCB0aGUgSHR0cEFnZW50XG4gIHJldHVybiBBY3Rvci5jcmVhdGVBY3RvcihpZGxGYWN0b3J5LCB7XG4gICAgYWdlbnQsXG4gICAgY2FuaXN0ZXJJZCxcbiAgICAuLi5vcHRpb25zLmFjdG9yT3B0aW9ucyxcbiAgfSk7XG59O1xuXG5cbiJdLCJuYW1lcyI6WyJBY3RvciIsIkh0dHBBZ2VudCIsImlkbEZhY3RvcnkiLCJjYW5pc3RlcklkIiwicHJvY2VzcyIsImVudiIsIkNBTklTVEVSX0lEX1VTRVIiLCJORVhUX1BVQkxJQ19VU0VSX0NBTklTVEVSX0lEIiwiY3JlYXRlQWN0b3IiLCJvcHRpb25zIiwiYWdlbnQiLCJhZ2VudE9wdGlvbnMiLCJjb25zb2xlIiwid2FybiIsIkRGWF9ORVRXT1JLIiwiZmV0Y2hSb290S2V5IiwiY2F0Y2giLCJlcnIiLCJlcnJvciIsImFjdG9yT3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/declarations/user/index.js\n"));

/***/ }),

/***/ "./src/declarations/user/user.did.js":
/*!*******************************************!*\
  !*** ./src/declarations/user/user.did.js ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   idlFactory: function() { return /* binding */ idlFactory; },\n/* harmony export */   init: function() { return /* binding */ init; }\n/* harmony export */ });\nconst idlFactory = (param)=>{\n    let { IDL } = param;\n    const ImageMimeTypes = IDL.Variant({\n        \"jpg\": IDL.Null,\n        \"jpeg\": IDL.Null\n    });\n    const Image = IDL.Record({\n        \"url\": IDL.Text,\n        \"encoding\": IDL.Text,\n        \"blob\": IDL.Vec(IDL.Nat8),\n        \"name\": IDL.Text,\n        \"size\": IDL.Nat,\n        \"mimetype\": ImageMimeTypes\n    });\n    const BirthDay = IDL.Record({\n        \"day\": IDL.Nat8,\n        \"month\": IDL.Nat8,\n        \"year\": IDL.Nat8\n    });\n    const CreateUserData = IDL.Record({\n        \"bio\": IDL.Text,\n        \"username\": IDL.Text,\n        \"picture\": Image,\n        \"birthday\": BirthDay\n    });\n    const CreateUserError = IDL.Variant({\n        \"userNotAuthenticated\": IDL.Null,\n        \"userAlreadyExists\": IDL.Null\n    });\n    const Result_3 = IDL.Variant({\n        \"ok\": IDL.Null,\n        \"err\": CreateUserError\n    });\n    const CreatePostData = IDL.Record({\n        \"description\": IDL.Text,\n        \"images\": IDL.Vec(Image)\n    });\n    const CreatePostError = IDL.Variant({\n        \"userNotFound\": IDL.Null,\n        \"userNotAuthenticated\": IDL.Null\n    });\n    const Result_2 = IDL.Variant({\n        \"ok\": IDL.Null,\n        \"err\": CreatePostError\n    });\n    const GetPostsFilters = IDL.Record({\n        \"to\": IDL.Int,\n        \"from\": IDL.Int\n    });\n    const PostCommentLike = IDL.Record({\n        \"userId\": IDL.Principal,\n        \"createdAt\": IDL.Int\n    });\n    const PostComment = IDL.Record({\n        \"id\": IDL.Principal,\n        \"linkedComment\": IDL.Opt(IDL.Principal),\n        \"userId\": IDL.Principal,\n        \"createdAt\": IDL.Int,\n        \"likes\": IDL.Vec(PostCommentLike),\n        \"comment\": IDL.Text\n    });\n    const Post = IDL.Record({\n        \"id\": IDL.Text,\n        \"createdAt\": IDL.Int,\n        \"description\": IDL.Text,\n        \"likes\": IDL.Vec(IDL.Principal),\n        \"updatedAt\": IDL.Int,\n        \"comments\": IDL.Vec(PostComment),\n        \"images\": IDL.Vec(Image)\n    });\n    const GetPostsResult = IDL.Record({\n        \"data\": IDL.Vec(IDL.Tuple(IDL.Text, Post))\n    });\n    const GetPostsError = IDL.Variant({\n        \"userNotFound\": IDL.Null,\n        \"userNotAuthenticated\": IDL.Null\n    });\n    const Result_1 = IDL.Variant({\n        \"ok\": GetPostsResult,\n        \"err\": GetPostsError\n    });\n    const UserProfile = IDL.Record({\n        \"bio\": IDL.Text,\n        \"username\": IDL.Text,\n        \"createdAt\": IDL.Int,\n        \"picture\": Image,\n        \"birthday\": BirthDay\n    });\n    const GetProfileError = IDL.Variant({\n        \"userNotFound\": IDL.Null,\n        \"userNotAuthenticated\": IDL.Null\n    });\n    const Result = IDL.Variant({\n        \"ok\": UserProfile,\n        \"err\": GetProfileError\n    });\n    return IDL.Service({\n        \"create\": IDL.Func([\n            CreateUserData\n        ], [\n            Result_3\n        ], []),\n        \"createPost\": IDL.Func([\n            CreatePostData\n        ], [\n            Result_2\n        ], []),\n        \"getPosts\": IDL.Func([\n            GetPostsFilters\n        ], [\n            Result_1\n        ], [\n            \"composite_query\"\n        ]),\n        \"getProfile\": IDL.Func([], [\n            Result\n        ], [\n            \"composite_query\"\n        ])\n    });\n};\nconst init = (param)=>{\n    let { IDL } = param;\n    return [];\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aEMsZ0JBQWlCRixJQUFJRyxJQUFJO1FBQ3pCLHdCQUF5QkgsSUFBSUcsSUFBSTtJQUNuQztJQUNBLE1BQU13QixXQUFXM0IsSUFBSUUsT0FBTyxDQUFDO1FBQzNCLE1BQU9zQjtRQUNQLE9BQVFFO0lBQ1Y7SUFDQSxNQUFNRSxjQUFjNUIsSUFBSUssTUFBTSxDQUFDO1FBQzdCLE9BQVFMLElBQUlNLElBQUk7UUFDaEIsWUFBYU4sSUFBSU0sSUFBSTtRQUNyQixhQUFjTixJQUFJa0IsR0FBRztRQUNyQixXQUFZZDtRQUNaLFlBQWFNO0lBQ2Y7SUFDQSxNQUFNbUIsa0JBQWtCN0IsSUFBSUUsT0FBTyxDQUFDO1FBQ2xDLGdCQUFpQkYsSUFBSUcsSUFBSTtRQUN6Qix3QkFBeUJILElBQUlHLElBQUk7SUFDbkM7SUFDQSxNQUFNMkIsU0FBUzlCLElBQUlFLE9BQU8sQ0FBQztRQUFFLE1BQU8wQjtRQUFhLE9BQVFDO0lBQWdCO0lBQ3pFLE9BQU83QixJQUFJK0IsT0FBTyxDQUFDO1FBQ2pCLFVBQVcvQixJQUFJZ0MsSUFBSSxDQUFDO1lBQUNyQjtTQUFlLEVBQUU7WUFBQ0U7U0FBUyxFQUFFLEVBQUU7UUFDcEQsY0FBZWIsSUFBSWdDLElBQUksQ0FBQztZQUFDbEI7U0FBZSxFQUFFO1lBQUNFO1NBQVMsRUFBRSxFQUFFO1FBQ3hELFlBQWFoQixJQUFJZ0MsSUFBSSxDQUFDO1lBQUNmO1NBQWdCLEVBQUU7WUFBQ1U7U0FBUyxFQUFFO1lBQUM7U0FBa0I7UUFDeEUsY0FBZTNCLElBQUlnQyxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQUNGO1NBQU8sRUFBRTtZQUFDO1NBQWtCO0lBQzNEO0FBQ0YsRUFBRTtBQUNLLE1BQU1HLE9BQU87UUFBQyxFQUFFakMsR0FBRyxFQUFFO0lBQU8sT0FBTyxFQUFFO0FBQUUsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvZGVjbGFyYXRpb25zL3VzZXIvdXNlci5kaWQuanM/NjllYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgaWRsRmFjdG9yeSA9ICh7IElETCB9KSA9PiB7XG4gIGNvbnN0IEltYWdlTWltZVR5cGVzID0gSURMLlZhcmlhbnQoeyAnanBnJyA6IElETC5OdWxsLCAnanBlZycgOiBJREwuTnVsbCB9KTtcbiAgY29uc3QgSW1hZ2UgPSBJREwuUmVjb3JkKHtcbiAgICAndXJsJyA6IElETC5UZXh0LFxuICAgICdlbmNvZGluZycgOiBJREwuVGV4dCxcbiAgICAnYmxvYicgOiBJREwuVmVjKElETC5OYXQ4KSxcbiAgICAnbmFtZScgOiBJREwuVGV4dCxcbiAgICAnc2l6ZScgOiBJREwuTmF0LFxuICAgICdtaW1ldHlwZScgOiBJbWFnZU1pbWVUeXBlcyxcbiAgfSk7XG4gIGNvbnN0IEJpcnRoRGF5ID0gSURMLlJlY29yZCh7XG4gICAgJ2RheScgOiBJREwuTmF0OCxcbiAgICAnbW9udGgnIDogSURMLk5hdDgsXG4gICAgJ3llYXInIDogSURMLk5hdDgsXG4gIH0pO1xuICBjb25zdCBDcmVhdGVVc2VyRGF0YSA9IElETC5SZWNvcmQoe1xuICAgICdiaW8nIDogSURMLlRleHQsXG4gICAgJ3VzZXJuYW1lJyA6IElETC5UZXh0LFxuICAgICdwaWN0dXJlJyA6IEltYWdlLFxuICAgICdiaXJ0aGRheScgOiBCaXJ0aERheSxcbiAgfSk7XG4gIGNvbnN0IENyZWF0ZVVzZXJFcnJvciA9IElETC5WYXJpYW50KHtcbiAgICAndXNlck5vdEF1dGhlbnRpY2F0ZWQnIDogSURMLk51bGwsXG4gICAgJ3VzZXJBbHJlYWR5RXhpc3RzJyA6IElETC5OdWxsLFxuICB9KTtcbiAgY29uc3QgUmVzdWx0XzMgPSBJREwuVmFyaWFudCh7ICdvaycgOiBJREwuTnVsbCwgJ2VycicgOiBDcmVhdGVVc2VyRXJyb3IgfSk7XG4gIGNvbnN0IENyZWF0ZVBvc3REYXRhID0gSURMLlJlY29yZCh7XG4gICAgJ2Rlc2NyaXB0aW9uJyA6IElETC5UZXh0LFxuICAgICdpbWFnZXMnIDogSURMLlZlYyhJbWFnZSksXG4gIH0pO1xuICBjb25zdCBDcmVhdGVQb3N0RXJyb3IgPSBJREwuVmFyaWFudCh7XG4gICAgJ3VzZXJOb3RGb3VuZCcgOiBJREwuTnVsbCxcbiAgICAndXNlck5vdEF1dGhlbnRpY2F0ZWQnIDogSURMLk51bGwsXG4gIH0pO1xuICBjb25zdCBSZXN1bHRfMiA9IElETC5WYXJpYW50KHsgJ29rJyA6IElETC5OdWxsLCAnZXJyJyA6IENyZWF0ZVBvc3RFcnJvciB9KTtcbiAgY29uc3QgR2V0UG9zdHNGaWx0ZXJzID0gSURMLlJlY29yZCh7ICd0bycgOiBJREwuSW50LCAnZnJvbScgOiBJREwuSW50IH0pO1xuICBjb25zdCBQb3N0Q29tbWVudExpa2UgPSBJREwuUmVjb3JkKHtcbiAgICAndXNlcklkJyA6IElETC5QcmluY2lwYWwsXG4gICAgJ2NyZWF0ZWRBdCcgOiBJREwuSW50LFxuICB9KTtcbiAgY29uc3QgUG9zdENvbW1lbnQgPSBJREwuUmVjb3JkKHtcbiAgICAnaWQnIDogSURMLlByaW5jaXBhbCxcbiAgICAnbGlua2VkQ29tbWVudCcgOiBJREwuT3B0KElETC5QcmluY2lwYWwpLFxuICAgICd1c2VySWQnIDogSURMLlByaW5jaXBhbCxcbiAgICAnY3JlYXRlZEF0JyA6IElETC5JbnQsXG4gICAgJ2xpa2VzJyA6IElETC5WZWMoUG9zdENvbW1lbnRMaWtlKSxcbiAgICAnY29tbWVudCcgOiBJREwuVGV4dCxcbiAgfSk7XG4gIGNvbnN0IFBvc3QgPSBJREwuUmVjb3JkKHtcbiAgICAnaWQnIDogSURMLlRleHQsXG4gICAgJ2NyZWF0ZWRBdCcgOiBJREwuSW50LFxuICAgICdkZXNjcmlwdGlvbicgOiBJREwuVGV4dCxcbiAgICAnbGlrZXMnIDogSURMLlZlYyhJREwuUHJpbmNpcGFsKSxcbiAgICAndXBkYXRlZEF0JyA6IElETC5JbnQsXG4gICAgJ2NvbW1lbnRzJyA6IElETC5WZWMoUG9zdENvbW1lbnQpLFxuICAgICdpbWFnZXMnIDogSURMLlZlYyhJbWFnZSksXG4gIH0pO1xuICBjb25zdCBHZXRQb3N0c1Jlc3VsdCA9IElETC5SZWNvcmQoe1xuICAgICdkYXRhJyA6IElETC5WZWMoSURMLlR1cGxlKElETC5UZXh0LCBQb3N0KSksXG4gIH0pO1xuICBjb25zdCBHZXRQb3N0c0Vycm9yID0gSURMLlZhcmlhbnQoe1xuICAgICd1c2VyTm90Rm91bmQnIDogSURMLk51bGwsXG4gICAgJ3VzZXJOb3RBdXRoZW50aWNhdGVkJyA6IElETC5OdWxsLFxuICB9KTtcbiAgY29uc3QgUmVzdWx0XzEgPSBJREwuVmFyaWFudCh7XG4gICAgJ29rJyA6IEdldFBvc3RzUmVzdWx0LFxuICAgICdlcnInIDogR2V0UG9zdHNFcnJvcixcbiAgfSk7XG4gIGNvbnN0IFVzZXJQcm9maWxlID0gSURMLlJlY29yZCh7XG4gICAgJ2JpbycgOiBJREwuVGV4dCxcbiAgICAndXNlcm5hbWUnIDogSURMLlRleHQsXG4gICAgJ2NyZWF0ZWRBdCcgOiBJREwuSW50LFxuICAgICdwaWN0dXJlJyA6IEltYWdlLFxuICAgICdiaXJ0aGRheScgOiBCaXJ0aERheSxcbiAgfSk7XG4gIGNvbnN0IEdldFByb2ZpbGVFcnJvciA9IElETC5WYXJpYW50KHtcbiAgICAndXNlck5vdEZvdW5kJyA6IElETC5OdWxsLFxuICAgICd1c2VyTm90QXV0aGVudGljYXRlZCcgOiBJREwuTnVsbCxcbiAgfSk7XG4gIGNvbnN0IFJlc3VsdCA9IElETC5WYXJpYW50KHsgJ29rJyA6IFVzZXJQcm9maWxlLCAnZXJyJyA6IEdldFByb2ZpbGVFcnJvciB9KTtcbiAgcmV0dXJuIElETC5TZXJ2aWNlKHtcbiAgICAnY3JlYXRlJyA6IElETC5GdW5jKFtDcmVhdGVVc2VyRGF0YV0sIFtSZXN1bHRfM10sIFtdKSxcbiAgICAnY3JlYXRlUG9zdCcgOiBJREwuRnVuYyhbQ3JlYXRlUG9zdERhdGFdLCBbUmVzdWx0XzJdLCBbXSksXG4gICAgJ2dldFBvc3RzJyA6IElETC5GdW5jKFtHZXRQb3N0c0ZpbHRlcnNdLCBbUmVzdWx0XzFdLCBbJ2NvbXBvc2l0ZV9xdWVyeSddKSxcbiAgICAnZ2V0UHJvZmlsZScgOiBJREwuRnVuYyhbXSwgW1Jlc3VsdF0sIFsnY29tcG9zaXRlX3F1ZXJ5J10pLFxuICB9KTtcbn07XG5leHBvcnQgY29uc3QgaW5pdCA9ICh7IElETCB9KSA9PiB7IHJldHVybiBbXTsgfTtcbiJdLCJuYW1lcyI6WyJpZGxGYWN0b3J5IiwiSURMIiwiSW1hZ2VNaW1lVHlwZXMiLCJWYXJpYW50IiwiTnVsbCIsIkltYWdlIiwiUmVjb3JkIiwiVGV4dCIsIlZlYyIsIk5hdDgiLCJOYXQiLCJCaXJ0aERheSIsIkNyZWF0ZVVzZXJEYXRhIiwiQ3JlYXRlVXNlckVycm9yIiwiUmVzdWx0XzMiLCJDcmVhdGVQb3N0RGF0YSIsIkNyZWF0ZVBvc3RFcnJvciIsIlJlc3VsdF8yIiwiR2V0UG9zdHNGaWx0ZXJzIiwiSW50IiwiUG9zdENvbW1lbnRMaWtlIiwiUHJpbmNpcGFsIiwiUG9zdENvbW1lbnQiLCJPcHQiLCJQb3N0IiwiR2V0UG9zdHNSZXN1bHQiLCJUdXBsZSIsIkdldFBvc3RzRXJyb3IiLCJSZXN1bHRfMSIsIlVzZXJQcm9maWxlIiwiR2V0UHJvZmlsZUVycm9yIiwiUmVzdWx0IiwiU2VydmljZSIsIkZ1bmMiLCJpbml0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/declarations/user/user.did.js\n"));

/***/ }),

/***/ "./src/lib/auth/auth-context.tsx":
/*!***************************************!*\
  !*** ./src/lib/auth/auth-context.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthContext: function() { return /* binding */ AuthContext; },\n/* harmony export */   AuthContextProvider: function() { return /* binding */ AuthContextProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var icp_connect_react_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! icp-connect-react/hooks */ \"../../packages/icp-connect-react/hooks/index.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"../../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$();\n\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)({});\nconst AuthContextProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const { connect, disconnect } = (0,icp_connect_react_hooks__WEBPACK_IMPORTED_MODULE_1__.useAuth)();\n    // TODO: Improve this type, example below is not working\n    // For now we need to force the type to infer the correct type\n    // const user = useActor<CanisterTypes>(\"user\");\n    const user = (0,icp_connect_react_hooks__WEBPACK_IMPORTED_MODULE_1__.useActor)(\"user\");\n    const [isAuth, setIsAuth] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)();\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        loadProfile();\n    }, [\n        isAuth\n    ]);\n    async function loadProfile() {\n        if (isAuth) {\n            try {\n                const response = await user.getProfile();\n                if (\"err\" in response) return;\n                const profile = {\n                    username: response.ok.username,\n                    bio: response.ok.bio,\n                    picture: response.ok.picture,\n                    createdAt: response.ok.createdAt\n                };\n                setProfile(profile);\n            } catch (error) {\n                console.log({\n                    error\n                });\n                throw error;\n            }\n        } else {\n            setProfile(undefined);\n        }\n    }\n    async function login() {\n        try {\n            await connect();\n            setIsAuth(true);\n        } catch (error) {\n            throw error;\n        }\n    }\n    async function logout() {\n        await disconnect();\n        setIsAuth(false);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            isAuth,\n            profile,\n            login,\n            logout\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/alannnc/Documents/dfx/astro_hackaton/d-snap/frontend/apps/webapp/src/lib/auth/auth-context.tsx\",\n        lineNumber: 81,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AuthContextProvider, \"Vjj5gGYryM6ioAwAeIx5xzhxBMM=\", false, function() {\n    return [\n        icp_connect_react_hooks__WEBPACK_IMPORTED_MODULE_1__.useAuth,\n        icp_connect_react_hooks__WEBPACK_IMPORTED_MODULE_1__.useActor\n    ];\n});\n_c = AuthContextProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthContextProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbGliL2F1dGgvYXV0aC1jb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUU0RDtBQUNVO0FBc0IvRCxNQUFNSyw0QkFBY0gsb0RBQWFBLENBQUMsQ0FBQyxHQUFzQjtBQUV6RCxNQUFNSSxzQkFBc0I7UUFBQyxFQUFFQyxRQUFRLEVBQTJCOztJQUN2RSxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFLEdBQUdSLGdFQUFPQTtJQUN2Qyx3REFBd0Q7SUFDeEQsOERBQThEO0lBQzlELGdEQUFnRDtJQUNoRCxNQUFNUyxPQUFPVixpRUFBUUEsQ0FBZ0I7SUFFckMsTUFBTSxDQUFDVyxRQUFRQyxVQUFVLEdBQUdSLCtDQUFRQSxDQUFVO0lBQzlDLE1BQU0sQ0FBQ1MsU0FBU0MsV0FBVyxHQUFHViwrQ0FBUUE7SUFFdENELGdEQUFTQSxDQUFDO1FBQ1JZO0lBQ0YsR0FBRztRQUFDSjtLQUFPO0lBRVgsZUFBZUk7UUFDYixJQUFJSixRQUFRO1lBQ1YsSUFBSTtnQkFDRixNQUFNSyxXQUFXLE1BQU1OLEtBQUtPLFVBQVU7Z0JBRXRDLElBQUksU0FBU0QsVUFBVTtnQkFFdkIsTUFBTUgsVUFBMkI7b0JBQy9CSyxVQUFVRixTQUFTRyxFQUFFLENBQUNELFFBQVE7b0JBQzlCRSxLQUFLSixTQUFTRyxFQUFFLENBQUNDLEdBQUc7b0JBQ3BCQyxTQUFTTCxTQUFTRyxFQUFFLENBQUNFLE9BQU87b0JBQzVCQyxXQUFXTixTQUFTRyxFQUFFLENBQUNHLFNBQVM7Z0JBQ2xDO2dCQUVBUixXQUFXRDtZQUNiLEVBQUUsT0FBT1UsT0FBTztnQkFDZEMsUUFBUUMsR0FBRyxDQUFDO29CQUFFRjtnQkFBTTtnQkFDcEIsTUFBTUE7WUFDUjtRQUNGLE9BQU87WUFDTFQsV0FBV1k7UUFDYjtJQUNGO0lBRUEsZUFBZUM7UUFDYixJQUFJO1lBQ0YsTUFBTW5CO1lBQ05JLFVBQVU7UUFDWixFQUFFLE9BQU9XLE9BQU87WUFDZCxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxlQUFlSztRQUNiLE1BQU1uQjtRQUNORyxVQUFVO0lBQ1o7SUFFQSxxQkFDRSw4REFBQ1AsWUFBWXdCLFFBQVE7UUFDbkJDLE9BQU87WUFDTG5CO1lBQ0FFO1lBQ0FjO1lBQ0FDO1FBQ0Y7a0JBQ0NyQjs7Ozs7O0FBR1AsRUFBRTtHQS9EV0Q7O1FBQ3FCTCw0REFBT0E7UUFJMUJELDZEQUFRQTs7O0tBTFZNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYXV0aC9hdXRoLWNvbnRleHQudHN4PzkzMjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FuaXN0ZXJUeXBlcyB9IGZyb20gXCJAL2RlY2xhcmF0aW9uc1wiO1xuaW1wb3J0IHsgQWN0b3JNYXAgfSBmcm9tIFwiaWNwLWNvbm5lY3QtY29yZS9jbGllbnRcIjtcbmltcG9ydCB7IHVzZUFjdG9yLCB1c2VBdXRoIH0gZnJvbSBcImljcC1jb25uZWN0LXJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBSZWFjdE5vZGUsIGNyZWF0ZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IHR5cGUgQXV0aFVzZXJQcm9maWxlID0ge1xuICBiaW86IHN0cmluZztcbiAgdXNlcm5hbWU6IHN0cmluZztcbiAgcGljdHVyZToge1xuICAgIHVybDogc3RyaW5nO1xuICB9O1xuICBjcmVhdGVkQXQ6IGJpZ2ludDtcbn07XG5cbmV4cG9ydCB0eXBlIEF1dGhDb250ZXh0VHlwZSA9IHtcbiAgaXNBdXRoOiBib29sZWFuO1xuICBwcm9maWxlPzogQXV0aFVzZXJQcm9maWxlO1xuICBsb2dpbjogKCkgPT4gdm9pZDtcbiAgbG9nb3V0OiAoKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IHR5cGUgQXV0aENvbnRleHRQcm92aWRlclR5cGUgPSB7XG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XG59O1xuXG5leHBvcnQgY29uc3QgQXV0aENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9IGFzIEF1dGhDb250ZXh0VHlwZSk7XG5cbmV4cG9ydCBjb25zdCBBdXRoQ29udGV4dFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfTogQXV0aENvbnRleHRQcm92aWRlclR5cGUpID0+IHtcbiAgY29uc3QgeyBjb25uZWN0LCBkaXNjb25uZWN0IH0gPSB1c2VBdXRoKCk7XG4gIC8vIFRPRE86IEltcHJvdmUgdGhpcyB0eXBlLCBleGFtcGxlIGJlbG93IGlzIG5vdCB3b3JraW5nXG4gIC8vIEZvciBub3cgd2UgbmVlZCB0byBmb3JjZSB0aGUgdHlwZSB0byBpbmZlciB0aGUgY29ycmVjdCB0eXBlXG4gIC8vIGNvbnN0IHVzZXIgPSB1c2VBY3RvcjxDYW5pc3RlclR5cGVzPihcInVzZXJcIik7XG4gIGNvbnN0IHVzZXIgPSB1c2VBY3RvcjxDYW5pc3RlclR5cGVzPihcInVzZXJcIikgYXMgQWN0b3JNYXA8Q2FuaXN0ZXJUeXBlcz5bXCJ1c2VyXCJdO1xuXG4gIGNvbnN0IFtpc0F1dGgsIHNldElzQXV0aF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtwcm9maWxlLCBzZXRQcm9maWxlXSA9IHVzZVN0YXRlPEF1dGhVc2VyUHJvZmlsZSB8IHVuZGVmaW5lZD4oKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvYWRQcm9maWxlKCk7XG4gIH0sIFtpc0F1dGhdKTtcblxuICBhc3luYyBmdW5jdGlvbiBsb2FkUHJvZmlsZSgpIHtcbiAgICBpZiAoaXNBdXRoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHVzZXIuZ2V0UHJvZmlsZSgpO1xuXG4gICAgICAgIGlmIChcImVyclwiIGluIHJlc3BvbnNlKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgcHJvZmlsZTogQXV0aFVzZXJQcm9maWxlID0ge1xuICAgICAgICAgIHVzZXJuYW1lOiByZXNwb25zZS5vay51c2VybmFtZSxcbiAgICAgICAgICBiaW86IHJlc3BvbnNlLm9rLmJpbyxcbiAgICAgICAgICBwaWN0dXJlOiByZXNwb25zZS5vay5waWN0dXJlLFxuICAgICAgICAgIGNyZWF0ZWRBdDogcmVzcG9uc2Uub2suY3JlYXRlZEF0LFxuICAgICAgICB9O1xuXG4gICAgICAgIHNldFByb2ZpbGUocHJvZmlsZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyh7IGVycm9yIH0pO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0UHJvZmlsZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGxvZ2luKCkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjb25uZWN0KCk7XG4gICAgICBzZXRJc0F1dGgodHJ1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGxvZ291dCgpIHtcbiAgICBhd2FpdCBkaXNjb25uZWN0KCk7XG4gICAgc2V0SXNBdXRoKGZhbHNlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPEF1dGhDb250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICBpc0F1dGgsXG4gICAgICAgIHByb2ZpbGUsXG4gICAgICAgIGxvZ2luLFxuICAgICAgICBsb2dvdXQsXG4gICAgICB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0F1dGhDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJ1c2VBY3RvciIsInVzZUF1dGgiLCJjcmVhdGVDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJBdXRoQ29udGV4dCIsIkF1dGhDb250ZXh0UHJvdmlkZXIiLCJjaGlsZHJlbiIsImNvbm5lY3QiLCJkaXNjb25uZWN0IiwidXNlciIsImlzQXV0aCIsInNldElzQXV0aCIsInByb2ZpbGUiLCJzZXRQcm9maWxlIiwibG9hZFByb2ZpbGUiLCJyZXNwb25zZSIsImdldFByb2ZpbGUiLCJ1c2VybmFtZSIsIm9rIiwiYmlvIiwicGljdHVyZSIsImNyZWF0ZWRBdCIsImVycm9yIiwiY29uc29sZSIsImxvZyIsInVuZGVmaW5lZCIsImxvZ2luIiwibG9nb3V0IiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib/auth/auth-context.tsx\n"));

/***/ }),

/***/ "./src/pages/_app.tsx":
/*!****************************!*\
  !*** ./src/pages/_app.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MyApp; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var _app_globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../app/globals.css */ \"./src/app/globals.css\");\n/* harmony import */ var _app_globals_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_app_globals_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_auth_auth_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/auth/auth-context */ \"./src/lib/auth/auth-context.tsx\");\n/* harmony import */ var _declarations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/declarations */ \"./src/declarations/index.ts\");\n/* harmony import */ var icp_connect_core_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! icp-connect-core/client */ \"../../packages/icp-connect-core/client/index.ts\");\n/* harmony import */ var icp_connect_core_identity_providers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! icp-connect-core/identity-providers */ \"../../packages/icp-connect-core/identity-providers/index.ts\");\n/* harmony import */ var icp_connect_react_context__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! icp-connect-react/context */ \"../../packages/icp-connect-react/context.tsx\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ \"../../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction MyApp(param) {\n    let { Component, pageProps } = param;\n    _s();\n    const [client, setClient] = (0,react__WEBPACK_IMPORTED_MODULE_7__.useState)();\n    (0,react__WEBPACK_IMPORTED_MODULE_7__.useEffect)(()=>{\n        initClient();\n    }, []);\n    async function initClient() {\n        const internetIdentity = new icp_connect_core_identity_providers__WEBPACK_IMPORTED_MODULE_5__.InternetIdentity({\n            providerUrl: \"http://127.0.0.1:4943/?canisterId=bkyz2-fmaaa-aaaaa-qaaaq-cai\"\n        });\n        const client = await icp_connect_core_client__WEBPACK_IMPORTED_MODULE_4__.Client.create({\n            host: \"http://localhost:4943\",\n            canisters: _declarations__WEBPACK_IMPORTED_MODULE_3__.Canisters,\n            providers: {\n                \"internet-identity\": internetIdentity\n            }\n        });\n        setClient(client);\n    }\n    return client ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(icp_connect_react_context__WEBPACK_IMPORTED_MODULE_6__.IcpConnectContextProvider, {\n        client: client,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lib_auth_auth_context__WEBPACK_IMPORTED_MODULE_2__.AuthContextProvider, {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                ...pageProps\n            }, void 0, false, {\n                fileName: \"/Users/alannnc/Documents/dfx/astro_hackaton/d-snap/frontend/apps/webapp/src/pages/_app.tsx\",\n                lineNumber: 38,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/alannnc/Documents/dfx/astro_hackaton/d-snap/frontend/apps/webapp/src/pages/_app.tsx\",\n            lineNumber: 37,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/alannnc/Documents/dfx/astro_hackaton/d-snap/frontend/apps/webapp/src/pages/_app.tsx\",\n        lineNumber: 36,\n        columnNumber: 5\n    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: \"Loading\"\n    }, void 0, false, {\n        fileName: \"/Users/alannnc/Documents/dfx/astro_hackaton/d-snap/frontend/apps/webapp/src/pages/_app.tsx\",\n        lineNumber: 42,\n        columnNumber: 5\n    }, this);\n}\n_s(MyApp, \"pdIeLTIl+YkbJRMXZiLvSQkh/co=\");\n_c = MyApp;\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvX2FwcC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUE0QjtBQUNtQztBQUNMO0FBQ1Q7QUFDc0I7QUFDRDtBQUUxQjtBQUk3QixTQUFTTyxNQUFNLEtBQWtDO1FBQWxDLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFZLEdBQWxDOztJQUM1QixNQUFNLENBQUNDLFFBQVFDLFVBQVUsR0FBR0wsK0NBQVFBO0lBRXBDRCxnREFBU0EsQ0FBQztRQUNSTztJQUNGLEdBQUcsRUFBRTtJQUVMLGVBQWVBO1FBQ2IsTUFBTUMsbUJBQW1CLElBQUlWLGlGQUFnQkEsQ0FBQztZQUM1Q1csYUFBYUMsK0RBQTZDO1FBQzVEO1FBRUEsTUFBTUwsU0FBUyxNQUFNUiwyREFBTUEsQ0FBQ2dCLE1BQU0sQ0FBZ0I7WUFDaERDLE1BQU1KLHVCQUErQjtZQUNyQ00sV0FBV3BCLG9EQUFTQTtZQUNwQnFCLFdBQVc7Z0JBQ1QscUJBQXFCVDtZQUN2QjtRQUNGO1FBRUFGLFVBQVVEO0lBQ1o7SUFFQSxPQUFPQSx1QkFDTCw4REFBQ04sZ0ZBQXlCQTtRQUFDTSxRQUFRQTtrQkFDakMsNEVBQUNWLHVFQUFtQkE7c0JBQ2xCLDRFQUFDUTtnQkFBVyxHQUFHQyxTQUFTOzs7Ozs7Ozs7Ozs7Ozs7NkJBSTVCLDhEQUFDYztrQkFBSTs7Ozs7O0FBRVQ7R0FoQ3dCaEI7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3BhZ2VzL19hcHAudHN4P2Y5ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiLi4vYXBwL2dsb2JhbHMuY3NzXCI7XG5pbXBvcnQgeyBBdXRoQ29udGV4dFByb3ZpZGVyIH0gZnJvbSBcIi4uL2xpYi9hdXRoL2F1dGgtY29udGV4dFwiO1xuaW1wb3J0IHsgQ2FuaXN0ZXJUeXBlcywgQ2FuaXN0ZXJzIH0gZnJvbSBcIkAvZGVjbGFyYXRpb25zXCI7XG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiaWNwLWNvbm5lY3QtY29yZS9jbGllbnRcIjtcbmltcG9ydCB7IEludGVybmV0SWRlbnRpdHkgfSBmcm9tIFwiaWNwLWNvbm5lY3QtY29yZS9pZGVudGl0eS1wcm92aWRlcnNcIjtcbmltcG9ydCB7IEljcENvbm5lY3RDb250ZXh0UHJvdmlkZXIgfSBmcm9tIFwiaWNwLWNvbm5lY3QtcmVhY3QvY29udGV4dFwiO1xuaW1wb3J0IHsgQXBwUHJvcHMgfSBmcm9tIFwibmV4dC9hcHBcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IHR5cGUgQ2xpZW50Q2FuaXN0ZXJUeXBlID0gQ2xpZW50PENhbmlzdGVyVHlwZXM+O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNeUFwcCh7IENvbXBvbmVudCwgcGFnZVByb3BzIH06IEFwcFByb3BzKSB7XG4gIGNvbnN0IFtjbGllbnQsIHNldENsaWVudF0gPSB1c2VTdGF0ZTxDbGllbnQ8Q2FuaXN0ZXJUeXBlcz4gfCB1bmRlZmluZWQ+KCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpbml0Q2xpZW50KCk7XG4gIH0sIFtdKTtcblxuICBhc3luYyBmdW5jdGlvbiBpbml0Q2xpZW50KCkge1xuICAgIGNvbnN0IGludGVybmV0SWRlbnRpdHkgPSBuZXcgSW50ZXJuZXRJZGVudGl0eSh7XG4gICAgICBwcm92aWRlclVybDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfSU5URVJORVRfSURFTlRJVFlfVVJMLFxuICAgIH0pO1xuXG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgQ2xpZW50LmNyZWF0ZTxDYW5pc3RlclR5cGVzPih7XG4gICAgICBob3N0OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19JQ19IT1NUISxcbiAgICAgIGNhbmlzdGVyczogQ2FuaXN0ZXJzLFxuICAgICAgcHJvdmlkZXJzOiB7XG4gICAgICAgIFwiaW50ZXJuZXQtaWRlbnRpdHlcIjogaW50ZXJuZXRJZGVudGl0eSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBzZXRDbGllbnQoY2xpZW50KTtcbiAgfVxuXG4gIHJldHVybiBjbGllbnQgPyAoXG4gICAgPEljcENvbm5lY3RDb250ZXh0UHJvdmlkZXIgY2xpZW50PXtjbGllbnR9PlxuICAgICAgPEF1dGhDb250ZXh0UHJvdmlkZXI+XG4gICAgICAgIDxDb21wb25lbnQgey4uLnBhZ2VQcm9wc30gLz5cbiAgICAgIDwvQXV0aENvbnRleHRQcm92aWRlcj5cbiAgICA8L0ljcENvbm5lY3RDb250ZXh0UHJvdmlkZXI+XG4gICkgOiAoXG4gICAgPGRpdj5Mb2FkaW5nPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiQXV0aENvbnRleHRQcm92aWRlciIsIkNhbmlzdGVycyIsIkNsaWVudCIsIkludGVybmV0SWRlbnRpdHkiLCJJY3BDb25uZWN0Q29udGV4dFByb3ZpZGVyIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJNeUFwcCIsIkNvbXBvbmVudCIsInBhZ2VQcm9wcyIsImNsaWVudCIsInNldENsaWVudCIsImluaXRDbGllbnQiLCJpbnRlcm5ldElkZW50aXR5IiwicHJvdmlkZXJVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfSU5URVJORVRfSURFTlRJVFlfVVJMIiwiY3JlYXRlIiwiaG9zdCIsIk5FWFRfUFVCTElDX0lDX0hPU1QiLCJjYW5pc3RlcnMiLCJwcm92aWRlcnMiLCJkaXYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/_app.tsx\n"));

/***/ }),

/***/ "../../packages/icp-connect-core/client/client.ts":
/*!********************************************************!*\
  !*** ../../packages/icp-connect-core/client/client.ts ***!
  \********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: function() { return /* binding */ Client; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/agent */ \"../../../node_modules/@dfinity/agent/lib/esm/index.js\");\n\nclass Client {\n    init() {\n        this.agent.fetchRootKey().then((err)=>{\n            console.warn(\"Unable to fetch root key. Check to ensure that your local replica is running\");\n        });\n        this.setActors();\n    }\n    setIdentity(identity) {\n        if (identity) this.agent.replaceIdentity(identity);\n        else this.agent.invalidateIdentity();\n        this.setActors();\n    }\n    setActors() {\n        const actors = Object.entries(this._canisters).reduce((reducer, current)=>{\n            const [name, canister] = current;\n            const { idlFactory, canisterId, configuration = {} } = canister;\n            const actor = _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.Actor.createActor(idlFactory, {\n                agent: this.agent,\n                canisterId,\n                ...configuration\n            });\n            return {\n                ...reducer,\n                [name]: actor\n            };\n        }, {});\n        this.actors = actors;\n    }\n    getActor(name) {\n        return this.actors[name];\n    }\n    getProviders() {\n        return this.providers;\n    }\n    static async create(options) {\n        const { host, canisters, providers } = options;\n        Object.keys(providers).forEach(async (key)=>{\n            await providers[key].init();\n        });\n        const agent = new _dfinity_agent__WEBPACK_IMPORTED_MODULE_0__.HttpAgent({\n            host,\n            verifyQuerySignatures: false\n        });\n        return new Client(agent, canisters, providers);\n    }\n    constructor(agent, _canisters, providers){\n        this.agent = agent;\n        this._canisters = _canisters;\n        this.providers = providers;\n        this.actors = {};\n        this.init();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtY29yZS9jbGllbnQvY2xpZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTREO0FBSXJELE1BQU1FO0lBV0hDLE9BQWE7UUFDbkIsSUFBSSxDQUFDQyxLQUFLLENBQUNDLFlBQVksR0FBR0MsSUFBSSxDQUFDLENBQUNDO1lBQzlCQyxRQUFRQyxJQUFJLENBQUM7UUFDZjtRQUVBLElBQUksQ0FBQ0MsU0FBUztJQUNoQjtJQUVPQyxZQUFZQyxRQUFtQixFQUFFO1FBQ3RDLElBQUlBLFVBQVUsSUFBSSxDQUFDUixLQUFLLENBQUNTLGVBQWUsQ0FBQ0Q7YUFDcEMsSUFBSSxDQUFDUixLQUFLLENBQUNVLGtCQUFrQjtRQUVsQyxJQUFJLENBQUNKLFNBQVM7SUFDaEI7SUFFUUEsWUFBa0I7UUFDeEIsTUFBTUssU0FBU0MsT0FBT0MsT0FBTyxDQUFDLElBQUksQ0FBQ0MsVUFBVSxFQUFFQyxNQUFNLENBQUMsQ0FBQ0MsU0FBU0M7WUFDOUQsTUFBTSxDQUFDQyxNQUFNQyxTQUFTLEdBQUdGO1lBQ3pCLE1BQU0sRUFBRUcsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLGdCQUFnQixDQUFDLENBQUMsRUFBRSxHQUFHSDtZQUV2RCxNQUFNSSxRQUFRM0IsaURBQUtBLENBQUM0QixXQUFXLENBQUNKLFlBQVk7Z0JBQzFDcEIsT0FBTyxJQUFJLENBQUNBLEtBQUs7Z0JBQ2pCcUI7Z0JBQ0EsR0FBR0MsYUFBYTtZQUNsQjtZQUVBLE9BQU87Z0JBQ0wsR0FBR04sT0FBTztnQkFDVixDQUFDRSxLQUFLLEVBQUVLO1lBQ1Y7UUFDRixHQUFHLENBQUM7UUFFSixJQUFJLENBQUNaLE1BQU0sR0FBR0E7SUFDaEI7SUFFT2MsU0FBNEJQLElBQU8sRUFBa0I7UUFDMUQsT0FBTyxJQUFJLENBQUNQLE1BQU0sQ0FBQ08sS0FBSztJQUMxQjtJQUVPUSxlQUFrQztRQUN2QyxPQUFPLElBQUksQ0FBQ0MsU0FBUztJQUN2QjtJQUVBLGFBQW9CQyxPQUFzQ0MsT0FBK0IsRUFBRTtRQUN6RixNQUFNLEVBQUVDLElBQUksRUFBRUMsU0FBUyxFQUFFSixTQUFTLEVBQUUsR0FBR0U7UUFFdkNqQixPQUFPb0IsSUFBSSxDQUFDTCxXQUFXTSxPQUFPLENBQUMsT0FBT0M7WUFDcEMsTUFBTVAsU0FBUyxDQUFDTyxJQUFJLENBQUNuQyxJQUFJO1FBQzNCO1FBRUEsTUFBTUMsUUFBUSxJQUFJSCxxREFBU0EsQ0FBQztZQUMxQmlDO1lBQ0FLLHVCQUF1QjtRQUN6QjtRQUVBLE9BQU8sSUFBSXJDLE9BQVVFLE9BQU8rQixXQUFXSjtJQUN6QztJQWhFQSxZQUNFLEtBQWlDLEVBQ2pDLFVBQTJDLEVBQzNDLFNBQTZDLENBQzdDO2FBSGlCM0IsUUFBQUE7YUFDQWMsYUFBQUE7YUFDQWEsWUFBQUE7YUFMWGhCLFNBQXNCLENBQUM7UUFPN0IsSUFBSSxDQUFDWixJQUFJO0lBQ1g7QUEyREYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3BhY2thZ2VzL2ljcC1jb25uZWN0LWNvcmUvY2xpZW50L2NsaWVudC50cz80ZTgxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFjdG9yLCBIdHRwQWdlbnQsIElkZW50aXR5IH0gZnJvbSBcIkBkZmluaXR5L2FnZW50XCI7XG5cbmltcG9ydCB7IEFjdG9yTWFwLCBDYW5pc3Rlck1hcCwgQ3JlYXRlQ2xpZW50T3B0aW9ucywgSWRlbnRpdHlQcm92aWRlcnMgfSBmcm9tIFwiLi9jbGllbnQudHlwZXNcIjtcblxuZXhwb3J0IGNsYXNzIENsaWVudDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4ge1xuICBwcml2YXRlIGFjdG9yczogQWN0b3JNYXA8VD4gPSB7fSBhcyBBY3Rvck1hcDxUPjtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYWdlbnQ6IEh0dHBBZ2VudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9jYW5pc3RlcnM6IENhbmlzdGVyTWFwPFQ+LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcHJvdmlkZXJzOiBJZGVudGl0eVByb3ZpZGVyc1xuICApIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmFnZW50LmZldGNoUm9vdEtleSgpLnRoZW4oKGVycjogYW55KSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gZmV0Y2ggcm9vdCBrZXkuIENoZWNrIHRvIGVuc3VyZSB0aGF0IHlvdXIgbG9jYWwgcmVwbGljYSBpcyBydW5uaW5nXCIpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXRBY3RvcnMoKTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRJZGVudGl0eShpZGVudGl0eT86IElkZW50aXR5KSB7XG4gICAgaWYgKGlkZW50aXR5KSB0aGlzLmFnZW50LnJlcGxhY2VJZGVudGl0eShpZGVudGl0eSk7XG4gICAgZWxzZSB0aGlzLmFnZW50LmludmFsaWRhdGVJZGVudGl0eSgpO1xuXG4gICAgdGhpcy5zZXRBY3RvcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0QWN0b3JzKCk6IHZvaWQge1xuICAgIGNvbnN0IGFjdG9ycyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuX2NhbmlzdGVycykucmVkdWNlKChyZWR1Y2VyLCBjdXJyZW50KSA9PiB7XG4gICAgICBjb25zdCBbbmFtZSwgY2FuaXN0ZXJdID0gY3VycmVudDtcbiAgICAgIGNvbnN0IHsgaWRsRmFjdG9yeSwgY2FuaXN0ZXJJZCwgY29uZmlndXJhdGlvbiA9IHt9IH0gPSBjYW5pc3RlcjtcblxuICAgICAgY29uc3QgYWN0b3IgPSBBY3Rvci5jcmVhdGVBY3RvcihpZGxGYWN0b3J5LCB7XG4gICAgICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgICAgICBjYW5pc3RlcklkLFxuICAgICAgICAuLi5jb25maWd1cmF0aW9uLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlZHVjZXIsXG4gICAgICAgIFtuYW1lXTogYWN0b3IsXG4gICAgICB9O1xuICAgIH0sIHt9KTtcblxuICAgIHRoaXMuYWN0b3JzID0gYWN0b3JzIGFzIEFjdG9yTWFwPFQ+O1xuICB9XG5cbiAgcHVibGljIGdldEFjdG9yPEsgZXh0ZW5kcyBrZXlvZiBUPihuYW1lOiBLKTogQWN0b3JNYXA8VD5bS10ge1xuICAgIHJldHVybiB0aGlzLmFjdG9yc1tuYW1lXTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQcm92aWRlcnMoKTogSWRlbnRpdHlQcm92aWRlcnMge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVycztcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgY3JlYXRlPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PihvcHRpb25zOiBDcmVhdGVDbGllbnRPcHRpb25zPFQ+KSB7XG4gICAgY29uc3QgeyBob3N0LCBjYW5pc3RlcnMsIHByb3ZpZGVycyB9ID0gb3B0aW9ucztcblxuICAgIE9iamVjdC5rZXlzKHByb3ZpZGVycykuZm9yRWFjaChhc3luYyAoa2V5KSA9PiB7XG4gICAgICBhd2FpdCBwcm92aWRlcnNba2V5XS5pbml0KCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBhZ2VudCA9IG5ldyBIdHRwQWdlbnQoe1xuICAgICAgaG9zdCxcbiAgICAgIHZlcmlmeVF1ZXJ5U2lnbmF0dXJlczogZmFsc2UsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IENsaWVudDxUPihhZ2VudCwgY2FuaXN0ZXJzLCBwcm92aWRlcnMpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQWN0b3IiLCJIdHRwQWdlbnQiLCJDbGllbnQiLCJpbml0IiwiYWdlbnQiLCJmZXRjaFJvb3RLZXkiLCJ0aGVuIiwiZXJyIiwiY29uc29sZSIsIndhcm4iLCJzZXRBY3RvcnMiLCJzZXRJZGVudGl0eSIsImlkZW50aXR5IiwicmVwbGFjZUlkZW50aXR5IiwiaW52YWxpZGF0ZUlkZW50aXR5IiwiYWN0b3JzIiwiT2JqZWN0IiwiZW50cmllcyIsIl9jYW5pc3RlcnMiLCJyZWR1Y2UiLCJyZWR1Y2VyIiwiY3VycmVudCIsIm5hbWUiLCJjYW5pc3RlciIsImlkbEZhY3RvcnkiLCJjYW5pc3RlcklkIiwiY29uZmlndXJhdGlvbiIsImFjdG9yIiwiY3JlYXRlQWN0b3IiLCJnZXRBY3RvciIsImdldFByb3ZpZGVycyIsInByb3ZpZGVycyIsImNyZWF0ZSIsIm9wdGlvbnMiLCJob3N0IiwiY2FuaXN0ZXJzIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJ2ZXJpZnlRdWVyeVNpZ25hdHVyZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../packages/icp-connect-core/client/client.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-core/client/client.types.ts":
/*!**************************************************************!*\
  !*** ../../packages/icp-connect-core/client/client.types.ts ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtY29yZS9jbGllbnQvY2xpZW50LnR5cGVzLnRzIiwibWFwcGluZ3MiOiI7QUE2Q29FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9wYWNrYWdlcy9pY3AtY29ubmVjdC1jb3JlL2NsaWVudC9jbGllbnQudHlwZXMudHM/YWVkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJZGVudGl0eVByb3ZpZGVyIH0gZnJvbSBcIi4uL2lkZW50aXR5LXByb3ZpZGVycy9pZGVudGl0eS1wcm92aWRlci5pbnRlcmZhY2VcIjtcbmltcG9ydCB7IEFjdG9yQ29uZmlnLCBBZ2VudCwgSHR0cEFnZW50T3B0aW9ucyB9IGZyb20gXCJAZGZpbml0eS9hZ2VudFwiO1xuaW1wb3J0IHsgSURMIH0gZnJvbSBcIkBkZmluaXR5L2NhbmRpZFwiO1xuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSBcIkBkZmluaXR5L3ByaW5jaXBhbFwiO1xuXG5leHBvcnQgdHlwZSBDcmVhdGVBY3Rvck9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBAc2VlIHtAbGluayBBZ2VudH1cbiAgICovXG4gIGFnZW50PzogQWdlbnQ7XG4gIC8qKlxuICAgKiBAc2VlIHtAbGluayBIdHRwQWdlbnRPcHRpb25zfVxuICAgKi9cbiAgYWdlbnRPcHRpb25zPzogSHR0cEFnZW50T3B0aW9ucztcbiAgLyoqXG4gICAqIEBzZWUge0BsaW5rIEFjdG9yQ29uZmlnfVxuICAgKi9cbiAgYWN0b3JPcHRpb25zPzogQWN0b3JDb25maWc7XG59O1xuXG5leHBvcnQgdHlwZSBBY3RvclN1YmNsYXNzVHlwZTxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiwgSyBleHRlbmRzIGtleW9mIFQ+ID0gUmV0dXJuVHlwZTxcbiAgVFtLXVtcImNyZWF0ZUFjdG9yXCJdXG4+O1xuXG5leHBvcnQgdHlwZSBDYW5pc3RlclR5cGU8VD4gPSB7XG4gIGNhbmlzdGVySWQ6IHN0cmluZyB8IFByaW5jaXBhbDtcbiAgY3JlYXRlQWN0b3I6IChjYW5pc3RlcklkOiBzdHJpbmcgfCBQcmluY2lwYWwsIG9wdGlvbnM/OiBDcmVhdGVBY3Rvck9wdGlvbnMpID0+IFQ7XG4gIGlkbEZhY3Rvcnk6IElETC5JbnRlcmZhY2VGYWN0b3J5O1xuICBjb25maWd1cmF0aW9uPzogQWN0b3JDb25maWc7XG59O1xuXG5leHBvcnQgdHlwZSBDYW5pc3Rlck1hcDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4gPSB7XG4gIFtLIGluIGtleW9mIFRdOiBDYW5pc3RlclR5cGU8QWN0b3JTdWJjbGFzc1R5cGU8VCwgSz4+O1xufTtcblxuZXhwb3J0IHR5cGUgQ3JlYXRlQ2xpZW50T3B0aW9uczxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4gPSB7XG4gIGhvc3Q6IHN0cmluZztcbiAgY2FuaXN0ZXJzOiBDYW5pc3Rlck1hcDxUPjtcbiAgcHJvdmlkZXJzOiBJZGVudGl0eVByb3ZpZGVycztcbn07XG5cbmV4cG9ydCB0eXBlIEFjdG9yTWFwPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PiA9IHtcbiAgW0sgaW4ga2V5b2YgVF06IEFjdG9yU3ViY2xhc3NUeXBlPFQsIEs+O1xufTtcblxuZXhwb3J0IHR5cGUgSWRlbnRpdHlQcm92aWRlcnMgPSB7IFtrZXk6IHN0cmluZ106IElkZW50aXR5UHJvdmlkZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../packages/icp-connect-core/client/client.types.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-core/client/index.ts":
/*!*******************************************************!*\
  !*** ../../packages/icp-connect-core/client/index.ts ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: function() { return /* reexport safe */ _client__WEBPACK_IMPORTED_MODULE_0__.Client; }\n/* harmony export */ });\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client */ \"../../packages/icp-connect-core/client/client.ts\");\n/* harmony import */ var _client_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.types */ \"../../packages/icp-connect-core/client/client.types.ts\");\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtY29yZS9jbGllbnQvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlCO0FBQ00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3BhY2thZ2VzL2ljcC1jb25uZWN0LWNvcmUvY2xpZW50L2luZGV4LnRzPzYxZWEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vY2xpZW50XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jbGllbnQudHlwZXNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../packages/icp-connect-core/client/index.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-core/identity-providers/identity-provider.interface.ts":
/*!*****************************************************************************************!*\
  !*** ../../packages/icp-connect-core/identity-providers/identity-provider.interface.ts ***!
  \*****************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtY29yZS9pZGVudGl0eS1wcm92aWRlcnMvaWRlbnRpdHktcHJvdmlkZXIuaW50ZXJmYWNlLnRzIiwibWFwcGluZ3MiOiI7QUFVQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtY29yZS9pZGVudGl0eS1wcm92aWRlcnMvaWRlbnRpdHktcHJvdmlkZXIuaW50ZXJmYWNlLnRzPzZmOGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSWRlbnRpdHkgfSBmcm9tIFwiQGRmaW5pdHkvYWdlbnRcIjtcbmltcG9ydCB7IFByaW5jaXBhbCB9IGZyb20gXCJAZGZpbml0eS9wcmluY2lwYWxcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJZGVudGl0eVByb3ZpZGVyIHtcbiAgaW5pdDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgY29ubmVjdDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZGlzY29ubmVjdDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgaXNBdXRoZW50aWNhdGVkOiAoKSA9PiBib29sZWFuO1xuICBnZXRJZGVudGl0eTogKCkgPT4gSWRlbnRpdHk7XG4gIGdldFByaW5jaXBhbDogKCkgPT4gUHJpbmNpcGFsO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../packages/icp-connect-core/identity-providers/identity-provider.interface.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-core/identity-providers/index.ts":
/*!*******************************************************************!*\
  !*** ../../packages/icp-connect-core/identity-providers/index.ts ***!
  \*******************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternetIdentity: function() { return /* reexport safe */ _internet_identity__WEBPACK_IMPORTED_MODULE_2__.InternetIdentity; }\n/* harmony export */ });\n/* harmony import */ var _identity_provider_interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity-provider.interface */ \"../../packages/icp-connect-core/identity-providers/identity-provider.interface.ts\");\n/* harmony import */ var _native_identity_provider_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./native-identity-provider.interface */ \"../../packages/icp-connect-core/identity-providers/native-identity-provider.interface.ts\");\n/* harmony import */ var _internet_identity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internet-identity */ \"../../packages/icp-connect-core/identity-providers/internet-identity/index.ts\");\n\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtY29yZS9pZGVudGl0eS1wcm92aWRlcnMvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE4QztBQUNPO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9wYWNrYWdlcy9pY3AtY29ubmVjdC1jb3JlL2lkZW50aXR5LXByb3ZpZGVycy9pbmRleC50cz9hMWMzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2lkZW50aXR5LXByb3ZpZGVyLmludGVyZmFjZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbmF0aXZlLWlkZW50aXR5LXByb3ZpZGVyLmludGVyZmFjZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vaW50ZXJuZXQtaWRlbnRpdHlcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../packages/icp-connect-core/identity-providers/index.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-core/identity-providers/internet-identity/index.ts":
/*!*************************************************************************************!*\
  !*** ../../packages/icp-connect-core/identity-providers/internet-identity/index.ts ***!
  \*************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternetIdentity: function() { return /* reexport safe */ _internet_identity__WEBPACK_IMPORTED_MODULE_0__.InternetIdentity; }\n/* harmony export */ });\n/* harmony import */ var _internet_identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internet-identity */ \"../../packages/icp-connect-core/identity-providers/internet-identity/internet-identity.ts\");\n/* harmony import */ var _internet_identity_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internet-identity.types */ \"../../packages/icp-connect-core/identity-providers/internet-identity/internet-identity.types.ts\");\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtY29yZS9pZGVudGl0eS1wcm92aWRlcnMvaW50ZXJuZXQtaWRlbnRpdHkvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9DO0FBQ00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3BhY2thZ2VzL2ljcC1jb25uZWN0LWNvcmUvaWRlbnRpdHktcHJvdmlkZXJzL2ludGVybmV0LWlkZW50aXR5L2luZGV4LnRzPzFmMWUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vaW50ZXJuZXQtaWRlbnRpdHlcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2ludGVybmV0LWlkZW50aXR5LnR5cGVzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../packages/icp-connect-core/identity-providers/internet-identity/index.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-core/identity-providers/internet-identity/internet-identity.ts":
/*!*************************************************************************************************!*\
  !*** ../../packages/icp-connect-core/identity-providers/internet-identity/internet-identity.ts ***!
  \*************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternetIdentity: function() { return /* binding */ InternetIdentity; }\n/* harmony export */ });\n/* harmony import */ var _dfinity_auth_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dfinity/auth-client */ \"../../../node_modules/@dfinity/auth-client/lib/esm/index.js\");\n\nconst defaultConfig = {\n    providerUrl: \"https://identity.ic0.app\"\n};\nclass InternetIdentity {\n    async init() {\n        var _this_identity;\n        this.client = await _dfinity_auth_client__WEBPACK_IMPORTED_MODULE_0__.AuthClient.create();\n        this.isAuth = await this.client.isAuthenticated();\n        this.identity = this.client.getIdentity();\n        this.principal = (_this_identity = this.identity) === null || _this_identity === void 0 ? void 0 : _this_identity.getPrincipal();\n    }\n    async setData() {\n        if (!this.client) throw new Error(\"init must be called before this method\");\n        try {\n            var _this_identity;\n            this.isAuth = await this.client.isAuthenticated();\n            this.identity = this.client.getIdentity();\n            this.principal = (_this_identity = this.identity) === null || _this_identity === void 0 ? void 0 : _this_identity.getPrincipal();\n        } catch (error) {\n            throw error;\n        }\n    }\n    connect() {\n        if (!this.client) throw new Error(\"init must be called before this method\");\n        return new Promise((resolve, reject)=>{\n            this.client.login({\n                identityProvider: this.config.providerUrl,\n                onSuccess: async ()=>{\n                    await this.setData();\n                    resolve();\n                },\n                onError: reject\n            });\n        });\n    }\n    async disconnect() {\n        if (!this.client) throw new Error(\"init must be called before this method\");\n        try {\n            await this.client.logout();\n            await this.setData();\n        } catch (error) {\n            throw error;\n        }\n    }\n    isAuthenticated() {\n        if (!this.client) throw new Error(\"init must be called before this method\");\n        return this.isAuth;\n    }\n    getIdentity() {\n        if (!this.client) throw new Error(\"init must be called before this method\");\n        return this.identity;\n    }\n    getPrincipal() {\n        if (!this.client) throw new Error(\"init must be called before this method\");\n        return this.principal;\n    }\n    constructor(config = {}){\n        this.config = defaultConfig;\n        this.config = {\n            ...this.config,\n            ...config\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtY29yZS9pZGVudGl0eS1wcm92aWRlcnMvaW50ZXJuZXQtaWRlbnRpdHkvaW50ZXJuZXQtaWRlbnRpdHkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDa0Q7QUFNbEQsTUFBTUMsZ0JBQXdDO0lBQzVDQyxhQUFhO0FBQ2Y7QUFFTyxNQUFNQztJQWNYLE1BQWFDLE9BQXNCO1lBSWhCO1FBSGpCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLE1BQU1MLDREQUFVQSxDQUFDTSxNQUFNO1FBQ3JDLElBQUksQ0FBQ0MsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDRixNQUFNLENBQUNHLGVBQWU7UUFDL0MsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDSixNQUFNLENBQUNLLFdBQVc7UUFDdkMsSUFBSSxDQUFDQyxTQUFTLElBQUcscUJBQUksQ0FBQ0YsUUFBUSxjQUFiLG9EQUFlRyxZQUFZO0lBQzlDO0lBRUEsTUFBY0MsVUFBeUI7UUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQ1IsTUFBTSxFQUFFLE1BQU0sSUFBSVMsTUFBTTtRQUVsQyxJQUFJO2dCQUdlO1lBRmpCLElBQUksQ0FBQ1AsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDRixNQUFNLENBQUNHLGVBQWU7WUFDL0MsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDSixNQUFNLENBQUNLLFdBQVc7WUFDdkMsSUFBSSxDQUFDQyxTQUFTLElBQUcscUJBQUksQ0FBQ0YsUUFBUSxjQUFiLG9EQUFlRyxZQUFZO1FBQzlDLEVBQUUsT0FBT0csT0FBTztZQUNkLE1BQU1BO1FBQ1I7SUFDRjtJQUVPQyxVQUF5QjtRQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDWCxNQUFNLEVBQUUsTUFBTSxJQUFJUyxNQUFNO1FBRWxDLE9BQU8sSUFBSUcsUUFBYyxDQUFDQyxTQUFTQztZQUNqQyxJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsS0FBSyxDQUFDO2dCQUNoQkMsa0JBQWtCLElBQUksQ0FBQ0MsTUFBTSxDQUFDcEIsV0FBVztnQkFDekNxQixXQUFXO29CQUNULE1BQU0sSUFBSSxDQUFDVixPQUFPO29CQUNsQks7Z0JBQ0Y7Z0JBQ0FNLFNBQVNMO1lBQ1g7UUFDRjtJQUNGO0lBRUEsTUFBYU0sYUFBNEI7UUFDdkMsSUFBSSxDQUFDLElBQUksQ0FBQ3BCLE1BQU0sRUFBRSxNQUFNLElBQUlTLE1BQU07UUFFbEMsSUFBSTtZQUNGLE1BQU0sSUFBSSxDQUFDVCxNQUFNLENBQUNxQixNQUFNO1lBQ3hCLE1BQU0sSUFBSSxDQUFDYixPQUFPO1FBQ3BCLEVBQUUsT0FBT0UsT0FBTztZQUNkLE1BQU1BO1FBQ1I7SUFDRjtJQUVPUCxrQkFBMkI7UUFDaEMsSUFBSSxDQUFDLElBQUksQ0FBQ0gsTUFBTSxFQUFFLE1BQU0sSUFBSVMsTUFBTTtRQUVsQyxPQUFPLElBQUksQ0FBQ1AsTUFBTTtJQUNwQjtJQUVPRyxjQUF3QjtRQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDTCxNQUFNLEVBQUUsTUFBTSxJQUFJUyxNQUFNO1FBRWxDLE9BQU8sSUFBSSxDQUFDTCxRQUFRO0lBQ3RCO0lBRU9HLGVBQTBCO1FBQy9CLElBQUksQ0FBQyxJQUFJLENBQUNQLE1BQU0sRUFBRSxNQUFNLElBQUlTLE1BQU07UUFFbEMsT0FBTyxJQUFJLENBQUNILFNBQVM7SUFDdkI7SUFwRUFnQixZQUFZTCxTQUFpQyxDQUFDLENBQUMsQ0FBRTthQU56Q0EsU0FBaUNyQjtRQU92QyxJQUFJLENBQUNxQixNQUFNLEdBQUc7WUFDWixHQUFHLElBQUksQ0FBQ0EsTUFBTTtZQUNkLEdBQUdBLE1BQU07UUFDWDtJQUNGO0FBZ0VGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9wYWNrYWdlcy9pY3AtY29ubmVjdC1jb3JlL2lkZW50aXR5LXByb3ZpZGVycy9pbnRlcm5ldC1pZGVudGl0eS9pbnRlcm5ldC1pZGVudGl0eS50cz8zMGIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElkZW50aXR5IH0gZnJvbSBcIkBkZmluaXR5L2FnZW50XCI7XG5pbXBvcnQgeyBBdXRoQ2xpZW50IH0gZnJvbSBcIkBkZmluaXR5L2F1dGgtY2xpZW50XCI7XG5pbXBvcnQgeyBQcmluY2lwYWwgfSBmcm9tIFwiQGRmaW5pdHkvcHJpbmNpcGFsXCI7XG5cbmltcG9ydCB7IElkZW50aXR5UHJvdmlkZXIgfSBmcm9tIFwiLi4vaWRlbnRpdHktcHJvdmlkZXIuaW50ZXJmYWNlXCI7XG5pbXBvcnQgeyBJbnRlcm5ldElkZW50aXR5Q29uZmlnIH0gZnJvbSBcIi4vaW50ZXJuZXQtaWRlbnRpdHkudHlwZXNcIjtcblxuY29uc3QgZGVmYXVsdENvbmZpZzogSW50ZXJuZXRJZGVudGl0eUNvbmZpZyA9IHtcbiAgcHJvdmlkZXJVcmw6IFwiaHR0cHM6Ly9pZGVudGl0eS5pYzAuYXBwXCIsXG59O1xuXG5leHBvcnQgY2xhc3MgSW50ZXJuZXRJZGVudGl0eSBpbXBsZW1lbnRzIElkZW50aXR5UHJvdmlkZXIge1xuICBwcml2YXRlIGNvbmZpZzogSW50ZXJuZXRJZGVudGl0eUNvbmZpZyA9IGRlZmF1bHRDb25maWc7XG4gIHByaXZhdGUgY2xpZW50ITogQXV0aENsaWVudDtcbiAgcHJpdmF0ZSBpc0F1dGghOiBib29sZWFuO1xuICBwcml2YXRlIGlkZW50aXR5ITogSWRlbnRpdHk7XG4gIHByaXZhdGUgcHJpbmNpcGFsITogUHJpbmNpcGFsO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogSW50ZXJuZXRJZGVudGl0eUNvbmZpZyA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLmNvbmZpZyxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5jbGllbnQgPSBhd2FpdCBBdXRoQ2xpZW50LmNyZWF0ZSgpO1xuICAgIHRoaXMuaXNBdXRoID0gYXdhaXQgdGhpcy5jbGllbnQuaXNBdXRoZW50aWNhdGVkKCk7XG4gICAgdGhpcy5pZGVudGl0eSA9IHRoaXMuY2xpZW50LmdldElkZW50aXR5KCk7XG4gICAgdGhpcy5wcmluY2lwYWwgPSB0aGlzLmlkZW50aXR5Py5nZXRQcmluY2lwYWwoKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2V0RGF0YSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuY2xpZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJpbml0IG11c3QgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIG1ldGhvZFwiKTtcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLmlzQXV0aCA9IGF3YWl0IHRoaXMuY2xpZW50LmlzQXV0aGVudGljYXRlZCgpO1xuICAgICAgdGhpcy5pZGVudGl0eSA9IHRoaXMuY2xpZW50LmdldElkZW50aXR5KCk7XG4gICAgICB0aGlzLnByaW5jaXBhbCA9IHRoaXMuaWRlbnRpdHk/LmdldFByaW5jaXBhbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuY2xpZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJpbml0IG11c3QgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIG1ldGhvZFwiKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmNsaWVudC5sb2dpbih7XG4gICAgICAgIGlkZW50aXR5UHJvdmlkZXI6IHRoaXMuY29uZmlnLnByb3ZpZGVyVXJsLFxuICAgICAgICBvblN1Y2Nlc3M6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNldERhdGEoKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IHJlamVjdCxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRpc2Nvbm5lY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmNsaWVudCkgdGhyb3cgbmV3IEVycm9yKFwiaW5pdCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdGhpcyBtZXRob2RcIik7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5jbGllbnQubG9nb3V0KCk7XG4gICAgICBhd2FpdCB0aGlzLnNldERhdGEoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGlzQXV0aGVudGljYXRlZCgpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuY2xpZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJpbml0IG11c3QgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIG1ldGhvZFwiKTtcblxuICAgIHJldHVybiB0aGlzLmlzQXV0aDtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJZGVudGl0eSgpOiBJZGVudGl0eSB7XG4gICAgaWYgKCF0aGlzLmNsaWVudCkgdGhyb3cgbmV3IEVycm9yKFwiaW5pdCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdGhpcyBtZXRob2RcIik7XG5cbiAgICByZXR1cm4gdGhpcy5pZGVudGl0eTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRQcmluY2lwYWwoKTogUHJpbmNpcGFsIHtcbiAgICBpZiAoIXRoaXMuY2xpZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJpbml0IG11c3QgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIG1ldGhvZFwiKTtcblxuICAgIHJldHVybiB0aGlzLnByaW5jaXBhbDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkF1dGhDbGllbnQiLCJkZWZhdWx0Q29uZmlnIiwicHJvdmlkZXJVcmwiLCJJbnRlcm5ldElkZW50aXR5IiwiaW5pdCIsImNsaWVudCIsImNyZWF0ZSIsImlzQXV0aCIsImlzQXV0aGVudGljYXRlZCIsImlkZW50aXR5IiwiZ2V0SWRlbnRpdHkiLCJwcmluY2lwYWwiLCJnZXRQcmluY2lwYWwiLCJzZXREYXRhIiwiRXJyb3IiLCJlcnJvciIsImNvbm5lY3QiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImxvZ2luIiwiaWRlbnRpdHlQcm92aWRlciIsImNvbmZpZyIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJkaXNjb25uZWN0IiwibG9nb3V0IiwiY29uc3RydWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../packages/icp-connect-core/identity-providers/internet-identity/internet-identity.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-core/identity-providers/internet-identity/internet-identity.types.ts":
/*!*******************************************************************************************************!*\
  !*** ../../packages/icp-connect-core/identity-providers/internet-identity/internet-identity.types.ts ***!
  \*******************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtY29yZS9pZGVudGl0eS1wcm92aWRlcnMvaW50ZXJuZXQtaWRlbnRpdHkvaW50ZXJuZXQtaWRlbnRpdHkudHlwZXMudHMiLCJtYXBwaW5ncyI6IjtBQTBEa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3BhY2thZ2VzL2ljcC1jb25uZWN0LWNvcmUvaWRlbnRpdHktcHJvdmlkZXJzL2ludGVybmV0LWlkZW50aXR5L2ludGVybmV0LWlkZW50aXR5LnR5cGVzLnRzP2IxNTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2lnbklkZW50aXR5IH0gZnJvbSBcIkBkZmluaXR5L2FnZW50XCI7XG5pbXBvcnQgeyBJZGxlT3B0aW9ucyB9IGZyb20gXCJAZGZpbml0eS9hdXRoLWNsaWVudFwiO1xuaW1wb3J0IHsgQXV0aENsaWVudFN0b3JhZ2UgfSBmcm9tIFwiQGRmaW5pdHkvYXV0aC1jbGllbnQvbGliL2Nqcy9zdG9yYWdlXCI7XG5cbmltcG9ydCB7IEJhc2VLZXlUeXBlIH0gZnJvbSBcIi4uL2ludGVybmV0LXByb3ZpZGVyLmNvbnN0YW50c1wiO1xuXG5leHBvcnQgdHlwZSBDb25uZWN0T3B0aW9ucyA9IHtcbiAgLyoqXG4gICAqIEFuIHtAbGluayBJZGVudGl0eX0gdG8gdXNlIGFzIHRoZSBiYXNlLlxuICAgKiAgQnkgZGVmYXVsdCwgYSBuZXcge0BsaW5rIEFub255bW91c0lkZW50aXR5fVxuICAgKi9cbiAgaWRlbnRpdHk/OiBTaWduSWRlbnRpdHk7XG4gIC8qKlxuICAgKiB7QGxpbmsgQXV0aENsaWVudFN0b3JhZ2V9XG4gICAqIEBkZXNjcmlwdGlvbiBPcHRpb25hbCBzdG9yYWdlIHdpdGggZ2V0LCBzZXQsIGFuZCByZW1vdmUuIFVzZXMge0BsaW5rIElkYlN0b3JhZ2V9IGJ5IGRlZmF1bHRcbiAgICovXG4gIHN0b3JhZ2U/OiBBdXRoQ2xpZW50U3RvcmFnZTtcbiAgLyoqXG4gICAqIHR5cGUgdG8gdXNlIGZvciB0aGUgYmFzZSBrZXlcbiAgICogQGRlZmF1bHQgJ0VDRFNBJ1xuICAgKiBJZiB5b3UgYXJlIHVzaW5nIGEgY3VzdG9tIHN0b3JhZ2UgcHJvdmlkZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IENyeXB0b0tleSBzdG9yYWdlLFxuICAgKiB5b3Ugc2hvdWxkIHVzZSAnRWQyNTUxOScgYXMgdGhlIGtleSB0eXBlLCBhcyBpdCBjYW4gc2VyaWFsaXplIHRvIGEgc3RyaW5nXG4gICAqL1xuICBrZXlUeXBlPzogQmFzZUtleVR5cGU7XG4gIC8qKlxuICAgKiBPcHRpb25zIHRvIGhhbmRsZSBpZGxlIHRpbWVvdXRzXG4gICAqIEBkZWZhdWx0IGFmdGVyIDEwIG1pbnV0ZXMsIGludmFsaWRhdGVzIHRoZSBpZGVudGl0eVxuICAgKi9cbiAgaWRsZU9wdGlvbnM/OiBJZGxlT3B0aW9ucztcbn07XG5cbmV4cG9ydCB0eXBlIEludGVybmV0SWRlbnRpdHlDcmVhdGVPcHRpb25zID0ge1xuICAvKipcbiAgICogQW4ge0BsaW5rIElkZW50aXR5fSB0byB1c2UgYXMgdGhlIGJhc2UuXG4gICAqICBCeSBkZWZhdWx0LCBhIG5ldyB7QGxpbmsgQW5vbnltb3VzSWRlbnRpdHl9XG4gICAqL1xuICBpZGVudGl0eT86IFNpZ25JZGVudGl0eTtcbiAgLyoqXG4gICAqIHtAbGluayBBdXRoQ2xpZW50U3RvcmFnZX1cbiAgICogQGRlc2NyaXB0aW9uIE9wdGlvbmFsIHN0b3JhZ2Ugd2l0aCBnZXQsIHNldCwgYW5kIHJlbW92ZS4gVXNlcyB7QGxpbmsgSWRiU3RvcmFnZX0gYnkgZGVmYXVsdFxuICAgKi9cbiAgc3RvcmFnZT86IEF1dGhDbGllbnRTdG9yYWdlO1xuICAvKipcbiAgICogdHlwZSB0byB1c2UgZm9yIHRoZSBiYXNlIGtleVxuICAgKiBAZGVmYXVsdCAnRUNEU0EnXG4gICAqIElmIHlvdSBhcmUgdXNpbmcgYSBjdXN0b20gc3RvcmFnZSBwcm92aWRlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgQ3J5cHRvS2V5IHN0b3JhZ2UsXG4gICAqIHlvdSBzaG91bGQgdXNlICdFZDI1NTE5JyBhcyB0aGUga2V5IHR5cGUsIGFzIGl0IGNhbiBzZXJpYWxpemUgdG8gYSBzdHJpbmdcbiAgICovXG4gIGtleVR5cGU/OiBCYXNlS2V5VHlwZTtcbiAgLyoqXG4gICAqIE9wdGlvbnMgdG8gaGFuZGxlIGlkbGUgdGltZW91dHNcbiAgICogQGRlZmF1bHQgYWZ0ZXIgMTAgbWludXRlcywgaW52YWxpZGF0ZXMgdGhlIGlkZW50aXR5XG4gICAqL1xuICBpZGxlT3B0aW9ucz86IElkbGVPcHRpb25zO1xufTtcblxuZXhwb3J0IHR5cGUgSW50ZXJuZXRJZGVudGl0eUNvbmZpZyA9IHtcbiAgcHJvdmlkZXJVcmw/OiBzdHJpbmc7XG59ICYgSW50ZXJuZXRJZGVudGl0eUNyZWF0ZU9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../packages/icp-connect-core/identity-providers/internet-identity/internet-identity.types.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-core/identity-providers/native-identity-provider.interface.ts":
/*!************************************************************************************************!*\
  !*** ../../packages/icp-connect-core/identity-providers/native-identity-provider.interface.ts ***!
  \************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtY29yZS9pZGVudGl0eS1wcm92aWRlcnMvbmF0aXZlLWlkZW50aXR5LXByb3ZpZGVyLmludGVyZmFjZS50cyIsIm1hcHBpbmdzIjoiO0FBT0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3BhY2thZ2VzL2ljcC1jb25uZWN0LWNvcmUvaWRlbnRpdHktcHJvdmlkZXJzL25hdGl2ZS1pZGVudGl0eS1wcm92aWRlci5pbnRlcmZhY2UudHM/NmRkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJZGVudGl0eVByb3ZpZGVyIH0gZnJvbSBcIi4vaWRlbnRpdHktcHJvdmlkZXIuaW50ZXJmYWNlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF0aXZlSWRlbnRpdHlQcm92aWRlciBleHRlbmRzIElkZW50aXR5UHJvdmlkZXIge1xuICAvKipcbiAgICogRGlzcGF0Y2ggdGhpcyBldmVudCB3aGVuIHRoZSByZWRpcmVjdF91cmkgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IG9wZW5lZFxuICAgKi9cbiAgc3VjY2Vzc0hhbmRsZXIodXJsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../packages/icp-connect-core/identity-providers/native-identity-provider.interface.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-react/context.tsx":
/*!****************************************************!*\
  !*** ../../packages/icp-connect-react/context.tsx ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IcpConnectContext: function() { return /* binding */ IcpConnectContext; },\n/* harmony export */   IcpConnectContextProvider: function() { return /* binding */ IcpConnectContextProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst IcpConnectContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({});\nconst IcpConnectContextProvider = (param)=>{\n    let { children, client } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(IcpConnectContext.Provider, {\n        value: {\n            client\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/alannnc/Documents/dfx/astro_hackaton/d-snap/frontend/packages/icp-connect-react/context.tsx\",\n        lineNumber: 20,\n        columnNumber: 5\n    }, undefined);\n};\n_c = IcpConnectContextProvider;\nvar _c;\n$RefreshReg$(_c, \"IcpConnectContextProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtcmVhY3QvY29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ3dEO0FBV2pELE1BQU1FLGtDQUFvQkQsb0RBQWFBLENBQTZDLENBQUMsR0FBVTtBQUUvRixNQUFNRSw0QkFBNEI7UUFBZ0MsRUFDdkVDLFFBQVEsRUFDUkMsTUFBTSxFQUM0QjtJQUNsQyxxQkFDRSw4REFBQ0gsa0JBQWtCSSxRQUFRO1FBQ3pCQyxPQUFPO1lBQ0xGO1FBQ0Y7a0JBQ0NEOzs7Ozs7QUFHUCxFQUFFO0tBWldEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9wYWNrYWdlcy9pY3AtY29ubmVjdC1yZWFjdC9jb250ZXh0LnRzeD81MDY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENsaWVudCB9IGZyb20gXCJpY3AtY29ubmVjdC1jb3JlL2NsaWVudFwiO1xuaW1wb3J0IFJlYWN0LCB7IFJlYWN0Tm9kZSwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgdHlwZSBJY3BDb25uZWN0Q29udGV4dFR5cGU8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+ID0ge1xuICBjbGllbnQ6IENsaWVudDxUPjtcbn07XG5cbmV4cG9ydCB0eXBlIEljcENvbm5lY3RDb250ZXh0UHJvdmlkZXJQcm9wczxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4gPSB7XG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XG4gIGNsaWVudDogQ2xpZW50PFQ+O1xufTtcblxuZXhwb3J0IGNvbnN0IEljcENvbm5lY3RDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxJY3BDb25uZWN0Q29udGV4dFR5cGU8UmVjb3JkPHN0cmluZywgYW55Pj4+KHt9IGFzIGFueSk7XG5cbmV4cG9ydCBjb25zdCBJY3BDb25uZWN0Q29udGV4dFByb3ZpZGVyID0gPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+Pih7XG4gIGNoaWxkcmVuLFxuICBjbGllbnQsXG59OiBJY3BDb25uZWN0Q29udGV4dFByb3ZpZGVyUHJvcHM8VD4pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8SWNwQ29ubmVjdENvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIGNsaWVudCxcbiAgICAgIH19PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvSWNwQ29ubmVjdENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsIkljcENvbm5lY3RDb250ZXh0IiwiSWNwQ29ubmVjdENvbnRleHRQcm92aWRlciIsImNoaWxkcmVuIiwiY2xpZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../packages/icp-connect-react/context.tsx\n"));

/***/ }),

/***/ "../../packages/icp-connect-react/hooks/index.ts":
/*!*******************************************************!*\
  !*** ../../packages/icp-connect-react/hooks/index.ts ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useActor: function() { return /* reexport safe */ _useActor__WEBPACK_IMPORTED_MODULE_0__.useActor; },\n/* harmony export */   useAuth: function() { return /* reexport safe */ _useAuth__WEBPACK_IMPORTED_MODULE_1__.useAuth; },\n/* harmony export */   useClient: function() { return /* reexport safe */ _useClient__WEBPACK_IMPORTED_MODULE_2__.useClient; },\n/* harmony export */   useProviders: function() { return /* reexport safe */ _useProviders__WEBPACK_IMPORTED_MODULE_3__.useProviders; }\n/* harmony export */ });\n/* harmony import */ var _useActor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useActor */ \"../../packages/icp-connect-react/hooks/useActor.ts\");\n/* harmony import */ var _useAuth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useAuth */ \"../../packages/icp-connect-react/hooks/useAuth.ts\");\n/* harmony import */ var _useClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useClient */ \"../../packages/icp-connect-react/hooks/useClient.ts\");\n/* harmony import */ var _useProviders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useProviders */ \"../../packages/icp-connect-react/hooks/useProviders.ts\");\n\n\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtcmVhY3QvaG9va3MvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMkI7QUFDRDtBQUNFO0FBQ0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3BhY2thZ2VzL2ljcC1jb25uZWN0LXJlYWN0L2hvb2tzL2luZGV4LnRzPzgzNDAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4vdXNlQWN0b3JcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3VzZUF1dGhcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3VzZUNsaWVudFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdXNlUHJvdmlkZXJzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../packages/icp-connect-react/hooks/index.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-react/hooks/useActor.ts":
/*!**********************************************************!*\
  !*** ../../packages/icp-connect-react/hooks/useActor.ts ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useActor: function() { return /* binding */ useActor; }\n/* harmony export */ });\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../context */ \"../../packages/icp-connect-react/context.tsx\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst useActor = (name)=>{\n    const { client } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_context__WEBPACK_IMPORTED_MODULE_0__.IcpConnectContext);\n    const actor = client.getActor(name);\n    if (!actor) throw new Error(\"This actor doesn't exist\");\n    return actor;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtcmVhY3QvaG9va3MvdXNlQWN0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzRTtBQUVuQztBQUU1QixNQUFNRSxXQUFXLENBQWdDQztJQUN0RCxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHSCxpREFBVUEsQ0FBQ0QsdURBQWlCQTtJQUUvQyxNQUFNSyxRQUFRRCxPQUFPRSxRQUFRLENBQUNIO0lBRTlCLElBQUksQ0FBQ0UsT0FBTyxNQUFNLElBQUlFLE1BQU07SUFFNUIsT0FBT0Y7QUFDVCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9wYWNrYWdlcy9pY3AtY29ubmVjdC1yZWFjdC9ob29rcy91c2VBY3Rvci50cz9hOWRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEljcENvbm5lY3RDb250ZXh0LCBJY3BDb25uZWN0Q29udGV4dFR5cGUgfSBmcm9tIFwiLi4vY29udGV4dFwiO1xuaW1wb3J0IHsgQWN0b3JNYXAgfSBmcm9tIFwiaWNwLWNvbm5lY3QtY29yZS9jbGllbnRcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IHVzZUFjdG9yID0gPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PihuYW1lOiBrZXlvZiBUKTogQWN0b3JNYXA8VD5ba2V5b2YgVF0gPT4ge1xuICBjb25zdCB7IGNsaWVudCB9ID0gdXNlQ29udGV4dChJY3BDb25uZWN0Q29udGV4dCkgYXMgSWNwQ29ubmVjdENvbnRleHRUeXBlPFQ+O1xuXG4gIGNvbnN0IGFjdG9yID0gY2xpZW50LmdldEFjdG9yKG5hbWUpO1xuXG4gIGlmICghYWN0b3IpIHRocm93IG5ldyBFcnJvcihcIlRoaXMgYWN0b3IgZG9lc24ndCBleGlzdFwiKTtcblxuICByZXR1cm4gYWN0b3I7XG59O1xuIl0sIm5hbWVzIjpbIkljcENvbm5lY3RDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUFjdG9yIiwibmFtZSIsImNsaWVudCIsImFjdG9yIiwiZ2V0QWN0b3IiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../packages/icp-connect-react/hooks/useActor.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-react/hooks/useAuth.ts":
/*!*********************************************************!*\
  !*** ../../packages/icp-connect-react/hooks/useAuth.ts ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var _useClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./useClient */ \"../../packages/icp-connect-react/hooks/useClient.ts\");\n/* harmony import */ var _useProviders__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useProviders */ \"../../packages/icp-connect-react/hooks/useProviders.ts\");\n\n\nconst useAuth = ()=>{\n    const client = (0,_useClient__WEBPACK_IMPORTED_MODULE_0__.useClient)();\n    const providers = (0,_useProviders__WEBPACK_IMPORTED_MODULE_1__.useProviders)();\n    const provider = providers[\"internet-identity\"];\n    async function connect() {\n        try {\n            await provider.connect();\n            const identity = provider.getIdentity();\n            client.setIdentity(identity);\n        } catch (error) {\n            throw error;\n        }\n    }\n    function disconnect() {\n        client.setIdentity();\n        return provider.disconnect();\n    }\n    function isAuthenticated() {\n        return provider.isAuthenticated();\n    }\n    function getIdentity() {\n        return provider.getIdentity();\n    }\n    function getPrincipal() {\n        return provider.getPrincipal();\n    }\n    return {\n        connect,\n        disconnect,\n        isAuthenticated,\n        getIdentity,\n        getPrincipal\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtcmVhY3QvaG9va3MvdXNlQXV0aC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFHd0M7QUFDTTtBQWdCdkMsTUFBTUUsVUFBVTtJQUNyQixNQUFNQyxTQUFTSCxxREFBU0E7SUFDeEIsTUFBTUksWUFBWUgsMkRBQVlBO0lBQzlCLE1BQU1JLFdBQVdELFNBQVMsQ0FBQyxvQkFBb0I7SUFFL0MsZUFBZUU7UUFDYixJQUFJO1lBQ0YsTUFBTUQsU0FBU0MsT0FBTztZQUN0QixNQUFNQyxXQUFXRixTQUFTRyxXQUFXO1lBQ3JDTCxPQUFPTSxXQUFXLENBQUNGO1FBQ3JCLEVBQUUsT0FBT0csT0FBTztZQUNkLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLFNBQVNDO1FBQ1BSLE9BQU9NLFdBQVc7UUFDbEIsT0FBT0osU0FBU00sVUFBVTtJQUM1QjtJQUVBLFNBQVNDO1FBQ1AsT0FBT1AsU0FBU08sZUFBZTtJQUNqQztJQUVBLFNBQVNKO1FBQ1AsT0FBT0gsU0FBU0csV0FBVztJQUM3QjtJQUVBLFNBQVNLO1FBQ1AsT0FBT1IsU0FBU1EsWUFBWTtJQUM5QjtJQUVBLE9BQU87UUFDTFA7UUFDQUs7UUFDQUM7UUFDQUo7UUFDQUs7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3BhY2thZ2VzL2ljcC1jb25uZWN0LXJlYWN0L2hvb2tzL3VzZUF1dGgudHM/MGQzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJZGVudGl0eSB9IGZyb20gXCJAZGZpbml0eS9hZ2VudFwiO1xuaW1wb3J0IHsgUHJpbmNpcGFsIH0gZnJvbSBcIkBkZmluaXR5L3ByaW5jaXBhbFwiO1xuXG5pbXBvcnQgeyB1c2VDbGllbnQgfSBmcm9tIFwiLi91c2VDbGllbnRcIjtcbmltcG9ydCB7IHVzZVByb3ZpZGVycyB9IGZyb20gXCIuL3VzZVByb3ZpZGVyc1wiO1xuXG5leHBvcnQgdHlwZSBMb2dpbk9wdGlvbnMgPSB7XG4gIG1heFRpbWVUb0xpdmU/OiBiaWdpbnQ7XG4gIGRlcml2YXRpb25PcmlnaW4/OiBzdHJpbmcgfCBVUkw7XG4gIHdpbmRvd09wZW5lckZlYXR1cmVzPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgQXV0aCA9IHtcbiAgY29ubmVjdDogKG9wdGlvbnM/OiBMb2dpbk9wdGlvbnMpID0+IFByb21pc2U8dm9pZD47XG4gIGRpc2Nvbm5lY3Q6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGlzQXV0aGVudGljYXRlZDogKCkgPT4gYm9vbGVhbjtcbiAgZ2V0SWRlbnRpdHk6ICgpID0+IElkZW50aXR5O1xuICBnZXRQcmluY2lwYWw6ICgpID0+IFByaW5jaXBhbDtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VBdXRoID0gKCk6IEF1dGggPT4ge1xuICBjb25zdCBjbGllbnQgPSB1c2VDbGllbnQoKTtcbiAgY29uc3QgcHJvdmlkZXJzID0gdXNlUHJvdmlkZXJzKCk7XG4gIGNvbnN0IHByb3ZpZGVyID0gcHJvdmlkZXJzW1wiaW50ZXJuZXQtaWRlbnRpdHlcIl07XG5cbiAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHJvdmlkZXIuY29ubmVjdCgpO1xuICAgICAgY29uc3QgaWRlbnRpdHkgPSBwcm92aWRlci5nZXRJZGVudGl0eSgpO1xuICAgICAgY2xpZW50LnNldElkZW50aXR5KGlkZW50aXR5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjbGllbnQuc2V0SWRlbnRpdHkoKTtcbiAgICByZXR1cm4gcHJvdmlkZXIuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBdXRoZW50aWNhdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBwcm92aWRlci5pc0F1dGhlbnRpY2F0ZWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElkZW50aXR5KCk6IElkZW50aXR5IHtcbiAgICByZXR1cm4gcHJvdmlkZXIuZ2V0SWRlbnRpdHkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByaW5jaXBhbCgpOiBQcmluY2lwYWwge1xuICAgIHJldHVybiBwcm92aWRlci5nZXRQcmluY2lwYWwoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29ubmVjdCxcbiAgICBkaXNjb25uZWN0LFxuICAgIGlzQXV0aGVudGljYXRlZCxcbiAgICBnZXRJZGVudGl0eSxcbiAgICBnZXRQcmluY2lwYWwsXG4gIH07XG59O1xuIl0sIm5hbWVzIjpbInVzZUNsaWVudCIsInVzZVByb3ZpZGVycyIsInVzZUF1dGgiLCJjbGllbnQiLCJwcm92aWRlcnMiLCJwcm92aWRlciIsImNvbm5lY3QiLCJpZGVudGl0eSIsImdldElkZW50aXR5Iiwic2V0SWRlbnRpdHkiLCJlcnJvciIsImRpc2Nvbm5lY3QiLCJpc0F1dGhlbnRpY2F0ZWQiLCJnZXRQcmluY2lwYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../packages/icp-connect-react/hooks/useAuth.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-react/hooks/useClient.ts":
/*!***********************************************************!*\
  !*** ../../packages/icp-connect-react/hooks/useClient.ts ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useClient: function() { return /* binding */ useClient; }\n/* harmony export */ });\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../context */ \"../../packages/icp-connect-react/context.tsx\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst useClient = ()=>{\n    const { client } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_context__WEBPACK_IMPORTED_MODULE_0__.IcpConnectContext);\n    return client;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtcmVhY3QvaG9va3MvdXNlQ2xpZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0M7QUFFWjtBQUU1QixNQUFNRSxZQUFZO0lBQ3ZCLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdGLGlEQUFVQSxDQUFDRCx1REFBaUJBO0lBQy9DLE9BQU9HO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtcmVhY3QvaG9va3MvdXNlQ2xpZW50LnRzP2Y0ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSWNwQ29ubmVjdENvbnRleHQgfSBmcm9tIFwiLi4vY29udGV4dFwiO1xuaW1wb3J0IHsgQ2xpZW50IH0gZnJvbSBcImljcC1jb25uZWN0LWNvcmUvY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5cbmV4cG9ydCBjb25zdCB1c2VDbGllbnQgPSA8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+KCk6IENsaWVudDxUPiA9PiB7XG4gIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VDb250ZXh0KEljcENvbm5lY3RDb250ZXh0KTtcbiAgcmV0dXJuIGNsaWVudCBhcyBDbGllbnQ8VD47XG59O1xuIl0sIm5hbWVzIjpbIkljcENvbm5lY3RDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUNsaWVudCIsImNsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../packages/icp-connect-react/hooks/useClient.ts\n"));

/***/ }),

/***/ "../../packages/icp-connect-react/hooks/useProviders.ts":
/*!**************************************************************!*\
  !*** ../../packages/icp-connect-react/hooks/useProviders.ts ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useProviders: function() { return /* binding */ useProviders; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../context */ \"../../packages/icp-connect-react/context.tsx\");\n\n\nconst useProviders = ()=>{\n    const { client } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_context__WEBPACK_IMPORTED_MODULE_1__.IcpConnectContext);\n    return client.getProviders();\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtcmVhY3QvaG9va3MvdXNlUHJvdmlkZXJzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBbUM7QUFFWTtBQUV4QyxNQUFNRSxlQUFlO0lBQzFCLE1BQU0sRUFBRUMsTUFBTSxFQUFFLEdBQUdILGlEQUFVQSxDQUFDQyx1REFBaUJBO0lBRS9DLE9BQU9FLE9BQU9DLFlBQVk7QUFDNUIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vcGFja2FnZXMvaWNwLWNvbm5lY3QtcmVhY3QvaG9va3MvdXNlUHJvdmlkZXJzLnRzPzRkODQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbXBvcnQgeyBJY3BDb25uZWN0Q29udGV4dCB9IGZyb20gXCIuLi9jb250ZXh0XCI7XG5cbmV4cG9ydCBjb25zdCB1c2VQcm92aWRlcnMgPSAoKSA9PiB7XG4gIGNvbnN0IHsgY2xpZW50IH0gPSB1c2VDb250ZXh0KEljcENvbm5lY3RDb250ZXh0KTtcblxuICByZXR1cm4gY2xpZW50LmdldFByb3ZpZGVycygpO1xufTtcbiJdLCJuYW1lcyI6WyJ1c2VDb250ZXh0IiwiSWNwQ29ubmVjdENvbnRleHQiLCJ1c2VQcm92aWRlcnMiLCJjbGllbnQiLCJnZXRQcm92aWRlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../packages/icp-connect-react/hooks/useProviders.ts\n"));

/***/ }),

/***/ "../../../node_modules/next/dist/compiled/process/browser.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/next/dist/compiled/process/browser.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBLFlBQVksT0FBTyxnQkFBZ0IsbUJBQW1CLE1BQU0sTUFBTSw0QkFBNEIsbURBQW1ELCtCQUErQixxREFBcUQsWUFBWSxJQUFJLG1DQUFtQyxhQUFhLEtBQUssb0JBQW9CLFNBQVMsbUJBQW1CLElBQUkscUNBQXFDLGVBQWUsS0FBSyx1QkFBdUIsU0FBUyx1QkFBdUIsSUFBSSx1QkFBdUIsbUJBQW1CLHVCQUF1QiwyQ0FBMkMsYUFBYSx1QkFBdUIsSUFBSSxjQUFjLFNBQVMsSUFBSSx3QkFBd0IsU0FBUywwQkFBMEIsNEJBQTRCLHFCQUFxQix1QkFBdUIsZ0RBQWdELGVBQWUsdUJBQXVCLElBQUksWUFBWSxTQUFTLElBQUksc0JBQXNCLFNBQVMsd0JBQXdCLFNBQVMsWUFBWSxNQUFNLFNBQVMsMkJBQTJCLFdBQVcsT0FBTyxRQUFRLGFBQWEsY0FBYyxLQUFLLEtBQUssYUFBYSxjQUFjLHNCQUFzQixNQUFNLE9BQU8sa0NBQWtDLE9BQU8sZUFBZSxTQUFTLElBQUksS0FBSyxhQUFhLE1BQU0sWUFBWSxLQUFLLFdBQVcsT0FBTyxRQUFRLG1CQUFtQix1QkFBdUIsb0NBQW9DLHVCQUF1QixZQUFZLG1CQUFtQixLQUFLLHFCQUFxQixzQkFBc0IscUJBQXFCLHlCQUF5QixtQkFBbUIsV0FBVyxhQUFhLDhCQUE4QixpQ0FBaUMsa0JBQWtCLGVBQWUsU0FBUyxVQUFVLGFBQWEsY0FBYyxpQkFBaUIsVUFBVSxtQkFBbUIsWUFBWSxXQUFXLHNCQUFzQiwwQkFBMEIsWUFBWSx1QkFBdUIsMkJBQTJCLHdCQUF3QixVQUFVLHNCQUFzQixxREFBcUQsaUJBQWlCLFdBQVcsb0JBQW9CLG1EQUFtRCxtQkFBbUIsWUFBWSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz9jMWE5Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "../../../node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************!*\
  !*** ../../../node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"../../../node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsbURBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFH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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxr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R0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz8zZDRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxue1xuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViQxID0gIGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeERFViA9IGpzeERFViQxO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "../../../node_modules/react/jsx-dev-runtime.js":
/*!******************************************************!*\
  !*** ../../../node_modules/react/jsx-dev-runtime.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"../../../node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQXNFO0FBQ3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzPzk0MjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "../../../node_modules/simple-cbor/src/index.js":
/*!******************************************************!*\
  !*** ../../../node_modules/simple-cbor/src/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__export(__webpack_require__(/*! ./serializer */ \"../../../node_modules/simple-cbor/src/serializer.js\"));\nconst value = __importStar(__webpack_require__(/*! ./value */ \"../../../node_modules/simple-cbor/src/value.js\"));\nexports.value = value;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFNBQVMsbUJBQU8sQ0FBQyx5RUFBYztBQUMvQiwyQkFBMkIsbUJBQU8sQ0FBQywrREFBUztBQUM1QyxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zaW1wbGUtY2Jvci9zcmMvaW5kZXguanM/N2ZmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zZXJpYWxpemVyXCIpKTtcbmNvbnN0IHZhbHVlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbHVlXCIpKTtcbmV4cG9ydHMudmFsdWUgPSB2YWx1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/simple-cbor/src/index.js\n"));

/***/ }),

/***/ "../../../node_modules/simple-cbor/src/serializer.js":
/*!***********************************************************!*\
  !*** ../../../node_modules/simple-cbor/src/serializer.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst cbor = __importStar(__webpack_require__(/*! ./value */ \"../../../node_modules/simple-cbor/src/value.js\"));\nconst BufferClasses = [\n    ArrayBuffer,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array,\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Float32Array,\n    Float64Array,\n];\nclass JsonDefaultCborEncoder {\n    // @param _serializer The CBOR Serializer to use.\n    // @param _stable Whether or not keys from objects should be sorted (stable). This is\n    //     particularly useful when testing encodings between JSON objects.\n    constructor(_serializer, _stable = false) {\n        this._serializer = _serializer;\n        this._stable = _stable;\n        this.name = \"jsonDefault\";\n        this.priority = -100;\n    }\n    match(value) {\n        return [\"undefined\", \"boolean\", \"number\", \"string\", \"object\"].indexOf(typeof value) != -1;\n    }\n    encode(value) {\n        switch (typeof value) {\n            case \"undefined\":\n                return cbor.undefined_();\n            case \"boolean\":\n                return cbor.bool(value);\n            case \"number\":\n                if (Math.floor(value) === value) {\n                    return cbor.number(value);\n                }\n                else {\n                    return cbor.doubleFloat(value);\n                }\n            case \"string\":\n                return cbor.string(value);\n            case \"object\":\n                if (value === null) {\n                    return cbor.null_();\n                }\n                else if (Array.isArray(value)) {\n                    return cbor.array(value.map((x) => this._serializer.serializeValue(x)));\n                }\n                else if (BufferClasses.find((x) => value instanceof x)) {\n                    return cbor.bytes(value.buffer);\n                }\n                else if (Object.getOwnPropertyNames(value).indexOf(\"toJSON\") !== -1) {\n                    return this.encode(value.toJSON());\n                }\n                else if (value instanceof Map) {\n                    const m = new Map();\n                    for (const [key, item] of value.entries()) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n                else {\n                    const m = new Map();\n                    for (const [key, item] of Object.entries(value)) {\n                        m.set(key, this._serializer.serializeValue(item));\n                    }\n                    return cbor.map(m, this._stable);\n                }\n            default:\n                throw new Error(\"Invalid value.\");\n        }\n    }\n}\nexports.JsonDefaultCborEncoder = JsonDefaultCborEncoder;\nclass ToCborEncoder {\n    constructor() {\n        this.name = \"cborEncoder\";\n        this.priority = -90;\n    }\n    match(value) {\n        return typeof value == \"object\" && typeof value[\"toCBOR\"] == \"function\";\n    }\n    encode(value) {\n        return value.toCBOR();\n    }\n}\nexports.ToCborEncoder = ToCborEncoder;\nclass CborSerializer {\n    constructor() {\n        this._encoders = new Set();\n    }\n    static withDefaultEncoders(stable = false) {\n        const s = new this();\n        s.addEncoder(new JsonDefaultCborEncoder(s, stable));\n        s.addEncoder(new ToCborEncoder());\n        return s;\n    }\n    removeEncoder(name) {\n        // Has to make an extra call to values() to ensure it doesn't break on iteration.\n        for (const encoder of this._encoders.values()) {\n            if (encoder.name == name) {\n                this._encoders.delete(encoder);\n            }\n        }\n    }\n    addEncoder(encoder) {\n        this._encoders.add(encoder);\n    }\n    getEncoderFor(value) {\n        let chosenEncoder = null;\n        for (const encoder of this._encoders) {\n            if (!chosenEncoder || encoder.priority > chosenEncoder.priority) {\n                if (encoder.match(value)) {\n                    chosenEncoder = encoder;\n                }\n            }\n        }\n        if (chosenEncoder === null) {\n            throw new Error(\"Could not find an encoder for value.\");\n        }\n        return chosenEncoder;\n    }\n    serializeValue(value) {\n        return this.getEncoderFor(value).encode(value);\n    }\n    serialize(value) {\n        return this.serializeValue(value);\n    }\n}\nexports.CborSerializer = CborSerializer;\nclass SelfDescribeCborSerializer extends CborSerializer {\n    serialize(value) {\n        return cbor.raw(new Uint8Array([\n            // Self describe CBOR.\n            ...new Uint8Array([0xd9, 0xd9, 0xf7]),\n            ...new Uint8Array(super.serializeValue(value)),\n        ]));\n    }\n}\nexports.SelfDescribeCborSerializer = SelfDescribeCborSerializer;\n//# sourceMappingURL=serializer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsK0RBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy9zZXJpYWxpemVyLmpzPzE1YzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjYm9yID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbHVlXCIpKTtcbmNvbnN0IEJ1ZmZlckNsYXNzZXMgPSBbXG4gICAgQXJyYXlCdWZmZXIsXG4gICAgVWludDhBcnJheSxcbiAgICBVaW50MTZBcnJheSxcbiAgICBVaW50MzJBcnJheSxcbiAgICBJbnQ4QXJyYXksXG4gICAgSW50MTZBcnJheSxcbiAgICBJbnQzMkFycmF5LFxuICAgIEZsb2F0MzJBcnJheSxcbiAgICBGbG9hdDY0QXJyYXksXG5dO1xuY2xhc3MgSnNvbkRlZmF1bHRDYm9yRW5jb2RlciB7XG4gICAgLy8gQHBhcmFtIF9zZXJpYWxpemVyIFRoZSBDQk9SIFNlcmlhbGl6ZXIgdG8gdXNlLlxuICAgIC8vIEBwYXJhbSBfc3RhYmxlIFdoZXRoZXIgb3Igbm90IGtleXMgZnJvbSBvYmplY3RzIHNob3VsZCBiZSBzb3J0ZWQgKHN0YWJsZSkuIFRoaXMgaXNcbiAgICAvLyAgICAgcGFydGljdWxhcmx5IHVzZWZ1bCB3aGVuIHRlc3RpbmcgZW5jb2RpbmdzIGJldHdlZW4gSlNPTiBvYmplY3RzLlxuICAgIGNvbnN0cnVjdG9yKF9zZXJpYWxpemVyLCBfc3RhYmxlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fc2VyaWFsaXplciA9IF9zZXJpYWxpemVyO1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBfc3RhYmxlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcImpzb25EZWZhdWx0XCI7XG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAtMTAwO1xuICAgIH1cbiAgICBtYXRjaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW1widW5kZWZpbmVkXCIsIFwiYm9vbGVhblwiLCBcIm51bWJlclwiLCBcInN0cmluZ1wiLCBcIm9iamVjdFwiXS5pbmRleE9mKHR5cGVvZiB2YWx1ZSkgIT0gLTE7XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLnVuZGVmaW5lZF8oKTtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNib3IuYm9vbCh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5udW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNib3IuZG91YmxlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5zdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5udWxsXygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5hcnJheSh2YWx1ZS5tYXAoKHgpID0+IHRoaXMuX3NlcmlhbGl6ZXIuc2VyaWFsaXplVmFsdWUoeCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQnVmZmVyQ2xhc3Nlcy5maW5kKCh4KSA9PiB2YWx1ZSBpbnN0YW5jZW9mIHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLmJ5dGVzKHZhbHVlLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5pbmRleE9mKFwidG9KU09OXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUodmFsdWUudG9KU09OKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGl0ZW1dIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5zZXQoa2V5LCB0aGlzLl9zZXJpYWxpemVyLnNlcmlhbGl6ZVZhbHVlKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Jvci5tYXAobSwgdGhpcy5fc3RhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnNldChrZXksIHRoaXMuX3NlcmlhbGl6ZXIuc2VyaWFsaXplVmFsdWUoaXRlbSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYm9yLm1hcChtLCB0aGlzLl9zdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZS5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkpzb25EZWZhdWx0Q2JvckVuY29kZXIgPSBKc29uRGVmYXVsdENib3JFbmNvZGVyO1xuY2xhc3MgVG9DYm9yRW5jb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiY2JvckVuY29kZXJcIjtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IC05MDtcbiAgICB9XG4gICAgbWF0Y2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZVtcInRvQ0JPUlwiXSA9PSBcImZ1bmN0aW9uXCI7XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9DQk9SKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ub0Nib3JFbmNvZGVyID0gVG9DYm9yRW5jb2RlcjtcbmNsYXNzIENib3JTZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZW5jb2RlcnMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHN0YXRpYyB3aXRoRGVmYXVsdEVuY29kZXJzKHN0YWJsZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHMgPSBuZXcgdGhpcygpO1xuICAgICAgICBzLmFkZEVuY29kZXIobmV3IEpzb25EZWZhdWx0Q2JvckVuY29kZXIocywgc3RhYmxlKSk7XG4gICAgICAgIHMuYWRkRW5jb2RlcihuZXcgVG9DYm9yRW5jb2RlcigpKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIHJlbW92ZUVuY29kZXIobmFtZSkge1xuICAgICAgICAvLyBIYXMgdG8gbWFrZSBhbiBleHRyYSBjYWxsIHRvIHZhbHVlcygpIHRvIGVuc3VyZSBpdCBkb2Vzbid0IGJyZWFrIG9uIGl0ZXJhdGlvbi5cbiAgICAgICAgZm9yIChjb25zdCBlbmNvZGVyIG9mIHRoaXMuX2VuY29kZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlci5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVycy5kZWxldGUoZW5jb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRW5jb2RlcihlbmNvZGVyKSB7XG4gICAgICAgIHRoaXMuX2VuY29kZXJzLmFkZChlbmNvZGVyKTtcbiAgICB9XG4gICAgZ2V0RW5jb2RlckZvcih2YWx1ZSkge1xuICAgICAgICBsZXQgY2hvc2VuRW5jb2RlciA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgZW5jb2RlciBvZiB0aGlzLl9lbmNvZGVycykge1xuICAgICAgICAgICAgaWYgKCFjaG9zZW5FbmNvZGVyIHx8IGVuY29kZXIucHJpb3JpdHkgPiBjaG9zZW5FbmNvZGVyLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIubWF0Y2godmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNob3NlbkVuY29kZXIgPSBlbmNvZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvc2VuRW5jb2RlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYW4gZW5jb2RlciBmb3IgdmFsdWUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaG9zZW5FbmNvZGVyO1xuICAgIH1cbiAgICBzZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVyRm9yKHZhbHVlKS5lbmNvZGUodmFsdWUpO1xuICAgIH1cbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2JvclNlcmlhbGl6ZXIgPSBDYm9yU2VyaWFsaXplcjtcbmNsYXNzIFNlbGZEZXNjcmliZUNib3JTZXJpYWxpemVyIGV4dGVuZHMgQ2JvclNlcmlhbGl6ZXIge1xuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2Jvci5yYXcobmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAgICAgLy8gU2VsZiBkZXNjcmliZSBDQk9SLlxuICAgICAgICAgICAgLi4ubmV3IFVpbnQ4QXJyYXkoWzB4ZDksIDB4ZDksIDB4ZjddKSxcbiAgICAgICAgICAgIC4uLm5ldyBVaW50OEFycmF5KHN1cGVyLnNlcmlhbGl6ZVZhbHVlKHZhbHVlKSksXG4gICAgICAgIF0pKTtcbiAgICB9XG59XG5leHBvcnRzLlNlbGZEZXNjcmliZUNib3JTZXJpYWxpemVyID0gU2VsZkRlc2NyaWJlQ2JvclNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWxpemVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/simple-cbor/src/serializer.js\n"));

/***/ }),

/***/ "../../../node_modules/simple-cbor/src/value.js":
/*!******************************************************!*\
  !*** ../../../node_modules/simple-cbor/src/value.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst MAX_U64_NUMBER = 0x20000000000000;\nfunction _concat(a, ...args) {\n    const newBuffer = new Uint8Array(a.byteLength + args.reduce((acc, b) => acc + b.byteLength, 0));\n    newBuffer.set(new Uint8Array(a), 0);\n    let i = a.byteLength;\n    for (const b of args) {\n        newBuffer.set(new Uint8Array(b), i);\n        i += b.byteLength;\n    }\n    return newBuffer.buffer;\n}\nfunction _serializeValue(major, minor, value) {\n    // Remove everything that's not an hexadecimal character. These are not\n    // considered errors since the value was already validated and they might\n    // be number decimals or sign.\n    value = value.replace(/[^0-9a-fA-F]/g, \"\");\n    // Create the buffer from the value with left padding with 0.\n    const length = 2 ** (minor - 24 /* Int8 */);\n    value = value.slice(-length * 2).padStart(length * 2, \"0\");\n    const bytes = [(major << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n    return new Uint8Array(bytes).buffer;\n}\nfunction _serializeNumber(major, value) {\n    if (value < 24) {\n        return new Uint8Array([(major << 5) + value]).buffer;\n    }\n    else {\n        const minor = value <= 0xff\n            ? 24 /* Int8 */\n            : value <= 0xffff\n                ? 25 /* Int16 */\n                : value <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        return _serializeValue(major, minor, value.toString(16));\n    }\n}\nfunction _serializeString(str) {\n    const utf8 = [];\n    for (let i = 0; i < str.length; i++) {\n        let charcode = str.charCodeAt(i);\n        if (charcode < 0x80) {\n            utf8.push(charcode);\n        }\n        else if (charcode < 0x800) {\n            utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n        else {\n            // Surrogate pair\n            i++;\n            charcode = ((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff);\n            utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));\n        }\n    }\n    return _concat(new Uint8Array(_serializeNumber(3 /* TextString */, str.length)), new Uint8Array(utf8));\n}\n/**\n * Tag a value.\n */\nfunction tagged(tag, value) {\n    if (tag == 0xd9d9f7) {\n        return _concat(new Uint8Array([0xd9, 0xd9, 0xf7]), value);\n    }\n    if (tag < 24) {\n        return _concat(new Uint8Array([(6 /* Tag */ << 5) + tag]), value);\n    }\n    else {\n        const minor = tag <= 0xff\n            ? 24 /* Int8 */\n            : tag <= 0xffff\n                ? 25 /* Int16 */\n                : tag <= 0xffffffff\n                    ? 26 /* Int32 */\n                    : 27 /* Int64 */;\n        const length = 2 ** (minor - 24 /* Int8 */);\n        const value = tag\n            .toString(16)\n            .slice(-length * 2)\n            .padStart(length * 2, \"0\");\n        const bytes = [(6 /* Tag */ << 5) + minor].concat(value.match(/../g).map((byte) => parseInt(byte, 16)));\n        return new Uint8Array(bytes).buffer;\n    }\n}\nexports.tagged = tagged;\n/**\n * Set the raw bytes contained by this value. This should only be used with another\n * CborValue, or if you are implementing extensions to CBOR.\n * @param bytes A buffer containing the value.\n */\nfunction raw(bytes) {\n    return new Uint8Array(bytes).buffer;\n}\nexports.raw = raw;\n/**\n * Encode a number that is between [0, 23].\n * @param n\n */\nfunction uSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    n = Math.min(Math.max(0, n), 23); // Clamp it.\n    const bytes = [(0 /* UnsignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.uSmall = uSmall;\nfunction u8(u8, radix) {\n    // Force u8 into a number, and validate it.\n    u8 = parseInt(\"\" + u8, radix);\n    if (isNaN(u8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u8 = Math.min(Math.max(0, u8), 0xff); // Clamp it.\n    u8 = u8.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 24 /* Int8 */, u8);\n}\nexports.u8 = u8;\nfunction u16(u16, radix) {\n    // Force u16 into a number, and validate it.\n    u16 = parseInt(\"\" + u16, radix);\n    if (isNaN(u16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u16 = Math.min(Math.max(0, u16), 0xffff); // Clamp it.\n    u16 = u16.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 25 /* Int16 */, u16);\n}\nexports.u16 = u16;\nfunction u32(u32, radix) {\n    // Force u32 into a number, and validate it.\n    u32 = parseInt(\"\" + u32, radix);\n    if (isNaN(u32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u32 = Math.min(Math.max(0, u32), 0xffffffff); // Clamp it.\n    u32 = u32.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 26 /* Int32 */, u32);\n}\nexports.u32 = u32;\nfunction u64(u64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof u64 == \"string\" && radix == 16) {\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (u64.match(/[^0-9a-fA-F]/)) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n    }\n    // Force u64 into a number, and validate it.\n    u64 = parseInt(\"\" + u64, radix);\n    if (isNaN(u64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    u64 = Math.min(Math.max(0, u64), MAX_U64_NUMBER); // Clamp it to actual limit.\n    u64 = u64.toString(16);\n    return _serializeValue(0 /* UnsignedInteger */, 27 /* Int64 */, u64);\n}\nexports.u64 = u64;\n/**\n * Encode a negative number that is between [-24, -1].\n */\nfunction iSmall(n) {\n    if (isNaN(n)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    if (n === 0) {\n        return uSmall(0);\n    }\n    // Negative n, clamped to [1, 24], minus 1 (there's no negative 0).\n    n = Math.min(Math.max(0, -n), 24) - 1;\n    const bytes = [(1 /* SignedInteger */ << 5) + n];\n    return new Uint8Array(bytes).buffer;\n}\nexports.iSmall = iSmall;\nfunction i8(i8, radix) {\n    // Force i8 into a number, and validate it.\n    i8 = parseInt(\"\" + i8, radix);\n    if (isNaN(i8)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i8 = Math.min(Math.max(0, -i8 - 1), 0xff);\n    i8 = i8.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 24 /* Int8 */, i8);\n}\nexports.i8 = i8;\nfunction i16(i16, radix) {\n    // Force i16 into a number, and validate it.\n    i16 = parseInt(\"\" + i16, radix);\n    if (isNaN(i16)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i16 = Math.min(Math.max(0, -i16 - 1), 0xffff);\n    i16 = i16.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 25 /* Int16 */, i16);\n}\nexports.i16 = i16;\nfunction i32(i32, radix) {\n    // Force i32 into a number, and validate it.\n    i32 = parseInt(\"\" + i32, radix);\n    if (isNaN(i32)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    // Negative n, clamped, minus 1 (there's no negative 0).\n    i32 = Math.min(Math.max(0, -i32 - 1), 0xffffffff);\n    i32 = i32.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 26 /* Int32 */, i32);\n}\nexports.i32 = i32;\nfunction i64(i64, radix) {\n    // Special consideration for numbers that might be larger than expected.\n    if (typeof i64 == \"string\" && radix == 16) {\n        if (i64.startsWith(\"-\")) {\n            i64 = i64.slice(1);\n        }\n        else {\n            // Clamp it.\n            i64 = \"0\";\n        }\n        // This is the only case where we guarantee we'll encode the number directly.\n        // Validate it's all hexadecimal first.\n        if (i64.match(/[^0-9a-fA-F]/) || i64.length > 16) {\n            throw new RangeError(\"Invalid number.\");\n        }\n        // We need to do -1 to the number.\n        let done = false;\n        let newI64 = i64.split(\"\").reduceRight((acc, x) => {\n            if (done) {\n                return x + acc;\n            }\n            let n = parseInt(x, 16) - 1;\n            if (n >= 0) {\n                done = true;\n                return n.toString(16) + acc;\n            }\n            else {\n                return \"f\" + acc;\n            }\n        }, \"\");\n        if (!done) {\n            // This number was 0.\n            return u64(0);\n        }\n        return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, newI64);\n    }\n    // Force i64 into a number, and validate it.\n    i64 = parseInt(\"\" + i64, radix);\n    if (isNaN(i64)) {\n        throw new RangeError(\"Invalid number.\");\n    }\n    i64 = Math.min(Math.max(0, -i64 - 1), 0x20000000000000); // Clamp it to actual.\n    i64 = i64.toString(16);\n    return _serializeValue(1 /* SignedInteger */, 27 /* Int64 */, i64);\n}\nexports.i64 = i64;\n/**\n * Encode a number using the smallest amount of bytes, by calling the methods\n * above. e.g. If the number fits in a u8, it will use that.\n */\nfunction number(n) {\n    if (n >= 0) {\n        if (n < 24) {\n            return uSmall(n);\n        }\n        else if (n <= 0xff) {\n            return u8(n);\n        }\n        else if (n <= 0xffff) {\n            return u16(n);\n        }\n        else if (n <= 0xffffffff) {\n            return u32(n);\n        }\n        else {\n            return u64(n);\n        }\n    }\n    else {\n        if (n >= -24) {\n            return iSmall(n);\n        }\n        else if (n >= -0xff) {\n            return i8(n);\n        }\n        else if (n >= -0xffff) {\n            return i16(n);\n        }\n        else if (n >= -0xffffffff) {\n            return i32(n);\n        }\n        else {\n            return i64(n);\n        }\n    }\n}\nexports.number = number;\n/**\n * Encode a byte array. This is different than the `raw()` method.\n */\nfunction bytes(bytes) {\n    return _concat(_serializeNumber(2 /* ByteString */, bytes.byteLength), bytes);\n}\nexports.bytes = bytes;\n/**\n * Encode a JavaScript string.\n */\nfunction string(str) {\n    return _serializeString(str);\n}\nexports.string = string;\n/**\n * Encode an array of cbor values.\n */\nfunction array(items) {\n    return _concat(_serializeNumber(4 /* Array */, items.length), ...items);\n}\nexports.array = array;\n/**\n * Encode a map of key-value pairs. The keys are string, and the values are CBOR\n * encoded.\n */\nfunction map(items, stable = false) {\n    if (!(items instanceof Map)) {\n        items = new Map(Object.entries(items));\n    }\n    let entries = Array.from(items.entries());\n    if (stable) {\n        entries = entries.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));\n    }\n    return _concat(_serializeNumber(5 /* Map */, items.size), ...entries.map(([k, v]) => _concat(_serializeString(k), v)));\n}\nexports.map = map;\n/**\n * Encode a single (32 bits) precision floating point number.\n */\nfunction singleFloat(f) {\n    const single = new Float32Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 26]), new Uint8Array(single.buffer));\n}\nexports.singleFloat = singleFloat;\n/**\n * Encode a double (64 bits) precision floating point number.\n */\nfunction doubleFloat(f) {\n    const single = new Float64Array([f]);\n    return _concat(new Uint8Array([(7 /* SimpleValue */ << 5) + 27]), new Uint8Array(single.buffer));\n}\nexports.doubleFloat = doubleFloat;\nfunction bool(v) {\n    return v ? true_() : false_();\n}\nexports.bool = bool;\n/**\n * Encode the boolean true.\n */\nfunction true_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 21]));\n}\nexports.true_ = true_;\n/**\n * Encode the boolean false.\n */\nfunction false_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 20]));\n}\nexports.false_ = false_;\n/**\n * Encode the constant null.\n */\nfunction null_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 22]));\n}\nexports.null_ = null_;\n/**\n * Encode the constant undefined.\n */\nfunction undefined_() {\n    return raw(new Uint8Array([(7 /* SimpleValue */ << 5) + 23]));\n}\nexports.undefined_ = undefined_;\n//# sourceMappingURL=value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3NpbXBsZS1jYm9yL3NyYy92YWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zaW1wbGUtY2Jvci9zcmMvdmFsdWUuanM/NmZjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1BWF9VNjRfTlVNQkVSID0gMHgyMDAwMDAwMDAwMDAwMDtcbmZ1bmN0aW9uIF9jb25jYXQoYSwgLi4uYXJncykge1xuICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGEuYnl0ZUxlbmd0aCArIGFyZ3MucmVkdWNlKChhY2MsIGIpID0+IGFjYyArIGIuYnl0ZUxlbmd0aCwgMCkpO1xuICAgIG5ld0J1ZmZlci5zZXQobmV3IFVpbnQ4QXJyYXkoYSksIDApO1xuICAgIGxldCBpID0gYS5ieXRlTGVuZ3RoO1xuICAgIGZvciAoY29uc3QgYiBvZiBhcmdzKSB7XG4gICAgICAgIG5ld0J1ZmZlci5zZXQobmV3IFVpbnQ4QXJyYXkoYiksIGkpO1xuICAgICAgICBpICs9IGIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZmZlci5idWZmZXI7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplVmFsdWUobWFqb3IsIG1pbm9yLCB2YWx1ZSkge1xuICAgIC8vIFJlbW92ZSBldmVyeXRoaW5nIHRoYXQncyBub3QgYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLiBUaGVzZSBhcmUgbm90XG4gICAgLy8gY29uc2lkZXJlZCBlcnJvcnMgc2luY2UgdGhlIHZhbHVlIHdhcyBhbHJlYWR5IHZhbGlkYXRlZCBhbmQgdGhleSBtaWdodFxuICAgIC8vIGJlIG51bWJlciBkZWNpbWFscyBvciBzaWduLlxuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW14wLTlhLWZBLUZdL2csIFwiXCIpO1xuICAgIC8vIENyZWF0ZSB0aGUgYnVmZmVyIGZyb20gdGhlIHZhbHVlIHdpdGggbGVmdCBwYWRkaW5nIHdpdGggMC5cbiAgICBjb25zdCBsZW5ndGggPSAyICoqIChtaW5vciAtIDI0IC8qIEludDggKi8pO1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoLWxlbmd0aCAqIDIpLnBhZFN0YXJ0KGxlbmd0aCAqIDIsIFwiMFwiKTtcbiAgICBjb25zdCBieXRlcyA9IFsobWFqb3IgPDwgNSkgKyBtaW5vcl0uY29uY2F0KHZhbHVlLm1hdGNoKC8uLi9nKS5tYXAoKGJ5dGUpID0+IHBhcnNlSW50KGJ5dGUsIDE2KSkpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyO1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZU51bWJlcihtYWpvciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAyNCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWyhtYWpvciA8PCA1KSArIHZhbHVlXSkuYnVmZmVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlub3IgPSB2YWx1ZSA8PSAweGZmXG4gICAgICAgICAgICA/IDI0IC8qIEludDggKi9cbiAgICAgICAgICAgIDogdmFsdWUgPD0gMHhmZmZmXG4gICAgICAgICAgICAgICAgPyAyNSAvKiBJbnQxNiAqL1xuICAgICAgICAgICAgICAgIDogdmFsdWUgPD0gMHhmZmZmZmZmZlxuICAgICAgICAgICAgICAgICAgICA/IDI2IC8qIEludDMyICovXG4gICAgICAgICAgICAgICAgICAgIDogMjcgLyogSW50NjQgKi87XG4gICAgICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUobWFqb3IsIG1pbm9yLCB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVTdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgdXRmOCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGFyY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhcmNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICB1dGY4LnB1c2goY2hhcmNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaCgweGMwIHwgKGNoYXJjb2RlID4+IDYpLCAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgdXRmOC5wdXNoKDB4ZTAgfCAoY2hhcmNvZGUgPj4gMTIpLCAweDgwIHwgKChjaGFyY29kZSA+PiA2KSAmIDB4M2YpLCAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNoYXJjb2RlID0gKChjaGFyY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZik7XG4gICAgICAgICAgICB1dGY4LnB1c2goMHhmMCB8IChjaGFyY29kZSA+PiAxOCksIDB4ODAgfCAoKGNoYXJjb2RlID4+IDEyKSAmIDB4M2YpLCAweDgwIHwgKChjaGFyY29kZSA+PiA2KSAmIDB4M2YpLCAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KF9zZXJpYWxpemVOdW1iZXIoMyAvKiBUZXh0U3RyaW5nICovLCBzdHIubGVuZ3RoKSksIG5ldyBVaW50OEFycmF5KHV0ZjgpKTtcbn1cbi8qKlxuICogVGFnIGEgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHRhZ2dlZCh0YWcsIHZhbHVlKSB7XG4gICAgaWYgKHRhZyA9PSAweGQ5ZDlmNykge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChuZXcgVWludDhBcnJheShbMHhkOSwgMHhkOSwgMHhmN10pLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0YWcgPCAyNCkge1xuICAgICAgICByZXR1cm4gX2NvbmNhdChuZXcgVWludDhBcnJheShbKDYgLyogVGFnICovIDw8IDUpICsgdGFnXSksIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pbm9yID0gdGFnIDw9IDB4ZmZcbiAgICAgICAgICAgID8gMjQgLyogSW50OCAqL1xuICAgICAgICAgICAgOiB0YWcgPD0gMHhmZmZmXG4gICAgICAgICAgICAgICAgPyAyNSAvKiBJbnQxNiAqL1xuICAgICAgICAgICAgICAgIDogdGFnIDw9IDB4ZmZmZmZmZmZcbiAgICAgICAgICAgICAgICAgICAgPyAyNiAvKiBJbnQzMiAqL1xuICAgICAgICAgICAgICAgICAgICA6IDI3IC8qIEludDY0ICovO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAyICoqIChtaW5vciAtIDI0IC8qIEludDggKi8pO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRhZ1xuICAgICAgICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgLnNsaWNlKC1sZW5ndGggKiAyKVxuICAgICAgICAgICAgLnBhZFN0YXJ0KGxlbmd0aCAqIDIsIFwiMFwiKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBbKDYgLyogVGFnICovIDw8IDUpICsgbWlub3JdLmNvbmNhdCh2YWx1ZS5tYXRjaCgvLi4vZykubWFwKChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXI7XG4gICAgfVxufVxuZXhwb3J0cy50YWdnZWQgPSB0YWdnZWQ7XG4vKipcbiAqIFNldCB0aGUgcmF3IGJ5dGVzIGNvbnRhaW5lZCBieSB0aGlzIHZhbHVlLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgd2l0aCBhbm90aGVyXG4gKiBDYm9yVmFsdWUsIG9yIGlmIHlvdSBhcmUgaW1wbGVtZW50aW5nIGV4dGVuc2lvbnMgdG8gQ0JPUi5cbiAqIEBwYXJhbSBieXRlcyBBIGJ1ZmZlciBjb250YWluaW5nIHRoZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcmF3KGJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKS5idWZmZXI7XG59XG5leHBvcnRzLnJhdyA9IHJhdztcbi8qKlxuICogRW5jb2RlIGEgbnVtYmVyIHRoYXQgaXMgYmV0d2VlbiBbMCwgMjNdLlxuICogQHBhcmFtIG5cbiAqL1xuZnVuY3Rpb24gdVNtYWxsKG4pIHtcbiAgICBpZiAoaXNOYU4obikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgfVxuICAgIG4gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBuKSwgMjMpOyAvLyBDbGFtcCBpdC5cbiAgICBjb25zdCBieXRlcyA9IFsoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8gPDwgNSkgKyBuXTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlcjtcbn1cbmV4cG9ydHMudVNtYWxsID0gdVNtYWxsO1xuZnVuY3Rpb24gdTgodTgsIHJhZGl4KSB7XG4gICAgLy8gRm9yY2UgdTggaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIHU4ID0gcGFyc2VJbnQoXCJcIiArIHU4LCByYWRpeCk7XG4gICAgaWYgKGlzTmFOKHU4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgdTggPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1OCksIDB4ZmYpOyAvLyBDbGFtcCBpdC5cbiAgICB1OCA9IHU4LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDAgLyogVW5zaWduZWRJbnRlZ2VyICovLCAyNCAvKiBJbnQ4ICovLCB1OCk7XG59XG5leHBvcnRzLnU4ID0gdTg7XG5mdW5jdGlvbiB1MTYodTE2LCByYWRpeCkge1xuICAgIC8vIEZvcmNlIHUxNiBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgdTE2ID0gcGFyc2VJbnQoXCJcIiArIHUxNiwgcmFkaXgpO1xuICAgIGlmIChpc05hTih1MTYpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICB1MTYgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1MTYpLCAweGZmZmYpOyAvLyBDbGFtcCBpdC5cbiAgICB1MTYgPSB1MTYudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8sIDI1IC8qIEludDE2ICovLCB1MTYpO1xufVxuZXhwb3J0cy51MTYgPSB1MTY7XG5mdW5jdGlvbiB1MzIodTMyLCByYWRpeCkge1xuICAgIC8vIEZvcmNlIHUzMiBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgdTMyID0gcGFyc2VJbnQoXCJcIiArIHUzMiwgcmFkaXgpO1xuICAgIGlmIChpc05hTih1MzIpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICB1MzIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1MzIpLCAweGZmZmZmZmZmKTsgLy8gQ2xhbXAgaXQuXG4gICAgdTMyID0gdTMyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDAgLyogVW5zaWduZWRJbnRlZ2VyICovLCAyNiAvKiBJbnQzMiAqLywgdTMyKTtcbn1cbmV4cG9ydHMudTMyID0gdTMyO1xuZnVuY3Rpb24gdTY0KHU2NCwgcmFkaXgpIHtcbiAgICAvLyBTcGVjaWFsIGNvbnNpZGVyYXRpb24gZm9yIG51bWJlcnMgdGhhdCBtaWdodCBiZSBsYXJnZXIgdGhhbiBleHBlY3RlZC5cbiAgICBpZiAodHlwZW9mIHU2NCA9PSBcInN0cmluZ1wiICYmIHJhZGl4ID09IDE2KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgY2FzZSB3aGVyZSB3ZSBndWFyYW50ZWUgd2UnbGwgZW5jb2RlIHRoZSBudW1iZXIgZGlyZWN0bHkuXG4gICAgICAgIC8vIFZhbGlkYXRlIGl0J3MgYWxsIGhleGFkZWNpbWFsIGZpcnN0LlxuICAgICAgICBpZiAodTY0Lm1hdGNoKC9bXjAtOWEtZkEtRl0vKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG51bWJlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgwIC8qIFVuc2lnbmVkSW50ZWdlciAqLywgMjcgLyogSW50NjQgKi8sIHU2NCk7XG4gICAgfVxuICAgIC8vIEZvcmNlIHU2NCBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgdTY0ID0gcGFyc2VJbnQoXCJcIiArIHU2NCwgcmFkaXgpO1xuICAgIGlmIChpc05hTih1NjQpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICB1NjQgPSBNYXRoLm1pbihNYXRoLm1heCgwLCB1NjQpLCBNQVhfVTY0X05VTUJFUik7IC8vIENsYW1wIGl0IHRvIGFjdHVhbCBsaW1pdC5cbiAgICB1NjQgPSB1NjQudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMCAvKiBVbnNpZ25lZEludGVnZXIgKi8sIDI3IC8qIEludDY0ICovLCB1NjQpO1xufVxuZXhwb3J0cy51NjQgPSB1NjQ7XG4vKipcbiAqIEVuY29kZSBhIG5lZ2F0aXZlIG51bWJlciB0aGF0IGlzIGJldHdlZW4gWy0yNCwgLTFdLlxuICovXG5mdW5jdGlvbiBpU21hbGwobikge1xuICAgIGlmIChpc05hTihuKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVTbWFsbCgwKTtcbiAgICB9XG4gICAgLy8gTmVnYXRpdmUgbiwgY2xhbXBlZCB0byBbMSwgMjRdLCBtaW51cyAxICh0aGVyZSdzIG5vIG5lZ2F0aXZlIDApLlxuICAgIG4gPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtbiksIDI0KSAtIDE7XG4gICAgY29uc3QgYnl0ZXMgPSBbKDEgLyogU2lnbmVkSW50ZWdlciAqLyA8PCA1KSArIG5dO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcykuYnVmZmVyO1xufVxuZXhwb3J0cy5pU21hbGwgPSBpU21hbGw7XG5mdW5jdGlvbiBpOChpOCwgcmFkaXgpIHtcbiAgICAvLyBGb3JjZSBpOCBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgaTggPSBwYXJzZUludChcIlwiICsgaTgsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4oaTgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICAvLyBOZWdhdGl2ZSBuLCBjbGFtcGVkLCBtaW51cyAxICh0aGVyZSdzIG5vIG5lZ2F0aXZlIDApLlxuICAgIGk4ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgLWk4IC0gMSksIDB4ZmYpO1xuICAgIGk4ID0gaTgudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMSAvKiBTaWduZWRJbnRlZ2VyICovLCAyNCAvKiBJbnQ4ICovLCBpOCk7XG59XG5leHBvcnRzLmk4ID0gaTg7XG5mdW5jdGlvbiBpMTYoaTE2LCByYWRpeCkge1xuICAgIC8vIEZvcmNlIGkxNiBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgaTE2ID0gcGFyc2VJbnQoXCJcIiArIGkxNiwgcmFkaXgpO1xuICAgIGlmIChpc05hTihpMTYpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICAvLyBOZWdhdGl2ZSBuLCBjbGFtcGVkLCBtaW51cyAxICh0aGVyZSdzIG5vIG5lZ2F0aXZlIDApLlxuICAgIGkxNiA9IE1hdGgubWluKE1hdGgubWF4KDAsIC1pMTYgLSAxKSwgMHhmZmZmKTtcbiAgICBpMTYgPSBpMTYudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBfc2VyaWFsaXplVmFsdWUoMSAvKiBTaWduZWRJbnRlZ2VyICovLCAyNSAvKiBJbnQxNiAqLywgaTE2KTtcbn1cbmV4cG9ydHMuaTE2ID0gaTE2O1xuZnVuY3Rpb24gaTMyKGkzMiwgcmFkaXgpIHtcbiAgICAvLyBGb3JjZSBpMzIgaW50byBhIG51bWJlciwgYW5kIHZhbGlkYXRlIGl0LlxuICAgIGkzMiA9IHBhcnNlSW50KFwiXCIgKyBpMzIsIHJhZGl4KTtcbiAgICBpZiAoaXNOYU4oaTMyKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgLy8gTmVnYXRpdmUgbiwgY2xhbXBlZCwgbWludXMgMSAodGhlcmUncyBubyBuZWdhdGl2ZSAwKS5cbiAgICBpMzIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtaTMyIC0gMSksIDB4ZmZmZmZmZmYpO1xuICAgIGkzMiA9IGkzMi50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIF9zZXJpYWxpemVWYWx1ZSgxIC8qIFNpZ25lZEludGVnZXIgKi8sIDI2IC8qIEludDMyICovLCBpMzIpO1xufVxuZXhwb3J0cy5pMzIgPSBpMzI7XG5mdW5jdGlvbiBpNjQoaTY0LCByYWRpeCkge1xuICAgIC8vIFNwZWNpYWwgY29uc2lkZXJhdGlvbiBmb3IgbnVtYmVycyB0aGF0IG1pZ2h0IGJlIGxhcmdlciB0aGFuIGV4cGVjdGVkLlxuICAgIGlmICh0eXBlb2YgaTY0ID09IFwic3RyaW5nXCIgJiYgcmFkaXggPT0gMTYpIHtcbiAgICAgICAgaWYgKGk2NC5zdGFydHNXaXRoKFwiLVwiKSkge1xuICAgICAgICAgICAgaTY0ID0gaTY0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2xhbXAgaXQuXG4gICAgICAgICAgICBpNjQgPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgd2UgZ3VhcmFudGVlIHdlJ2xsIGVuY29kZSB0aGUgbnVtYmVyIGRpcmVjdGx5LlxuICAgICAgICAvLyBWYWxpZGF0ZSBpdCdzIGFsbCBoZXhhZGVjaW1hbCBmaXJzdC5cbiAgICAgICAgaWYgKGk2NC5tYXRjaCgvW14wLTlhLWZBLUZdLykgfHwgaTY0Lmxlbmd0aCA+IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIC0xIHRvIHRoZSBudW1iZXIuXG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIGxldCBuZXdJNjQgPSBpNjQuc3BsaXQoXCJcIikucmVkdWNlUmlnaHQoKGFjYywgeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geCArIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuID0gcGFyc2VJbnQoeCwgMTYpIC0gMTtcbiAgICAgICAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbi50b1N0cmluZygxNikgKyBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJmXCIgKyBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFwiXCIpO1xuICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbnVtYmVyIHdhcyAwLlxuICAgICAgICAgICAgcmV0dXJuIHU2NCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDEgLyogU2lnbmVkSW50ZWdlciAqLywgMjcgLyogSW50NjQgKi8sIG5ld0k2NCk7XG4gICAgfVxuICAgIC8vIEZvcmNlIGk2NCBpbnRvIGEgbnVtYmVyLCBhbmQgdmFsaWRhdGUgaXQuXG4gICAgaTY0ID0gcGFyc2VJbnQoXCJcIiArIGk2NCwgcmFkaXgpO1xuICAgIGlmIChpc05hTihpNjQpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBudW1iZXIuXCIpO1xuICAgIH1cbiAgICBpNjQgPSBNYXRoLm1pbihNYXRoLm1heCgwLCAtaTY0IC0gMSksIDB4MjAwMDAwMDAwMDAwMDApOyAvLyBDbGFtcCBpdCB0byBhY3R1YWwuXG4gICAgaTY0ID0gaTY0LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVZhbHVlKDEgLyogU2lnbmVkSW50ZWdlciAqLywgMjcgLyogSW50NjQgKi8sIGk2NCk7XG59XG5leHBvcnRzLmk2NCA9IGk2NDtcbi8qKlxuICogRW5jb2RlIGEgbnVtYmVyIHVzaW5nIHRoZSBzbWFsbGVzdCBhbW91bnQgb2YgYnl0ZXMsIGJ5IGNhbGxpbmcgdGhlIG1ldGhvZHNcbiAqIGFib3ZlLiBlLmcuIElmIHRoZSBudW1iZXIgZml0cyBpbiBhIHU4LCBpdCB3aWxsIHVzZSB0aGF0LlxuICovXG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmIChuID49IDApIHtcbiAgICAgICAgaWYgKG4gPCAyNCkge1xuICAgICAgICAgICAgcmV0dXJuIHVTbWFsbChuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDB4ZmYpIHtcbiAgICAgICAgICAgIHJldHVybiB1OChuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIHUxNihuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiB1MzIobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdTY0KG4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobiA+PSAtMjQpIHtcbiAgICAgICAgICAgIHJldHVybiBpU21hbGwobik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA+PSAtMHhmZikge1xuICAgICAgICAgICAgcmV0dXJuIGk4KG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG4gPj0gLTB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIGkxNihuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuID49IC0weGZmZmZmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gaTMyKG4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGk2NChuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuLyoqXG4gKiBFbmNvZGUgYSBieXRlIGFycmF5LiBUaGlzIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBgcmF3KClgIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXMoYnl0ZXMpIHtcbiAgICByZXR1cm4gX2NvbmNhdChfc2VyaWFsaXplTnVtYmVyKDIgLyogQnl0ZVN0cmluZyAqLywgYnl0ZXMuYnl0ZUxlbmd0aCksIGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXMgPSBieXRlcztcbi8qKlxuICogRW5jb2RlIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gX3NlcmlhbGl6ZVN0cmluZyhzdHIpO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG4vKipcbiAqIEVuY29kZSBhbiBhcnJheSBvZiBjYm9yIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXkoaXRlbXMpIHtcbiAgICByZXR1cm4gX2NvbmNhdChfc2VyaWFsaXplTnVtYmVyKDQgLyogQXJyYXkgKi8sIGl0ZW1zLmxlbmd0aCksIC4uLml0ZW1zKTtcbn1cbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbi8qKlxuICogRW5jb2RlIGEgbWFwIG9mIGtleS12YWx1ZSBwYWlycy4gVGhlIGtleXMgYXJlIHN0cmluZywgYW5kIHRoZSB2YWx1ZXMgYXJlIENCT1JcbiAqIGVuY29kZWQuXG4gKi9cbmZ1bmN0aW9uIG1hcChpdGVtcywgc3RhYmxlID0gZmFsc2UpIHtcbiAgICBpZiAoIShpdGVtcyBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgICAgaXRlbXMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKGl0ZW1zKSk7XG4gICAgfVxuICAgIGxldCBlbnRyaWVzID0gQXJyYXkuZnJvbShpdGVtcy5lbnRyaWVzKCkpO1xuICAgIGlmIChzdGFibGUpIHtcbiAgICAgICAgZW50cmllcyA9IGVudHJpZXMuc29ydCgoW2tleUFdLCBba2V5Ql0pID0+IGtleUEubG9jYWxlQ29tcGFyZShrZXlCKSk7XG4gICAgfVxuICAgIHJldHVybiBfY29uY2F0KF9zZXJpYWxpemVOdW1iZXIoNSAvKiBNYXAgKi8sIGl0ZW1zLnNpemUpLCAuLi5lbnRyaWVzLm1hcCgoW2ssIHZdKSA9PiBfY29uY2F0KF9zZXJpYWxpemVTdHJpbmcoayksIHYpKSk7XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbi8qKlxuICogRW5jb2RlIGEgc2luZ2xlICgzMiBiaXRzKSBwcmVjaXNpb24gZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBzaW5nbGVGbG9hdChmKSB7XG4gICAgY29uc3Qgc2luZ2xlID0gbmV3IEZsb2F0MzJBcnJheShbZl0pO1xuICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDI2XSksIG5ldyBVaW50OEFycmF5KHNpbmdsZS5idWZmZXIpKTtcbn1cbmV4cG9ydHMuc2luZ2xlRmxvYXQgPSBzaW5nbGVGbG9hdDtcbi8qKlxuICogRW5jb2RlIGEgZG91YmxlICg2NCBiaXRzKSBwcmVjaXNpb24gZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBkb3VibGVGbG9hdChmKSB7XG4gICAgY29uc3Qgc2luZ2xlID0gbmV3IEZsb2F0NjRBcnJheShbZl0pO1xuICAgIHJldHVybiBfY29uY2F0KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDI3XSksIG5ldyBVaW50OEFycmF5KHNpbmdsZS5idWZmZXIpKTtcbn1cbmV4cG9ydHMuZG91YmxlRmxvYXQgPSBkb3VibGVGbG9hdDtcbmZ1bmN0aW9uIGJvb2wodikge1xuICAgIHJldHVybiB2ID8gdHJ1ZV8oKSA6IGZhbHNlXygpO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbi8qKlxuICogRW5jb2RlIHRoZSBib29sZWFuIHRydWUuXG4gKi9cbmZ1bmN0aW9uIHRydWVfKCkge1xuICAgIHJldHVybiByYXcobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjFdKSk7XG59XG5leHBvcnRzLnRydWVfID0gdHJ1ZV87XG4vKipcbiAqIEVuY29kZSB0aGUgYm9vbGVhbiBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gZmFsc2VfKCkge1xuICAgIHJldHVybiByYXcobmV3IFVpbnQ4QXJyYXkoWyg3IC8qIFNpbXBsZVZhbHVlICovIDw8IDUpICsgMjBdKSk7XG59XG5leHBvcnRzLmZhbHNlXyA9IGZhbHNlXztcbi8qKlxuICogRW5jb2RlIHRoZSBjb25zdGFudCBudWxsLlxuICovXG5mdW5jdGlvbiBudWxsXygpIHtcbiAgICByZXR1cm4gcmF3KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDIyXSkpO1xufVxuZXhwb3J0cy5udWxsXyA9IG51bGxfO1xuLyoqXG4gKiBFbmNvZGUgdGhlIGNvbnN0YW50IHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gdW5kZWZpbmVkXygpIHtcbiAgICByZXR1cm4gcmF3KG5ldyBVaW50OEFycmF5KFsoNyAvKiBTaW1wbGVWYWx1ZSAqLyA8PCA1KSArIDIzXSkpO1xufVxuZXhwb3J0cy51bmRlZmluZWRfID0gdW5kZWZpbmVkXztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbHVlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/simple-cbor/src/value.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/curves/esm/abstract/curve.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/@noble/curves/esm/abstract/curve.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: function() { return /* binding */ validateBasic; },\n/* harmony export */   wNAF: function() { return /* binding */ wNAF; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"../../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3NEO0FBQ1Y7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQseUNBQXlDO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYTtBQUNqQixJQUFJLHlEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsb0RBQU87QUFDbEI7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzPzg4YjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/curves/esm/abstract/edwards.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twistedEdwards: function() { return /* binding */ twistedEdwards; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"../../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"../../../node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax + y = 1 + dxy\n\n\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nfunction twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    const inBig = (n) => typeof n === 'bigint' && _0n < n; // n in [1..]\n    const inRange = (n, max) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n    const in0MaskRange = (n) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n    function assertInRange(n, max) {\n        // n in [1..max-1]\n        if (inRange(n, max))\n            return n;\n        throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n    }\n    function assertGE0(n) {\n        // n in [0..CURVE_ORDER-1]\n        return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n    }\n    const pointPrecomputes = new Map();\n    function isPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Extended Point works in extended coordinates: (x, y, z, t)  (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            if (!in0MaskRange(ex))\n                throw new Error('x required');\n            if (!in0MaskRange(ey))\n                throw new Error('y required');\n            if (!in0MaskRange(ez))\n                throw new Error('z required');\n            if (!in0MaskRange(et))\n                throw new Error('t required');\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            if (!in0MaskRange(x) || !in0MaskRange(y))\n                throw new Error('invalid affine point');\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            const { a, d } = CURVE;\n            if (this.is0())\n                throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n            // Equation in affine coordinates: ax + y = 1 + dxy\n            // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n            const { ex: X, ey: Y, ez: Z, et: T } = this;\n            const X2 = modP(X * X); // X\n            const Y2 = modP(Y * Y); // Y\n            const Z2 = modP(Z * Z); // Z\n            const Z4 = modP(Z2 * Z2); // Z\n            const aX2 = modP(X2 * a); // aX\n            const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n            const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n            if (left !== right)\n                throw new Error('bad point: equation left != right (1)');\n            // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n            const XY = modP(X * Y);\n            const ZT = modP(Z * T);\n            if (XY !== ZT)\n                throw new Error('bad point: equation left != right (2)');\n        }\n        // Compare one point to another.\n        equals(other) {\n            isPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            isPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n)\n                    return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        multiplyUnsafe(scalar) {\n            let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n            if (n === _0n)\n                return I;\n            if (this.equals(I) || n === _1n)\n                return this;\n            if (this.equals(G))\n                return this.wNAF(n).p;\n            return wnaf.unsafeLadder(this, n);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            const { ex: x, ey: y, ez: z } = this;\n            const is0 = this.is0();\n            if (iz == null)\n                iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n            const ax = modP(x * iz);\n            const ay = modP(y * iz);\n            const zz = modP(z * iz);\n            if (is0)\n                return { x: _0n, y: _1n };\n            if (zz !== _1n)\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex, len); // copy hex to a new array\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(normed);\n            if (y === _0n) {\n                // y=0 is allowed\n            }\n            else {\n                // RFC8032 prohibits >= p, but ZIP215 doesn't\n                if (zip215)\n                    assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n                else\n                    assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n            }\n            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y - 1\n            const v = modP(d * y2 - a); // v = d y + 1.\n            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, nByteLength * 8);\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n    function getExtendedPublicKey(key) {\n        const len = nByteLength;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        assertGE0(s); // 0 <= s < l\n        const res = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(R, _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(s, Fp.BYTES));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('result', res, nByteLength * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(sig.slice(len, 2 * len));\n        // zip215: true is good for consensus-critical apps and allows points < 2^256\n        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n        let A, R, SB;\n        try {\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2Vkd2FyZHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDbUM7QUFDRjtBQUNRO0FBQ1E7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUIsd0RBQWE7QUFDOUIsSUFBSSxxREFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVksNEZBQTRGO0FBQ3hHO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1QsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWiwyREFBMkQ7QUFDM0QsbUVBQW1FO0FBQ25FLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJLFFBQVEsVUFBVSxFQUFFLEVBQUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7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Q2xCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFXO0FBQ3pCO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQVc7QUFDbEMsOERBQThEO0FBQzlELG1EQUFtRDtBQUNuRCxzQ0FBc0M7QUFDdEMsMENBQTBDO0FBQzFDLCtDQUErQztBQUMvQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQWM7QUFDbEMseUNBQXlDLHNEQUFXO0FBQ3BEO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsY0FBYyxzREFBVztBQUN6QjtBQUNBLGdDQUFnQztBQUNoQyxnQkFBZ0IsNkJBQTZCO0FBQzdDLG9FQUFvRTtBQUNwRSw4Q0FBOEM7QUFDOUMsMkVBQTJFO0FBQzNFLHdDQUF3QztBQUN4QyxzQkFBc0I7QUFDdEIsb0JBQW9CLGtEQUFjLElBQUksc0RBQWtCO0FBQ3hELGVBQWUsc0RBQVcsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsOEJBQThCO0FBQzlCLGNBQWMsc0RBQVcsNkJBQTZCO0FBQ3RELGNBQWMsc0RBQVc7QUFDekI7QUFDQSxnQ0FBZ0M7QUFDaEMsa0JBQWtCLHNEQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9lZHdhcmRzLmpzP2IzMTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVHdpc3RlZCBFZHdhcmRzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogYXjCsiArIHnCsiA9IDEgKyBkeMKyecKyXG5pbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF84biA9IEJpZ0ludCg4KTtcbi8vIHZlcmlmaWNhdGlvbiBydWxlIGlzIGVpdGhlciB6aXAyMTUgb3IgcmZjODAzMiAvIG5pc3QxODYtNS4gQ29uc3VsdCBmcm9tSGV4OlxuY29uc3QgVkVSSUZZX0RFRkFVTFQgPSB7IHppcDIxNTogdHJ1ZSB9O1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIGhhc2g6ICdmdW5jdGlvbicsXG4gICAgICAgIGE6ICdiaWdpbnQnLFxuICAgICAgICBkOiAnYmlnaW50JyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBhZGp1c3RTY2FsYXJCeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZG9tYWluOiAnZnVuY3Rpb24nLFxuICAgICAgICB1dlJhdGlvOiAnZnVuY3Rpb24nLFxuICAgICAgICBtYXBUb0N1cnZlOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbi8vIEl0IGlzIG5vdCBnZW5lcmljIHR3aXN0ZWQgY3VydmUgZm9yIG5vdywgYnV0IGVkMjU1MTkvZWQ0NDggZ2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIHR3aXN0ZWRFZHdhcmRzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSLCBwcmVoYXNoOiBwcmVoYXNoLCBoYXNoOiBjSGFzaCwgcmFuZG9tQnl0ZXMsIG5CeXRlTGVuZ3RoLCBoOiBjb2ZhY3RvciwgfSA9IENVUlZFO1xuICAgIGNvbnN0IE1BU0sgPSBfMm4gPDwgKEJpZ0ludChuQnl0ZUxlbmd0aCAqIDgpIC0gXzFuKTtcbiAgICBjb25zdCBtb2RQID0gRnAuY3JlYXRlOyAvLyBGdW5jdGlvbiBvdmVycmlkZXNcbiAgICAvLyBzcXJ0KHUvdilcbiAgICBjb25zdCB1dlJhdGlvID0gQ1VSVkUudXZSYXRpbyB8fFxuICAgICAgICAoKHUsIHYpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSwgdmFsdWU6IEZwLnNxcnQodSAqIEZwLmludih2KSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIHZhbHVlOiBfMG4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgY29uc3QgYWRqdXN0U2NhbGFyQnl0ZXMgPSBDVVJWRS5hZGp1c3RTY2FsYXJCeXRlcyB8fCAoKGJ5dGVzKSA9PiBieXRlcyk7IC8vIE5PT1BcbiAgICBjb25zdCBkb21haW4gPSBDVVJWRS5kb21haW4gfHxcbiAgICAgICAgKChkYXRhLCBjdHgsIHBoZmxhZykgPT4ge1xuICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGggfHwgcGhmbGFnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dHMvcHJlLWhhc2ggYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTsgLy8gTk9PUFxuICAgIGNvbnN0IGluQmlnID0gKG4pID0+IHR5cGVvZiBuID09PSAnYmlnaW50JyAmJiBfMG4gPCBuOyAvLyBuIGluIFsxLi5dXG4gICAgY29uc3QgaW5SYW5nZSA9IChuLCBtYXgpID0+IGluQmlnKG4pICYmIGluQmlnKG1heCkgJiYgbiA8IG1heDsgLy8gbiBpbiBbMS4ubWF4LTFdXG4gICAgY29uc3QgaW4wTWFza1JhbmdlID0gKG4pID0+IG4gPT09IF8wbiB8fCBpblJhbmdlKG4sIE1BU0spOyAvLyBuIGluIFswLi5NQVNLLTFdXG4gICAgZnVuY3Rpb24gYXNzZXJ0SW5SYW5nZShuLCBtYXgpIHtcbiAgICAgICAgLy8gbiBpbiBbMS4ubWF4LTFdXG4gICAgICAgIGlmIChpblJhbmdlKG4sIG1heCkpXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBzY2FsYXIgPCAke21heH0sIGdvdCAke3R5cGVvZiBufSAke259YCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFMChuKSB7XG4gICAgICAgIC8vIG4gaW4gWzAuLkNVUlZFX09SREVSLTFdXG4gICAgICAgIHJldHVybiBuID09PSBfMG4gPyBuIDogYXNzZXJ0SW5SYW5nZShuLCBDVVJWRV9PUkRFUik7IC8vIEdFID0gcHJpbWUgc3ViZ3JvdXAsIG5vdCBmdWxsIGdyb3VwXG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gaXNQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZW5kZWRQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvLyBFeHRlbmRlZCBQb2ludCB3b3JrcyBpbiBleHRlbmRlZCBjb29yZGluYXRlczogKHgsIHksIHosIHQpIOKIiyAoeD14L3osIHk9eS96LCB0PXh5KS5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud2lzdGVkX0Vkd2FyZHNfY3VydmUjRXh0ZW5kZWRfY29vcmRpbmF0ZXNcbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGV4LCBleSwgZXosIGV0KSB7XG4gICAgICAgICAgICB0aGlzLmV4ID0gZXg7XG4gICAgICAgICAgICB0aGlzLmV5ID0gZXk7XG4gICAgICAgICAgICB0aGlzLmV6ID0gZXo7XG4gICAgICAgICAgICB0aGlzLmV0ID0gZXQ7XG4gICAgICAgICAgICBpZiAoIWluME1hc2tSYW5nZShleCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAoIWluME1hc2tSYW5nZShleSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAoIWluME1hc2tSYW5nZShleikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAoIWluME1hc2tSYW5nZShldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuZGVkIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIWluME1hc2tSYW5nZSh4KSB8fCAhaW4wTWFza1JhbmdlKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgXzFuLCBtb2RQKHggKiB5KSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAuZXopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCByZXF1aXJlZCBmb3IgZnJvbUhleCgpLCB3aGljaCBhbHdheXMgY3JlYXRlcyB2YWxpZCBwb2ludHMuXG4gICAgICAgIC8vIENvdWxkIGJlIHVzZWZ1bCBmb3IgZnJvbUFmZmluZSgpLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpOyAvLyBUT0RPOiBvcHRpbWl6ZSwgd2l0aCB2YXJzIGJlbG93P1xuICAgICAgICAgICAgLy8gRXF1YXRpb24gaW4gYWZmaW5lIGNvb3JkaW5hdGVzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrJcbiAgICAgICAgICAgIC8vIEVxdWF0aW9uIGluIHByb2plY3RpdmUgY29vcmRpbmF0ZXMgKFgvWiwgWS9aLCBaKTogIChhWMKyICsgWcKyKVrCsiA9IFrigbQgKyBkWMKyWcKyXG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYLCBleTogWSwgZXo6IFosIGV0OiBUIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgWDIgPSBtb2RQKFggKiBYKTsgLy8gWMKyXG4gICAgICAgICAgICBjb25zdCBZMiA9IG1vZFAoWSAqIFkpOyAvLyBZwrJcbiAgICAgICAgICAgIGNvbnN0IFoyID0gbW9kUChaICogWik7IC8vIFrCslxuICAgICAgICAgICAgY29uc3QgWjQgPSBtb2RQKFoyICogWjIpOyAvLyBa4oG0XG4gICAgICAgICAgICBjb25zdCBhWDIgPSBtb2RQKFgyICogYSk7IC8vIGFYwrJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBtb2RQKFoyICogbW9kUChhWDIgKyBZMikpOyAvLyAoYVjCsiArIFnCsilawrJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbW9kUChaNCArIG1vZFAoZCAqIG1vZFAoWDIgKiBZMikpKTsgLy8gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgICAgIGlmIChsZWZ0ICE9PSByaWdodClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMSknKTtcbiAgICAgICAgICAgIC8vIEluIEV4dGVuZGVkIGNvb3JkaW5hdGVzIHdlIGFsc28gaGF2ZSBULCB3aGljaCBpcyB4Knk9VC9aOiBjaGVjayBYKlkgPT0gWipUXG4gICAgICAgICAgICBjb25zdCBYWSA9IG1vZFAoWCAqIFkpO1xuICAgICAgICAgICAgY29uc3QgWlQgPSBtb2RQKFogKiBUKTtcbiAgICAgICAgICAgIGlmIChYWSAhPT0gWlQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQgKDIpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBpc1BvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEsIGV6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIsIGV6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBYMVoyID0gbW9kUChYMSAqIFoyKTtcbiAgICAgICAgICAgIGNvbnN0IFgyWjEgPSBtb2RQKFgyICogWjEpO1xuICAgICAgICAgICAgY29uc3QgWTFaMiA9IG1vZFAoWTEgKiBaMik7XG4gICAgICAgICAgICBjb25zdCBZMloxID0gbW9kUChZMiAqIFoxKTtcbiAgICAgICAgICAgIHJldHVybiBYMVoyID09PSBYMloxICYmIFkxWjIgPT09IFkyWjE7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIC8vIEZsaXBzIHBvaW50IHNpZ24gdG8gYSBuZWdhdGl2ZSBvbmUgKC14LCB5IGluIGFmZmluZSBjb29yZHMpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KG1vZFAoLXRoaXMuZXgpLCB0aGlzLmV5LCB0aGlzLmV6LCBtb2RQKC10aGlzLmV0KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFzdCBhbGdvIGZvciBkb3VibGluZyBFeHRlbmRlZCBQb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgICAgICAgLy8gQ29zdDogNE0gKyA0UyArIDEqYSArIDZhZGQgKyAxKjIuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgxKTsgLy8gQSA9IFgxMlxuICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoWTEgKiBZMSk7IC8vIEIgPSBZMTJcbiAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKF8ybiAqIG1vZFAoWjEgKiBaMSkpOyAvLyBDID0gMipaMTJcbiAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKGEgKiBBKTsgLy8gRCA9IGEqQVxuICAgICAgICAgICAgY29uc3QgeDF5MSA9IFgxICsgWTE7XG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUChtb2RQKHgxeTEgKiB4MXkxKSAtIEEgLSBCKTsgLy8gRSA9IChYMStZMSkyLUEtQlxuICAgICAgICAgICAgY29uc3QgRyA9IEQgKyBCOyAvLyBHID0gRCtCXG4gICAgICAgICAgICBjb25zdCBGID0gRyAtIEM7IC8vIEYgPSBHLUNcbiAgICAgICAgICAgIGNvbnN0IEggPSBEIC0gQjsgLy8gSCA9IEQtQlxuICAgICAgICAgICAgY29uc3QgWDMgPSBtb2RQKEUgKiBGKTsgLy8gWDMgPSBFKkZcbiAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7IC8vIFkzID0gRypIXG4gICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpOyAvLyBUMyA9IEUqSFxuICAgICAgICAgICAgY29uc3QgWjMgPSBtb2RQKEYgKiBHKTsgLy8gWjMgPSBGKkdcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhc3QgYWxnbyBmb3IgYWRkaW5nIDIgRXh0ZW5kZWQgUG9pbnRzLlxuICAgICAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjYWRkaXRpb24tYWRkLTIwMDgtaHdjZFxuICAgICAgICAvLyBDb3N0OiA5TSArIDEqYSArIDEqZCArIDdhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgaXNQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSwgZXo6IFoxLCBldDogVDEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMiwgZXk6IFkyLCBlejogWjIsIGV0OiBUMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICAvLyBGYXN0ZXIgYWxnbyBmb3IgYWRkaW5nIDIgRXh0ZW5kZWQgUG9pbnRzIHdoZW4gY3VydmUncyBhPS0xLlxuICAgICAgICAgICAgLy8gaHR0cDovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbCNhZGRpdGlvbi1hZGQtMjAwOC1od2NkLTRcbiAgICAgICAgICAgIC8vIENvc3Q6IDhNICsgOGFkZCArIDIqMi5cbiAgICAgICAgICAgIC8vIE5vdGU6IEl0IGRvZXMgbm90IGNoZWNrIHdoZXRoZXIgdGhlIGBvdGhlcmAgcG9pbnQgaXMgdmFsaWQuXG4gICAgICAgICAgICBpZiAoYSA9PT0gQmlnSW50KC0xKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IEEgPSBtb2RQKChZMSAtIFgxKSAqIChZMiArIFgyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoKFkxICsgWDEpICogKFkyIC0gWDIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBGID0gbW9kUChCIC0gQSk7XG4gICAgICAgICAgICAgICAgaWYgKEYgPT09IF8wbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG91YmxlKCk7IC8vIFNhbWUgcG9pbnQuIFRlc3RzIHNheSBpdCBkb2Vzbid0IGFmZmVjdCB0aW1pbmdcbiAgICAgICAgICAgICAgICBjb25zdCBDID0gbW9kUChaMSAqIF8ybiAqIFQyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBEID0gbW9kUChUMSAqIF8ybiAqIFoyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBFID0gRCArIEM7XG4gICAgICAgICAgICAgICAgY29uc3QgRyA9IEIgKyBBO1xuICAgICAgICAgICAgICAgIGNvbnN0IEggPSBEIC0gQztcbiAgICAgICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7XG4gICAgICAgICAgICAgICAgY29uc3QgVDMgPSBtb2RQKEUgKiBIKTtcbiAgICAgICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoWDEgKiBYMik7IC8vIEEgPSBYMSpYMlxuICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoWTEgKiBZMik7IC8vIEIgPSBZMSpZMlxuICAgICAgICAgICAgY29uc3QgQyA9IG1vZFAoVDEgKiBkICogVDIpOyAvLyBDID0gVDEqZCpUMlxuICAgICAgICAgICAgY29uc3QgRCA9IG1vZFAoWjEgKiBaMik7IC8vIEQgPSBaMSpaMlxuICAgICAgICAgICAgY29uc3QgRSA9IG1vZFAoKFgxICsgWTEpICogKFgyICsgWTIpIC0gQSAtIEIpOyAvLyBFID0gKFgxK1kxKSooWDIrWTIpLUEtQlxuICAgICAgICAgICAgY29uc3QgRiA9IEQgLSBDOyAvLyBGID0gRC1DXG4gICAgICAgICAgICBjb25zdCBHID0gRCArIEM7IC8vIEcgPSBEK0NcbiAgICAgICAgICAgIGNvbnN0IEggPSBtb2RQKEIgLSBhICogQSk7IC8vIEggPSBCLWEqQVxuICAgICAgICAgICAgY29uc3QgWDMgPSBtb2RQKEUgKiBGKTsgLy8gWDMgPSBFKkZcbiAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7IC8vIFkzID0gRypIXG4gICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpOyAvLyBUMyA9IEUqSFxuICAgICAgICAgICAgY29uc3QgWjMgPSBtb2RQKEYgKiBHKTsgLy8gWjMgPSBGKkdcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gdGhpcy53TkFGKGFzc2VydEluUmFuZ2Uoc2NhbGFyLCBDVVJWRV9PUkRFUikpO1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3AsIGZdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgIC8vIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgIC8vIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLlxuICAgICAgICAvLyBEb2VzIE5PVCBhbGxvdyBzY2FsYXJzIGhpZ2hlciB0aGFuIENVUlZFLm4uXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICAgICAgbGV0IG4gPSBhc3NlcnRHRTAoc2NhbGFyKTsgLy8gMCA8PSBzY2FsYXIgPCBDVVJWRS5uXG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzKEkpIHx8IG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFscyhHKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKG4pLnA7XG4gICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHBvaW50IGlzIG9mIHNtYWxsIG9yZGVyLlxuICAgICAgICAvLyBJZiB5b3UgYWRkIHNvbWV0aGluZyB0byBzbWFsbCBvcmRlciBwb2ludCwgeW91IHdpbGwgaGF2ZSBcImRpcnR5XCJcbiAgICAgICAgLy8gcG9pbnQgd2l0aCB0b3JzaW9uIGNvbXBvbmVudC5cbiAgICAgICAgLy8gTXVsdGlwbGllcyBwb2ludCBieSBjb2ZhY3RvciBhbmQgY2hlY2tzIGlmIHRoZSByZXN1bHQgaXMgMC5cbiAgICAgICAgaXNTbWFsbE9yZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpLmlzMCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgcG9pbnQgYnkgY3VydmUgb3JkZXIgYW5kIGNoZWNrcyBpZiB0aGUgcmVzdWx0IGlzIDAuXG4gICAgICAgIC8vIFJldHVybnMgYGZhbHNlYCBpcyB0aGUgcG9pbnQgaXMgZGlydHkuXG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgQ1VSVkVfT1JERVIpLmlzMCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIEV4dGVuZGVkIHBvaW50IHRvIGRlZmF1bHQgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IHgsIGV5OiB5LCBlejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IF84biA6IEZwLmludih6KTsgLy8gOCB3YXMgY2hvc2VuIGFyYml0cmFyaWx5XG4gICAgICAgICAgICBjb25zdCBheCA9IG1vZFAoeCAqIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gbW9kUCh5ICogaXopO1xuICAgICAgICAgICAgY29uc3QgenogPSBtb2RQKHogKiBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IF8wbiwgeTogXzFuIH07XG4gICAgICAgICAgICBpZiAoenogIT09IF8xbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgIC8vIFVzZXMgYWxnbyBmcm9tIFJGQzgwMzIgNS4xLjMuXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCwgemlwMjE1ID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZCwgYSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBGcC5CWVRFUztcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCwgbGVuKTsgLy8gY29weSBoZXggdG8gYSBuZXcgYXJyYXlcbiAgICAgICAgICAgIGNvbnN0IG5vcm1lZCA9IGhleC5zbGljZSgpOyAvLyBjb3B5IGFnYWluLCB3ZSdsbCBtYW5pcHVsYXRlIGl0XG4gICAgICAgICAgICBjb25zdCBsYXN0Qnl0ZSA9IGhleFtsZW4gLSAxXTsgLy8gc2VsZWN0IGxhc3QgYnl0ZVxuICAgICAgICAgICAgbm9ybWVkW2xlbiAtIDFdID0gbGFzdEJ5dGUgJiB+MHg4MDsgLy8gY2xlYXIgbGFzdCBiaXRcbiAgICAgICAgICAgIGNvbnN0IHkgPSB1dC5ieXRlc1RvTnVtYmVyTEUobm9ybWVkKTtcbiAgICAgICAgICAgIGlmICh5ID09PSBfMG4pIHtcbiAgICAgICAgICAgICAgICAvLyB5PTAgaXMgYWxsb3dlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUkZDODAzMiBwcm9oaWJpdHMgPj0gcCwgYnV0IFpJUDIxNSBkb2Vzbid0XG4gICAgICAgICAgICAgICAgaWYgKHppcDIxNSlcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SW5SYW5nZSh5LCBNQVNLKTsgLy8gemlwMjE1PXRydWUgWzEuLlAtMV0gKDJeMjU1LTE5LTEgZm9yIGVkMjU1MTkpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnRJblJhbmdlKHksIEZwLk9SREVSKTsgLy8gemlwMjE1PWZhbHNlIFsxLi5NQVNLLTFdICgyXjI1Ni0xIGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRWQyNTUxOTogeMKyID0gKHnCsi0xKS8oZHnCsisxKSBtb2QgcC4gRWQ0NDg6IHjCsiA9ICh5wrItMSkvKGR5wrItMSkgbW9kIHAuIEdlbmVyaWMgY2FzZTpcbiAgICAgICAgICAgIC8vIGF4wrIrecKyPTErZHjCsnnCsiA9PiB5wrItMT1keMKyecKyLWF4wrIgPT4gecKyLTE9eMKyKGR5wrItYSkgPT4geMKyPSh5wrItMSkvKGR5wrItYSlcbiAgICAgICAgICAgIGNvbnN0IHkyID0gbW9kUCh5ICogeSk7IC8vIGRlbm9taW5hdG9yIGlzIGFsd2F5cyBub24tMCBtb2QgcC5cbiAgICAgICAgICAgIGNvbnN0IHUgPSBtb2RQKHkyIC0gXzFuKTsgLy8gdSA9IHnCsiAtIDFcbiAgICAgICAgICAgIGNvbnN0IHYgPSBtb2RQKGQgKiB5MiAtIGEpOyAvLyB2ID0gZCB5wrIgKyAxLlxuICAgICAgICAgICAgbGV0IHsgaXNWYWxpZCwgdmFsdWU6IHggfSA9IHV2UmF0aW8odSwgdik7IC8vIOKImih1L3YpXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludC5mcm9tSGV4OiBpbnZhbGlkIHkgY29vcmRpbmF0ZScpO1xuICAgICAgICAgICAgY29uc3QgaXNYT2RkID0gKHggJiBfMW4pID09PSBfMW47IC8vIFRoZXJlIGFyZSAyIHNxdWFyZSByb290cy4gVXNlIHhfMCBiaXQgdG8gc2VsZWN0IHByb3BlclxuICAgICAgICAgICAgY29uc3QgaXNMYXN0Qnl0ZU9kZCA9IChsYXN0Qnl0ZSAmIDB4ODApICE9PSAwOyAvLyB4XzAsIGxhc3QgYml0XG4gICAgICAgICAgICBpZiAoIXppcDIxNSAmJiB4ID09PSBfMG4gJiYgaXNMYXN0Qnl0ZU9kZClcbiAgICAgICAgICAgICAgICAvLyBpZiB4PTAgYW5kIHhfMCA9IDEsIGZhaWxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50LmZyb21IZXg6IHg9MCBhbmQgeF8wPTEnKTtcbiAgICAgICAgICAgIGlmIChpc0xhc3RCeXRlT2RkICE9PSBpc1hPZGQpXG4gICAgICAgICAgICAgICAgeCA9IG1vZFAoLXgpOyAvLyBpZiB4XzAgIT0geCBtb2QgMiwgc2V0IHggPSBwLXhcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5mcm9tQWZmaW5lKHsgeCwgeSB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdktleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZLZXkpLnBvaW50O1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdXQubnVtYmVyVG9CeXRlc0xFKHksIEZwLkJZVEVTKTsgLy8gZWFjaCB5IGhhcyAyIHggdmFsdWVzICh4LCAteSlcbiAgICAgICAgICAgIGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdIHw9IHggJiBfMW4gPyAweDgwIDogMDsgLy8gd2hlbiBjb21wcmVzc2luZywgaXQncyBlbm91Z2ggdG8gc3RvcmUgeVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzOyAvLyBhbmQgdXNlIHRoZSBsYXN0IGJ5dGUgdG8gZW5jb2RlIHNpZ24gb2YgeFxuICAgICAgICB9XG4gICAgICAgIHRvSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKCkpOyAvLyBTYW1lIGFzIHRvUmF3Qnl0ZXMsIGJ1dCByZXR1cm5zIHN0cmluZy5cbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgXzFuLCBtb2RQKENVUlZFLkd4ICogQ1VSVkUuR3kpKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KF8wbiwgXzFuLCBfMW4sIF8wbik7IC8vIDAsIDEsIDEsIDBcbiAgICBjb25zdCB7IEJBU0U6IEcsIFpFUk86IEkgfSA9IFBvaW50O1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBuQnl0ZUxlbmd0aCAqIDgpO1xuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgLy8gTGl0dGxlLWVuZGlhbiBTSEE1MTIgd2l0aCBtb2R1bG8gblxuICAgIGZ1bmN0aW9uIG1vZE5fTEUoaGFzaCkge1xuICAgICAgICByZXR1cm4gbW9kTih1dC5ieXRlc1RvTnVtYmVyTEUoaGFzaCkpO1xuICAgIH1cbiAgICAvKiogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgY3JlYXRlcyBwdWJsaWMga2V5IGFuZCBvdGhlciBzdHVmZi4gUkZDODAzMiA1LjEuNSAqL1xuICAgIGZ1bmN0aW9uIGdldEV4dGVuZGVkUHVibGljS2V5KGtleSkge1xuICAgICAgICBjb25zdCBsZW4gPSBuQnl0ZUxlbmd0aDtcbiAgICAgICAga2V5ID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBsZW4pO1xuICAgICAgICAvLyBIYXNoIHByaXZhdGUga2V5IHdpdGggY3VydmUncyBoYXNoIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdW5pZm9ybWluZ2x5IHJhbmRvbSBpbnB1dFxuICAgICAgICAvLyBDaGVjayBieXRlIGxlbmd0aHM6IGVuc3VyZSg2NCwgaChlbnN1cmUoMzIsIGtleSkpKVxuICAgICAgICBjb25zdCBoYXNoZWQgPSBlbnN1cmVCeXRlcygnaGFzaGVkIHByaXZhdGUga2V5JywgY0hhc2goa2V5KSwgMiAqIGxlbik7XG4gICAgICAgIGNvbnN0IGhlYWQgPSBhZGp1c3RTY2FsYXJCeXRlcyhoYXNoZWQuc2xpY2UoMCwgbGVuKSk7IC8vIGNsZWFyIGZpcnN0IGhhbGYgYml0cywgcHJvZHVjZSBGRVxuICAgICAgICBjb25zdCBwcmVmaXggPSBoYXNoZWQuc2xpY2UobGVuLCAyICogbGVuKTsgLy8gc2Vjb25kIGhhbGYgaXMgY2FsbGVkIGtleSBwcmVmaXggKDUuMS42KVxuICAgICAgICBjb25zdCBzY2FsYXIgPSBtb2ROX0xFKGhlYWQpOyAvLyBUaGUgYWN0dWFsIHByaXZhdGUgc2NhbGFyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gRy5tdWx0aXBseShzY2FsYXIpOyAvLyBQb2ludCBvbiBFZHdhcmRzIGN1cnZlIGFrYSBwdWJsaWMga2V5XG4gICAgICAgIGNvbnN0IHBvaW50Qnl0ZXMgPSBwb2ludC50b1Jhd0J5dGVzKCk7IC8vIFVpbnQ4QXJyYXkgcmVwcmVzZW50YXRpb25cbiAgICAgICAgcmV0dXJuIHsgaGVhZCwgcHJlZml4LCBzY2FsYXIsIHBvaW50LCBwb2ludEJ5dGVzIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZXMgRWREU0EgcHViIGtleS4gUkZDODAzMiA1LjEuNS4gUHJpdmtleSBpcyBoYXNoZWQuIFVzZSBmaXJzdCBoYWxmIHdpdGggMyBiaXRzIGNsZWFyZWRcbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdktleSkge1xuICAgICAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdktleSkucG9pbnRCeXRlcztcbiAgICB9XG4gICAgLy8gaW50KCdMRScsIFNIQTUxMihkb20yKEYsIEMpIHx8IG1zZ3MpKSBtb2QgTlxuICAgIGZ1bmN0aW9uIGhhc2hEb21haW5Ub1NjYWxhcihjb250ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoKSwgLi4ubXNncykge1xuICAgICAgICBjb25zdCBtc2cgPSB1dC5jb25jYXRCeXRlcyguLi5tc2dzKTtcbiAgICAgICAgcmV0dXJuIG1vZE5fTEUoY0hhc2goZG9tYWluKG1zZywgZW5zdXJlQnl0ZXMoJ2NvbnRleHQnLCBjb250ZXh0KSwgISFwcmVoYXNoKSkpO1xuICAgIH1cbiAgICAvKiogU2lnbnMgbWVzc2FnZSB3aXRoIHByaXZhdGVLZXkuIFJGQzgwMzIgNS4xLjYgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZywgcHJpdktleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIG1zZyA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGggZXRjLlxuICAgICAgICBjb25zdCB7IHByZWZpeCwgc2NhbGFyLCBwb2ludEJ5dGVzIH0gPSBnZXRFeHRlbmRlZFB1YmxpY0tleShwcml2S2V5KTtcbiAgICAgICAgY29uc3QgciA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIHByZWZpeCwgbXNnKTsgLy8gciA9IGRvbTIoRiwgQykgfHwgcHJlZml4IHx8IFBIKE0pXG4gICAgICAgIGNvbnN0IFIgPSBHLm11bHRpcGx5KHIpLnRvUmF3Qnl0ZXMoKTsgLy8gUiA9IHJHXG4gICAgICAgIGNvbnN0IGsgPSBoYXNoRG9tYWluVG9TY2FsYXIob3B0aW9ucy5jb250ZXh0LCBSLCBwb2ludEJ5dGVzLCBtc2cpOyAvLyBSIHx8IEEgfHwgUEgoTSlcbiAgICAgICAgY29uc3QgcyA9IG1vZE4ociArIGsgKiBzY2FsYXIpOyAvLyBTID0gKHIgKyBrICogcykgbW9kIExcbiAgICAgICAgYXNzZXJ0R0UwKHMpOyAvLyAwIDw9IHMgPCBsXG4gICAgICAgIGNvbnN0IHJlcyA9IHV0LmNvbmNhdEJ5dGVzKFIsIHV0Lm51bWJlclRvQnl0ZXNMRShzLCBGcC5CWVRFUykpO1xuICAgICAgICByZXR1cm4gZW5zdXJlQnl0ZXMoJ3Jlc3VsdCcsIHJlcywgbkJ5dGVMZW5ndGggKiAyKTsgLy8gNjQtYnl0ZSBzaWduYXR1cmVcbiAgICB9XG4gICAgY29uc3QgdmVyaWZ5T3B0cyA9IFZFUklGWV9ERUZBVUxUO1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5LCBvcHRpb25zID0gdmVyaWZ5T3B0cykge1xuICAgICAgICBjb25zdCB7IGNvbnRleHQsIHppcDIxNSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgbGVuID0gRnAuQllURVM7IC8vIFZlcmlmaWVzIEVkRFNBIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuIFJGQzgwMzIgNS4xLjcuXG4gICAgICAgIHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWcsIDIgKiBsZW4pOyAvLyBBbiBleHRlbmRlZCBncm91cCBlcXVhdGlvbiBpcyBjaGVja2VkLlxuICAgICAgICBtc2cgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1zZyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnID0gcHJlaGFzaChtc2cpOyAvLyBmb3IgZWQyNTUxOXBoLCBldGNcbiAgICAgICAgY29uc3QgcyA9IHV0LmJ5dGVzVG9OdW1iZXJMRShzaWcuc2xpY2UobGVuLCAyICogbGVuKSk7XG4gICAgICAgIC8vIHppcDIxNTogdHJ1ZSBpcyBnb29kIGZvciBjb25zZW5zdXMtY3JpdGljYWwgYXBwcyBhbmQgYWxsb3dzIHBvaW50cyA8IDJeMjU2XG4gICAgICAgIC8vIHppcDIxNTogZmFsc2UgZm9sbG93cyBSRkM4MDMyIC8gTklTVDE4Ni01IGFuZCByZXN0cmljdHMgcG9pbnRzIHRvIENVUlZFLnBcbiAgICAgICAgbGV0IEEsIFIsIFNCO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgQSA9IFBvaW50LmZyb21IZXgocHVibGljS2V5LCB6aXAyMTUpO1xuICAgICAgICAgICAgUiA9IFBvaW50LmZyb21IZXgoc2lnLnNsaWNlKDAsIGxlbiksIHppcDIxNSk7XG4gICAgICAgICAgICBTQiA9IEcubXVsdGlwbHlVbnNhZmUocyk7IC8vIDAgPD0gcyA8IGwgaXMgZG9uZSBpbnNpZGVcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXppcDIxNSAmJiBBLmlzU21hbGxPcmRlcigpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBrID0gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQsIFIudG9SYXdCeXRlcygpLCBBLnRvUmF3Qnl0ZXMoKSwgbXNnKTtcbiAgICAgICAgY29uc3QgUmtBID0gUi5hZGQoQS5tdWx0aXBseVVuc2FmZShrKSk7XG4gICAgICAgIC8vIFs4XVtTXUIgPSBbOF1SICsgWzhdW2tdQSdcbiAgICAgICAgcmV0dXJuIFJrQS5zdWJ0cmFjdChTQikuY2xlYXJDb2ZhY3RvcigpLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICB9XG4gICAgRy5fc2V0V2luZG93U2l6ZSg4KTsgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBnZXRFeHRlbmRlZFB1YmxpY0tleSxcbiAgICAgICAgLy8gZWQyNTUxOSBwcml2YXRlIGtleXMgYXJlIHVuaWZvcm0gMzJiLiBObyBuZWVkIHRvIGNoZWNrIGZvciBtb2R1bG8gYmlhcywgbGlrZSBpbiBzZWNwMjU2azEuXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlJ3JlIGRvaW5nIHNjYWxhciBtdWx0aXBsaWNhdGlvbiAodXNlZCBpbiBnZXRQdWJsaWNLZXkgZXRjKSB3aXRoIHByZWNvbXB1dGVkIEJBU0VfUE9JTlRcbiAgICAgICAgICogdmFsdWVzLiBUaGlzIHNsb3dzIGRvd24gZmlyc3QgZ2V0UHVibGljS2V5KCkgYnkgbWlsbGlzZWNvbmRzIChzZWUgU3BlZWQgc2VjdGlvbiksXG4gICAgICAgICAqIGJ1dCBhbGxvd3MgdG8gc3BlZWQtdXAgc3Vic2VxdWVudCBnZXRQdWJsaWNLZXkoKSBjYWxscyB1cCB0byAyMHguXG4gICAgICAgICAqIEBwYXJhbSB3aW5kb3dTaXplIDIsIDQsIDgsIDE2XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgRXh0ZW5kZWRQb2ludDogUG9pbnQsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZHdhcmRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/curves/esm/abstract/edwards.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: function() { return /* binding */ createHasher; },\n/* harmony export */   expand_message_xmd: function() { return /* binding */ expand_message_xmd; },\n/* harmony export */   expand_message_xof: function() { return /* binding */ expand_message_xof; },\n/* harmony export */   hash_to_field: function() { return /* binding */ hash_to_field; },\n/* harmony export */   isogenyMap: function() { return /* binding */ isogenyMap; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"../../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../../../node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(dst))\n        return dst;\n    if (typeof dst === 'string')\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction abytes(item) {\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(item))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    abytes(msg);\n    abytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    abytes(msg);\n    abytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    abytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtQztBQUM2RDtBQUNoRztBQUNBLFFBQVEsa0RBQU87QUFDZjtBQUNBO0FBQ0EsZUFBZSxzREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFNBQVMsT0FBTztBQUN4RTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0RBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVyxDQUFDLHNEQUFXO0FBQ3ZDLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixzREFBVztBQUM3QixhQUFhLHNEQUFXO0FBQ3hCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsZ0NBQWdDLHNEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLFNBQVMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDTztBQUNQLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlEQUFpRDtBQUNqRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanM/ZGM2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBpc0J5dGVzLCBjb25jYXRCeXRlcywgdXRmOFRvQnl0ZXMsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZURTVChkc3QpIHtcbiAgICBpZiAoaXNCeXRlcyhkc3QpKVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIGlmICh0eXBlb2YgZHN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKGRzdCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZycpO1xufVxuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIEkyT1NQIGNhbGw6IHZhbHVlPSR7dmFsdWV9IGxlbmd0aD0ke2xlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhYnl0ZXMoaXRlbSkge1xuICAgIGlmICghaXNCeXRlcyhpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBpc051bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHNcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjFcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIERTVCA9IEgoY29uY2F0Qnl0ZXModXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB4bWQgbGVuZ3RoJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gY29uY2F0Qnl0ZXMoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcbiAgICBjb25zdCBsX2lfYl9zdHIgPSBpMm9zcChsZW5JbkJ5dGVzLCAyKTsgLy8gbGVuX2luX2J5dGVzX3N0clxuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKGNvbmNhdEJ5dGVzKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKGNvbmNhdEJ5dGVzKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKGNvbmNhdEJ5dGVzKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9IGNvbmNhdEJ5dGVzKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4vLyAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbi8vIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4vLyAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjJcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBpc051bShjb3VudCk7XG4gICAgY29uc3QgRFNUID0gdmFsaWRhdGVEU1QoX0RTVCk7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gaGFzaF90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgeyAuLi5kZWYsIERTVDogZGVmLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSB1MC5hZGQodTEpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBlbmNvZGVfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgeyAuLi5kZWYsIERTVDogZGVmLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/curves/esm/abstract/modular.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: function() { return /* binding */ Field; },\n/* harmony export */   FpDiv: function() { return /* binding */ FpDiv; },\n/* harmony export */   FpInvertBatch: function() { return /* binding */ FpInvertBatch; },\n/* harmony export */   FpIsSquare: function() { return /* binding */ FpIsSquare; },\n/* harmony export */   FpPow: function() { return /* binding */ FpPow; },\n/* harmony export */   FpSqrt: function() { return /* binding */ FpSqrt; },\n/* harmony export */   FpSqrtEven: function() { return /* binding */ FpSqrtEven; },\n/* harmony export */   FpSqrtOdd: function() { return /* binding */ FpSqrtOdd; },\n/* harmony export */   getFieldBytesLength: function() { return /* binding */ getFieldBytesLength; },\n/* harmony export */   getMinHashLength: function() { return /* binding */ getMinHashLength; },\n/* harmony export */   hashToPrivateScalar: function() { return /* binding */ hashToPrivateScalar; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   isNegativeLE: function() { return /* binding */ isNegativeLE; },\n/* harmony export */   mapHashToField: function() { return /* binding */ mapHashToField; },\n/* harmony export */   mod: function() { return /* binding */ mod; },\n/* harmony export */   nLength: function() { return /* binding */ nLength; },\n/* harmony export */   pow: function() { return /* binding */ pow; },\n/* harmony export */   pow2: function() { return /* binding */ pow2; },\n/* harmony export */   tonelliShanks: function() { return /* binding */ tonelliShanks; },\n/* harmony export */   validateField: function() { return /* binding */ validateField; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUN1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUVBQXFFLFFBQVEsTUFBTSxPQUFPO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxtQ0FBbUM7QUFDbkMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLDhC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QTRCLElBQUk7QUFDM0UsdUJBQXVCLDBEQUFlLFFBQVEsMERBQWU7QUFDN0Q7QUFDQTtBQUNBLGtCQUFrQiwwREFBZSxzQkFBc0IsMERBQWU7QUFDdEU7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanM/N2Q0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmltcG9ydCB7IGJpdE1hc2ssIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAobW9kdWxvIDw9IF8wbiB8fCBwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIERvZXMgeCBeICgyIF4gcG93ZXIpIG1vZCBwLiBwb3cyKDMwLCA0KSA9PSAzMCBeICgyIF4gNClcbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIFdpbGwgc3RhcnQgYW4gaW5maW5pdGUgbG9vcCBpZiBmaWVsZCBvcmRlciBQIGlzIG5vdCBwcmltZS5cbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG4gICAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xuICAgIGxldCBRLCBTLCBaO1xuICAgIC8vIFN0ZXAgMTogQnkgZmFjdG9yaW5nIG91dCBwb3dlcnMgb2YgMiBmcm9tIHAgLSAxLFxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspXG4gICAgICAgIDtcbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRmllbGQgT1JERVIgPiAwLCBnb3QgJHtPUkRFUn1gKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3Qgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZwLmZyb21CeXRlczogZXhwZWN0ZWQgJHtCWVRFU30sIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBtYXBLZXlUb0ZpZWxkIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7aGFzaExlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGhhc2gpIDogYnl0ZXNUb051bWJlckJFKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2xlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckJFKGtleSkgOiBieXRlc1RvTnVtYmVyTEUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!**********************************************************************!*\
  !*** ../../../node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: function() { return /* binding */ montgomery; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"../../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        a: 'bigint',\n    }, {\n        montgomeryBits: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        powPminus2: 'function',\n        Gu: 'bigint',\n    });\n    // Set defaults\n    return Object.freeze({ ...curve });\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.pow)(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */\n    function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [x_2, x_3];\n    }\n    // Accepts 0 as well\n    function assertFieldElement(n) {\n        if (typeof n === 'bigint' && _0n <= n && n < P)\n            return n;\n        throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(pointU, scalar) {\n        const u = assertFieldElement(pointU);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = assertFieldElement(scalar);\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('u coordinate', uEnc, montgomeryBytes);\n        if (fieldLen === 32)\n            u[31] &= 127; // 0b0111_1111\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(u);\n    }\n    function decodeScalar(n) {\n        const bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('scalar', n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen)\n            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n        GuBytes: GuBytes,\n    };\n}\n//# sourceMappingURL=montgomery.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vbnRnb21lcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDd0M7QUFDbUQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5REFBYztBQUNsQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCLHdCQUF3QixnREFBRztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnREFBRztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0I7QUFDQSwwQkFBMEI7QUFDMUIsZUFBZSwwREFBZTtBQUM5QjtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCLEtBQUssVUFBVSxhQUFhLElBQUk7QUFDekYsZUFBZSwwREFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOERBQThEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9udGdvbWVyeS5qcz82NTk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IG1vZCwgcG93IH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNMRSwgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIGE6ICdiaWdpbnQnLFxuICAgIH0sIHtcbiAgICAgICAgbW9udGdvbWVyeUJpdHM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIGRvbWFpbjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcG93UG1pbnVzMjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgR3U6ICdiaWdpbnQnLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uY3VydmUgfSk7XG59XG4vLyBOT1RFOiBub3QgcmVhbGx5IG1vbnRnb21lcnkgY3VydmUsIGp1c3QgYnVuY2ggb2YgdmVyeSBzcGVjaWZpYyBtZXRob2RzIGZvciBYMjU1MTkvWDQ0OCAoUkZDIDc3NDgsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3NzQ4KVxuLy8gVXNlcyBvbmx5IG9uZSBjb29yZGluYXRlIGluc3RlYWQgb2YgdHdvXG5leHBvcnQgZnVuY3Rpb24gbW9udGdvbWVyeShjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IFAgfSA9IENVUlZFO1xuICAgIGNvbnN0IG1vZFAgPSAobikgPT4gbW9kKG4sIFApO1xuICAgIGNvbnN0IG1vbnRnb21lcnlCaXRzID0gQ1VSVkUubW9udGdvbWVyeUJpdHM7XG4gICAgY29uc3QgbW9udGdvbWVyeUJ5dGVzID0gTWF0aC5jZWlsKG1vbnRnb21lcnlCaXRzIC8gOCk7XG4gICAgY29uc3QgZmllbGRMZW4gPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICBjb25zdCBhZGp1c3RTY2FsYXJCeXRlcyA9IENVUlZFLmFkanVzdFNjYWxhckJ5dGVzIHx8ICgoYnl0ZXMpID0+IGJ5dGVzKTtcbiAgICBjb25zdCBwb3dQbWludXMyID0gQ1VSVkUucG93UG1pbnVzMiB8fCAoKHgpID0+IHBvdyh4LCBQIC0gQmlnSW50KDIpLCBQKSk7XG4gICAgLy8gY3N3YXAgZnJvbSBSRkM3NzQ4LiBCdXQgaXQgaXMgbm90IGZyb20gUkZDNzc0OCFcbiAgICAvKlxuICAgICAgY3N3YXAoc3dhcCwgeF8yLCB4XzMpOlxuICAgICAgICAgICBkdW1teSA9IG1hc2soc3dhcCkgQU5EICh4XzIgWE9SIHhfMylcbiAgICAgICAgICAgeF8yID0geF8yIFhPUiBkdW1teVxuICAgICAgICAgICB4XzMgPSB4XzMgWE9SIGR1bW15XG4gICAgICAgICAgIFJldHVybiAoeF8yLCB4XzMpXG4gICAgV2hlcmUgbWFzayhzd2FwKSBpcyB0aGUgYWxsLTEgb3IgYWxsLTAgd29yZCBvZiB0aGUgc2FtZSBsZW5ndGggYXMgeF8yXG4gICAgIGFuZCB4XzMsIGNvbXB1dGVkLCBlLmcuLCBhcyBtYXNrKHN3YXApID0gMCAtIHN3YXAuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBjc3dhcChzd2FwLCB4XzIsIHhfMykge1xuICAgICAgICBjb25zdCBkdW1teSA9IG1vZFAoc3dhcCAqICh4XzIgLSB4XzMpKTtcbiAgICAgICAgeF8yID0gbW9kUCh4XzIgLSBkdW1teSk7XG4gICAgICAgIHhfMyA9IG1vZFAoeF8zICsgZHVtbXkpO1xuICAgICAgICByZXR1cm4gW3hfMiwgeF8zXTtcbiAgICB9XG4gICAgLy8gQWNjZXB0cyAwIGFzIHdlbGxcbiAgICBmdW5jdGlvbiBhc3NlcnRGaWVsZEVsZW1lbnQobikge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT09ICdiaWdpbnQnICYmIF8wbiA8PSBuICYmIG4gPCBQKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgc2NhbGFyIDAgPCBzY2FsYXIgPCBDVVJWRS5QJyk7XG4gICAgfVxuICAgIC8vIHgyNTUxOSBmcm9tIDRcbiAgICAvLyBUaGUgY29uc3RhbnQgYTI0IGlzICg0ODY2NjIgLSAyKSAvIDQgPSAxMjE2NjUgZm9yIGN1cnZlMjU1MTkvWDI1NTE5XG4gICAgY29uc3QgYTI0ID0gKENVUlZFLmEgLSBCaWdJbnQoMikpIC8gQmlnSW50KDQpO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvaW50VSB1IGNvb3JkaW5hdGUgKHgpIG9uIE1vbnRnb21lcnkgQ3VydmUgMjU1MTlcbiAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICogQHJldHVybnMgbmV3IFBvaW50IG9uIE1vbnRnb21lcnkgY3VydmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb250Z29tZXJ5TGFkZGVyKHBvaW50VSwgc2NhbGFyKSB7XG4gICAgICAgIGNvbnN0IHUgPSBhc3NlcnRGaWVsZEVsZW1lbnQocG9pbnRVKTtcbiAgICAgICAgLy8gU2VjdGlvbiA1OiBJbXBsZW1lbnRhdGlvbnMgTVVTVCBhY2NlcHQgbm9uLWNhbm9uaWNhbCB2YWx1ZXMgYW5kIHByb2Nlc3MgdGhlbSBhc1xuICAgICAgICAvLyBpZiB0aGV5IGhhZCBiZWVuIHJlZHVjZWQgbW9kdWxvIHRoZSBmaWVsZCBwcmltZS5cbiAgICAgICAgY29uc3QgayA9IGFzc2VydEZpZWxkRWxlbWVudChzY2FsYXIpO1xuICAgICAgICBjb25zdCB4XzEgPSB1O1xuICAgICAgICBsZXQgeF8yID0gXzFuO1xuICAgICAgICBsZXQgel8yID0gXzBuO1xuICAgICAgICBsZXQgeF8zID0gdTtcbiAgICAgICAgbGV0IHpfMyA9IF8xbjtcbiAgICAgICAgbGV0IHN3YXAgPSBfMG47XG4gICAgICAgIGxldCBzdztcbiAgICAgICAgZm9yIChsZXQgdCA9IEJpZ0ludChtb250Z29tZXJ5Qml0cyAtIDEpOyB0ID49IF8wbjsgdC0tKSB7XG4gICAgICAgICAgICBjb25zdCBrX3QgPSAoayA+PiB0KSAmIF8xbjtcbiAgICAgICAgICAgIHN3YXAgXj0ga190O1xuICAgICAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB4XzIsIHhfMyk7XG4gICAgICAgICAgICB4XzIgPSBzd1swXTtcbiAgICAgICAgICAgIHhfMyA9IHN3WzFdO1xuICAgICAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB6XzIsIHpfMyk7XG4gICAgICAgICAgICB6XzIgPSBzd1swXTtcbiAgICAgICAgICAgIHpfMyA9IHN3WzFdO1xuICAgICAgICAgICAgc3dhcCA9IGtfdDtcbiAgICAgICAgICAgIGNvbnN0IEEgPSB4XzIgKyB6XzI7XG4gICAgICAgICAgICBjb25zdCBBQSA9IG1vZFAoQSAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQiA9IHhfMiAtIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEJCID0gbW9kUChCICogQik7XG4gICAgICAgICAgICBjb25zdCBFID0gQUEgLSBCQjtcbiAgICAgICAgICAgIGNvbnN0IEMgPSB4XzMgKyB6XzM7XG4gICAgICAgICAgICBjb25zdCBEID0geF8zIC0gel8zO1xuICAgICAgICAgICAgY29uc3QgREEgPSBtb2RQKEQgKiBBKTtcbiAgICAgICAgICAgIGNvbnN0IENCID0gbW9kUChDICogQik7XG4gICAgICAgICAgICBjb25zdCBkYWNiID0gREEgKyBDQjtcbiAgICAgICAgICAgIGNvbnN0IGRhX2NiID0gREEgLSBDQjtcbiAgICAgICAgICAgIHhfMyA9IG1vZFAoZGFjYiAqIGRhY2IpO1xuICAgICAgICAgICAgel8zID0gbW9kUCh4XzEgKiBtb2RQKGRhX2NiICogZGFfY2IpKTtcbiAgICAgICAgICAgIHhfMiA9IG1vZFAoQUEgKiBCQik7XG4gICAgICAgICAgICB6XzIgPSBtb2RQKEUgKiAoQUEgKyBtb2RQKGEyNCAqIEUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gKHhfMiwgeF8zKSA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKVxuICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKTtcbiAgICAgICAgeF8yID0gc3dbMF07XG4gICAgICAgIHhfMyA9IHN3WzFdO1xuICAgICAgICAvLyAoel8yLCB6XzMpID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpXG4gICAgICAgIHN3ID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpO1xuICAgICAgICB6XzIgPSBzd1swXTtcbiAgICAgICAgel8zID0gc3dbMV07XG4gICAgICAgIC8vIHpfMl4ocCAtIDIpXG4gICAgICAgIGNvbnN0IHoyID0gcG93UG1pbnVzMih6XzIpO1xuICAgICAgICAvLyBSZXR1cm4geF8yICogKHpfMl4ocCAtIDIpKVxuICAgICAgICByZXR1cm4gbW9kUCh4XzIgKiB6Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZVVDb29yZGluYXRlKHUpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXNMRShtb2RQKHUpLCBtb250Z29tZXJ5Qnl0ZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVVQ29vcmRpbmF0ZSh1RW5jKSB7XG4gICAgICAgIC8vIFNlY3Rpb24gNTogV2hlbiByZWNlaXZpbmcgc3VjaCBhbiBhcnJheSwgaW1wbGVtZW50YXRpb25zIG9mIFgyNTUxOVxuICAgICAgICAvLyBNVVNUIG1hc2sgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGluIHRoZSBmaW5hbCBieXRlLlxuICAgICAgICBjb25zdCB1ID0gZW5zdXJlQnl0ZXMoJ3UgY29vcmRpbmF0ZScsIHVFbmMsIG1vbnRnb21lcnlCeXRlcyk7XG4gICAgICAgIGlmIChmaWVsZExlbiA9PT0gMzIpXG4gICAgICAgICAgICB1WzMxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExXG4gICAgICAgIHJldHVybiBieXRlc1RvTnVtYmVyTEUodSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVNjYWxhcihuKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlQnl0ZXMoJ3NjYWxhcicsIG4pO1xuICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IG1vbnRnb21lcnlCeXRlcyAmJiBsZW4gIT09IGZpZWxkTGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke21vbnRnb21lcnlCeXRlc30gb3IgJHtmaWVsZExlbn0gYnl0ZXMsIGdvdCAke2xlbn1gKTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJMRShhZGp1c3RTY2FsYXJCeXRlcyhieXRlcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsYXJNdWx0KHNjYWxhciwgdSkge1xuICAgICAgICBjb25zdCBwb2ludFUgPSBkZWNvZGVVQ29vcmRpbmF0ZSh1KTtcbiAgICAgICAgY29uc3QgX3NjYWxhciA9IGRlY29kZVNjYWxhcihzY2FsYXIpO1xuICAgICAgICBjb25zdCBwdSA9IG1vbnRnb21lcnlMYWRkZXIocG9pbnRVLCBfc2NhbGFyKTtcbiAgICAgICAgLy8gVGhlIHJlc3VsdCB3YXMgbm90IGNvbnRyaWJ1dG9yeVxuICAgICAgICAvLyBodHRwczovL2NyLnlwLnRvL2VjZGguaHRtbCN2YWxpZGF0ZVxuICAgICAgICBpZiAocHUgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIG9yIHB1YmxpYyBrZXkgcmVjZWl2ZWQnKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVDb29yZGluYXRlKHB1KTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcHVibGljIGtleSBmcm9tIHByaXZhdGUuIEJ5IGRvaW5nIHNjYWxhciBtdWx0aXBsaWNhdGlvbiBvZiBiYXNlIHBvaW50LlxuICAgIGNvbnN0IEd1Qnl0ZXMgPSBlbmNvZGVVQ29vcmRpbmF0ZShDVVJWRS5HdSk7XG4gICAgZnVuY3Rpb24gc2NhbGFyTXVsdEJhc2Uoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBzY2FsYXJNdWx0KHNjYWxhciwgR3VCeXRlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxhck11bHQsXG4gICAgICAgIHNjYWxhck11bHRCYXNlLFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQ6IChwcml2YXRlS2V5LCBwdWJsaWNLZXkpID0+IHNjYWxhck11bHQocHJpdmF0ZUtleSwgcHVibGljS2V5KSxcbiAgICAgICAgZ2V0UHVibGljS2V5OiAocHJpdmF0ZUtleSkgPT4gc2NhbGFyTXVsdEJhc2UocHJpdmF0ZUtleSksXG4gICAgICAgIHV0aWxzOiB7IHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IENVUlZFLnJhbmRvbUJ5dGVzKENVUlZFLm5CeXRlTGVuZ3RoKSB9LFxuICAgICAgICBHdUJ5dGVzOiBHdUJ5dGVzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb250Z29tZXJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/curves/esm/abstract/montgomery.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/curves/esm/abstract/utils.js":
/*!*****************************************************************!*\
  !*** ../../../node_modules/@noble/curves/esm/abstract/utils.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: function() { return /* binding */ bitGet; },\n/* harmony export */   bitLen: function() { return /* binding */ bitLen; },\n/* harmony export */   bitMask: function() { return /* binding */ bitMask; },\n/* harmony export */   bitSet: function() { return /* binding */ bitSet; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   bytesToNumberBE: function() { return /* binding */ bytesToNumberBE; },\n/* harmony export */   bytesToNumberLE: function() { return /* binding */ bytesToNumberLE; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createHmacDrbg: function() { return /* binding */ createHmacDrbg; },\n/* harmony export */   ensureBytes: function() { return /* binding */ ensureBytes; },\n/* harmony export */   equalBytes: function() { return /* binding */ equalBytes; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   hexToNumber: function() { return /* binding */ hexToNumber; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   numberToBytesBE: function() { return /* binding */ numberToBytesBE; },\n/* harmony export */   numberToBytesLE: function() { return /* binding */ numberToBytesLE; },\n/* harmony export */   numberToHexUnpadded: function() { return /* binding */ numberToHexUnpadded; },\n/* harmony export */   numberToVarBytesBE: function() { return /* binding */ numberToVarBytesBE; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   validateObject: function() { return /* binding */ validateObject; }\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    let res = new Uint8Array(sum);\n    let pad = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ087QUFDUDtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQ25ELDhEQUE4RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0IsR0FBRyxLQUFLLEdBQUcsV0FBVyxjQUFjLEtBQUs7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLFdBQVcsWUFBWSxJQUFJO0FBQ3BELGtDQUFrQyxvQkFBb0IsSUFBSSxhQUFhLEdBQUc7QUFDMUU7QUFDQSxrQ0FBa0MsVUFBVSxJQUFJLFNBQVM7QUFDekQsa0NBQWtDLG9CQUFvQixJQUFJLFNBQVM7QUFDbkUsa0NBQWtDLDJCQUEyQjtBQUM3RCxrQ0FBa0Msd0JBQXdCO0FBQzFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanM/MDlmZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXMoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgaWYgKCFpc0J5dGVzKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgbGV0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgbGV0IHBhZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgY29uc3QgYml0U2V0ID0gKG4sIHBvcywgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn07XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdThmciA9IChhcnIpID0+IFVpbnQ4QXJyYXkuZnJvbShhcnIpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXModmFsKSxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/curves/esm/ed25519.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/@noble/curves/esm/ed25519.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: function() { return /* binding */ ED25519_TORSION_SUBGROUP; },\n/* harmony export */   RistrettoPoint: function() { return /* binding */ RistrettoPoint; },\n/* harmony export */   ed25519: function() { return /* binding */ ed25519; },\n/* harmony export */   ed25519ctx: function() { return /* binding */ ed25519ctx; },\n/* harmony export */   ed25519ph: function() { return /* binding */ ed25519ph; },\n/* harmony export */   edwardsToMontgomery: function() { return /* binding */ edwardsToMontgomery; },\n/* harmony export */   edwardsToMontgomeryPriv: function() { return /* binding */ edwardsToMontgomeryPriv; },\n/* harmony export */   edwardsToMontgomeryPub: function() { return /* binding */ edwardsToMontgomeryPub; },\n/* harmony export */   encodeToCurve: function() { return /* binding */ encodeToCurve; },\n/* harmony export */   hashToCurve: function() { return /* binding */ hashToCurve; },\n/* harmony export */   hashToRistretto255: function() { return /* binding */ hashToRistretto255; },\n/* harmony export */   hash_to_ristretto255: function() { return /* binding */ hash_to_ristretto255; },\n/* harmony export */   x25519: function() { return /* binding */ x25519; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"../../../node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ \"../../../node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/edwards.js */ \"../../../node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"../../../node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"../../../node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/utils.js */ \"../../../node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"../../../node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\nconst ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n// (-1) aka (a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);\n// prettier-ignore\nconst _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\nfunction ed25519_pow_2_252_3(x) {\n    const P = ED25519_P;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x) % P; // x^31\n    const b10 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5) % P;\n    const b20 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10) % P;\n    const b40 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20) % P;\n    const b80 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40) % P;\n    const b160 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80) % P;\n    const b240 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80) % P;\n    const b250 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))\n        x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\n// Just in case\nconst ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ED25519_P, undefined, true);\nconst ed25519Defaults = {\n    // Param: a\n    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: BigInt(8),\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/v\n    uvRatio,\n};\nconst ed25519 = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)(ed25519Defaults);\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.concatBytes)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nconst ed25519ctx = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n});\nconst ed25519ph = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n    prehash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n});\nconst x25519 = /* @__PURE__ */ (() => (0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x) => {\n        const P = ED25519_P;\n        // x^(p-2) aka x^(2^255-21)\n        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n        return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n}))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nfunction edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nconst edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nfunction edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1\nconst ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)\nconst ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic\nconst ELL2_J = BigInt(486662);\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([xd, yd]); // batch division\n    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint))\n        throw new Error('RistrettoPoint expected');\n}\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */\n    static hashToCurve(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHash', hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHex', hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.equalBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32), hex) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n)\n            throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */\n    toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x * zInv, P))\n            y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))\n            s = mod(-s);\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32); // 11\n    }\n    toHex() {\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\nconst RistrettoPoint = /* @__PURE__ */ (() => {\n    if (!RistPoint.BASE)\n        RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO)\n        RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nconst hashToRistretto255 = (msg, options) => {\n    const d = options.DST;\n    const DST = typeof d === 'string' ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)(d) : d;\n    const uniform_bytes = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nconst hash_to_ristretto255 = hashToRistretto255; // legacy\n//# sourceMappingURL=ed25519.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2VkMjU1MTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM4QztBQUM4QjtBQUNyQjtBQUNEO0FBQzZCO0FBQzBCO0FBQzlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGdCQUFnQiwwREFBSSx3QkFBd0I7QUFDNUMsZ0JBQWdCLDBEQUFJLHVCQUF1QjtBQUMzQyxpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsa0JBQWtCLDBEQUFJO0FBQ3RCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsdUJBQXVCLDBEQUFJO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlEQUFHLGdCQUFnQjtBQUNsQyxlQUFlLHlEQUFHLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0EsWUFBWSx5REFBRyxtQkFBbUI7QUFDbEMsZ0JBQWdCLHlEQUFHLGdCQUFnQjtBQUNuQyxxQkFBcUI7QUFDckIsa0JBQWtCLHlEQUFHLDBCQUEwQjtBQUMvQyxnQ0FBZ0M7QUFDaEMsNkJBQTZCLHlEQUFHLFNBQVM7QUFDekMsMkJBQTJCLHlEQUFHLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUSxrRUFBWTtBQUNwQixZQUFZLHlEQUFHO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QjtBQUN6QixrQ0FBa0M7QUFDbEMsWUFBWSxrRUFBWTtBQUN4QjtBQUNBLGVBQWUsbUVBQWUsU0FBUztBQUN2QztBQUNBO0FBQ0EsZUFBZSw4REFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ0Esd0NBQXdDLGdFQUFXO0FBQ25ELDBCQUEwQiw4RUFBa0IsZUFBZSx3REFBTTtBQUNqRTtBQUNBO0FBQ0E7QUFDTyxpREFBaUQ7QUFDeEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9lZDI1NTE5LmpzPzcxYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhNTEyIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGE1MTInO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzLCB1dGY4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgdHdpc3RlZEVkd2FyZHMgfSBmcm9tICcuL2Fic3RyYWN0L2Vkd2FyZHMuanMnO1xuaW1wb3J0IHsgbW9udGdvbWVyeSB9IGZyb20gJy4vYWJzdHJhY3QvbW9udGdvbWVyeS5qcyc7XG5pbXBvcnQgeyBGaWVsZCwgRnBTcXJ0RXZlbiwgaXNOZWdhdGl2ZUxFLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgZXF1YWxCeXRlcywgbnVtYmVyVG9CeXRlc0xFLCB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBleHBhbmRfbWVzc2FnZV94bWQgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuLyoqXG4gKiBlZDI1NTE5IFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIGZvbGxvd2luZyBhZGRvbnM6XG4gKiAtIFgyNTUxOSBFQ0RIXG4gKiAtIFJpc3RyZXR0byBjb2ZhY3RvciBlbGltaW5hdGlvblxuICogLSBFbGxpZ2F0b3IgaGFzaC10by1ncm91cCAvIHBvaW50IGluZGlzdGluZ3Vpc2hhYmlsaXR5XG4gKi9cbmNvbnN0IEVEMjU1MTlfUCA9IEJpZ0ludCgnNTc4OTYwNDQ2MTg2NTgwOTc3MTE3ODU0OTI1MDQzNDM5NTM5MjY2MzQ5OTIzMzI4MjAyODIwMTk3Mjg3OTIwMDM5NTY1NjQ4MTk5NDknKTtcbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IEVEMjU1MTlfU1FSVF9NMSA9IEJpZ0ludCgnMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTInKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzVuID0gQmlnSW50KDUpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMTBuID0gQmlnSW50KDEwKSwgXzIwbiA9IEJpZ0ludCgyMCksIF80MG4gPSBCaWdJbnQoNDApLCBfODBuID0gQmlnSW50KDgwKTtcbmZ1bmN0aW9uIGVkMjU1MTlfcG93XzJfMjUyXzMoeCkge1xuICAgIGNvbnN0IFAgPSBFRDI1NTE5X1A7XG4gICAgY29uc3QgeDIgPSAoeCAqIHgpICUgUDtcbiAgICBjb25zdCBiMiA9ICh4MiAqIHgpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGI0ID0gKHBvdzIoYjIsIF8ybiwgUCkgKiBiMikgJSBQOyAvLyB4XjE1LCAxMTExXG4gICAgY29uc3QgYjUgPSAocG93MihiNCwgXzFuLCBQKSAqIHgpICUgUDsgLy8geF4zMVxuICAgIGNvbnN0IGIxMCA9IChwb3cyKGI1LCBfNW4sIFApICogYjUpICUgUDtcbiAgICBjb25zdCBiMjAgPSAocG93MihiMTAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgYjQwID0gKHBvdzIoYjIwLCBfMjBuLCBQKSAqIGIyMCkgJSBQO1xuICAgIGNvbnN0IGI4MCA9IChwb3cyKGI0MCwgXzQwbiwgUCkgKiBiNDApICUgUDtcbiAgICBjb25zdCBiMTYwID0gKHBvdzIoYjgwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNDAgPSAocG93MihiMTYwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNTAgPSAocG93MihiMjQwLCBfMTBuLCBQKSAqIGIxMCkgJSBQO1xuICAgIGNvbnN0IHBvd19wXzVfOCA9IChwb3cyKGIyNTAsIF8ybiwgUCkgKiB4KSAlIFA7XG4gICAgLy8gXiBUbyBwb3cgdG8gKHArMykvOCwgbXVsdGlwbHkgaXQgYnkgeC5cbiAgICByZXR1cm4geyBwb3dfcF81XzgsIGIyIH07XG59XG5mdW5jdGlvbiBhZGp1c3RTY2FsYXJCeXRlcyhieXRlcykge1xuICAgIC8vIFNlY3Rpb24gNTogRm9yIFgyNTUxOSwgaW4gb3JkZXIgdG8gZGVjb2RlIDMyIHJhbmRvbSBieXRlcyBhcyBhbiBpbnRlZ2VyIHNjYWxhcixcbiAgICAvLyBzZXQgdGhlIHRocmVlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgICBieXRlc1swXSAmPSAyNDg7IC8vIDBiMTExMV8xMDAwXG4gICAgLy8gYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCB0byB6ZXJvLFxuICAgIGJ5dGVzWzMxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExXG4gICAgLy8gc2V0IHRoZSBzZWNvbmQgbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGxhc3QgYnl0ZSB0byAxXG4gICAgYnl0ZXNbMzFdIHw9IDY0OyAvLyAwYjAxMDBfMDAwMFxuICAgIHJldHVybiBieXRlcztcbn1cbi8vIHNxcnQodS92KVxuZnVuY3Rpb24gdXZSYXRpbyh1LCB2KSB7XG4gICAgY29uc3QgUCA9IEVEMjU1MTlfUDtcbiAgICBjb25zdCB2MyA9IG1vZCh2ICogdiAqIHYsIFApOyAvLyB2wrNcbiAgICBjb25zdCB2NyA9IG1vZCh2MyAqIHYzICogdiwgUCk7IC8vIHbigbdcbiAgICAvLyAocCszKS84IGFuZCAocC01KS84XG4gICAgY29uc3QgcG93ID0gZWQyNTUxOV9wb3dfMl8yNTJfMyh1ICogdjcpLnBvd19wXzVfODtcbiAgICBsZXQgeCA9IG1vZCh1ICogdjMgKiBwb3csIFApOyAvLyAodXbCsykodXbigbcpXihwLTUpLzhcbiAgICBjb25zdCB2eDIgPSBtb2QodiAqIHggKiB4LCBQKTsgLy8gdnjCslxuICAgIGNvbnN0IHJvb3QxID0geDsgLy8gRmlyc3Qgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCByb290MiA9IG1vZCh4ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gU2Vjb25kIHJvb3QgY2FuZGlkYXRlXG4gICAgY29uc3QgdXNlUm9vdDEgPSB2eDIgPT09IHU7IC8vIElmIHZ4wrIgPSB1IChtb2QgcCksIHggaXMgYSBzcXVhcmUgcm9vdFxuICAgIGNvbnN0IHVzZVJvb3QyID0gdngyID09PSBtb2QoLXUsIFApOyAvLyBJZiB2eMKyID0gLXUsIHNldCB4IDwtLSB4ICogMl4oKHAtMSkvNClcbiAgICBjb25zdCBub1Jvb3QgPSB2eDIgPT09IG1vZCgtdSAqIEVEMjU1MTlfU1FSVF9NMSwgUCk7IC8vIFRoZXJlIGlzIG5vIHZhbGlkIHJvb3QsIHZ4wrIgPSAtdeKImigtMSlcbiAgICBpZiAodXNlUm9vdDEpXG4gICAgICAgIHggPSByb290MTtcbiAgICBpZiAodXNlUm9vdDIgfHwgbm9Sb290KVxuICAgICAgICB4ID0gcm9vdDI7IC8vIFdlIHJldHVybiByb290MiBhbnl3YXksIGZvciBjb25zdC10aW1lXG4gICAgaWYgKGlzTmVnYXRpdmVMRSh4LCBQKSlcbiAgICAgICAgeCA9IG1vZCgteCwgUCk7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdXNlUm9vdDEgfHwgdXNlUm9vdDIsIHZhbHVlOiB4IH07XG59XG4vLyBKdXN0IGluIGNhc2VcbmV4cG9ydCBjb25zdCBFRDI1NTE5X1RPUlNJT05fU1VCR1JPVVAgPSBbXG4gICAgJzAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdjNzE3NmE3MDNkNGRkODRmYmEzYzBiNzYwZDEwNjcwZjJhMjA1M2ZhMmMzOWNjYzY0ZWM3ZmQ3NzkyYWMwMzdhJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MCcsXG4gICAgJzI2ZTg5NThmYzJiMjI3YjA0NWMzZjQ4OWYyZWY5OGYwZDVkZmFjMDVkM2M2MzMzOWIxMzgwMjg4NmQ1M2ZjMDUnLFxuICAgICdlY2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjdmJyxcbiAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmM4NScsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdjNzE3NmE3MDNkNGRkODRmYmEzYzBiNzYwZDEwNjcwZjJhMjA1M2ZhMmMzOWNjYzY0ZWM3ZmQ3NzkyYWMwM2ZhJyxcbl07XG5jb25zdCBGcCA9IEZpZWxkKEVEMjU1MTlfUCwgdW5kZWZpbmVkLCB0cnVlKTtcbmNvbnN0IGVkMjU1MTlEZWZhdWx0cyA9IHtcbiAgICAvLyBQYXJhbTogYVxuICAgIGE6IEJpZ0ludCgtMSksIC8vIEZwLmNyZWF0ZSgtMSkgaXMgcHJvcGVyOyBvdXIgd2F5IHN0aWxsIHdvcmtzIGFuZCBpcyBmYXN0ZXJcbiAgICAvLyBkIGlzIGVxdWFsIHRvIC0xMjE2NjUvMTIxNjY2IG92ZXIgZmluaXRlIGZpZWxkLlxuICAgIC8vIE5lZ2F0aXZlIG51bWJlciBpcyBQIC0gbnVtYmVyLCBhbmQgZGl2aXNpb24gaXMgaW52ZXJ0KG51bWJlciwgUClcbiAgICBkOiBCaWdJbnQoJzM3MDk1NzA1OTM0NjY5NDM5MzQzMTM4MDgzNTA4NzU0NTY1MTg5NTQyMTEzODc5ODQzMjE5MDE2Mzg4Nzg1NTMzMDg1OTQwMjgzNTU1JyksXG4gICAgLy8gRmluaXRlIGZpZWxkIPCdlL1wIG92ZXIgd2hpY2ggd2UnbGwgZG8gY2FsY3VsYXRpb25zOyAybioqMjU1biAtIDE5blxuICAgIEZwLFxuICAgIC8vIFN1Ymdyb3VwIG9yZGVyOiBob3cgbWFueSBwb2ludHMgY3VydmUgaGFzXG4gICAgLy8gMm4qKjI1Mm4gKyAyNzc0MjMxNzc3NzM3MjM1MzUzNTg1MTkzNzc5MDg4MzY0ODQ5M247XG4gICAgbjogQmlnSW50KCc3MjM3MDA1NTc3MzMyMjYyMjEzOTczMTg2NTYzMDQyOTk0MjQwODU3MTE2MzU5Mzc5OTA3NjA2MDAxOTUwOTM4Mjg1NDU0MjUwOTg5JyksXG4gICAgLy8gQ29mYWN0b3JcbiAgICBoOiBCaWdJbnQoOCksXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzE1MTEyMjIxMzQ5NTM1NDAwNzcyNTAxMTUxNDA5NTg4NTMxNTExNDU0MDEyNjkzMDQxODU3MjA2MDQ2MTEzMjgzOTQ5ODQ3NzYyMjAyJyksXG4gICAgR3k6IEJpZ0ludCgnNDYzMTY4MzU2OTQ5MjY0NzgxNjk0MjgzOTQwMDM0NzUxNjMxNDEzMDc5OTM4NjYyNTYyMjU2MTU3ODMwMzM2MDMxNjUyNTE4NTU5NjAnKSxcbiAgICBoYXNoOiBzaGE1MTIsXG4gICAgcmFuZG9tQnl0ZXMsXG4gICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgLy8gZG9tMlxuICAgIC8vIFJhdGlvIG9mIHUgdG8gdi4gQWxsb3dzIHVzIHRvIGNvbWJpbmUgaW52ZXJzaW9uIGFuZCBzcXVhcmUgcm9vdC4gVXNlcyBhbGdvIGZyb20gUkZDODAzMiA1LjEuMy5cbiAgICAvLyBDb25zdGFudC10aW1lLCB1L+KImnZcbiAgICB1dlJhdGlvLFxufTtcbmV4cG9ydCBjb25zdCBlZDI1NTE5ID0gLyogQF9fUFVSRV9fICovIHR3aXN0ZWRFZHdhcmRzKGVkMjU1MTlEZWZhdWx0cyk7XG5mdW5jdGlvbiBlZDI1NTE5X2RvbWFpbihkYXRhLCBjdHgsIHBoZmxhZykge1xuICAgIGlmIChjdHgubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHQgaXMgdG9vIGJpZycpO1xuICAgIHJldHVybiBjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnU2lnRWQyNTUxOSBubyBFZDI1NTE5IGNvbGxpc2lvbnMnKSwgbmV3IFVpbnQ4QXJyYXkoW3BoZmxhZyA/IDEgOiAwLCBjdHgubGVuZ3RoXSksIGN0eCwgZGF0YSk7XG59XG5leHBvcnQgY29uc3QgZWQyNTUxOWN0eCA9IC8qIEBfX1BVUkVfXyAqLyB0d2lzdGVkRWR3YXJkcyh7XG4gICAgLi4uZWQyNTUxOURlZmF1bHRzLFxuICAgIGRvbWFpbjogZWQyNTUxOV9kb21haW4sXG59KTtcbmV4cG9ydCBjb25zdCBlZDI1NTE5cGggPSAvKiBAX19QVVJFX18gKi8gdHdpc3RlZEVkd2FyZHMoe1xuICAgIC4uLmVkMjU1MTlEZWZhdWx0cyxcbiAgICBkb21haW46IGVkMjU1MTlfZG9tYWluLFxuICAgIHByZWhhc2g6IHNoYTUxMixcbn0pO1xuZXhwb3J0IGNvbnN0IHgyNTUxOSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbW9udGdvbWVyeSh7XG4gICAgUDogRUQyNTUxOV9QLFxuICAgIGE6IEJpZ0ludCg0ODY2NjIpLFxuICAgIG1vbnRnb21lcnlCaXRzOiAyNTUsIC8vIG4gaXMgMjUzIGJpdHNcbiAgICBuQnl0ZUxlbmd0aDogMzIsXG4gICAgR3U6IEJpZ0ludCg5KSxcbiAgICBwb3dQbWludXMyOiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBQID0gRUQyNTUxOV9QO1xuICAgICAgICAvLyB4XihwLTIpIGFrYSB4XigyXjI1NS0yMSlcbiAgICAgICAgY29uc3QgeyBwb3dfcF81XzgsIGIyIH0gPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHgpO1xuICAgICAgICByZXR1cm4gbW9kKHBvdzIocG93X3BfNV84LCBCaWdJbnQoMyksIFApICogYjIsIFApO1xuICAgIH0sXG4gICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgcmFuZG9tQnl0ZXMsXG59KSkoKTtcbi8qKlxuICogQ29udmVydHMgZWQyNTUxOSBwdWJsaWMga2V5IHRvIHgyNTUxOSBwdWJsaWMga2V5LiBVc2VzIGZvcm11bGE6XG4gKiAqIGAodSwgdikgPSAoKDEreSkvKDEteSksIHNxcnQoLTQ4NjY2NCkqdS94KWBcbiAqICogYCh4LCB5KSA9IChzcXJ0KC00ODY2NjQpKnUvdiwgKHUtMSkvKHUrMSkpYFxuICogQGV4YW1wbGVcbiAqICAgY29uc3Qgc29tZW9uZXNQdWIgPSBlZDI1NTE5LmdldFB1YmxpY0tleShlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSk7XG4gKiAgIGNvbnN0IGFQcml2ID0geDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqICAgeDI1NTE5LmdldFNoYXJlZFNlY3JldChhUHJpdiwgZWR3YXJkc1RvTW9udGdvbWVyeVB1Yihzb21lb25lc1B1YikpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHViKGVkd2FyZHNQdWIpIHtcbiAgICBjb25zdCB7IHkgfSA9IGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KGVkd2FyZHNQdWIpO1xuICAgIGNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbiAgICByZXR1cm4gRnAudG9CeXRlcyhGcC5jcmVhdGUoKF8xbiArIHkpICogRnAuaW52KF8xbiAtIHkpKSk7XG59XG5leHBvcnQgY29uc3QgZWR3YXJkc1RvTW9udGdvbWVyeSA9IGVkd2FyZHNUb01vbnRnb21lcnlQdWI7IC8vIGRlcHJlY2F0ZWRcbi8qKlxuICogQ29udmVydHMgZWQyNTUxOSBzZWNyZXQga2V5IHRvIHgyNTUxOSBzZWNyZXQga2V5LlxuICogQGV4YW1wbGVcbiAqICAgY29uc3Qgc29tZW9uZXNQdWIgPSB4MjU1MTkuZ2V0UHVibGljS2V5KHgyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpO1xuICogICBjb25zdCBhUHJpdiA9IGVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogICB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KGVkd2FyZHNUb01vbnRnb21lcnlQcml2KGFQcml2KSwgc29tZW9uZXNQdWIpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdihlZHdhcmRzUHJpdikge1xuICAgIGNvbnN0IGhhc2hlZCA9IGVkMjU1MTlEZWZhdWx0cy5oYXNoKGVkd2FyZHNQcml2LnN1YmFycmF5KDAsIDMyKSk7XG4gICAgcmV0dXJuIGVkMjU1MTlEZWZhdWx0cy5hZGp1c3RTY2FsYXJCeXRlcyhoYXNoZWQpLnN1YmFycmF5KDAsIDMyKTtcbn1cbi8vIEhhc2ggVG8gQ3VydmUgRWxsaWdhdG9yMiBNYXAgKE5PVEU6IGRpZmZlcmVudCBmcm9tIHJpc3RyZXR0bzI1NSBlbGxpZ2F0b3IpXG4vLyBOT1RFOiB2ZXJ5IGltcG9ydGFudCBwYXJ0IGlzIHVzYWdlIG9mIEZwU3FydEV2ZW4gZm9yIEVMTDJfQzFfRURXQVJEUywgc2luY2Vcbi8vIFNhZ2VNYXRoIHJldHVybnMgZGlmZmVyZW50IHJvb3QgZmlyc3QgYW5kIGV2ZXJ5dGhpbmcgZmFsbHMgYXBhcnRcbmNvbnN0IEVMTDJfQzEgPSAoRnAuT1JERVIgKyBCaWdJbnQoMykpIC8gQmlnSW50KDgpOyAvLyAxLiBjMSA9IChxICsgMykgLyA4ICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG5jb25zdCBFTEwyX0MyID0gRnAucG93KF8ybiwgRUxMMl9DMSk7IC8vIDIuIGMyID0gMl5jMVxuY29uc3QgRUxMMl9DMyA9IEZwLnNxcnQoRnAubmVnKEZwLk9ORSkpOyAvLyAzLiBjMyA9IHNxcnQoLTEpXG5jb25zdCBFTEwyX0M0ID0gKEZwLk9SREVSIC0gQmlnSW50KDUpKSAvIEJpZ0ludCg4KTsgLy8gNC4gYzQgPSAocSAtIDUpIC8gOCAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuY29uc3QgRUxMMl9KID0gQmlnSW50KDQ4NjY2Mik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkodSkge1xuICAgIGxldCB0djEgPSBGcC5zcXIodSk7IC8vICAxLiAgdHYxID0gdV4yXG4gICAgdHYxID0gRnAubXVsKHR2MSwgXzJuKTsgLy8gIDIuICB0djEgPSAyICogdHYxXG4gICAgbGV0IHhkID0gRnAuYWRkKHR2MSwgRnAuT05FKTsgLy8gIDMuICAgeGQgPSB0djEgKyAxICAgICAgICAgIyBOb256ZXJvOiAtMSBpcyBzcXVhcmUgKG1vZCBwKSwgdHYxIGlzIG5vdFxuICAgIGxldCB4MW4gPSBGcC5uZWcoRUxMMl9KKTsgLy8gIDQuICB4MW4gPSAtSiAgICAgICAgICAgICAgIyB4MSA9IHgxbiAvIHhkID0gLUogLyAoMSArIDIgKiB1XjIpXG4gICAgbGV0IHR2MiA9IEZwLnNxcih4ZCk7IC8vICA1LiAgdHYyID0geGReMlxuICAgIGxldCBneGQgPSBGcC5tdWwodHYyLCB4ZCk7IC8vICA2LiAgZ3hkID0gdHYyICogeGQgICAgICAgICMgZ3hkID0geGReM1xuICAgIGxldCBneDEgPSBGcC5tdWwodHYxLCBFTEwyX0opOyAvLyAgNy4gIGd4MSA9IEogKiB0djEgICAgICAgICAjIHgxbiArIEogKiB4ZFxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICA4LiAgZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjIgKyBKICogeDFuICogeGRcbiAgICBneDEgPSBGcC5hZGQoZ3gxLCB0djIpOyAvLyAgOS4gIGd4MSA9IGd4MSArIHR2MiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkICsgeGReMlxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICAxMC4gZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjMgKyBKICogeDFuXjIgKiB4ZCArIHgxbiAqIHhkXjJcbiAgICBsZXQgdHYzID0gRnAuc3FyKGd4ZCk7IC8vICAxMS4gdHYzID0gZ3hkXjJcbiAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gIDEyLiB0djIgPSB0djNeMiAgICAgICAgICAgIyBneGReNFxuICAgIHR2MyA9IEZwLm11bCh0djMsIGd4ZCk7IC8vICAxMy4gdHYzID0gdHYzICogZ3hkICAgICAgICMgZ3hkXjNcbiAgICB0djMgPSBGcC5tdWwodHYzLCBneDEpOyAvLyAgMTQuIHR2MyA9IHR2MyAqIGd4MSAgICAgICAjIGd4MSAqIGd4ZF4zXG4gICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gIDE1LiB0djIgPSB0djIgKiB0djMgICAgICAgIyBneDEgKiBneGReN1xuICAgIGxldCB5MTEgPSBGcC5wb3codHYyLCBFTEwyX0M0KTsgLy8gIDE2LiB5MTEgPSB0djJeYzQgICAgICAgICMgKGd4MSAqIGd4ZF43KV4oKHAgLSA1KSAvIDgpXG4gICAgeTExID0gRnAubXVsKHkxMSwgdHYzKTsgLy8gIDE3LiB5MTEgPSB5MTEgKiB0djMgICAgICAgIyBneDEqZ3hkXjMqKGd4MSpneGReNyleKChwLTUpLzgpXG4gICAgbGV0IHkxMiA9IEZwLm11bCh5MTEsIEVMTDJfQzMpOyAvLyAgMTguIHkxMiA9IHkxMSAqIGMzXG4gICAgdHYyID0gRnAuc3FyKHkxMSk7IC8vICAxOS4gdHYyID0geTExXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjAuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMSA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAyMS4gIGUxID0gdHYyID09IGd4MVxuICAgIGxldCB5MSA9IEZwLmNtb3YoeTEyLCB5MTEsIGUxKTsgLy8gIDIyLiAgeTEgPSBDTU9WKHkxMiwgeTExLCBlMSkgICMgSWYgZyh4MSkgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gICAgbGV0IHgybiA9IEZwLm11bCh4MW4sIHR2MSk7IC8vICAyMy4geDJuID0geDFuICogdHYxICAgICAgICMgeDIgPSB4Mm4gLyB4ZCA9IDIgKiB1XjIgKiB4MW4gLyB4ZFxuICAgIGxldCB5MjEgPSBGcC5tdWwoeTExLCB1KTsgLy8gIDI0LiB5MjEgPSB5MTEgKiB1XG4gICAgeTIxID0gRnAubXVsKHkyMSwgRUxMMl9DMik7IC8vICAyNS4geTIxID0geTIxICogYzJcbiAgICBsZXQgeTIyID0gRnAubXVsKHkyMSwgRUxMMl9DMyk7IC8vICAyNi4geTIyID0geTIxICogYzNcbiAgICBsZXQgZ3gyID0gRnAubXVsKGd4MSwgdHYxKTsgLy8gIDI3LiBneDIgPSBneDEgKiB0djEgICAgICAgIyBnKHgyKSA9IGd4MiAvIGd4ZCA9IDIgKiB1XjIgKiBnKHgxKVxuICAgIHR2MiA9IEZwLnNxcih5MjEpOyAvLyAgMjguIHR2MiA9IHkyMV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDI5LiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTIgPSBGcC5lcWwodHYyLCBneDIpOyAvLyAgMzAuICBlMiA9IHR2MiA9PSBneDJcbiAgICBsZXQgeTIgPSBGcC5jbW92KHkyMiwgeTIxLCBlMik7IC8vICAzMS4gIHkyID0gQ01PVih5MjIsIHkyMSwgZTIpICAjIElmIGcoeDIpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuICAgIHR2MiA9IEZwLnNxcih5MSk7IC8vICAzMi4gdHYyID0geTFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAzMy4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUzID0gRnAuZXFsKHR2MiwgZ3gxKTsgLy8gIDM0LiAgZTMgPSB0djIgPT0gZ3gxXG4gICAgbGV0IHhuID0gRnAuY21vdih4Mm4sIHgxbiwgZTMpOyAvLyAgMzUuICB4biA9IENNT1YoeDJuLCB4MW4sIGUzKSAgIyBJZiBlMywgeCA9IHgxLCBlbHNlIHggPSB4MlxuICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGUzKTsgLy8gIDM2LiAgIHkgPSBDTU9WKHkyLCB5MSwgZTMpICAgICMgSWYgZTMsIHkgPSB5MSwgZWxzZSB5ID0geTJcbiAgICBsZXQgZTQgPSBGcC5pc09kZCh5KTsgLy8gIDM3LiAgZTQgPSBzZ24wKHkpID09IDEgICAgICAgICMgRml4IHNpZ24gb2YgeVxuICAgIHkgPSBGcC5jbW92KHksIEZwLm5lZyh5KSwgZTMgIT09IGU0KTsgLy8gIDM4LiAgIHkgPSBDTU9WKHksIC15LCBlMyBYT1IgZTQpXG4gICAgcmV0dXJuIHsgeE1uOiB4biwgeE1kOiB4ZCwgeU1uOiB5LCB5TWQ6IF8xbiB9OyAvLyAgMzkuIHJldHVybiAoeG4sIHhkLCB5LCAxKVxufVxuY29uc3QgRUxMMl9DMV9FRFdBUkRTID0gRnBTcXJ0RXZlbihGcCwgRnAubmVnKEJpZ0ludCg0ODY2NjQpKSk7IC8vIHNnbjAoYzEpIE1VU1QgZXF1YWwgMFxuZnVuY3Rpb24gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfZWR3YXJkczI1NTE5KHUpIHtcbiAgICBjb25zdCB7IHhNbiwgeE1kLCB5TW4sIHlNZCB9ID0gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KTsgLy8gIDEuICAoeE1uLCB4TWQsIHlNbiwgeU1kKSA9XG4gICAgLy8gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KVxuICAgIGxldCB4biA9IEZwLm11bCh4TW4sIHlNZCk7IC8vICAyLiAgeG4gPSB4TW4gKiB5TWRcbiAgICB4biA9IEZwLm11bCh4biwgRUxMMl9DMV9FRFdBUkRTKTsgLy8gIDMuICB4biA9IHhuICogYzFcbiAgICBsZXQgeGQgPSBGcC5tdWwoeE1kLCB5TW4pOyAvLyAgNC4gIHhkID0geE1kICogeU1uICAgICMgeG4gLyB4ZCA9IGMxICogeE0gLyB5TVxuICAgIGxldCB5biA9IEZwLnN1Yih4TW4sIHhNZCk7IC8vICA1LiAgeW4gPSB4TW4gLSB4TWRcbiAgICBsZXQgeWQgPSBGcC5hZGQoeE1uLCB4TWQpOyAvLyAgNi4gIHlkID0geE1uICsgeE1kICAgICMgKG4gLyBkIC0gMSkgLyAobiAvIGQgKyAxKSA9IChuIC0gZCkgLyAobiArIGQpXG4gICAgbGV0IHR2MSA9IEZwLm11bCh4ZCwgeWQpOyAvLyAgNy4gdHYxID0geGQgKiB5ZFxuICAgIGxldCBlID0gRnAuZXFsKHR2MSwgRnAuWkVSTyk7IC8vICA4LiAgIGUgPSB0djEgPT0gMFxuICAgIHhuID0gRnAuY21vdih4biwgRnAuWkVSTywgZSk7IC8vICA5LiAgeG4gPSBDTU9WKHhuLCAwLCBlKVxuICAgIHhkID0gRnAuY21vdih4ZCwgRnAuT05FLCBlKTsgLy8gIDEwLiB4ZCA9IENNT1YoeGQsIDEsIGUpXG4gICAgeW4gPSBGcC5jbW92KHluLCBGcC5PTkUsIGUpOyAvLyAgMTEuIHluID0gQ01PVih5biwgMSwgZSlcbiAgICB5ZCA9IEZwLmNtb3YoeWQsIEZwLk9ORSwgZSk7IC8vICAxMi4geWQgPSBDTU9WKHlkLCAxLCBlKVxuICAgIGNvbnN0IGludiA9IEZwLmludmVydEJhdGNoKFt4ZCwgeWRdKTsgLy8gYmF0Y2ggZGl2aXNpb25cbiAgICByZXR1cm4geyB4OiBGcC5tdWwoeG4sIGludlswXSksIHk6IEZwLm11bCh5biwgaW52WzFdKSB9OyAvLyAgMTMuIHJldHVybiAoeG4sIHhkLCB5biwgeWQpXG59XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihlZDI1NTE5LkV4dGVuZGVkUG9pbnQsIChzY2FsYXJzKSA9PiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkoc2NhbGFyc1swXSksIHtcbiAgICBEU1Q6ICdlZHdhcmRzMjU1MTlfWE1EOlNIQS01MTJfRUxMMl9ST18nLFxuICAgIGVuY29kZURTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX05VXycsXG4gICAgcDogRnAuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGE1MTIsXG59KSkoKTtcbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuZnVuY3Rpb24gYXNzZXJ0UnN0UG9pbnQob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJpc3RQb2ludCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmlzdHJldHRvUG9pbnQgZXhwZWN0ZWQnKTtcbn1cbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IFNRUlRfTTEgPSBFRDI1NTE5X1NRUlRfTTE7XG4vLyDiiJooYWQgLSAxKVxuY29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSBCaWdJbnQoJzI1MDYzMDY4OTUzMzg0NjIzNDc0MTExNDE0MTU4NzAyMTUyNzAxMjQ0NTMxNTAyNDkyNjU2NDYwMDc5MjEwNDgyNjEwNDMwNzUwMjM1Jyk7XG4vLyAxIC8g4oiaKGEtZClcbmNvbnN0IElOVlNRUlRfQV9NSU5VU19EID0gQmlnSW50KCc1NDQ2OTMwNzAwODkwOTMxNjkyMDk5NTgxMzg2ODc0NTE0MTYwNTM5MzU5NzI5MjkyNzQ1NjkyMTIwNTMxMjg5NjMxMTcyMTAxNzU3OCcpO1xuLy8gMS1kwrJcbmNvbnN0IE9ORV9NSU5VU19EX1NRID0gQmlnSW50KCcxMTU5ODQzMDIxNjY4Nzc5ODc5MTkzNzc1NTIxODU1NTg2NjQ3OTM3MzU3NzU5NzE1NDE3NjU0NDM5ODc5NzIwODc2MTExODA2ODM4Jyk7XG4vLyAoZC0xKcKyXG5jb25zdCBEX01JTlVTX09ORV9TUSA9IEJpZ0ludCgnNDA0NDA4MzQzNDYzMDg1MzY4NTgxMDEwNDI0NjkzMjMxOTA4MjYyNDgzOTkxNDYyMzg3MDgzNTIyNDAxMzMyMjA4NjUxMzcyNjU5NTInKTtcbi8vIENhbGN1bGF0ZXMgMS/iiJoobnVtYmVyKVxuY29uc3QgaW52ZXJ0U3FydCA9IChudW1iZXIpID0+IHV2UmF0aW8oXzFuLCBudW1iZXIpO1xuY29uc3QgTUFYXzI1NUIgPSBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpO1xuY29uc3QgYnl0ZXMyNTVUb051bWJlckxFID0gKGJ5dGVzKSA9PiBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZShieXRlc1RvTnVtYmVyTEUoYnl0ZXMpICYgTUFYXzI1NUIpO1xuLy8gQ29tcHV0ZXMgRWxsaWdhdG9yIG1hcCBmb3IgUmlzdHJldHRvXG4vLyBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbGxpZ2F0b3IuaHRtbFxuZnVuY3Rpb24gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMCkge1xuICAgIGNvbnN0IHsgZCB9ID0gZWQyNTUxOS5DVVJWRTtcbiAgICBjb25zdCBQID0gZWQyNTUxOS5DVVJWRS5GcC5PUkRFUjtcbiAgICBjb25zdCBtb2QgPSBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcbiAgICBjb25zdCByID0gbW9kKFNRUlRfTTEgKiByMCAqIHIwKTsgLy8gMVxuICAgIGNvbnN0IE5zID0gbW9kKChyICsgXzFuKSAqIE9ORV9NSU5VU19EX1NRKTsgLy8gMlxuICAgIGxldCBjID0gQmlnSW50KC0xKTsgLy8gM1xuICAgIGNvbnN0IEQgPSBtb2QoKGMgLSBkICogcikgKiBtb2QociArIGQpKTsgLy8gNFxuICAgIGxldCB7IGlzVmFsaWQ6IE5zX0RfaXNfc3EsIHZhbHVlOiBzIH0gPSB1dlJhdGlvKE5zLCBEKTsgLy8gNVxuICAgIGxldCBzXyA9IG1vZChzICogcjApOyAvLyA2XG4gICAgaWYgKCFpc05lZ2F0aXZlTEUoc18sIFApKVxuICAgICAgICBzXyA9IG1vZCgtc18pO1xuICAgIGlmICghTnNfRF9pc19zcSlcbiAgICAgICAgcyA9IHNfOyAvLyA3XG4gICAgaWYgKCFOc19EX2lzX3NxKVxuICAgICAgICBjID0gcjsgLy8gOFxuICAgIGNvbnN0IE50ID0gbW9kKGMgKiAociAtIF8xbikgKiBEX01JTlVTX09ORV9TUSAtIEQpOyAvLyA5XG4gICAgY29uc3QgczIgPSBzICogcztcbiAgICBjb25zdCBXMCA9IG1vZCgocyArIHMpICogRCk7IC8vIDEwXG4gICAgY29uc3QgVzEgPSBtb2QoTnQgKiBTUVJUX0FEX01JTlVTX09ORSk7IC8vIDExXG4gICAgY29uc3QgVzIgPSBtb2QoXzFuIC0gczIpOyAvLyAxMlxuICAgIGNvbnN0IFczID0gbW9kKF8xbiArIHMyKTsgLy8gMTNcbiAgICByZXR1cm4gbmV3IGVkMjU1MTkuRXh0ZW5kZWRQb2ludChtb2QoVzAgKiBXMyksIG1vZChXMiAqIFcxKSwgbW9kKFcxICogVzMpLCBtb2QoVzAgKiBXMikpO1xufVxuLyoqXG4gKiBFYWNoIGVkMjU1MTkvRXh0ZW5kZWRQb2ludCBoYXMgOCBkaWZmZXJlbnQgZXF1aXZhbGVudCBwb2ludHMuIFRoaXMgY2FuIGJlXG4gKiBhIHNvdXJjZSBvZiBidWdzIGZvciBwcm90b2NvbHMgbGlrZSByaW5nIHNpZ25hdHVyZXMuIFJpc3RyZXR0byB3YXMgY3JlYXRlZCB0byBzb2x2ZSB0aGlzLlxuICogUmlzdHJldHRvIHBvaW50IG9wZXJhdGVzIGluIFg6WTpaOlQgZXh0ZW5kZWQgY29vcmRpbmF0ZXMgbGlrZSBFeHRlbmRlZFBvaW50LFxuICogYnV0IGl0IHNob3VsZCB3b3JrIGluIGl0cyBvd24gbmFtZXNwYWNlOiBkbyBub3QgY29tYmluZSB0aG9zZSB0d28uXG4gKiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1yaXN0cmV0dG8yNTUtZGVjYWY0NDhcbiAqL1xuY2xhc3MgUmlzdFBvaW50IHtcbiAgICAvLyBQcml2YXRlIHByb3BlcnR5IHRvIGRpc2NvdXJhZ2UgY29tYmluaW5nIEV4dGVuZGVkUG9pbnQgKyBSaXN0cmV0dG9Qb2ludFxuICAgIC8vIEFsd2F5cyB1c2UgUmlzdHJldHRvIGVuY29kaW5nL2RlY29kaW5nIGluc3RlYWQuXG4gICAgY29uc3RydWN0b3IoZXApIHtcbiAgICAgICAgdGhpcy5lcCA9IGVwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFmZmluZShhcCkge1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludChlZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUFmZmluZShhcCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyB1bmlmb3JtIG91dHB1dCBvZiA2NC1ieXRlIGhhc2ggZnVuY3Rpb24gbGlrZSBzaGE1MTIgYW5kIGNvbnZlcnRzIGl0IHRvIGBSaXN0cmV0dG9Qb2ludGAuXG4gICAgICogVGhlIGhhc2gtdG8tZ3JvdXAgb3BlcmF0aW9uIGFwcGxpZXMgRWxsaWdhdG9yIHR3aWNlIGFuZCBhZGRzIHRoZSByZXN1bHRzLlxuICAgICAqICoqTm90ZToqKiB0aGlzIGlzIG9uZS13YXkgbWFwLCB0aGVyZSBpcyBubyBjb252ZXJzaW9uIGZyb20gcG9pbnQgdG8gaGFzaC5cbiAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbGxpZ2F0b3IuaHRtbFxuICAgICAqIEBwYXJhbSBoZXggNjQtYnl0ZSBvdXRwdXQgb2YgYSBoYXNoIGZ1bmN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hUb0N1cnZlKGhleCkge1xuICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygncmlzdHJldHRvSGFzaCcsIGhleCwgNjQpO1xuICAgICAgICBjb25zdCByMSA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXguc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgY29uc3QgUjEgPSBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIxKTtcbiAgICAgICAgY29uc3QgcjIgPSBieXRlczI1NVRvTnVtYmVyTEUoaGV4LnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICBjb25zdCBSMiA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjIpO1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludChSMS5hZGQoUjIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgcmlzdHJldHRvLWVuY29kZWQgc3RyaW5nIHRvIHJpc3RyZXR0byBwb2ludC5cbiAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9kZWNvZGluZy5odG1sXG4gICAgICogQHBhcmFtIGhleCBSaXN0cmV0dG8tZW5jb2RlZCAzMiBieXRlcy4gTm90IGV2ZXJ5IDMyLWJ5dGUgc3RyaW5nIGlzIHZhbGlkIHJpc3RyZXR0byBlbmNvZGluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygncmlzdHJldHRvSGV4JywgaGV4LCAzMik7XG4gICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gZWQyNTUxOS5DVVJWRTtcbiAgICAgICAgY29uc3QgUCA9IGVkMjU1MTkuQ1VSVkUuRnAuT1JERVI7XG4gICAgICAgIGNvbnN0IG1vZCA9IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgICAgICBjb25zdCBlbXNnID0gJ1Jpc3RyZXR0b1BvaW50LmZyb21IZXg6IHRoZSBoZXggaXMgbm90IHZhbGlkIGVuY29kaW5nIG9mIFJpc3RyZXR0b1BvaW50JztcbiAgICAgICAgY29uc3QgcyA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXgpO1xuICAgICAgICAvLyAxLiBDaGVjayB0aGF0IHNfYnl0ZXMgaXMgdGhlIGNhbm9uaWNhbCBlbmNvZGluZyBvZiBhIGZpZWxkIGVsZW1lbnQsIG9yIGVsc2UgYWJvcnQuXG4gICAgICAgIC8vIDMuIENoZWNrIHRoYXQgcyBpcyBub24tbmVnYXRpdmUsIG9yIGVsc2UgYWJvcnRcbiAgICAgICAgaWYgKCFlcXVhbEJ5dGVzKG51bWJlclRvQnl0ZXNMRShzLCAzMiksIGhleCkgfHwgaXNOZWdhdGl2ZUxFKHMsIFApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVtc2cpO1xuICAgICAgICBjb25zdCBzMiA9IG1vZChzICogcyk7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKF8xbiArIGEgKiBzMik7IC8vIDQgKGEgaXMgLTEpXG4gICAgICAgIGNvbnN0IHUyID0gbW9kKF8xbiAtIGEgKiBzMik7IC8vIDVcbiAgICAgICAgY29uc3QgdTFfMiA9IG1vZCh1MSAqIHUxKTtcbiAgICAgICAgY29uc3QgdTJfMiA9IG1vZCh1MiAqIHUyKTtcbiAgICAgICAgY29uc3QgdiA9IG1vZChhICogZCAqIHUxXzIgLSB1Ml8yKTsgLy8gNlxuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlOiBJIH0gPSBpbnZlcnRTcXJ0KG1vZCh2ICogdTJfMikpOyAvLyA3XG4gICAgICAgIGNvbnN0IER4ID0gbW9kKEkgKiB1Mik7IC8vIDhcbiAgICAgICAgY29uc3QgRHkgPSBtb2QoSSAqIER4ICogdik7IC8vIDlcbiAgICAgICAgbGV0IHggPSBtb2QoKHMgKyBzKSAqIER4KTsgLy8gMTBcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRSh4LCBQKSlcbiAgICAgICAgICAgIHggPSBtb2QoLXgpOyAvLyAxMFxuICAgICAgICBjb25zdCB5ID0gbW9kKHUxICogRHkpOyAvLyAxMVxuICAgICAgICBjb25zdCB0ID0gbW9kKHggKiB5KTsgLy8gMTJcbiAgICAgICAgaWYgKCFpc1ZhbGlkIHx8IGlzTmVnYXRpdmVMRSh0LCBQKSB8fCB5ID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZW1zZyk7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KG5ldyBlZDI1NTE5LkV4dGVuZGVkUG9pbnQoeCwgeSwgXzFuLCB0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgcmlzdHJldHRvIHBvaW50IHRvIFVpbnQ4QXJyYXkuXG4gICAgICogaHR0cHM6Ly9yaXN0cmV0dG8uZ3JvdXAvZm9ybXVsYXMvZW5jb2RpbmcuaHRtbFxuICAgICAqL1xuICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgIGxldCB7IGV4OiB4LCBleTogeSwgZXo6IHosIGV0OiB0IH0gPSB0aGlzLmVwO1xuICAgICAgICBjb25zdCBQID0gZWQyNTUxOS5DVVJWRS5GcC5PUkRFUjtcbiAgICAgICAgY29uc3QgbW9kID0gZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGU7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKG1vZCh6ICsgeSkgKiBtb2QoeiAtIHkpKTsgLy8gMVxuICAgICAgICBjb25zdCB1MiA9IG1vZCh4ICogeSk7IC8vIDJcbiAgICAgICAgLy8gU3F1YXJlIHJvb3QgYWx3YXlzIGV4aXN0c1xuICAgICAgICBjb25zdCB1MnNxID0gbW9kKHUyICogdTIpO1xuICAgICAgICBjb25zdCB7IHZhbHVlOiBpbnZzcXJ0IH0gPSBpbnZlcnRTcXJ0KG1vZCh1MSAqIHUyc3EpKTsgLy8gM1xuICAgICAgICBjb25zdCBEMSA9IG1vZChpbnZzcXJ0ICogdTEpOyAvLyA0XG4gICAgICAgIGNvbnN0IEQyID0gbW9kKGludnNxcnQgKiB1Mik7IC8vIDVcbiAgICAgICAgY29uc3QgekludiA9IG1vZChEMSAqIEQyICogdCk7IC8vIDZcbiAgICAgICAgbGV0IEQ7IC8vIDdcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRSh0ICogekludiwgUCkpIHtcbiAgICAgICAgICAgIGxldCBfeCA9IG1vZCh5ICogU1FSVF9NMSk7XG4gICAgICAgICAgICBsZXQgX3kgPSBtb2QoeCAqIFNRUlRfTTEpO1xuICAgICAgICAgICAgeCA9IF94O1xuICAgICAgICAgICAgeSA9IF95O1xuICAgICAgICAgICAgRCA9IG1vZChEMSAqIElOVlNRUlRfQV9NSU5VU19EKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEQgPSBEMjsgLy8gOFxuICAgICAgICB9XG4gICAgICAgIGlmIChpc05lZ2F0aXZlTEUoeCAqIHpJbnYsIFApKVxuICAgICAgICAgICAgeSA9IG1vZCgteSk7IC8vIDlcbiAgICAgICAgbGV0IHMgPSBtb2QoKHogLSB5KSAqIEQpOyAvLyAxMCAoY2hlY2sgZm9vdGVyJ3Mgbm90ZSwgbm8gc3FydCgtYSkpXG4gICAgICAgIGlmIChpc05lZ2F0aXZlTEUocywgUCkpXG4gICAgICAgICAgICBzID0gbW9kKC1zKTtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXNMRShzLCAzMik7IC8vIDExXG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICAgIH1cbiAgICAvLyBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEgfSA9IHRoaXMuZXA7XG4gICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIgfSA9IG90aGVyLmVwO1xuICAgICAgICBjb25zdCBtb2QgPSBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcbiAgICAgICAgLy8gKHgxICogeTIgPT0geTEgKiB4MikgfCAoeTEgKiB5MiA9PSB4MSAqIHgyKVxuICAgICAgICBjb25zdCBvbmUgPSBtb2QoWDEgKiBZMikgPT09IG1vZChZMSAqIFgyKTtcbiAgICAgICAgY29uc3QgdHdvID0gbW9kKFkxICogWTIpID09PSBtb2QoWDEgKiBYMik7XG4gICAgICAgIHJldHVybiBvbmUgfHwgdHdvO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0UnN0UG9pbnQob3RoZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludCh0aGlzLmVwLmFkZChvdGhlci5lcCkpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAuc3VidHJhY3Qob3RoZXIuZXApKTtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAubXVsdGlwbHkoc2NhbGFyKSk7XG4gICAgfVxuICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludCh0aGlzLmVwLm11bHRpcGx5VW5zYWZlKHNjYWxhcikpO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAuZG91YmxlKCkpO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAubmVnYXRlKCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBSaXN0cmV0dG9Qb2ludCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGlmICghUmlzdFBvaW50LkJBU0UpXG4gICAgICAgIFJpc3RQb2ludC5CQVNFID0gbmV3IFJpc3RQb2ludChlZDI1NTE5LkV4dGVuZGVkUG9pbnQuQkFTRSk7XG4gICAgaWYgKCFSaXN0UG9pbnQuWkVSTylcbiAgICAgICAgUmlzdFBvaW50LlpFUk8gPSBuZXcgUmlzdFBvaW50KGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5aRVJPKTtcbiAgICByZXR1cm4gUmlzdFBvaW50O1xufSkoKTtcbi8vIEhhc2hpbmcgdG8gcmlzdHJldHRvMjU1LiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNhcHBlbmRpeC1CXG5leHBvcnQgY29uc3QgaGFzaFRvUmlzdHJldHRvMjU1ID0gKG1zZywgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGQgPSBvcHRpb25zLkRTVDtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhkKSA6IGQ7XG4gICAgY29uc3QgdW5pZm9ybV9ieXRlcyA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgNjQsIHNoYTUxMik7XG4gICAgY29uc3QgUCA9IFJpc3RQb2ludC5oYXNoVG9DdXJ2ZSh1bmlmb3JtX2J5dGVzKTtcbiAgICByZXR1cm4gUDtcbn07XG5leHBvcnQgY29uc3QgaGFzaF90b19yaXN0cmV0dG8yNTUgPSBoYXNoVG9SaXN0cmV0dG8yNTU7IC8vIGxlZ2FjeVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWQyNTUxOS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/curves/esm/ed25519.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/hashes/esm/_assert.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/@noble/hashes/esm/_assert.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: function() { return /* binding */ bool; },\n/* harmony export */   bytes: function() { return /* binding */ bytes; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   output: function() { return /* binding */ output; }\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ __webpack_exports__[\"default\"] = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVEsa0JBQWtCLFNBQVM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixJQUFJO0FBQ3JGO0FBQ0E7QUFDcUQ7QUFDckQsaUJBQWlCO0FBQ2pCLCtEQUFlLE1BQU0sRUFBQztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/MGE0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbi8vIGNvcGllZCBmcm9tIHV0aWxzXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/hashes/esm/_sha2.js":
/*!********************************************************!*\
  !*** ../../../node_modules/@noble/hashes/esm/_sha2.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: function() { return /* binding */ SHA2; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"../../../node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"../../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzPzhiYTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhpc3RzLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5leHBvcnQgY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/hashes/esm/_u64.js":
/*!*******************************************************!*\
  !*** ../../../node_modules/@noble/hashes/esm/_u64.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   add3H: function() { return /* binding */ add3H; },\n/* harmony export */   add3L: function() { return /* binding */ add3L; },\n/* harmony export */   add4H: function() { return /* binding */ add4H; },\n/* harmony export */   add4L: function() { return /* binding */ add4L; },\n/* harmony export */   add5H: function() { return /* binding */ add5H; },\n/* harmony export */   add5L: function() { return /* binding */ add5L; },\n/* harmony export */   fromBig: function() { return /* binding */ fromBig; },\n/* harmony export */   rotlBH: function() { return /* binding */ rotlBH; },\n/* harmony export */   rotlBL: function() { return /* binding */ rotlBL; },\n/* harmony export */   rotlSH: function() { return /* binding */ rotlSH; },\n/* harmony export */   rotlSL: function() { return /* binding */ rotlSL; },\n/* harmony export */   rotr32H: function() { return /* binding */ rotr32H; },\n/* harmony export */   rotr32L: function() { return /* binding */ rotr32L; },\n/* harmony export */   rotrBH: function() { return /* binding */ rotrBH; },\n/* harmony export */   rotrBL: function() { return /* binding */ rotrBL; },\n/* harmony export */   rotrSH: function() { return /* binding */ rotrSH; },\n/* harmony export */   rotrSL: function() { return /* binding */ rotrSL; },\n/* harmony export */   shrSH: function() { return /* binding */ shrSH; },\n/* harmony export */   shrSL: function() { return /* binding */ shrSL; },\n/* harmony export */   split: function() { return /* binding */ split; },\n/* harmony export */   toBig: function() { return /* binding */ toBig; }\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lMO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUFlLEdBQUcsRUFBQztBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanM/ODYyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/hashes/esm/crypto.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/@noble/hashes/esm/crypto.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: function() { return /* binding */ crypto; }\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcz9hYTdhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/hashes/esm/sha256.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/@noble/hashes/esm/sha256.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: function() { return /* binding */ sha224; },\n/* harmony export */   sha256: function() { return /* binding */ sha256; }\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"../../../node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"../../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ2lCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0EsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDOUMsK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzP2MzNzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEyLTI1NiBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMgdG8gZXhlY3V0ZSBiaXJ0aGRheSBhdHRhY2suXG4vLyBCVEMgbmV0d29yayBpcyBkb2luZyAyXjY3IGhhc2hlcy9zZWMgYXMgcGVyIGVhcmx5IDIwMjMuXG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/hashes/esm/sha512.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/@noble/hashes/esm/sha512.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: function() { return /* binding */ SHA512; },\n/* harmony export */   sha384: function() { return /* binding */ sha384; },\n/* harmony export */   sha512: function() { return /* binding */ sha512; },\n/* harmony export */   sha512_224: function() { return /* binding */ sha512_224; },\n/* harmony export */   sha512_256: function() { return /* binding */ sha512_256; }\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ \"../../../node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"../../../node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"../../../node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTUxMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFrQztBQUNOO0FBQ2lCO0FBQzdDO0FBQ0E7QUFDQSxzREFBc0QscURBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLDBDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlFQUFpRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFVLGtCQUFrQixzREFBVSxrQkFBa0IscURBQVM7QUFDekYsd0JBQXdCLHNEQUFVLGtCQUFrQixzREFBVSxrQkFBa0IscURBQVM7QUFDekY7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFVLGlCQUFpQixzREFBVSxpQkFBaUIscURBQVM7QUFDdkYsd0JBQXdCLHNEQUFVLGlCQUFpQixzREFBVSxpQkFBaUIscURBQVM7QUFDdkY7QUFDQSx5QkFBeUIscURBQVM7QUFDbEMseUJBQXlCLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUVBQWlFO0FBQy9FO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBUztBQUNsQyx3QkFBd0IscURBQVM7QUFDakM7QUFDQTtBQUNBLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEYsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlLEVBQUUsbURBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFTO0FBQ2pDLGlCQUFpQixxREFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQyxXQUFXLGVBQWUsRUFBRSxtREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLG1DQUFtQywwREFBZTtBQUNsRCxtQ0FBbUMsMERBQWU7QUFDbEQsK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzPzUyYzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHU2NCBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBSb3VuZCBjb250YW50cyAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFtTSEE1MTJfS2gsIFNIQTUxMl9LbF0gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmV4cG9ydCBjbGFzcyBTSEE1MTIgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMTI4LCA2NCwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZSB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIEFsc28gbG9va3MgY2xlYW5lciBhbmQgZWFzaWVyIHRvIHZlcmlmeSB3aXRoIHNwZWMuXG4gICAgICAgIC8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg2YTA5ZTY2NyB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGYzYmNjOTA4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4YmI2N2FlODUgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4NGNhYTczYiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDNjNmVmMzcyIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4ZmU5NGY4MmIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHhhNTRmZjUzYSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDVmMWQzNmYxIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NTEwZTUyN2YgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhZGU2ODJkMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDliMDU2ODhjIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MmIzZTZjMWYgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgxZjgzZDlhYiB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweGZiNDFiZDZiIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NWJlMGNkMTkgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHgxMzdlMjE3OSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEE1MTJfV19ILmZpbGwoMCk7XG4gICAgICAgIFNIQTUxMl9XX0wuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDhjM2QzN2M4IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4MTk1NDRkYTIgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg3M2UxOTk2NiB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg5ZGNkNGQ2IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MWRmYWI3YWUgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMmZmOWM4MiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDY3OWRkNTE0IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTgyZjlmY2YgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHgwZjZkMmI2OSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweDdiZDQ0ZGE4IHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4NzdlMzZmNzMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgwNGM0ODk0MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDNmOWQ4NWE4IHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NmExZDM2YzggfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgxMTEyZTZhZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDkxZDY5MmExIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4MjIzMTIxOTQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmYzJiZjcyYyB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDlmNTU1ZmEzIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4Yzg0YzY0YzIgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgyMzkzYjg2YiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDZmNTNiMTUxIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4OTYzODc3MTkgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1OTQwZWFiZCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDk2MjgzZWUyIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YTg4ZWZmZTMgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHhiZTVlMWUyNSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDUzODYzOTkyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MmIwMTk5ZmMgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHgyYzg1YjhhYSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDBlYjcyZGRjIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4ODFjNTJjYTIgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDMyO1xuICAgIH1cbn1cbmNsYXNzIFNIQTM4NCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweGNiYmI5ZDVkIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg2MjlhMjkyYSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4OTE1OTAxNWEgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDE1MmZlY2Q4IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg2NzMzMjY2NyB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OGViNDRhODcgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweGRiMGMyZTBkIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg0N2I1NDgxZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSA0ODtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2hhNTEyID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBNTEyKCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTM4NCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTUxMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/hashes/esm/sha512.js\n"));

/***/ }),

/***/ "../../../node_modules/@noble/hashes/esm/utils.js":
/*!********************************************************!*\
  !*** ../../../node_modules/@noble/hashes/esm/utils.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: function() { return /* binding */ Hash; },\n/* harmony export */   asyncLoop: function() { return /* binding */ asyncLoop; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   checkOpts: function() { return /* binding */ checkOpts; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createView: function() { return /* binding */ createView; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   isLE: function() { return /* binding */ isLE; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; },\n/* harmony export */   rotr: function() { return /* binding */ rotr; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   u32: function() { return /* binding */ u32; },\n/* harmony export */   u8: function() { return /* binding */ u8; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   wrapConstructor: function() { return /* binding */ wrapConstructor; },\n/* harmony export */   wrapConstructorWithOpts: function() { return /* binding */ wrapConstructorWithOpts; },\n/* harmony export */   wrapXOFConstructorWithOpts: function() { return /* binding */ wrapXOFConstructorWithOpts; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"../../../node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzP2MxM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkICgyMDI1LTA0LTMwKSwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbi8vIE90aGVyIGxpYnJhcmllcyB3b3VsZCBzaWxlbnRseSBjb3JydXB0IHRoZSBkYXRhIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3IsXG4vLyB3aGVuIHRoZXkgZG9uJ3Qgc3VwcG9ydCBpdC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGlmICghaXNCeXRlcyhhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "../../../node_modules/idb/build/index.js":
/*!************************************************!*\
  !*** ../../../node_modules/idb/build/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDB: function() { return /* binding */ deleteDB; },\n/* harmony export */   openDB: function() { return /* binding */ openDB; },\n/* harmony export */   unwrap: function() { return /* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.u; },\n/* harmony export */   wrap: function() { return /* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w; }\n/* harmony export */ });\n/* harmony import */ var _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap-idb-value.js */ \"../../../node_modules/idb/build/wrap-idb-value.js\");\n\n\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade((0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.result), event.oldVersion, event.newVersion, (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\n(0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.r)((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lkYi9idWlsZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRTtBQUNOOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5Q0FBeUMsSUFBSTtBQUM5RTtBQUNBLHdCQUF3QixxREFBSTtBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFJLHNEQUFzRCxxREFBSTtBQUNsRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVUsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFJO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUUyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lkYi9idWlsZC9pbmRleC5qcz9lZWMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHcgYXMgd3JhcCwgciBhcyByZXBsYWNlVHJhcHMgfSBmcm9tICcuL3dyYXAtaWRiLXZhbHVlLmpzJztcbmV4cG9ydCB7IHUgYXMgdW53cmFwLCB3IGFzIHdyYXAgfSBmcm9tICcuL3dyYXAtaWRiLXZhbHVlLmpzJztcblxuLyoqXG4gKiBPcGVuIGEgZGF0YWJhc2UuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgZGF0YWJhc2UuXG4gKiBAcGFyYW0gdmVyc2lvbiBTY2hlbWEgdmVyc2lvbi5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQWRkaXRpb25hbCBjYWxsYmFja3MuXG4gKi9cbmZ1bmN0aW9uIG9wZW5EQihuYW1lLCB2ZXJzaW9uLCB7IGJsb2NrZWQsIHVwZ3JhZGUsIGJsb2NraW5nLCB0ZXJtaW5hdGVkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihuYW1lLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBvcGVuUHJvbWlzZSA9IHdyYXAocmVxdWVzdCk7XG4gICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCd1cGdyYWRlbmVlZGVkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB1cGdyYWRlKHdyYXAocmVxdWVzdC5yZXN1bHQpLCBldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCB3cmFwKHJlcXVlc3QudHJhbnNhY3Rpb24pLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlZCkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoZXZlbnQpID0+IGJsb2NrZWQoXG4gICAgICAgIC8vIENhc3RpbmcgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC1ET00tbGliLWdlbmVyYXRvci9wdWxsLzE0MDVcbiAgICAgICAgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQubmV3VmVyc2lvbiwgZXZlbnQpKTtcbiAgICB9XG4gICAgb3BlblByb21pc2VcbiAgICAgICAgLnRoZW4oKGRiKSA9PiB7XG4gICAgICAgIGlmICh0ZXJtaW5hdGVkKVxuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiB0ZXJtaW5hdGVkKCkpO1xuICAgICAgICBpZiAoYmxvY2tpbmcpIHtcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ3ZlcnNpb25jaGFuZ2UnLCAoZXZlbnQpID0+IGJsb2NraW5nKGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIGV2ZW50KSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICByZXR1cm4gb3BlblByb21pc2U7XG59XG4vKipcbiAqIERlbGV0ZSBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICovXG5mdW5jdGlvbiBkZWxldGVEQihuYW1lLCB7IGJsb2NrZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShuYW1lKTtcbiAgICBpZiAoYmxvY2tlZCkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoZXZlbnQpID0+IGJsb2NrZWQoXG4gICAgICAgIC8vIENhc3RpbmcgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC1ET00tbGliLWdlbmVyYXRvci9wdWxsLzE0MDVcbiAgICAgICAgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXAocmVxdWVzdCkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xufVxuXG5jb25zdCByZWFkTWV0aG9kcyA9IFsnZ2V0JywgJ2dldEtleScsICdnZXRBbGwnLCAnZ2V0QWxsS2V5cycsICdjb3VudCddO1xuY29uc3Qgd3JpdGVNZXRob2RzID0gWydwdXQnLCAnYWRkJywgJ2RlbGV0ZScsICdjbGVhciddO1xuY29uc3QgY2FjaGVkTWV0aG9kcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHtcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBJREJEYXRhYmFzZSAmJlxuICAgICAgICAhKHByb3AgaW4gdGFyZ2V0KSAmJlxuICAgICAgICB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApKVxuICAgICAgICByZXR1cm4gY2FjaGVkTWV0aG9kcy5nZXQocHJvcCk7XG4gICAgY29uc3QgdGFyZ2V0RnVuY05hbWUgPSBwcm9wLnJlcGxhY2UoL0Zyb21JbmRleCQvLCAnJyk7XG4gICAgY29uc3QgdXNlSW5kZXggPSBwcm9wICE9PSB0YXJnZXRGdW5jTmFtZTtcbiAgICBjb25zdCBpc1dyaXRlID0gd3JpdGVNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKTtcbiAgICBpZiAoXG4gICAgLy8gQmFpbCBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHRhcmdldC4gRWcsIGdldEFsbCBpc24ndCBpbiBFZGdlLlxuICAgICEodGFyZ2V0RnVuY05hbWUgaW4gKHVzZUluZGV4ID8gSURCSW5kZXggOiBJREJPYmplY3RTdG9yZSkucHJvdG90eXBlKSB8fFxuICAgICAgICAhKGlzV3JpdGUgfHwgcmVhZE1ldGhvZHMuaW5jbHVkZXModGFyZ2V0RnVuY05hbWUpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIGZ1bmN0aW9uIChzdG9yZU5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gaXNXcml0ZSA/ICdyZWFkd3JpdGUnIDogdW5kZWZpbmVkIGd6aXBwcyBiZXR0ZXIsIGJ1dCBmYWlscyBpbiBFZGdlIDooXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2FjdGlvbihzdG9yZU5hbWUsIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6ICdyZWFkb25seScpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdHguc3RvcmU7XG4gICAgICAgIGlmICh1c2VJbmRleClcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5pbmRleChhcmdzLnNoaWZ0KCkpO1xuICAgICAgICAvLyBNdXN0IHJlamVjdCBpZiBvcCByZWplY3RzLlxuICAgICAgICAvLyBJZiBpdCdzIGEgd3JpdGUgb3BlcmF0aW9uLCBtdXN0IHJlamVjdCBpZiB0eC5kb25lIHJlamVjdHMuXG4gICAgICAgIC8vIE11c3QgcmVqZWN0IHdpdGggb3AgcmVqZWN0aW9uIGZpcnN0LlxuICAgICAgICAvLyBNdXN0IHJlc29sdmUgd2l0aCBvcCB2YWx1ZS5cbiAgICAgICAgLy8gTXVzdCBoYW5kbGUgYm90aCBwcm9taXNlcyAobm8gdW5oYW5kbGVkIHJlamVjdGlvbnMpXG4gICAgICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGFyZ2V0W3RhcmdldEZ1bmNOYW1lXSguLi5hcmdzKSxcbiAgICAgICAgICAgIGlzV3JpdGUgJiYgdHguZG9uZSxcbiAgICAgICAgXSkpWzBdO1xuICAgIH07XG4gICAgY2FjaGVkTWV0aG9kcy5zZXQocHJvcCwgbWV0aG9kKTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxucmVwbGFjZVRyYXBzKChvbGRUcmFwcykgPT4gKHtcbiAgICAuLi5vbGRUcmFwcyxcbiAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlciksXG4gICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiAhIWdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHx8IG9sZFRyYXBzLmhhcyh0YXJnZXQsIHByb3ApLFxufSkpO1xuXG5leHBvcnQgeyBkZWxldGVEQiwgb3BlbkRCIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/idb/build/index.js\n"));

/***/ }),

/***/ "../../../node_modules/idb/build/wrap-idb-value.js":
/*!*********************************************************!*\
  !*** ../../../node_modules/idb/build/wrap-idb-value.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ reverseTransformCache; },\n/* harmony export */   i: function() { return /* binding */ instanceOfAny; },\n/* harmony export */   r: function() { return /* binding */ replaceTraps; },\n/* harmony export */   u: function() { return /* binding */ unwrap; },\n/* harmony export */   w: function() { return /* binding */ wrap; }\n/* harmony export */ });\nconst instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lkYi9idWlsZC93cmFwLWlkYi12YWx1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL3dyYXAtaWRiLXZhbHVlLmpzPzkzNWUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaW5zdGFuY2VPZkFueSA9IChvYmplY3QsIGNvbnN0cnVjdG9ycykgPT4gY29uc3RydWN0b3JzLnNvbWUoKGMpID0+IG9iamVjdCBpbnN0YW5jZW9mIGMpO1xuXG5sZXQgaWRiUHJveHlhYmxlVHlwZXM7XG5sZXQgY3Vyc29yQWR2YW5jZU1ldGhvZHM7XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldElkYlByb3h5YWJsZVR5cGVzKCkge1xuICAgIHJldHVybiAoaWRiUHJveHlhYmxlVHlwZXMgfHxcbiAgICAgICAgKGlkYlByb3h5YWJsZVR5cGVzID0gW1xuICAgICAgICAgICAgSURCRGF0YWJhc2UsXG4gICAgICAgICAgICBJREJPYmplY3RTdG9yZSxcbiAgICAgICAgICAgIElEQkluZGV4LFxuICAgICAgICAgICAgSURCQ3Vyc29yLFxuICAgICAgICAgICAgSURCVHJhbnNhY3Rpb24sXG4gICAgICAgIF0pKTtcbn1cbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0byBwcmV2ZW50IGl0IHRocm93aW5nIHVwIGluIG5vZGUgZW52aXJvbm1lbnRzLlxuZnVuY3Rpb24gZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIChjdXJzb3JBZHZhbmNlTWV0aG9kcyB8fFxuICAgICAgICAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgPSBbXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmFkdmFuY2UsXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZVByaW1hcnlLZXksXG4gICAgICAgIF0pKTtcbn1cbmNvbnN0IGN1cnNvclJlcXVlc3RNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNhY3Rpb25Eb25lTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2Zvcm1DYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gcHJvbWlzaWZ5UmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdW5saXN0ZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHdyYXAocmVxdWVzdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgfSk7XG4gICAgcHJvbWlzZVxuICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgLy8gU2luY2UgY3Vyc29yaW5nIHJldXNlcyB0aGUgSURCUmVxdWVzdCAoKnNpZ2gqKSwgd2UgY2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbFxuICAgICAgICAvLyAoc2VlIHdyYXBGdW5jdGlvbikuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQkN1cnNvcikge1xuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdE1hcC5zZXQodmFsdWUsIHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhdGNoaW5nIHRvIGF2b2lkIFwiVW5jYXVnaHQgUHJvbWlzZSBleGNlcHRpb25zXCJcbiAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAvLyBUaGlzIG1hcHBpbmcgZXhpc3RzIGluIHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBidXQgZG9lc24ndCBkb2Vzbid0IGV4aXN0IGluIHRyYW5zZm9ybUNhY2hlLiBUaGlzXG4gICAgLy8gaXMgYmVjYXVzZSB3ZSBjcmVhdGUgbWFueSBwcm9taXNlcyBmcm9tIGEgc2luZ2xlIElEQlJlcXVlc3QuXG4gICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChwcm9taXNlLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih0eCkge1xuICAgIC8vIEVhcmx5IGJhaWwgaWYgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGEgZG9uZSBwcm9taXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIGlmICh0cmFuc2FjdGlvbkRvbmVNYXAuaGFzKHR4KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRvbmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHR4LmVycm9yIHx8IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0RXJyb3InLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XG4gICAgfSk7XG4gICAgLy8gQ2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICB0cmFuc2FjdGlvbkRvbmVNYXAuc2V0KHR4LCBkb25lKTtcbn1cbmxldCBpZGJQcm94eVRyYXBzID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdHJhbnNhY3Rpb24uZG9uZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnZG9uZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRG9uZU1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIFBvbHlmaWxsIGZvciBvYmplY3RTdG9yZU5hbWVzIGJlY2F1c2Ugb2YgRWRnZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnb2JqZWN0U3RvcmVOYW1lcycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Lm9iamVjdFN0b3JlTmFtZXMgfHwgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSB0eC5zdG9yZSByZXR1cm4gdGhlIG9ubHkgc3RvcmUgaW4gdGhlIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG1hbnkuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3N0b3JlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzFdXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogcmVjZWl2ZXIub2JqZWN0U3RvcmUocmVjZWl2ZXIub2JqZWN0U3RvcmVOYW1lc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZSB0cmFuc2Zvcm0gd2hhdGV2ZXIgd2UgZ2V0IGJhY2suXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldFtwcm9wXSk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbiAmJlxuICAgICAgICAgICAgKHByb3AgPT09ICdkb25lJyB8fCBwcm9wID09PSAnc3RvcmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3AgaW4gdGFyZ2V0O1xuICAgIH0sXG59O1xuZnVuY3Rpb24gcmVwbGFjZVRyYXBzKGNhbGxiYWNrKSB7XG4gICAgaWRiUHJveHlUcmFwcyA9IGNhbGxiYWNrKGlkYlByb3h5VHJhcHMpO1xufVxuZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBEdWUgdG8gZXhwZWN0ZWQgb2JqZWN0IGVxdWFsaXR5ICh3aGljaCBpcyBlbmZvcmNlZCBieSB0aGUgY2FjaGluZyBpbiBgd3JhcGApLCB3ZVxuICAgIC8vIG9ubHkgY3JlYXRlIG9uZSBuZXcgZnVuYyBwZXIgZnVuYy5cbiAgICAvLyBFZGdlIGRvZXNuJ3Qgc3VwcG9ydCBvYmplY3RTdG9yZU5hbWVzIChib29vKSwgc28gd2UgcG9seWZpbGwgaXQgaGVyZS5cbiAgICBpZiAoZnVuYyA9PT0gSURCRGF0YWJhc2UucHJvdG90eXBlLnRyYW5zYWN0aW9uICYmXG4gICAgICAgICEoJ29iamVjdFN0b3JlTmFtZXMnIGluIElEQlRyYW5zYWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZU5hbWVzLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGZ1bmMuY2FsbCh1bndyYXAodGhpcyksIHN0b3JlTmFtZXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwLnNldCh0eCwgc3RvcmVOYW1lcy5zb3J0ID8gc3RvcmVOYW1lcy5zb3J0KCkgOiBbc3RvcmVOYW1lc10pO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAodHgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDdXJzb3IgbWV0aG9kcyBhcmUgc3BlY2lhbCwgYXMgdGhlIGJlaGF2aW91ciBpcyBhIGxpdHRsZSBtb3JlIGRpZmZlcmVudCB0byBzdGFuZGFyZCBJREIuIEluXG4gICAgLy8gSURCLCB5b3UgYWR2YW5jZSB0aGUgY3Vyc29yIGFuZCB3YWl0IGZvciBhIG5ldyAnc3VjY2Vzcycgb24gdGhlIElEQlJlcXVlc3QgdGhhdCBnYXZlIHlvdSB0aGVcbiAgICAvLyBjdXJzb3IuIEl0J3Mga2luZGEgbGlrZSBhIHByb21pc2UgdGhhdCBjYW4gcmVzb2x2ZSB3aXRoIG1hbnkgdmFsdWVzLiBUaGF0IGRvZXNuJ3QgbWFrZSBzZW5zZVxuICAgIC8vIHdpdGggcmVhbCBwcm9taXNlcywgc28gZWFjaCBhZHZhbmNlIG1ldGhvZHMgcmV0dXJucyBhIG5ldyBwcm9taXNlIGZvciB0aGUgY3Vyc29yIG9iamVjdCwgb3JcbiAgICAvLyB1bmRlZmluZWQgaWYgdGhlIGVuZCBvZiB0aGUgY3Vyc29yIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgaWYgKGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkuaW5jbHVkZXMoZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICAgICAgZnVuYy5hcHBseSh1bndyYXAodGhpcyksIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAoY3Vyc29yUmVxdWVzdE1hcC5nZXQodGhpcykpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICByZXR1cm4gd3JhcChmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncykpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHdyYXBGdW5jdGlvbih2YWx1ZSk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHJldHVybiwgaXQganVzdCBjcmVhdGVzIGEgJ2RvbmUnIHByb21pc2UgZm9yIHRoZSB0cmFuc2FjdGlvbixcbiAgICAvLyB3aGljaCBpcyBsYXRlciByZXR1cm5lZCBmb3IgdHJhbnNhY3Rpb24uZG9uZSAoc2VlIGlkYk9iamVjdEhhbmRsZXIpLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uKVxuICAgICAgICBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odmFsdWUpO1xuICAgIGlmIChpbnN0YW5jZU9mQW55KHZhbHVlLCBnZXRJZGJQcm94eWFibGVUeXBlcygpKSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh2YWx1ZSwgaWRiUHJveHlUcmFwcyk7XG4gICAgLy8gUmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2sgaWYgd2UncmUgbm90IGdvaW5nIHRvIHRyYW5zZm9ybSBpdC5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB3cmFwKHZhbHVlKSB7XG4gICAgLy8gV2Ugc29tZXRpbWVzIGdlbmVyYXRlIG11bHRpcGxlIHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdCAoZWcgd2hlbiBjdXJzb3JpbmcpLCBiZWNhdXNlXG4gICAgLy8gSURCIGlzIHdlaXJkIGFuZCBhIHNpbmdsZSBJREJSZXF1ZXN0IGNhbiB5aWVsZCBtYW55IHJlc3BvbnNlcywgc28gdGhlc2UgY2FuJ3QgYmUgY2FjaGVkLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlJlcXVlc3QpXG4gICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KHZhbHVlKTtcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHRyYW5zZm9ybWVkIHRoaXMgdmFsdWUgYmVmb3JlLCByZXVzZSB0aGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gICAgLy8gVGhpcyBpcyBmYXN0ZXIsIGJ1dCBpdCBhbHNvIHByb3ZpZGVzIG9iamVjdCBlcXVhbGl0eS5cbiAgICBpZiAodHJhbnNmb3JtQ2FjaGUuaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKTtcbiAgICAvLyBOb3QgYWxsIHR5cGVzIGFyZSB0cmFuc2Zvcm1lZC5cbiAgICAvLyBUaGVzZSBtYXkgYmUgcHJpbWl0aXZlIHR5cGVzLCBzbyB0aGV5IGNhbid0IGJlIFdlYWtNYXAga2V5cy5cbiAgICBpZiAobmV3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRyYW5zZm9ybUNhY2hlLnNldCh2YWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KG5ld1ZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmNvbnN0IHVud3JhcCA9ICh2YWx1ZSkgPT4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG5cbmV4cG9ydCB7IHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBhcyBhLCBpbnN0YW5jZU9mQW55IGFzIGksIHJlcGxhY2VUcmFwcyBhcyByLCB1bndyYXAgYXMgdSwgd3JhcCBhcyB3IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../node_modules/idb/build/wrap-idb-value.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("../../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("../../../node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);